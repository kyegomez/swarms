# File: applications/azure_openai.md

# Deploying Azure OpenAI in Production: A Comprehensive Guide

In today's fast-paced digital landscape, leveraging cutting-edge technologies has become essential for businesses to stay competitive and provide exceptional services to their customers. One such technology that has gained significant traction is Azure OpenAI, a powerful platform that allows developers to integrate advanced natural language processing (NLP) capabilities into their applications. Whether you're building a chatbot, a content generation system, or any other AI-powered solution, Azure OpenAI offers a robust and scalable solution for production-grade deployment.

In this comprehensive guide, we'll walk through the process of setting up and deploying Azure OpenAI in a production environment. We'll dive deep into the code, provide clear explanations, and share best practices to ensure a smooth and successful implementation.

## Prerequisites:
Before we begin, it's essential to have the following prerequisites in place:

1. **Python**: You'll need to have Python installed on your system. This guide assumes you're using Python 3.6 or later.
2. **Azure Subscription**: You'll need an active Azure subscription to access Azure OpenAI services.
3. **Azure OpenAI Resource**: Create an Azure OpenAI resource in your Azure subscription.
4. **Python Packages**: Install the required Python packages, including `python-dotenv` and `swarms`.

## Setting up the Environment:
To kick things off, we'll set up our development environment and install the necessary dependencies.

1. **Create a Virtual Environment**: It's a best practice to create a virtual environment to isolate your project dependencies from the rest of your system. You can create a virtual environment using `venv` or any other virtual environment management tool of your choice.

```
python -m venv myenv
```

2. **Activate the Virtual Environment**: Activate the virtual environment to ensure that any packages you install are isolated within the environment.

```
source myenv/bin/activate  # On Windows, use `myenv\Scripts\activate`
```

3. **Install Required Packages**: Install the `python-dotenv` and `swarms` packages using pip.

```
pip install python-dotenv swarms
```

4. **Create a `.env` File**: In the root directory of your project, create a new file called `.env`. This file will store your Azure OpenAI credentials and configuration settings.

```
AZURE_OPENAI_ENDPOINT=<your_azure_openai_endpoint>
AZURE_OPENAI_DEPLOYMENT=<your_azure_openai_deployment_name>
OPENAI_API_VERSION=<your_openai_api_version>
AZURE_OPENAI_API_KEY=<your_azure_openai_api_key>
AZURE_OPENAI_AD_TOKEN=<your_azure_openai_ad_token>
```

Replace the placeholders with your actual Azure OpenAI credentials and configuration settings.

## Connecting to Azure OpenAI:
Now that we've set up our environment, let's dive into the code that connects to Azure OpenAI and interacts with the language model.

```python
import os
from dotenv import load_dotenv
from swarms import AzureOpenAI

# Load the environment variables
load_dotenv()

# Create an instance of the AzureOpenAI class
model = AzureOpenAI(
    azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
    deployment_name=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
    openai_api_version=os.getenv("OPENAI_API_VERSION"),
    openai_api_key=os.getenv("AZURE_OPENAI_API_KEY"),
    azure_ad_token=os.getenv("AZURE_OPENAI_AD_TOKEN")
)
```

## Let's break down this code:

1. **Import Statements**: We import the necessary modules, including `os` for interacting with the operating system, `load_dotenv` from `python-dotenv` to load environment variables, and `AzureOpenAI` from `swarms` to interact with the Azure OpenAI service.

2. **Load Environment Variables**: We use `load_dotenv()` to load the environment variables stored in the `.env` file we created earlier.

3. **Create AzureOpenAI Instance**: We create an instance of the `AzureOpenAI` class by passing in the required configuration parameters:
   - `azure_endpoint`: The endpoint URL for your Azure OpenAI resource.
   - `deployment_name`: The name of the deployment you want to use.
   - `openai_api_version`: The version of the OpenAI API you want to use.
   - `openai_api_key`: Your Azure OpenAI API key, which authenticates your requests.
   - `azure_ad_token`: An optional Azure Active Directory (AAD) token for additional security.

Querying the Language Model:
With our connection to Azure OpenAI established, we can now query the language model and receive responses.

```python
# Define the prompt
prompt = "Analyze this load document and assess it for any risks and create a table in markdwon format."

# Generate a response
response = model(prompt)
print(response)
```

## Here's what's happening:

1. **Define the Prompt**: We define a prompt, which is the input text or question we want to feed into the language model.

2. **Generate a Response**: We call the `model` instance with the `prompt` as an argument. This triggers the Azure OpenAI service to process the prompt and generate a response.

3. **Print the Response**: Finally, we print the response received from the language model.

Running the Code:
To run the code, save it in a Python file (e.g., `main.py`) and execute it from the command line:

```
python main.py
```

## Best Practices for Production Deployment:
While the provided code serves as a basic example, there are several best practices to consider when deploying Azure OpenAI in a production environment:

1. **Secure Credentials Management**: Instead of storing sensitive credentials like API keys in your codebase, consider using secure storage solutions like Azure Key Vault or environment variables managed by your cloud provider.

2. **Error Handling and Retries**: Implement robust error handling and retry mechanisms to handle potential failures or rate-limiting scenarios.

3. **Logging and Monitoring**: Implement comprehensive logging and monitoring strategies to track application performance, identify issues, and gather insights for optimization.

4. **Scalability and Load Testing**: Conduct load testing to ensure your application can handle anticipated traffic volumes and scale appropriately based on demand.

5. **Caching and Optimization**: Explore caching strategies and performance optimizations to improve response times and reduce the load on the Azure OpenAI service.

6. **Integration with Other Services**: Depending on your use case, you may need to integrate Azure OpenAI with other Azure services or third-party tools for tasks like data processing, storage, or analysis.

7. **Compliance and Security**: Ensure your application adheres to relevant compliance standards and security best practices, especially when handling sensitive data.

## Conclusion:
Azure OpenAI is a powerful platform that enables developers to integrate advanced natural language processing capabilities into their applications. By following the steps outlined in this guide, you can set up a production-ready environment for deploying Azure OpenAI and start leveraging its capabilities in your projects.

Remember, this guide serves as a starting point, and there are numerous additional features and capabilities within Azure OpenAI that you can explore to enhance your applications further. As with any production deployment, it's crucial to follow best practices, conduct thorough testing, and implement robust monitoring and security measures.

With the right approach and careful planning, you can successfully deploy Azure OpenAI in a production environment and unlock the power of cutting-edge language models to drive innovation and provide exceptional experiences for your users.

--------------------------------------------------

# File: applications/blog.md

# The Future of Manufacturing: Leveraging Autonomous LLM Agents for Cost Reduction and Revenue Growth

## Table of Contents

1. [Introduction](#introduction)
2. [Understanding Autonomous LLM Agents](#understanding-autonomous-llm-agents)
3. [RAG Embedding Databases: The Knowledge Foundation](#rag-embedding-databases)
4. [Function Calling and External Tools: Enhancing Capabilities](#function-calling-and-external-tools)
5. [Cost Reduction Strategies](#cost-reduction-strategies)
   5.1. [Optimizing Supply Chain Management](#optimizing-supply-chain-management)
   5.2. [Enhancing Quality Control](#enhancing-quality-control)
   5.3. [Streamlining Maintenance and Repairs](#streamlining-maintenance-and-repairs)
   5.4. [Improving Energy Efficiency](#improving-energy-efficiency)
6. [Revenue Growth Opportunities](#revenue-growth-opportunities)
   6.1. [Product Innovation and Development](#product-innovation-and-development)
   6.2. [Personalized Customer Experiences](#personalized-customer-experiences)
   6.3. [Market Analysis and Trend Prediction](#market-analysis-and-trend-prediction)
   6.4. [Optimizing Pricing Strategies](#optimizing-pricing-strategies)
7. [Implementation Strategies](#implementation-strategies)
8. [Overcoming Challenges and Risks](#overcoming-challenges-and-risks)
9. [Case Studies](#case-studies)
10. [Future Outlook](#future-outlook)
11. [Conclusion](#conclusion)

## 1. Introduction <a name="introduction"></a>

In today's rapidly evolving manufacturing landscape, executives and CEOs face unprecedented challenges and opportunities. The key to maintaining a competitive edge lies in embracing cutting-edge technologies that can revolutionize operations, reduce costs, and drive revenue growth. One such transformative technology is the integration of autonomous Large Language Model (LLM) agents equipped with Retrieval-Augmented Generation (RAG) embedding databases, function calling capabilities, and access to external tools.

This comprehensive blog post aims to explore how these advanced AI systems can be leveraged to address the most pressing issues in manufacturing enterprises. We will delve into the intricacies of these technologies, provide concrete examples of their applications, and offer insights into implementation strategies. By the end of this article, you will have a clear understanding of how autonomous LLM agents can become a cornerstone of your manufacturing business's digital transformation journey.

## 2. Understanding Autonomous LLM Agents <a name="understanding-autonomous-llm-agents"></a>

Autonomous LLM agents represent the cutting edge of artificial intelligence in the manufacturing sector. These sophisticated systems are built upon large language models, which are neural networks trained on vast amounts of text data. What sets them apart is their ability to operate autonomously, making decisions and taking actions with minimal human intervention.

Key features of autonomous LLM agents include:

1. **Natural Language Processing (NLP)**: They can understand and generate human-like text, enabling seamless communication with employees across all levels of the organization.

2. **Contextual Understanding**: These agents can grasp complex scenarios and nuanced information, making them ideal for handling intricate manufacturing processes.

3. **Adaptive Learning**: Through continuous interaction and feedback, they can improve their performance over time, becoming more efficient and accurate.

4. **Multi-modal Input Processing**: Advanced agents can process not only text but also images, audio, and sensor data, providing a holistic view of manufacturing operations.

5. **Task Automation**: They can automate a wide range of tasks, from data analysis to decision-making, freeing up human resources for more strategic activities.

The integration of autonomous LLM agents in manufacturing environments opens up new possibilities for optimization, innovation, and growth. As we explore their applications throughout this blog, it's crucial to understand that these agents are not meant to replace human workers but to augment their capabilities and drive overall productivity.

## 3. RAG Embedding Databases: The Knowledge Foundation <a name="rag-embedding-databases"></a>

At the heart of effective autonomous LLM agents lies the Retrieval-Augmented Generation (RAG) embedding database. This technology serves as the knowledge foundation, enabling agents to access and utilize vast amounts of relevant information quickly and accurately.

RAG embedding databases work by:

1. **Vectorizing Information**: Converting textual data into high-dimensional vectors that capture semantic meaning.

2. **Efficient Storage**: Organizing these vectors in a way that allows for rapid retrieval of relevant information.

3. **Contextual Retrieval**: Enabling the agent to pull relevant information based on the current context or query.

4. **Dynamic Updates**: Allowing for continuous updates to the knowledge base, ensuring the agent always has access to the most current information.

In the manufacturing context, RAG embedding databases can store a wealth of information, including:

- Technical specifications of machinery and products
- Historical production data and performance metrics
- Quality control guidelines and standards
- Supplier information and supply chain data
- Market trends and customer feedback

By leveraging RAG embedding databases, autonomous LLM agents can make informed decisions based on a comprehensive understanding of the manufacturing ecosystem. This leads to more accurate predictions, better problem-solving capabilities, and the ability to generate innovative solutions.

For example, when faced with a production bottleneck, an agent can quickly retrieve relevant historical data, equipment specifications, and best practices to propose an optimal solution. This rapid access to contextual information significantly reduces decision-making time and improves the quality of outcomes.

## 4. Function Calling and External Tools: Enhancing Capabilities <a name="function-calling-and-external-tools"></a>

The true power of autonomous LLM agents in manufacturing environments is realized through their ability to interact with external systems and tools. This is achieved through function calling and integration with specialized external tools.

Function calling allows the agent to:

1. **Execute Specific Tasks**: Trigger predefined functions to perform complex operations or calculations.

2. **Interact with Databases**: Query and update various databases within the manufacturing ecosystem.

3. **Control Equipment**: Send commands to machinery or robotic systems on the production floor.

4. **Generate Reports**: Automatically compile and format data into meaningful reports for different stakeholders.

External tools that can be integrated include:

- **Predictive Maintenance Software**: To schedule and optimize equipment maintenance.
- **Supply Chain Management Systems**: For real-time tracking and optimization of inventory and logistics.
- **Quality Control Systems**: To monitor and analyze product quality metrics.
- **Energy Management Tools**: For monitoring and optimizing energy consumption across the facility.
- **Customer Relationship Management (CRM) Software**: To analyze customer data and improve service.

By combining the cognitive abilities of LLM agents with the specialized functionalities of external tools, manufacturing enterprises can create a powerful ecosystem that drives efficiency and innovation.

For instance, an autonomous agent could:

1. Detect an anomaly in production quality through data analysis.
2. Use function calling to query the maintenance database for equipment history.
3. Leverage an external predictive maintenance tool to assess the risk of equipment failure.
4. Automatically schedule maintenance and adjust production schedules to minimize downtime.
5. Generate a comprehensive report for management, detailing the issue, actions taken, and impact on production.

This level of integration and automation can lead to significant improvements in operational efficiency, cost reduction, and overall productivity.

## 5. Cost Reduction Strategies <a name="cost-reduction-strategies"></a>

One of the primary benefits of implementing autonomous LLM agents in manufacturing is the potential for substantial cost reductions across various aspects of operations. Let's explore some key areas where these agents can drive down expenses:

### 5.1. Optimizing Supply Chain Management <a name="optimizing-supply-chain-management"></a>

Autonomous LLM agents can revolutionize supply chain management by:

- **Predictive Inventory Management**: Analyzing historical data, market trends, and production schedules to optimize inventory levels, reducing carrying costs and minimizing stockouts.

- **Supplier Selection and Negotiation**: Evaluating supplier performance, market conditions, and contract terms to recommend the most cost-effective suppliers and negotiate better deals.

- **Logistics Optimization**: Analyzing transportation routes, warehouse locations, and delivery schedules to minimize logistics costs and improve delivery times.

Example: A large automotive manufacturer implemented an autonomous LLM agent to optimize its global supply chain. The agent analyzed data from multiple sources, including production schedules, supplier performance metrics, and global shipping trends. By optimizing inventory levels and renegotiating supplier contracts, the company reduced supply chain costs by 15% in the first year, resulting in savings of over $100 million.

### 5.2. Enhancing Quality Control <a name="enhancing-quality-control"></a>

Quality control is a critical aspect of manufacturing that directly impacts costs. Autonomous LLM agents can significantly improve quality control processes by:

- **Real-time Defect Detection**: Integrating with computer vision systems to identify and classify defects in real-time, reducing waste and rework.

- **Root Cause Analysis**: Analyzing production data to identify the root causes of quality issues and recommending corrective actions.

- **Predictive Quality Management**: Leveraging historical data and machine learning models to predict potential quality issues before they occur.

Example: A semiconductor manufacturer deployed an autonomous LLM agent to enhance its quality control processes. The agent analyzed data from multiple sensors on the production line, historical quality records, and equipment maintenance logs. By identifying subtle patterns that led to defects, the agent helped reduce scrap rates by 30% and improved overall yield by 5%, resulting in annual savings of $50 million.

### 5.3. Streamlining Maintenance and Repairs <a name="streamlining-maintenance-and-repairs"></a>

Effective maintenance is crucial for minimizing downtime and extending the lifespan of expensive manufacturing equipment. Autonomous LLM agents can optimize maintenance processes by:

- **Predictive Maintenance**: Analyzing equipment sensor data, maintenance history, and production schedules to predict when maintenance is needed, reducing unplanned downtime.

- **Maintenance Scheduling Optimization**: Balancing maintenance needs with production schedules to minimize disruptions and maximize equipment availability.

- **Repair Knowledge Management**: Creating and maintaining a comprehensive knowledge base of repair procedures, making it easier for technicians to quickly address issues.

Example: A paper mill implemented an autonomous LLM agent to manage its maintenance operations. The agent analyzed vibration data from critical equipment, historical maintenance records, and production schedules. By implementing a predictive maintenance strategy, the mill reduced unplanned downtime by 40% and extended the lifespan of key equipment by 25%, resulting in annual savings of $15 million in maintenance costs and lost production time.

### 5.4. Improving Energy Efficiency <a name="improving-energy-efficiency"></a>

Energy consumption is a significant cost factor in manufacturing. Autonomous LLM agents can help reduce energy costs by:

- **Real-time Energy Monitoring**: Analyzing energy consumption data across the facility to identify inefficiencies and anomalies.

- **Process Optimization for Energy Efficiency**: Recommending changes to production processes to reduce energy consumption without impacting output.

- **Demand Response Management**: Integrating with smart grid systems to optimize energy usage based on variable electricity prices and demand.

Example: A large chemical manufacturing plant deployed an autonomous LLM agent to optimize its energy consumption. The agent analyzed data from thousands of sensors across the facility, weather forecasts, and electricity price fluctuations. By optimizing process parameters and scheduling energy-intensive operations during off-peak hours, the plant reduced its energy costs by 18%, saving $10 million annually.

## 6. Revenue Growth Opportunities <a name="revenue-growth-opportunities"></a>

While cost reduction is crucial, autonomous LLM agents also present significant opportunities for revenue growth in manufacturing enterprises. Let's explore how these advanced AI systems can drive top-line growth:

### 6.1. Product Innovation and Development <a name="product-innovation-and-development"></a>

Autonomous LLM agents can accelerate and enhance the product innovation process by:

- **Market Trend Analysis**: Analyzing vast amounts of market data, customer feedback, and industry reports to identify emerging trends and unmet needs.

- **Design Optimization**: Leveraging generative design techniques and historical performance data to suggest optimal product designs that balance functionality, manufacturability, and cost.

- **Rapid Prototyping Assistance**: Guiding engineers through the prototyping process, suggesting materials and manufacturing techniques based on design requirements and cost constraints.

Example: A consumer electronics manufacturer utilized an autonomous LLM agent to enhance its product development process. The agent analyzed social media trends, customer support tickets, and competitor product features to identify key areas for innovation. By suggesting novel features and optimizing designs for manufacturability, the company reduced time-to-market for new products by 30% and increased the success rate of new product launches by 25%, resulting in a 15% increase in annual revenue.

### 6.2. Personalized Customer Experiences <a name="personalized-customer-experiences"></a>

In the age of mass customization, providing personalized experiences can significantly boost customer satisfaction and revenue. Autonomous LLM agents can facilitate this by:

- **Customer Preference Analysis**: Analyzing historical purchase data, customer interactions, and market trends to predict individual customer preferences.

- **Dynamic Product Configuration**: Enabling real-time product customization based on customer inputs and preferences, while ensuring manufacturability.

- **Personalized Marketing and Sales Support**: Generating tailored marketing content and sales recommendations for each customer or market segment.

Example: A high-end furniture manufacturer implemented an autonomous LLM agent to power its online customization platform. The agent analyzed customer behavior, design trends, and production capabilities to offer personalized product recommendations and customization options. This led to a 40% increase in online sales and a 20% increase in average order value, driving significant revenue growth.

### 6.3. Market Analysis and Trend Prediction <a name="market-analysis-and-trend-prediction"></a>

Staying ahead of market trends is crucial for maintaining a competitive edge. Autonomous LLM agents can provide valuable insights by:

- **Competitive Intelligence**: Analyzing competitor activities, product launches, and market positioning to identify threats and opportunities.

- **Demand Forecasting**: Combining historical sales data, economic indicators, and market trends to predict future demand more accurately.

- **Emerging Market Identification**: Analyzing global economic data, demographic trends, and industry reports to identify promising new markets for expansion.

Example: A global automotive parts manufacturer employed an autonomous LLM agent to enhance its market intelligence capabilities. The agent analyzed data from industry reports, social media, patent filings, and economic indicators to predict the growth of electric vehicle adoption in different regions. This insight allowed the company to strategically invest in EV component manufacturing, resulting in a 30% year-over-year growth in this high-margin segment.

### 6.4. Optimizing Pricing Strategies <a name="optimizing-pricing-strategies"></a>

Pricing is a critical lever for revenue growth. Autonomous LLM agents can optimize pricing strategies by:

- **Dynamic Pricing Models**: Analyzing market conditions, competitor pricing, and demand fluctuations to suggest optimal pricing in real-time.

- **Value-based Pricing Analysis**: Assessing customer perceived value through sentiment analysis and willingness-to-pay studies to maximize revenue.

- **Bundle and Discount Optimization**: Recommending product bundles and discount structures that maximize overall revenue and profitability.

Example: A industrial equipment manufacturer implemented an autonomous LLM agent to optimize its pricing strategy. The agent analyzed historical sales data, competitor pricing, economic indicators, and customer sentiment to recommend dynamic pricing models for different product lines and markets. This resulted in a 10% increase in profit margins and a 7% boost in overall revenue within the first year of implementation.

## 7. Implementation Strategies <a name="implementation-strategies"></a>

Successfully implementing autonomous LLM agents in a manufacturing environment requires a strategic approach. Here are key steps and considerations for executives and CEOs:

1. **Start with a Clear Vision and Objectives**:
   - Define specific goals for cost reduction and revenue growth.
   - Identify key performance indicators (KPIs) to measure success.

2. **Conduct a Comprehensive Readiness Assessment**:
   - Evaluate existing IT infrastructure and data management systems.
   - Assess the quality and accessibility of historical data.
   - Identify potential integration points with existing systems and processes.

3. **Build a Cross-functional Implementation Team**:
   - Include representatives from IT, operations, engineering, and business strategy.
   - Consider partnering with external AI and manufacturing technology experts.

4. **Develop a Phased Implementation Plan**:
   - Start with pilot projects in specific areas (e.g., predictive maintenance or supply chain optimization).
   - Scale successful pilots across the organization.

5. **Invest in Data Infrastructure and Quality**:
   - Ensure robust data collection and storage systems are in place.
   - Implement data cleaning and standardization processes.



6. **Choose the Right LLM and RAG Technologies**:
   - Evaluate different LLM options based on performance, cost, and specific manufacturing requirements.
   - Select RAG embedding databases that can efficiently handle the scale and complexity of manufacturing data.

7. **Develop a Robust Integration Strategy**:
   - Plan for seamless integration with existing ERP, MES, and other critical systems.
   - Ensure proper API development and management for connecting with external tools and databases.

8. **Prioritize Security and Compliance**:
   - Implement strong data encryption and access control measures.
   - Ensure compliance with industry regulations and data privacy laws.

9. **Invest in Change Management and Training**:
   - Develop comprehensive training programs for employees at all levels.
   - Communicate the benefits and address concerns about AI implementation.

10. **Establish Governance and Oversight**:
    - Create a governance structure to oversee the use and development of AI systems.
    - Implement ethical guidelines for AI decision-making.

11. **Plan for Continuous Improvement**:
    - Set up feedback loops to continuously refine and improve the AI systems.
    - Stay updated on advancements in LLM and RAG technologies.

Example: A leading automotive manufacturer implemented autonomous LLM agents across its global operations using a phased approach. They started with a pilot project in predictive maintenance at a single plant, which reduced downtime by 25%. Building on this success, they expanded to supply chain optimization and quality control. Within three years, the company had deployed AI agents across all major operations, resulting in a 12% reduction in overall production costs and a 9% increase in productivity.

## 8. Overcoming Challenges and Risks <a name="overcoming-challenges-and-risks"></a>

While the benefits of autonomous LLM agents in manufacturing are substantial, there are several challenges and risks that executives must address:

### Data Quality and Availability

**Challenge**: Manufacturing environments often have siloed, inconsistent, or incomplete data, which can hinder the effectiveness of AI systems.

**Solution**:
- Invest in data infrastructure and standardization across the organization.
- Implement data governance policies to ensure consistent data collection and management.
- Use data augmentation techniques to address gaps in historical data.

### Integration with Legacy Systems

**Challenge**: Many manufacturing facilities rely on legacy systems that may not easily integrate with modern AI technologies.

**Solution**:
- Develop custom APIs and middleware to facilitate communication between legacy systems and AI agents.
- Consider a gradual modernization strategy, replacing legacy systems over time.
- Use edge computing devices to bridge the gap between old equipment and new AI systems.

### Workforce Adaptation and Resistance

**Challenge**: Employees may resist AI implementation due to fear of job displacement or lack of understanding.

**Solution**:
- Emphasize that AI is a tool to augment human capabilities, not replace workers.
- Provide comprehensive training programs to upskill employees.
- Involve workers in the AI implementation process to gain buy-in and valuable insights.

### Ethical Considerations and Bias

**Challenge**: AI systems may inadvertently perpetuate biases present in historical data or decision-making processes.

**Solution**:
- Implement rigorous testing for bias in AI models and decisions.
- Establish an ethics committee to oversee AI implementations.
- Regularly audit AI systems for fairness and unintended consequences.

### Security and Intellectual Property Protection

**Challenge**: AI systems may be vulnerable to cyber attacks or could potentially expose sensitive manufacturing processes.

**Solution**:
- Implement robust cybersecurity measures, including encryption and access controls.
- Develop clear policies on data handling and AI model ownership.
- Regularly conduct security audits and penetration testing.

Example: A pharmaceutical manufacturer faced challenges integrating AI agents with its highly regulated production processes. They addressed this by creating a cross-functional team of IT specialists, process engineers, and compliance officers. This team developed a custom integration layer that allowed AI agents to interact with existing systems while maintaining regulatory compliance. They also implemented a rigorous change management process, which included extensive training and a phased rollout. As a result, they successfully deployed AI agents that optimized production scheduling and quality control, leading to a 15% increase in throughput and a 30% reduction in quality-related issues.

## 9. Case Studies <a name="case-studies"></a>

To illustrate the transformative potential of autonomous LLM agents in manufacturing, let's examine several real-world case studies:

### Case Study 1: Global Electronics Manufacturer

**Challenge**: A leading electronics manufacturer was struggling with supply chain disruptions and rising production costs.

**Solution**: They implemented an autonomous LLM agent integrated with their supply chain management system and production planning tools.

**Results**:
- 22% reduction in inventory carrying costs
- 18% improvement in on-time deliveries
- 15% decrease in production lead times
- $200 million annual cost savings

**Key Factors for Success**:
- Comprehensive integration with existing systems
- Real-time data processing capabilities
- Continuous learning and optimization algorithms

### Case Study 2: Automotive Parts Supplier

**Challenge**: An automotive parts supplier needed to improve quality control and reduce warranty claims.

**Solution**: They deployed an AI-powered quality control system using computer vision and an autonomous LLM agent for defect analysis and prediction.

**Results**:
- 40% reduction in defect rates
- 60% decrease in warranty claims
- 25% improvement in overall equipment effectiveness (OEE)
- $75 million annual savings in quality-related costs

**Key Factors for Success**:
- High-quality image data collection system
- Integration of domain expertise into the AI model
- Continuous feedback loop for model improvement

### Case Study 3: Food and Beverage Manufacturer

**Challenge**: A large food and beverage manufacturer wanted to optimize its energy consumption and reduce waste in its production processes.

**Solution**: They implemented an autonomous LLM agent that integrated with their energy management systems and production equipment.

**Results**:
- 20% reduction in energy consumption
- 30% decrease in production waste
- 12% increase in overall production efficiency
- $50 million annual cost savings
- Significant progress towards sustainability goals

**Key Factors for Success**:
- Comprehensive sensor network for real-time data collection
- Integration with smart grid systems for dynamic energy management
- Collaboration with process engineers to refine AI recommendations

### Case Study 4: Aerospace Component Manufacturer

**Challenge**: An aerospace component manufacturer needed to accelerate product development and improve first-time-right rates for new designs.

**Solution**: They implemented an autonomous LLM agent to assist in the design process, leveraging historical data, simulation results, and industry standards.

**Results**:
- 35% reduction in design cycle time
- 50% improvement in first-time-right rates for new designs
- 20% increase in successful patent applications
- $100 million increase in annual revenue from new products

**Key Factors for Success**:
- Integration of CAD systems with the AI agent
- Incorporation of aerospace industry standards and regulations into the AI knowledge base
- Collaborative approach between AI and human engineers

These case studies demonstrate the wide-ranging benefits of autonomous LLM agents across various manufacturing sectors. The key takeaway is that successful implementation requires a holistic approach, combining technology integration, process redesign, and a focus on continuous improvement.

## 10. Future Outlook <a name="future-outlook"></a>

As we look to the future of manufacturing, the role of autonomous LLM agents is set to become even more critical. Here are some key trends and developments that executives should keep on their radar:

### 1. Advanced Natural Language Interfaces

Future LLM agents will feature more sophisticated natural language interfaces, allowing workers at all levels to interact with complex manufacturing systems using conversational language. This will democratize access to AI capabilities and enhance overall operational efficiency.

### 2. Enhanced Multi-modal Learning

Next-generation agents will be able to process and analyze data from a wider range of sources, including text, images, video, and sensor data. This will enable more comprehensive insights and decision-making capabilities across the manufacturing ecosystem.

### 3. Collaborative AI Systems

We'll see the emergence of AI ecosystems where multiple specialized agents collaborate to solve complex manufacturing challenges. For example, a design optimization agent might work in tandem with a supply chain agent and a quality control agent to develop new products that are optimized for both performance and manufacturability.

### 4. Quantum-enhanced AI

As quantum computing becomes more accessible, it will significantly enhance the capabilities of LLM agents, particularly in complex optimization problems common in manufacturing. This could lead to breakthroughs in areas such as materials science and process optimization.

### 5. Augmented Reality Integration

LLM agents will increasingly be integrated with augmented reality (AR) systems, providing real-time guidance and information to workers on the factory floor. This could revolutionize training, maintenance, and quality control processes.

### 6. Autonomous Factories

The ultimate vision is the development of fully autonomous factories where LLM agents orchestrate entire production processes with minimal human intervention. While this is still on the horizon, progressive implementation of autonomous systems will steadily move the industry in this direction.

### 7. Ethical AI and Explainable Decision-Making

As AI systems become more prevalent in critical manufacturing decisions, there will be an increased focus on developing ethical AI frameworks and enhancing the explainability of AI decision-making processes. This will be crucial for maintaining trust and meeting regulatory requirements.

### 8. Circular Economy Optimization

Future LLM agents will play a key role in optimizing manufacturing processes for sustainability and circular economy principles. This will include enhancing recycling processes, optimizing resource use, and designing products for easy disassembly and reuse.

To stay ahead in this rapidly evolving landscape, manufacturing executives should:

1. **Foster a Culture of Innovation**: Encourage experimentation with new AI technologies and applications.

2. **Invest in Continuous Learning**: Ensure your workforce is constantly upskilling to work effectively with advanced AI systems.

3. **Collaborate with AI Research Institutions**: Partner with universities and research labs to stay at the forefront of AI advancements in manufacturing.

4. **Participate in Industry Consortiums**: Join manufacturing technology consortiums to share knowledge and shape industry standards for AI adoption.

5. **Develop Flexible and Scalable AI Infrastructure**: Build systems that can easily incorporate new AI capabilities as they emerge.

6. **Monitor Regulatory Developments**: Stay informed about evolving regulations related to AI in manufacturing to ensure compliance and competitive advantage.

By embracing these future trends and preparing their organizations accordingly, manufacturing executives can position their companies to thrive in the AI-driven future of industry.

## 11. Conclusion <a name="conclusion"></a>

The integration of autonomous LLM agents with RAG embedding databases, function calling, and external tools represents a paradigm shift in manufacturing. This technology has the potential to dramatically reduce costs, drive revenue growth, and revolutionize how manufacturing enterprises operate.

Key takeaways for executives and CEOs:

1. **Transformative Potential**: Autonomous LLM agents can impact every aspect of manufacturing, from supply chain optimization to product innovation.

2. **Data-Driven Decision Making**: These AI systems enable more informed, real-time decision-making based on comprehensive data analysis.

3. **Competitive Advantage**: Early adopters of this technology are likely to gain significant competitive advantages in terms of efficiency, quality, and innovation.

4. **Holistic Implementation**: Success requires a strategic approach that addresses technology, processes, and people.

5. **Continuous Evolution**: The field of AI in manufacturing is rapidly advancing, necessitating ongoing investment and adaptation.

6. **Ethical Considerations**: As AI becomes more prevalent, addressing ethical concerns and maintaining transparency will be crucial.

7. **Future Readiness**: Preparing for future developments, such as quantum-enhanced AI and autonomous factories, will be key to long-term success.

The journey to implement autonomous LLM agents in manufacturing is complex but potentially transformative. It requires vision, commitment, and a willingness to reimagine traditional manufacturing processes. However, the potential rewards – in terms of cost savings, revenue growth, and competitive advantage – are substantial.

As a manufacturing executive or CEO, your role is to lead this transformation, fostering a culture of innovation and continuous improvement. By embracing the power of autonomous LLM agents, you can position your organization at the forefront of the next industrial revolution, driving sustainable growth and success in an increasingly competitive global marketplace.

The future of manufacturing is intelligent, autonomous, and data-driven. The time to act is now. Embrace the potential of autonomous LLM agents and lead your organization into a new era of manufacturing excellence.

--------------------------------------------------

# File: applications/business-analyst-agent.md

## Building Analyst Agents with Swarms to write Business Reports

> Jupyter Notebook accompanying this post is accessible at: [Business Analyst Agent Notebook](https://github.com/kyegomez/swarms/blob/master/examples/demos/business_analysis_swarm/business-analyst-agent.ipynb)

Solving a business problem often involves preparing a Business Case Report. This report comprehensively analyzes the problem, evaluates potential solutions, and provides evidence-based recommendations and an implementation plan to effectively address the issue and drive business value. While the process of preparing one requires an experienced business analyst, the workflow can be augmented using AI agents. Two candidates stick out as areas to work on:

- Developing an outline to solve the problem
- Doing background research and gathering data 
  
In this post, we will explore how Swarms agents can be used to tackle a busuiness problem by outlining the solution, conducting background research and generating a preliminary report.

Before we proceed, this blog uses 3 API tools. Please obtain the following keys and store them in a `.env` file in the same folder as this file.

- **[OpenAI API](https://openai.com/blog/openai-api)** as `OPENAI_API_KEY`
- **[TavilyAI API](https://app.tavily.com/home)** `TAVILY_API_KEY`
- **[KayAI API](https://www.kay.ai/)** as `KAY_API_KEY`

```python
import dotenv
dotenv.load_dotenv()  # Load environment variables from .env file
```

### Developing an Outline to solve the problem

Assume the business problem is: **How do we improve Nike's revenue in Q3 2024?** We first create a planning agent to break down the problem into dependent sub-problems.


#### Step 1. Defining the Data Model and Tool Schema

Using Pydantic, we define a structure to help the agent generate sub-problems. 

- **QueryType:** Questions are either standalone or involve a combination of multiple others
- **Query:** Defines structure of a question.
- **QueryPlan:** Allows generation of a dependency graph of sub-questions


```python
import enum
from typing import List
from pydantic import Field, BaseModel

class QueryType(str, enum.Enum):
    """Enumeration representing the types of queries that can be asked to a question answer system."""

    SINGLE_QUESTION = "SINGLE"
    MERGE_MULTIPLE_RESPONSES = "MERGE_MULTIPLE_RESPONSES"

class Query(BaseModel):
    """Class representing a single question in a query plan."""

    id: int = Field(..., description="Unique id of the query")
    question: str = Field(
        ...,
        description="Question asked using a question answering system",
    )
    dependencies: List[int] = Field(
        default_factory=list,
        description="List of sub questions that need to be answered before asking this question",
    )
    node_type: QueryType = Field(
        default=QueryType.SINGLE_QUESTION,
        description="Type of question, either a single question or a multi-question merge",
    )

class QueryPlan(BaseModel):
    """Container class representing a tree of questions to ask a question answering system."""

    query_graph: List[Query] = Field(
        ..., description="The query graph representing the plan"
    )

    def _dependencies(self, ids: List[int]) -> List[Query]:
        """Returns the dependencies of a query given their ids."""
        
        return [q for q in self.query_graph if q.id in ids]
```

Also, a `tool_schema` needs to be defined. It is an instance of `QueryPlan` and is used to initialize the agent.

```python
tool_schema = QueryPlan(
    query_graph = [query.dict() for query in [
        Query(
            id=1,
            question="How do we improve Nike's revenue in Q3 2024?",
            dependencies=[2],
            node_type=QueryType('SINGLE')
        ),
        # ... other queries ...
    ]]
)
```

#### Step 2. Defining the Planning Agent

We specify the query, task specification and an appropriate system prompt.

```python
from swarm_models import OpenAIChat
from swarms import Agent

query = "How do we improve Nike's revenue in Q3 2024?"
task = f"Consider: {query}. Generate just the correct query plan in JSON format."
system_prompt = (
        "You are a world class query planning algorithm " 
        "capable of breaking apart questions into its " 
        "dependency queries such that the answers can be " 
        "used to inform the parent question. Do not answer " 
        "the questions, simply provide a correct compute " 
        "graph with good specific questions to ask and relevant " 
        "dependencies. Before you call the function, think " 
        "step-by-step to get a better understanding of the problem."
    )
llm = OpenAIChat(
    temperature=0.0, model_name="gpt-4", max_tokens=4000
)
```

Then, we proceed with agent definition.

```python
# Initialize the agent
agent = Agent(
    agent_name="Query Planner",
    system_prompt=system_prompt,
    # Set the tool schema to the JSON string -- this is the key difference
    tool_schema=tool_schema,
    llm=llm,
    max_loops=1,
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    interactive=False,
    # Set the output type to the tool schema which is a BaseModel
    output_type=tool_schema, # or dict, or str
    metadata_output_type="json",
    # List of schemas that the agent can handle
    list_base_models=[tool_schema],
    function_calling_format_type="OpenAI",
    function_calling_type="json", # or soon yaml
)
```

#### Step 3. Obtaining Outline from Planning Agent 

We now run the agent, and since its output is in JSON format, we can load it as a dictionary.

```python
generated_data = agent.run(task)
```

At times the agent could return extra content other than JSON. Below function will filter it out.

```python
def process_json_output(content):
    # Find the index of the first occurrence of '```json\n'
    start_index = content.find('```json\n')
    if start_index == -1:
        # If '```json\n' is not found, return the original content
        return content
    # Return the part of the content after '```json\n' and remove the '```' at the end
    return content[start_index + len('```json\n'):].rstrip('`')

# Use the function to clean up the output
json_content = process_json_output(generated_data.content)

import json

# Load the JSON string into a Python object
json_object = json.loads(json_content)

# Convert the Python object back to a JSON string
json_content = json.dumps(json_object, indent=2)

# Print the JSON string
print(json_content)
```

Below is the output this produces

```json
{
  "main_query": "How do we improve Nike's revenue in Q3 2024?",
  "sub_queries": [
    {
      "id": "1",
      "query": "What is Nike's current revenue trend?"
    },
    {
      "id": "2",
      "query": "What are the projected market trends for the sports apparel industry in 2024?"
    },
    {
      "id": "3",
      "query": "What are the current successful strategies being used by Nike's competitors?",
      "dependencies": [
        "2"
      ]
    },
    {
      "id": "4",
      "query": "What are the current and projected economic conditions in Nike's major markets?",
      "dependencies": [
        "2"
      ]
    },
    {
      "id": "5",
      "query": "What are the current consumer preferences in the sports apparel industry?",
      "dependencies": [
        "2"
      ]
    },
    {
      "id": "6",
      "query": "What are the potential areas of improvement in Nike's current business model?",
      "dependencies": [
        "1"
      ]
    },
    {
      "id": "7",
      "query": "What are the potential new markets for Nike to explore in 2024?",
      "dependencies": [
        "2",
        "4"
      ]
    },
    {
      "id": "8",
      "query": "What are the potential new products or services Nike could introduce in 2024?",
      "dependencies": [
        "5"
      ]
    },
    {
      "id": "9",
      "query": "What are the potential marketing strategies Nike could use to increase its revenue in Q3 2024?",
      "dependencies": [
        "3",
        "5",
        "7",
        "8"
      ]
    },
    {
      "id": "10",
      "query": "What are the potential cost-saving strategies Nike could implement to increase its net revenue in Q3 2024?",
      "dependencies": [
        "6"
      ]
    }
  ]
}
```

The JSON dictionary is not convenient for humans to process. We make a directed graph out of it.

```python
import networkx as nx
import matplotlib.pyplot as plt
import textwrap
import random

# Create a directed graph
G = nx.DiGraph()

# Define a color map
color_map = {}

# Add nodes and edges to the graph
for sub_query in json_object['sub_queries']:
    # Check if 'dependencies' key exists in sub_query, if not, initialize it as an empty list
    if 'dependencies' not in sub_query:
        sub_query['dependencies'] = []
    # Assign a random color for each node
    color_map[sub_query['id']] = "#{:06x}".format(random.randint(0, 0xFFFFFF))
    G.add_node(sub_query['id'], label=textwrap.fill(sub_query['query'], width=20))
    for dependency in sub_query['dependencies']:
        G.add_edge(dependency, sub_query['id'])

# Draw the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=800, node_color=[color_map[node] for node in G.nodes()], node_shape="o", alpha=0.5, linewidths=40)

# Prepare labels for legend
labels = nx.get_node_attributes(G, 'label')
handles = [plt.Line2D([0], [0], marker='o', color=color_map[node], label=f"{node}: {label}", markersize=10, linestyle='None') for node, label in labels.items()]

# Create a legend
plt.legend(handles=handles, title="Queries", bbox_to_anchor=(1.05, 1), loc='upper left')

plt.show()
```

This produces the below diagram which makes the plan much more convenient to understand.

![Query Plan Diagram](../assets/img/docs/query-plan.png)

### Doing Background Research and Gathering Data

At this point, we have solved the first half of the problem. We have an outline consisting of sub-problems to to tackled to solve our business problem. This will form the overall structure of our report. We now need to research information for each sub-problem in order to write an informed report. This mechanically intensive and is the aspect that will most benefit from Agentic intervention. 

Essentially, we can spawn parallel agents to gather the data. Each agent will have 2 tools:

- Internet access
- Financial data retrieval

As they run parallelly, they will add their knowledge into a common long-term memory. We will then spawn a separate report writing agent with access to this memory to generate our business case report.

#### Step 4. Defining Tools for Worker Agents

Let us first define the 2 tools. 

```python
import os
from typing import List, Dict

from swarms import tool

os.environ['TAVILY_API_KEY'] = os.getenv('TAVILY_API_KEY')
os.environ["KAY_API_KEY"] = os.getenv('KAY_API_KEY')

from langchain_community.tools.tavily_search import TavilySearchResults
from langchain_core.pydantic_v1 import BaseModel, Field

from kay.rag.retrievers import KayRetriever

def browser(query: str) -> str:
    """
    Search the query in the browser with the Tavily API tool.
    Args:
        query (str): The query to search in the browser.
    Returns:
        str: The search results
    """
    internet_search = TavilySearchResults()
    results =  internet_search.invoke({"query": query})
    response = '' 
    for result in results:
        response += (result['content'] + '\n')
    return response

def kay_retriever(query: str) -> str:
    """
    Search the financial data query with the KayAI API tool.
    Args:
        query (str): The query to search in the KayRetriever.
    Returns:
        str: The first context retrieved as a string.
    """
    # Initialize the retriever
    retriever = KayRetriever(dataset_id = "company",  data_types=["10-K", "10-Q", "8-K", "PressRelease"])
    # Query the retriever
    context = retriever.query(query=query,num_context=1)
    return context[0]['chunk_embed_text']
```

#### Step 5. Defining Long-Term Memory

As mentioned previously, the worker agents running parallelly, will pool their knowledge into a common memory. Let us define that.

```python
import logging
import os
import uuid
from typing import Callable, List, Optional

import chromadb
import numpy as np
from dotenv import load_dotenv

from swarms.utils.data_to_text import data_to_text
from swarms.utils.markdown_message import display_markdown_message
from swarms_memory import  AbstractVectorDatabase


# Results storage using local ChromaDB
class ChromaDB(AbstractVectorDatabase):
    """

    ChromaDB database

    Args:
        metric (str): The similarity metric to use.
        output (str): The name of the collection to store the results in.
        limit_tokens (int, optional): The maximum number of tokens to use for the query. Defaults to 1000.
        n_results (int, optional): The number of results to retrieve. Defaults to 2.

    Methods:
        add: _description_
        query: _description_

    Examples:
        >>> chromadb = ChromaDB(
        >>>     metric="cosine",
        >>>     output="results",
        >>>     llm="gpt3",
        >>>     openai_api_key=OPENAI_API_KEY,
        >>> )
        >>> chromadb.add(task, result, result_id)
    """

    def __init__(
        self,
        metric: str = "cosine",
        output_dir: str = "swarms",
        limit_tokens: Optional[int] = 1000,
        n_results: int = 3,
        embedding_function: Callable = None,
        docs_folder: str = None,
        verbose: bool = False,
        *args,
        **kwargs,
    ):
        self.metric = metric
        self.output_dir = output_dir
        self.limit_tokens = limit_tokens
        self.n_results = n_results
        self.docs_folder = docs_folder
        self.verbose = verbose

        # Disable ChromaDB logging
        if verbose:
            logging.getLogger("chromadb").setLevel(logging.INFO)

        # Create Chroma collection
        chroma_persist_dir = "chroma"
        chroma_client = chromadb.PersistentClient(
            settings=chromadb.config.Settings(
                persist_directory=chroma_persist_dir,
            ),
            *args,
            **kwargs,
        )

        # Embedding model
        if embedding_function:
            self.embedding_function = embedding_function
        else:
            self.embedding_function = None

        # Create ChromaDB client
        self.client = chromadb.Client()

        # Create Chroma collection
        self.collection = chroma_client.get_or_create_collection(
            name=output_dir,
            metadata={"hnsw:space": metric},
            embedding_function=self.embedding_function,
            # data_loader=self.data_loader,
            *args,
            **kwargs,
        )
        display_markdown_message(
            "ChromaDB collection created:"
            f" {self.collection.name} with metric: {self.metric} and"
            f" output directory: {self.output_dir}"
        )

        # If docs
        if docs_folder:
            display_markdown_message(
                f"Traversing directory: {docs_folder}"
            )
            self.traverse_directory()

    def add(
        self,
        document: str,
        *args,
        **kwargs,
    ):
        """
        Add a document to the ChromaDB collection.

        Args:
            document (str): The document to be added.
            condition (bool, optional): The condition to check before adding the document. Defaults to True.

        Returns:
            str: The ID of the added document.
        """
        try:
            doc_id = str(uuid.uuid4())
            self.collection.add(
                ids=[doc_id],
                documents=[document],
                *args,
                **kwargs,
            )
            print('-----------------')
            print("Document added successfully")
            print('-----------------')
            return doc_id
        except Exception as e:
            raise Exception(f"Failed to add document: {str(e)}")

    def query(
        self,
        query_text: str,
        *args,
        **kwargs,
    ):
        """
        Query documents from the ChromaDB collection.

        Args:
            query (str): The query string.
            n_docs (int, optional): The number of documents to retrieve. Defaults to 1.

        Returns:
            dict: The retrieved documents.
        """
        try:
            docs = self.collection.query(
                query_texts=[query_text],
                n_results=self.n_results,
                *args,
                **kwargs,
            )["documents"]
            return docs[0]
        except Exception as e:
            raise Exception(f"Failed to query documents: {str(e)}")

    def traverse_directory(self):
        """
        Traverse through every file in the given directory and its subdirectories,
        and return the paths of all files.
        Parameters:
        - directory_name (str): The name of the directory to traverse.
        Returns:
        - list: A list of paths to each file in the directory and its subdirectories.
        """
        added_to_db = False

        for root, dirs, files in os.walk(self.docs_folder):
            for file in files:
                file = os.path.join(self.docs_folder, file)
                _, ext = os.path.splitext(file)
                data = data_to_text(file)
                added_to_db = self.add([data])
                print(f"{file} added to Database")

        return added_to_db
```

We can now proceed to initialize the memory.

```python
from chromadb.utils import embedding_functions
default_ef = embedding_functions.DefaultEmbeddingFunction()

memory = ChromaDB(
    metric="cosine",
    n_results=3,
    output_dir="results",
    embedding_function=default_ef
)
```

#### Step 6. Defining Worker Agents 

The Worker Agent sub-classes the `Agent` class. The only different between these 2 is in how the `run()` method works. In the `Agent` class, `run()` simply returns the set of tool commands to run, but does not execute it. We, however, desire this. In addition, after we run our tools, we get the relevant information as output. We want to add this information to our memory. Hence, to incorporate these 2 changes, we define `WorkerAgent` as follows.

```python
class WorkerAgent(Agent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    
    def run(self, task, *args, **kwargs):
        response = super().run(task, *args, **kwargs)
        print(response.content)

        json_dict = json.loads(process_json_output(response.content))

        #print(json.dumps(json_dict, indent=2))
        
        if response!=None:
            try:
                commands = json_dict["commands"]
            except:
                commands = [json_dict['command']]
                
            for command in commands:
                tool_name = command["name"]

                if tool_name not in ['browser', 'kay_retriever']:
                    continue
                
                query = command["args"]["query"]

                # Get the tool by its name
                tool = globals()[tool_name]
                tool_response = tool(query)

                # Add tool's output to long term memory
                self.long_term_memory.add(tool_response)
```

We can then instantiate an object of the `WorkerAgent` class.

```python
worker_agent = WorkerAgent(
    agent_name="Worker Agent",
    system_prompt=(
        "Autonomous agent that can interact with browser, "
        "financial data retriever and other agents. Be Helpful " 
        "and Kind. Use the tools provided to assist the user. "
        "Generate the plan with list of commands in JSON format."
    ),
    llm=OpenAIChat(
    temperature=0.0, model_name="gpt-4", max_tokens=4000
),
    max_loops="auto",
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    interactive=True,
    tools=[browser, kay_retriever],
    long_term_memory=memory,
    code_interpreter=True,
)
```

#### Step 7. Running the Worker Agents

At this point, we need to setup a concurrent workflow. While the order of adding tasks to the workflow doesn't matter (since they will all run concurrently late when executed), we can take some time to define an order for these tasks. This order will come in handy later when writing the report using our Writer Agent. 

The order we will follow is Breadth First Traversal (BFT) of the sub-queries in the graph we had made earlier (shown below again for reference). BFT makes sense to be used here because we want all the dependent parent questions to be answered before answering the child question. Also, since we could have independent subgraphs, we will also perform BFT separately on each subgraph.

![Query Plan Mini](../assets/img/docs/query-plan-mini.png)

Below is the code that produces the order of processing sub-queries.

```python
from collections import deque, defaultdict

# Define the graph nodes
nodes = json_object['sub_queries']

# Create a graph from the nodes
graph = defaultdict(list)
for node in nodes:
    for dependency in node['dependencies']:
        graph[dependency].append(node['id'])

# Find all nodes with no dependencies (potential starting points)
start_nodes = [node['id'] for node in nodes if not node['dependencies']]

# Adjust the BFT function to handle dependencies correctly
def bft_corrected(start, graph, nodes_info):
    visited = set()
    queue = deque([start])
    order = []
    
    while queue:
        node = queue.popleft()
        if node not in visited:
            # Check if all dependencies of the current node are visited
            node_dependencies = [n['id'] for n in nodes if n['id'] == node][0]
            dependencies_met = all(dep in visited for dep in nodes_info[node_dependencies]['dependencies'])
            
            if dependencies_met:
                visited.add(node)
                order.append(node)
                # Add only nodes to the queue whose dependencies are fully met
                for next_node in graph[node]:
                    if all(dep in visited for dep in nodes_info[next_node]['dependencies']):
                        queue.append(next_node)
            else:
                # Requeue the node to check dependencies later
                queue.append(node)
    
    return order

# Dictionary to access node information quickly
nodes_info = {node['id']: node for node in nodes}

# Perform BFT for each unvisited start node using the corrected BFS function
visited_global = set()
bfs_order = []

for start in start_nodes:
    if start not in visited_global:
        order = bft_corrected(start, graph, nodes_info)
        bfs_order.extend(order)
        visited_global.update(order)

print("BFT Order:", bfs_order)
```

This produces the following output.

```python
BFT Order: ['1', '6', '10', '2', '3', '4', '5', '7', '8', '9']
```

Now, let's define our `ConcurrentWorkflow` and run it.

```python
import os
from dotenv import load_dotenv
from swarms import Agent, ConcurrentWorkflow, OpenAIChat, Task

# Create a workflow
workflow = ConcurrentWorkflow(max_workers=5)
task_list = []

for node in bfs_order:
    sub_query =nodes_info[node]['query']
    task = Task(worker_agent, sub_query)
    print('-----------------')
    print("Added task: ", sub_query)
    print('-----------------')
    task_list.append(task)

workflow.add(tasks=task_list)

# Run the workflow
workflow.run()
```

Below is part of the output this workflow produces. We clearly see the thought process of the agent and the plan it came up to solve a particular sub-query. In addition, we see the tool-calling schema it produces in `"command"`.

```python
...
...
content='\n{\n  "thoughts": {\n    "text": "To find out Nike\'s current revenue trend, I will use the financial data retriever tool to search for \'Nike revenue trend\'.",\n    "reasoning": "The financial data retriever tool allows me to search for specific financial data, so I can look up the current revenue trend of Nike.", \n    "plan": "Use the financial data retriever tool to search for \'Nike revenue trend\'. Parse the result to get the current revenue trend and format that into a readable report."\n  },\n  "command": {\n    "name": "kay_retriever", \n    "args": {\n      "query": "Nike revenue trend"\n    }\n  }\n}\n```' response_metadata={'token_usage': {'completion_tokens': 152, 'prompt_tokens': 1527, 'total_tokens': 1679}, 'model_name': 'gpt-4', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}
Saved agent state to: Worker Agent_state.json

{
  "thoughts": {
    "text": "To find out Nike's current revenue trend, I will use the financial data retriever tool to search for 'Nike revenue trend'.",
    "reasoning": "The financial data retriever tool allows me to search for specific financial data, so I can look up the current revenue trend of Nike.", 
    "plan": "Use the financial data retriever tool to search for 'Nike revenue trend'. Parse the result to get the current revenue trend and format that into a readable report."
  },
  "command": {
    "name": "kay_retriever", 
    "args": {
      "query": "Nike revenue trend"
    }
  }
}

-----------------
Document added successfully
-----------------
...
...
```

Here, `"name"` pertains to the name of the tool to be called and `"args"` is the arguments to be passed to the tool call. Like mentioned before, we modify `Agent`'s default behaviour in `WorkerAgent`. Hence, the tool call is executed here and its results (information from web pages and Kay Retriever API) are added to long-term memory. We get confirmation for this from the message `Document added successfully`. 


#### Step 7. Generating the report using Writer Agent

At this point, our Worker Agents have gathered all the background information required to generate the report. We have also defined a coherent structure to write the report, which is following the BFT order to answering the sub-queries. Now it's time to define a Writer Agent and call it sequentially in the order of sub-queries. 

```python
from swarms import Agent, OpenAIChat, tool

agent = Agent(
    agent_name="Writer Agent",
    agent_description=(
        "This agent writes reports based on information in long-term memory"
    ),
    system_prompt=(
        "You are a world-class financial report writer. " 
        "Write analytical and accurate responses using memory to answer the query. "
        "Do not mention use of long-term memory in the report. "
        "Do not mention Writer Agent in response."
        "Return only response content in strict markdown format."
    ),
    llm=OpenAIChat(temperature=0.2, model='gpt-3.5-turbo'),
    max_loops=1,
    autosave=True,
    verbose=True,
    long_term_memory=memory,
)
```

The report individual sections of the report will be collected in a list.

```python
report = []
```

Let us now run the writer agent.

```python
for node in bfs_order:
    sub_query =nodes_info[node]['query']
    print("Running task: ", sub_query)
    out = agent.run(f"Consider: {sub_query}. Write response in strict markdown format using long-term memory. Do not mention Writer Agent in response.")
    print(out)
    try:
        report.append(out.content)
    except:
        pass
```

Now, we need to clean up the repoort a bit to make it render professionally. 

```python
# Remove any content before the first "#" as that signals start of heading
# Anything before this usually contains filler content
stripped_report = [entry[entry.find('#'):] if '#' in entry else entry for entry in report]
report = stripped_report

# At times the LLM outputs \\n instead of \n
cleaned_report = [entry.replace("\\n", "\n") for entry in report]
import re

# Function to clean up unnecessary metadata from the report entries
def clean_report(report):
    cleaned_report = []
    for entry in report:
        # This pattern matches 'response_metadata={' followed by any characters that are not '}' (non-greedy), 
        # possibly nested inside other braces, until the closing '}'.
        cleaned_entry = re.sub(r"response_metadata=\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}", "", entry, flags=re.DOTALL)
        cleaned_report.append(cleaned_entry)
    return cleaned_report

# Apply the cleaning function to the markdown report
cleaned_report = clean_report(cleaned_report)
```

After cleaning, we append parts of the report together to get out final report.

```python
final_report = ' \n '.join(cleaned_report)
```

In Jupyter Notebook, we can use the below code to render it in Markdown. 

```python
from IPython.display import display, Markdown

display(Markdown(final_report))
```


## Final Generated Report


### Nike's Current Revenue Trend

Nike's current revenue trend has been steadily increasing over the past few years. In the most recent fiscal year, Nike reported a revenue of $37.4 billion, which was a 7% increase from the previous year. This growth can be attributed to strong sales in key markets, successful marketing campaigns, and a focus on innovation in product development. Overall, Nike continues to demonstrate strong financial performance and is well-positioned for future growth. 
 ### Potential Areas of Improvement in Nike's Business Model

1. **Sustainability Practices**: Nike could further enhance its sustainability efforts by reducing its carbon footprint, using more eco-friendly materials, and ensuring ethical labor practices throughout its supply chain.

2. **Diversification of Product Portfolio**: While Nike is known for its athletic footwear and apparel, diversifying into new product categories or expanding into untapped markets could help drive growth and mitigate risks associated with a single product line.

3. **E-commerce Strategy**: Improving the online shopping experience, investing in digital marketing, and leveraging data analytics to personalize customer interactions could boost online sales and customer loyalty.

4. **Innovation and R&D**: Continuously investing in research and development to stay ahead of competitors, introduce new technologies, and enhance product performance could help maintain Nike's competitive edge in the market.

5. **Brand Image and Reputation**: Strengthening brand image through effective marketing campaigns, community engagement, and transparent communication with stakeholders can help build trust and loyalty among consumers. 
 ### Potential Cost-Saving Strategies for Nike to Increase Net Revenue in Q3 2024

1. **Supply Chain Optimization**: Streamlining the supply chain, reducing transportation costs, and improving inventory management can lead to significant cost savings for Nike.

2. **Operational Efficiency**: Implementing lean manufacturing practices, reducing waste, and optimizing production processes can help lower production costs and improve overall efficiency.

3. **Outsourcing Non-Core Functions**: Outsourcing non-core functions such as IT services, customer support, or logistics can help reduce overhead costs and focus resources on core business activities.

4. **Energy Efficiency**: Investing in energy-efficient technologies, renewable energy sources, and sustainable practices can lower utility costs and demonstrate a commitment to environmental responsibility.

5. **Negotiating Supplier Contracts**: Negotiating better terms with suppliers, leveraging economies of scale, and exploring alternative sourcing options can help lower procurement costs and improve margins.

By implementing these cost-saving strategies, Nike can improve its bottom line and increase net revenue in Q3 2024. 
 ### Projected Market Trends for the Sports Apparel Industry in 2024

1. **Sustainable Fashion**: Consumers are increasingly demanding eco-friendly and sustainable products, leading to a rise in sustainable sportswear options in the market.

2. **Digital Transformation**: The sports apparel industry is expected to continue its shift towards digital platforms, with a focus on e-commerce, personalized shopping experiences, and digital marketing strategies.

3. **Athleisure Wear**: The trend of athleisure wear, which combines athletic and leisure clothing, is projected to remain popular in 2024 as consumers seek comfort and versatility in their apparel choices.

4. **Innovative Materials**: Advances in technology and material science are likely to drive the development of innovative fabrics and performance-enhancing materials in sports apparel, catering to the demand for high-quality and functional products.

5. **Health and Wellness Focus**: With a growing emphasis on health and wellness, sports apparel brands are expected to incorporate features that promote comfort, performance, and overall well-being in their products.

Overall, the sports apparel industry in 2024 is anticipated to be characterized by sustainability, digitalization, innovation, and a focus on consumer health and lifestyle trends. 
 ### Current Successful Strategies Used by Nike's Competitors

1. **Adidas**: Adidas has been successful in leveraging collaborations with celebrities and designers to create limited-edition collections that generate hype and drive sales. They have also focused on sustainability initiatives, such as using recycled materials in their products, to appeal to environmentally conscious consumers.

2. **Under Armour**: Under Armour has differentiated itself by targeting performance-driven athletes and emphasizing technological innovation in their products. They have also invested heavily in digital marketing and e-commerce to reach a wider audience and enhance the customer shopping experience.

3. **Puma**: Puma has successfully capitalized on the athleisure trend by offering stylish and versatile sportswear that can be worn both in and out of the gym. They have also focused on building partnerships with influencers and sponsoring high-profile athletes to increase brand visibility and credibility.

4. **Lululemon**: Lululemon has excelled in creating a strong community around its brand, hosting events, classes, and collaborations to engage with customers beyond just selling products. They have also prioritized customer experience by offering personalized services and creating a seamless omnichannel shopping experience.

5. **New Balance**: New Balance has carved out a niche in the market by emphasizing quality craftsmanship, heritage, and authenticity in their products. They have also focused on customization and personalization options for customers, allowing them to create unique and tailored footwear and apparel.

Overall, Nike's competitors have found success through a combination of innovative product offerings, strategic marketing initiatives, and a focus on customer engagement and experience. 
 ### Current and Projected Economic Conditions in Nike's Major Markets

1. **United States**: The United States, being one of Nike's largest markets, is currently experiencing moderate economic growth driven by consumer spending, low unemployment rates, and a rebound in manufacturing. However, uncertainties surrounding trade policies, inflation, and interest rates could impact consumer confidence and spending in the near future.

2. **China**: China remains a key market for Nike, with a growing middle class and increasing demand for sportswear and athletic footwear. Despite recent trade tensions with the U.S., China's economy is projected to continue expanding, driven by domestic consumption, infrastructure investments, and technological advancements.

3. **Europe**: Economic conditions in Europe vary across countries, with some experiencing sluggish growth due to Brexit uncertainties, political instability, and trade tensions. However, overall consumer confidence is improving, and the sports apparel market is expected to grow, driven by e-commerce and sustainability trends.

4. **Emerging Markets**: Nike's presence in emerging markets such as India, Brazil, and Southeast Asia provides opportunities for growth, given the rising disposable incomes, urbanization, and increasing focus on health and fitness. However, challenges such as currency fluctuations, regulatory changes, and competition from local brands could impact Nike's performance in these markets.

Overall, Nike's major markets exhibit a mix of opportunities and challenges, with economic conditions influenced by global trends, geopolitical factors, and consumer preferences."  
 ### Current Consumer Preferences in the Sports Apparel Industry

1. **Sustainability**: Consumers are increasingly seeking eco-friendly and sustainable options in sports apparel, driving brands to focus on using recycled materials, reducing waste, and promoting ethical practices.

2. **Athleisure**: The trend of athleisure wear continues to be popular, with consumers looking for versatile and comfortable clothing that can be worn both during workouts and in everyday life.

3. **Performance and Functionality**: Consumers prioritize performance-enhancing features in sports apparel, such as moisture-wicking fabrics, breathable materials, and ergonomic designs that enhance comfort and mobility.

4. **Personalization**: Customization options, personalized fit, and unique design elements are appealing to consumers who seek individuality and exclusivity in their sports apparel choices.

5. **Brand Transparency**: Consumers value transparency in brand practices, including supply chain transparency, ethical sourcing, and clear communication on product quality and manufacturing processes.

Overall, consumer preferences in the sports apparel industry are shifting towards sustainability, versatility, performance, personalization, and transparency, influencing brand strategies and product offerings. 
 ### Potential New Markets for Nike to Explore in 2024

1. **India**: With a growing population, increasing disposable incomes, and a rising interest in health and fitness, India presents a significant opportunity for Nike to expand its presence and tap into a large consumer base.

2. **Africa**: The African market, particularly countries with emerging economies and a young population, offers potential for Nike to introduce its products and capitalize on the growing demand for sportswear and athletic footwear.

3. **Middle East**: Countries in the Middle East, known for their luxury shopping destinations and a growing interest in sports and fitness activities, could be strategic markets for Nike to target and establish a strong foothold.

4. **Latin America**: Markets in Latin America, such as Brazil, Mexico, and Argentina, present opportunities for Nike to cater to a diverse consumer base and leverage the region's passion for sports and active lifestyles.

5. **Southeast Asia**: Rapid urbanization, increasing urban middle-class population, and a trend towards health and wellness in countries like Indonesia, Thailand, and Vietnam make Southeast Asia an attractive region for Nike to explore and expand its market reach.

By exploring these new markets in 2024, Nike can diversify its geographical presence, reach untapped consumer segments, and drive growth in emerging economies. 
 ### Potential New Products or Services Nike Could Introduce in 2024

1. **Smart Apparel**: Nike could explore the integration of technology into its apparel, such as smart fabrics that monitor performance metrics, provide feedback, or enhance comfort during workouts.

2. **Athletic Accessories**: Introducing a line of athletic accessories like gym bags, water bottles, or fitness trackers could complement Nike's existing product offerings and provide additional value to customers.

3. **Customization Platforms**: Offering personalized design options for footwear and apparel through online customization platforms could appeal to consumers seeking unique and tailored products.

4. **Athletic Recovery Gear**: Developing recovery-focused products like compression wear, recovery sandals, or massage tools could cater to athletes and fitness enthusiasts looking to enhance post-workout recovery.

5. **Sustainable Collections**: Launching sustainable collections made from eco-friendly materials, recycled fabrics, or biodegradable components could align with consumer preferences for environmentally conscious products.

By introducing these new products or services in 2024, Nike can innovate its product portfolio, cater to evolving consumer needs, and differentiate itself in the competitive sports apparel market. 
 ### Potential Marketing Strategies for Nike to Increase Revenue in Q3 2024

1. **Influencer Partnerships**: Collaborating with popular athletes, celebrities, or social media influencers to promote Nike products can help reach a wider audience and drive sales.

2. **Interactive Campaigns**: Launching interactive marketing campaigns, contests, or events that engage customers and create buzz around new product releases can generate excitement and increase brand visibility.

3. **Social Media Engagement**: Leveraging social media platforms to connect with consumers, share user-generated content, and respond to feedback can build brand loyalty and encourage repeat purchases.

4. **Localized Marketing**: Tailoring marketing messages, promotions, and product offerings to specific regions or target demographics can enhance relevance and appeal to diverse consumer groups.

5. **Customer Loyalty Programs**: Implementing loyalty programs, exclusive offers, or rewards for repeat customers can incentivize brand loyalty, increase retention rates, and drive higher lifetime customer value.

By employing these marketing strategies in Q3 2024, Nike can enhance its brand presence, attract new customers, and ultimately boost revenue growth.













--------------------------------------------------

# File: applications/compliance_swarm.md



--------------------------------------------------

# File: applications/customer_support.md

## **Applications of Swarms: Revolutionizing Customer Support**

---

**Introduction**:  
In today's fast-paced digital world, responsive and efficient customer support is a linchpin for business success. The introduction of AI-driven swarms in the customer support domain can transform the way businesses interact with and assist their customers. By leveraging the combined power of multiple AI agents working in concert, businesses can achieve unprecedented levels of efficiency, customer satisfaction, and operational cost savings.

---

### **The Benefits of Using Swarms for Customer Support:**

1. **24/7 Availability**: Swarms never sleep. Customers receive instantaneous support at any hour, ensuring constant satisfaction and loyalty.
  
2. **Infinite Scalability**: Whether it's ten inquiries or ten thousand, swarms can handle fluctuating volumes with ease, eliminating the need for vast human teams and minimizing response times.
  
3. **Adaptive Intelligence**: Swarms learn collectively, meaning that a solution found for one customer can be instantly applied to benefit all. This leads to constantly improving support experiences, evolving with every interaction.

---

### **Features - Reinventing Customer Support**:

- **AI Inbox Monitor**: Continuously scans email inboxes, identifying and categorizing support requests for swift responses.
  
- **Intelligent Debugging**: Proactively helps customers by diagnosing and troubleshooting underlying issues.
  
- **Automated Refunds & Coupons**: Seamless integration with payment systems like Stripe allows for instant issuance of refunds or coupons if a problem remains unresolved.
  
- **Full System Integration**: Holistically connects with CRM, email systems, and payment portals, ensuring a cohesive and unified support experience.
  
- **Conversational Excellence**: With advanced LLMs (Language Model Transformers), the swarm agents can engage in natural, human-like conversations, enhancing customer comfort and trust.
  
- **Rule-based Operation**: By working with rule engines, swarms ensure that all actions adhere to company guidelines, ensuring consistent, error-free support.
  
- **Turing Test Ready**: Crafted to meet and exceed the Turing Test standards, ensuring that every customer interaction feels genuine and personal.

---

**Conclusion**:  
Swarms are not just another technological advancement; they represent the future of customer support. Their ability to provide round-the-clock, scalable, and continuously improving support can redefine customer experience standards. By adopting swarms, businesses can stay ahead of the curve, ensuring unparalleled customer loyalty and satisfaction.

**Experience the future of customer support. Dive into the swarm revolution.**



--------------------------------------------------

# File: applications/enterprise.md



--------------------------------------------------

# File: applications/marketing_agencies.md

## **Swarms in Marketing Agencies: A New Era of Automated Media Strategy**

---

### **Introduction**: 
- Brief background on marketing agencies and their role in driving brand narratives and sales.
- Current challenges and pain points faced in media planning, placements, and budgeting.
- Introduction to the transformative potential of swarms in reshaping the marketing industry.

---

### **1. Fundamental Problem: Media Plan Creation**:
   - **Definition**: The challenge of creating an effective media plan that resonates with a target audience and aligns with brand objectives.
   
   - **Traditional Solutions and Their Shortcomings**: Manual brainstorming sessions, over-reliance on past strategies, and long turnaround times leading to inefficiency.
   
   - **How Swarms Address This Problem**: 
      - **Benefit 1**: Automated Media Plan Generation – Swarms ingest branding summaries, objectives, and marketing strategies to generate media plans, eliminating guesswork and human error.
      - **Real-world Application of Swarms**: The automation of media plans based on client briefs, including platform selections, audience targeting, and creative versions.

---

### **2. Fundamental Problem: Media Placements**:
   - **Definition**: The tedious task of determining where ads will be placed, considering demographics, platform specifics, and more.
   
   - **Traditional Solutions and Their Shortcomings**: Manual placement leading to possible misalignment with target audiences and brand objectives.
   
   - **How Swarms Address This Problem**: 
      - **Benefit 2**: Precision Media Placements – Swarms analyze audience data and demographics to suggest the best placements, optimizing for conversions and brand reach.
      - **Real-world Application of Swarms**: Automated selection of ad placements across platforms like Facebook, Google, and DSPs based on media plans.

---

### **3. Fundamental Problem: Budgeting**:
   - **Definition**: Efficiently allocating and managing advertising budgets across multiple campaigns, platforms, and timeframes.
   
   - **Traditional Solutions and Their Shortcomings**: Manual budgeting using tools like Excel, prone to errors, and inefficient shifts in allocations.
   
   - **How Swarms Address This Problem**: 
      - **Benefit 3**: Intelligent Media Budgeting – Swarms enable dynamic budget allocation based on performance analytics, maximizing ROI.
      - **Real-world Application of Swarms**: Real-time adjustments in budget allocations based on campaign performance, eliminating long waiting periods and manual recalculations.

---

### **Features**:
1. Automated Media Plan Generator: Input your objectives and receive a comprehensive media plan.
2. Precision Media Placement Tool: Ensure your ads appear in the right places to the right people.
3. Dynamic Budget Allocation: Maximize ROI with real-time budget adjustments.
4. Integration with Common Tools: Seamless integration with tools like Excel and APIs for exporting placements.
5. Conversational Platform: A suite of tools built for modern marketing agencies, bringing all tasks under one umbrella.

---

### **Testimonials**:
- "Swarms have completely revolutionized our media planning process. What used to take weeks now takes mere hours." - *Senior Media Strategist, Top-tier Marketing Agency*
- "The precision with which we can place ads now is unprecedented. It's like having a crystal ball for marketing!" - *Campaign Manager, Global Advertising Firm*

---

### **Conclusion**: 
- Reiterate the immense potential of swarms in revolutionizing media planning, placements, and budgeting for marketing agencies.
- Call to action: For marketing agencies looking to step into the future and leave manual inefficiencies behind, swarms are the answer.

---

--------------------------------------------------

# File: blogs/blog.md

# Swarms API: Orchestrating the Future of AI Agent Collaboration

In today's rapidly evolving AI landscape, we're witnessing a fundamental shift from single-agent AI systems to complex, collaborative multi-agent architectures. While individual AI models like GPT-4 and Claude have demonstrated remarkable capabilities, they often struggle with complex tasks requiring diverse expertise, nuanced decision-making, and specialized domain knowledge. Enter the Swarms API, an enterprise-grade solution designed to orchestrate collaborative intelligence through coordinated AI agent swarms.

## The Problem: The Limitations of Single-Agent AI

Despite significant advances in large language models and AI systems, single-agent architectures face inherent limitations when tackling complex real-world problems:

### Expertise Boundaries
Even the most advanced AI models have knowledge boundaries. No single model can possess expert-level knowledge across all domains simultaneously. When a task requires deep expertise in multiple areas (finance, law, medicine, and technical analysis, for example), a single agent quickly reaches its limits.

### Complex Reasoning Chains
Many real-world problems demand multistep reasoning with multiple feedback loops and verification processes. Single agents often struggle to maintain reasoning coherence through extended problem-solving journeys, leading to errors that compound over time.

### Workflow Orchestration
Enterprise applications frequently require sophisticated workflows with multiple handoffs, approvals, and specialized processing steps. Managing this orchestration with individual AI instances is inefficient and error-prone.

### Resource Optimization
Deploying high-powered AI models for every task is expensive and inefficient. Organizations need right-sized solutions that match computing resources to task requirements.

### Collaboration Mechanisms
The most sophisticated human problem-solving happens in teams, where specialists collaborate, debate, and refine solutions together. This collaborative intelligence is difficult to replicate with isolated AI agents.

## The Solution: Swarms API

The Swarms API addresses these challenges through a revolutionary approach to AI orchestration. By enabling multiple specialized agents to collaborate in coordinated swarms, it unlocks new capabilities previously unattainable with single-agent architectures.

### What is the Swarms API?

The Swarms API is an enterprise-grade platform that enables organizations to deploy and manage intelligent agent swarms in the cloud. Rather than relying on a single AI agent to handle complex tasks, the Swarms API orchestrates teams of specialized AI agents that work together, each handling specific aspects of a larger problem.

The platform provides a robust infrastructure for creating, executing, and managing sophisticated AI agent workflows without the burden of maintaining the underlying infrastructure. With its cloud-native architecture, the Swarms API offers scalability, reliability, and security essential for enterprise deployments.

## Core Capabilities

The Swarms API delivers a comprehensive suite of capabilities designed for production-grade AI orchestration:

### Intelligent Swarm Management

At its core, the Swarms API enables the creation and execution of collaborative agent swarms. These swarms consist of specialized AI agents designed to work together on complex tasks. Unlike traditional AI approaches where a single model handles the entire workload, swarms distribute tasks among specialized agents, each contributing its expertise to the collective solution.

For example, a financial analysis swarm might include:
- A data preprocessing agent that cleans and normalizes financial data
- A market analyst agent that identifies trends and patterns
- An economic forecasting agent that predicts future market conditions
- A report generation agent that compiles insights into a comprehensive analysis

By coordinating these specialized agents, the swarm can deliver more accurate, nuanced, and valuable results than any single agent could produce alone.

### Automatic Agent Generation

One of the most powerful features of the Swarms API is its ability to dynamically create optimized agents based on task requirements. Rather than manually configuring each agent in a swarm, users can specify the overall task and let the platform automatically generate appropriate agents with optimized prompts and configurations.

This automatic agent generation significantly reduces the expertise and effort required to deploy effective AI solutions. The system analyzes the task requirements and creates a set of agents specifically designed to address different aspects of the problem. This approach not only saves time but also improves the quality of results by ensuring each agent is properly configured for its specific role.

### Multiple Swarm Architectures

Different problems require different collaboration patterns. The Swarms API supports various swarm architectures to match specific workflow needs:

- **SequentialWorkflow**: Agents work in a predefined sequence, with each agent handling specific subtasks in order
- **ConcurrentWorkflow**: Multiple agents work simultaneously on different aspects of a task
- **GroupChat**: Agents collaborate in a discussion format to solve problems collectively
- **HierarchicalSwarm**: Organizes agents in a structured hierarchy with managers and workers
- **MajorityVoting**: Uses a consensus mechanism where multiple agents vote on the best solution
- **AutoSwarmBuilder**: Automatically designs and builds an optimal swarm architecture based on the task
- **MixtureOfAgents**: Combines multiple agent types to tackle diverse aspects of a problem
- **MultiAgentRouter**: Routes subtasks to specialized agents based on their capabilities
- **AgentRearrange**: Dynamically reorganizes the workflow between agents based on evolving task requirements

This flexibility allows organizations to select the most appropriate collaboration pattern for each specific use case, optimizing the balance between efficiency, thoroughness, and creativity.

### Scheduled Execution

The Swarms API enables automated, scheduled swarm executions, allowing organizations to set up recurring tasks that run automatically at specified times. This feature is particularly valuable for regular reporting, monitoring, and analysis tasks that need to be performed on a consistent schedule.

For example, a financial services company could schedule a daily market analysis swarm to run before trading hours, providing updated insights based on overnight market movements. Similarly, a cybersecurity team might schedule hourly security assessment swarms to continuously monitor potential threats.

### Comprehensive Logging

Transparency and auditability are essential for enterprise AI applications. The Swarms API provides comprehensive logging capabilities that track all API interactions, agent communications, and decision processes. This detailed logging enables:

- Debugging and troubleshooting swarm behaviors
- Auditing decision trails for compliance and quality assurance
- Analyzing performance patterns to identify optimization opportunities
- Documenting the rationale behind AI-generated recommendations

These logs provide valuable insights into how swarms operate and make decisions, increasing trust and enabling continuous improvement of AI workflows.

### Cost Management

AI deployment costs can quickly escalate without proper oversight. The Swarms API addresses this challenge through:

- **Predictable, transparent pricing**: Clear cost structures that make budgeting straightforward
- **Optimized resource utilization**: Intelligent allocation of computing resources based on task requirements
- **Detailed cost breakdowns**: Comprehensive reporting on token usage, agent costs, and total expenditures
- **Model flexibility**: Freedom to choose the most cost-effective models for each agent based on task complexity

This approach ensures organizations get maximum value from their AI investments without unexpected cost overruns.

### Enterprise Security

Security is paramount for enterprise AI deployments. The Swarms API implements robust security measures including:

- **Full API key authentication**: Secure access control for all API interactions
- **Comprehensive key management**: Tools for creating, rotating, and revoking API keys
- **Usage monitoring**: Tracking and alerting for suspicious activity patterns
- **Secure data handling**: Appropriate data protection throughout the swarm execution lifecycle

These security features ensure that sensitive data and AI workflows remain protected in accordance with enterprise security requirements.

## How It Works: Behind the Scenes

The Swarms API operates on a sophisticated architecture designed for reliability, scalability, and performance. Here's a look at what happens when you submit a task to the Swarms API:

1. **Task Submission**: You send a request to the API with your task description and desired swarm configuration.

2. **Swarm Configuration**: The system either uses your specified agent configuration or automatically generates an optimal swarm structure based on the task requirements.

3. **Agent Initialization**: Each agent in the swarm is initialized with its specific instructions, model parameters, and role definitions.

4. **Orchestration Setup**: The system establishes the communication and workflow patterns between agents based on the selected swarm architecture.

5. **Execution**: The swarm begins working on the task, with agents collaborating according to their defined roles and relationships.

6. **Monitoring and Adjustment**: Throughout execution, the system monitors agent performance and makes adjustments as needed.

7. **Result Compilation**: Once the task is complete, the system compiles the results into the requested format.

8. **Response Delivery**: The final output is returned to you, along with metadata about the execution process.

This entire process happens seamlessly in the cloud, with the Swarms API handling all the complexities of agent coordination, resource allocation, and workflow management.

## Real-World Applications

The Swarms API enables a wide range of applications across industries. Here are some compelling use cases that demonstrate its versatility:

### Financial Services

#### Investment Research
Financial institutions can deploy research swarms that combine market analysis, economic forecasting, company evaluation, and risk assessment. These swarms can evaluate investment opportunities much more comprehensively than single-agent systems, considering multiple factors simultaneously:

- Macroeconomic indicators
- Company fundamentals
- Market sentiment
- Technical analysis patterns
- Regulatory considerations

For example, an investment research swarm analyzing a potential stock purchase might include specialists in the company's industry, financial statement analysis, market trend identification, and risk assessment. This collaborative approach delivers more nuanced insights than any single analyst or model could produce independently.

#### Regulatory Compliance
Financial regulations are complex and constantly evolving. Compliance swarms can monitor regulatory changes, assess their impact on existing policies, and recommend appropriate adjustments. These swarms might include:

- Regulatory monitoring agents that track new rules and guidelines
- Policy analysis agents that evaluate existing compliance frameworks
- Gap assessment agents that identify discrepancies
- Documentation agents that update compliance materials

This approach ensures comprehensive coverage of regulatory requirements while minimizing compliance risks.

### Healthcare

#### Medical Research Analysis
The medical literature grows at an overwhelming pace, making it difficult for researchers and clinicians to stay current. Research analysis swarms can continuously scan new publications, identify relevant findings, and synthesize insights for specific research questions or clinical scenarios.

A medical research swarm might include:
- Literature scanning agents that identify relevant publications
- Methodology assessment agents that evaluate research quality
- Clinical relevance agents that determine practical applications
- Summary agents that compile key findings into accessible reports

This collaborative approach enables more thorough literature reviews and helps bridge the gap between research and clinical practice.

#### Treatment Planning
Complex medical cases often benefit from multidisciplinary input. Treatment planning swarms can integrate perspectives from different medical specialties, consider patient-specific factors, and recommend comprehensive care approaches.

For example, an oncology treatment planning swarm might include specialists in:
- Diagnostic interpretation
- Treatment protocol evaluation
- Drug interaction assessment
- Patient history analysis
- Evidence-based outcome prediction

By combining these specialized perspectives, the swarm can develop more personalized and effective treatment recommendations.

### Legal Services

#### Contract Analysis
Legal contracts contain numerous interconnected provisions that must be evaluated holistically. Contract analysis swarms can review complex agreements more thoroughly by assigning different sections to specialized agents:

- Definition analysis agents that ensure consistent terminology
- Risk assessment agents that identify potential liabilities
- Compliance agents that check regulatory requirements
- Precedent comparison agents that evaluate terms against standards
- Conflict detection agents that identify internal inconsistencies

This distributed approach enables more comprehensive contract reviews while reducing the risk of overlooking critical details.

#### Legal Research
Legal research requires examining statutes, case law, regulations, and scholarly commentary. Research swarms can conduct multi-faceted legal research by coordinating specialized agents focusing on different aspects of the legal landscape.

A legal research swarm might include:
- Statutory analysis agents that examine relevant laws
- Case law agents that review judicial precedents
- Regulatory agents that assess administrative rules
- Scholarly analysis agents that evaluate academic perspectives
- Synthesis agents that integrate findings into cohesive arguments

This collaborative approach produces more comprehensive legal analyses that consider multiple sources of authority.

### Research and Development

#### Scientific Literature Review
Scientific research increasingly spans multiple disciplines, making comprehensive literature reviews challenging. Literature review swarms can analyze publications across relevant fields, identify methodological approaches, and synthesize findings from diverse sources.

For example, a biomedical engineering literature review swarm might include specialists in:
- Materials science
- Cellular biology
- Clinical applications
- Regulatory requirements
- Statistical methods

By integrating insights from these different perspectives, the swarm can produce more comprehensive and valuable literature reviews.

#### Experimental Design
Designing robust experiments requires considering multiple factors simultaneously. Experimental design swarms can develop sophisticated research protocols by integrating methodological expertise, statistical considerations, practical constraints, and ethical requirements.

An experimental design swarm might coordinate:
- Methodology agents that design experimental procedures
- Statistical agents that determine appropriate sample sizes and analyses
- Logistics agents that assess practical feasibility
- Ethics agents that evaluate potential concerns
- Documentation agents that prepare formal protocols

This collaborative approach leads to more rigorous experimental designs while addressing potential issues preemptively.

### Software Development

#### Code Review and Optimization
Code review requires evaluating multiple aspects simultaneously: functionality, security, performance, maintainability, and adherence to standards. Code review swarms can distribute these concerns among specialized agents:

- Functionality agents that evaluate whether code meets requirements
- Security agents that identify potential vulnerabilities
- Performance agents that assess computational efficiency
- Style agents that check adherence to coding standards
- Documentation agents that review comments and documentation

By addressing these different aspects in parallel, code review swarms can provide more comprehensive feedback to development teams.

#### System Architecture Design
Designing complex software systems requires balancing numerous considerations. Architecture design swarms can develop more robust system designs by coordinating specialists in different architectural concerns:

- Scalability agents that evaluate growth potential
- Security agents that assess protective measures
- Performance agents that analyze efficiency
- Maintainability agents that consider long-term management
- Integration agents that evaluate external system connections

This collaborative approach leads to more balanced architectural decisions that address multiple requirements simultaneously.

## Getting Started with the Swarms API

The Swarms API is designed for straightforward integration into existing workflows. Let's walk through the setup process and explore some practical code examples for different industries.

### 1. Setting Up Your Environment

First, create an account on [swarms.world](https://swarms.world). After registration, navigate to the API key management interface at [https://swarms.world/platform/api-keys](https://swarms.world/platform/api-keys) to generate your API key.

Once you have your API key, set up your Python environment:

```python
# Install required packages
pip install requests python-dotenv
```

Create a basic project structure:

```
swarms-project/
├── .env                # Store your API key securely
├── swarms_client.py    # Helper functions for API interaction
└── examples/           # Industry-specific examples
```

In your `.env` file, add your API key:

```
SWARMS_API_KEY=your_api_key_here
```

### 2. Creating a Basic Swarms Client

Let's create a simple client to interact with the Swarms API:

```python
# swarms_client.py
import os
import requests
from dotenv import load_dotenv
import json

# Load environment variables
load_dotenv()

# Configuration
API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

# Standard headers for all requests
headers = {
    "x-api-key": API_KEY,
    "Content-Type": "application/json"
}

def check_api_health():
    """Simple health check to verify API connectivity."""
    response = requests.get(f"{BASE_URL}/health", headers=headers)
    return response.json()

def run_swarm(swarm_config):
    """Execute a swarm with the provided configuration."""
    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=swarm_config
    )
    return response.json()

def get_available_swarms():
    """Retrieve list of available swarm types."""
    response = requests.get(f"{BASE_URL}/v1/swarms/available", headers=headers)
    return response.json()

def get_available_models():
    """Retrieve list of available AI models."""
    response = requests.get(f"{BASE_URL}/v1/models/available", headers=headers)
    return response.json()

def get_swarm_logs():
    """Retrieve logs of previous swarm executions."""
    response = requests.get(f"{BASE_URL}/v1/swarm/logs", headers=headers)
    return response.json()
```

### 3. Industry-Specific Examples

Let's explore practical applications of the Swarms API across different industries.

#### Healthcare: Clinical Research Assistant

This example creates a swarm that analyzes clinical trial data and summarizes findings:

```python
# healthcare_example.py
from swarms_client import run_swarm
import json

def clinical_research_assistant():
    """
    Create a swarm that analyzes clinical trial data, identifies patterns,
    and generates comprehensive research summaries.
    """
    swarm_config = {
        "name": "Clinical Research Assistant",
        "description": "Analyzes medical research data and synthesizes findings",
        "agents": [
            {
                "agent_name": "Data Preprocessor",
                "description": "Cleans and organizes clinical trial data",
                "system_prompt": "You are a data preprocessing specialist focused on clinical trials. "
                                "Your task is to organize, clean, and structure raw clinical data for analysis. "
                                "Identify and handle missing values, outliers, and inconsistencies in the data.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Clinical Analyst",
                "description": "Analyzes preprocessed data to identify patterns and insights",
                "system_prompt": "You are a clinical research analyst with expertise in interpreting medical data. "
                                "Your job is to examine preprocessed clinical trial data, identify significant patterns, "
                                "and determine the clinical relevance of these findings. Consider factors such as "
                                "efficacy, safety profiles, and patient subgroups.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Medical Writer",
                "description": "Synthesizes analysis into comprehensive reports",
                "system_prompt": "You are a medical writer specializing in clinical research. "
                                "Your task is to take the analyses provided and create comprehensive, "
                                "well-structured reports that effectively communicate findings to both "
                                "medical professionals and regulatory authorities. Follow standard "
                                "medical publication guidelines.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            }
        ],
        "max_loops": 1,
        "swarm_type": "SequentialWorkflow",
        "task": "Analyze the provided Phase III clinical trial data for Drug XYZ, "
                "a novel treatment for type 2 diabetes. Identify efficacy patterns across "
                "different patient demographics, note any safety concerns, and prepare "
                "a comprehensive summary suitable for submission to regulatory authorities."
    }
    
    # Execute the swarm
    result = run_swarm(swarm_config)
    
    # Print formatted results
    print(json.dumps(result, indent=4))
    return result

if __name__ == "__main__":
    clinical_research_assistant()
```

#### Legal: Contract Analysis System

This example demonstrates a swarm designed to analyze complex legal contracts:

```python
# legal_example.py
from swarms_client import run_swarm
import json

def contract_analysis_system():
    """
    Create a swarm that thoroughly analyzes legal contracts,
    identifies potential risks, and suggests improvements.
    """
    swarm_config = {
        "name": "Contract Analysis System",
        "description": "Analyzes legal contracts for risks and improvement opportunities",
        "agents": [
            {
                "agent_name": "Clause Extractor",
                "description": "Identifies and categorizes key clauses in contracts",
                "system_prompt": "You are a legal document specialist. Your task is to "
                                "carefully review legal contracts and identify all key clauses, "
                                "categorizing them by type (liability, indemnification, termination, etc.). "
                                "Extract each clause with its context and prepare them for detailed analysis.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Risk Assessor",
                "description": "Evaluates clauses for potential legal risks",
                "system_prompt": "You are a legal risk assessment expert. Your job is to "
                                "analyze contract clauses and identify potential legal risks, "
                                "exposure points, and unfavorable terms. Rate each risk on a "
                                "scale of 1-5 and provide justification for your assessment.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Improvement Recommender",
                "description": "Suggests alternative language to mitigate risks",
                "system_prompt": "You are a contract drafting expert. Based on the risk "
                                "assessment provided, suggest alternative language for "
                                "problematic clauses to better protect the client's interests. "
                                "Ensure suggestions are legally sound and professionally worded.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Summary Creator",
                "description": "Creates executive summary of findings and recommendations",
                "system_prompt": "You are a legal communication specialist. Create a clear, "
                                "concise executive summary of the contract analysis, highlighting "
                                "key risks and recommendations. Your summary should be understandable "
                                "to non-legal executives while maintaining accuracy.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            }
        ],
        "max_loops": 1,
        "swarm_type": "SequentialWorkflow",
        "task": "Analyze the attached software licensing agreement between TechCorp and ClientInc. "
                "Identify all key clauses, assess potential risks to ClientInc, suggest improvements "
                "to better protect ClientInc's interests, and create an executive summary of findings."
    }
    
    # Execute the swarm
    result = run_swarm(swarm_config)
    
    # Print formatted results
    print(json.dumps(result, indent=4))
    return result

if __name__ == "__main__":
    contract_analysis_system()
```

#### Private Equity: Investment Opportunity Analysis

This example shows a swarm that performs comprehensive due diligence on potential investments:

```python
# private_equity_example.py
from swarms_client import run_swarm, schedule_swarm
import json
from datetime import datetime, timedelta

def investment_opportunity_analysis():
    """
    Create a swarm that performs comprehensive due diligence
    on potential private equity investment opportunities.
    """
    swarm_config = {
        "name": "PE Investment Analyzer",
        "description": "Performs comprehensive analysis of private equity investment opportunities",
        "agents": [
            {
                "agent_name": "Financial Analyst",
                "description": "Analyzes financial statements and projections",
                "system_prompt": "You are a private equity financial analyst with expertise in "
                                "evaluating company financials. Review the target company's financial "
                                "statements, analyze growth trajectories, profit margins, cash flow patterns, "
                                "and debt structure. Identify financial red flags and growth opportunities.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Market Researcher",
                "description": "Assesses market conditions and competitive landscape",
                "system_prompt": "You are a market research specialist in the private equity sector. "
                                "Analyze the target company's market position, industry trends, competitive "
                                "landscape, and growth potential. Identify market-related risks and opportunities "
                                "that could impact investment returns.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Operational Due Diligence",
                "description": "Evaluates operational efficiency and improvement opportunities",
                "system_prompt": "You are an operational due diligence expert. Analyze the target "
                                "company's operational structure, efficiency metrics, supply chain, "
                                "technology infrastructure, and management capabilities. Identify "
                                "operational improvement opportunities that could increase company value.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Risk Assessor",
                "description": "Identifies regulatory, legal, and business risks",
                "system_prompt": "You are a risk assessment specialist in private equity. "
                                "Evaluate potential regulatory challenges, legal liabilities, "
                                "compliance issues, and business model vulnerabilities. Rate "
                                "each risk based on likelihood and potential impact.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Investment Thesis Creator",
                "description": "Synthesizes analysis into comprehensive investment thesis",
                "system_prompt": "You are a private equity investment strategist. Based on the "
                                "analyses provided, develop a comprehensive investment thesis "
                                "that includes valuation assessment, potential returns, value "
                                "creation opportunities, exit strategies, and investment recommendations.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            }
        ],
        "max_loops": 1,
        "swarm_type": "SequentialWorkflow",
        "task": "Perform comprehensive due diligence on HealthTech Inc., a potential acquisition "
                "target in the healthcare technology sector. The company develops remote patient "
                "monitoring solutions and has shown 35% year-over-year growth for the past three years. "
                "Analyze financials, market position, operational structure, potential risks, and "
                "develop an investment thesis with a recommended valuation range."
    }
    
    # Option 1: Execute the swarm immediately
    result = run_swarm(swarm_config)
    
    # Option 2: Schedule the swarm for tomorrow morning
    tomorrow = (datetime.now() + timedelta(days=1)).replace(hour=8, minute=0, second=0).isoformat()
    # scheduled_result = schedule_swarm(swarm_config, tomorrow, "America/New_York")
    
    # Print formatted results from immediate execution
    print(json.dumps(result, indent=4))
    return result

if __name__ == "__main__":
    investment_opportunity_analysis()
```


#### Education: Curriculum Development Assistant

This example shows how to use the Concurrent Workflow swarm type:

```python
# education_example.py
from swarms_client import run_swarm
import json

def curriculum_development_assistant():
    """
    Create a swarm that assists in developing educational curriculum
    with concurrent subject matter experts.
    """
    swarm_config = {
        "name": "Curriculum Development Assistant",
        "description": "Develops comprehensive educational curriculum",
        "agents": [
            {
                "agent_name": "Subject Matter Expert",
                "description": "Provides domain expertise on the subject",
                "system_prompt": "You are a subject matter expert in data science. "
                                "Your role is to identify the essential concepts, skills, "
                                "and knowledge that students need to master in a comprehensive "
                                "data science curriculum. Focus on both theoretical foundations "
                                "and practical applications, ensuring the content reflects current "
                                "industry standards and practices.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Instructional Designer",
                "description": "Structures learning objectives and activities",
                "system_prompt": "You are an instructional designer specializing in technical education. "
                                "Your task is to transform subject matter content into structured learning "
                                "modules with clear objectives, engaging activities, and appropriate assessments. "
                                "Design the learning experience to accommodate different learning styles and "
                                "knowledge levels.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Assessment Specialist",
                "description": "Develops evaluation methods and assessments",
                "system_prompt": "You are an educational assessment specialist. "
                                "Design comprehensive assessment strategies to evaluate student "
                                "learning throughout the curriculum. Create formative and summative "
                                "assessments, rubrics, and feedback mechanisms that align with learning "
                                "objectives and provide meaningful insights into student progress.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            },
            {
                "agent_name": "Curriculum Integrator",
                "description": "Synthesizes input from all specialists into a cohesive curriculum",
                "system_prompt": "You are a curriculum development coordinator. "
                                "Your role is to synthesize the input from subject matter experts, "
                                "instructional designers, and assessment specialists into a cohesive, "
                                "comprehensive curriculum. Ensure logical progression of topics, "
                                "integration of theory and practice, and alignment between content, "
                                "activities, and assessments.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1
            }
        ],
        "max_loops": 1,
        "swarm_type": "ConcurrentWorkflow",  # Experts work simultaneously before integration
        "task": "Develop a comprehensive 12-week data science curriculum for advanced undergraduate "
                "students with programming experience. The curriculum should cover data analysis, "
                "machine learning, data visualization, and ethics in AI. Include weekly learning "
                "objectives, teaching materials, hands-on activities, and assessment methods. "
                "The curriculum should prepare students for entry-level data science positions."
    }
    
    # Execute the swarm
    result = run_swarm(swarm_config)
    
    # Print formatted results
    print(json.dumps(result, indent=4))
    return result

if __name__ == "__main__":
    curriculum_development_assistant()
```


### 5. Monitoring and Optimization

To optimize your swarm configurations and track usage patterns, you can retrieve and analyze logs:

```python
# analytics_example.py
from swarms_client import get_swarm_logs
import json

def analyze_swarm_usage():
    """
    Analyze swarm usage patterns to optimize configurations and costs.
    """
    # Retrieve logs
    logs = get_swarm_logs()

    return logs
if __name__ == "__main__":
    analyze_swarm_usage()
```

### 6. Next Steps

Once you've implemented and tested these examples, you can further optimize your swarm configurations by:

1. Experimenting with different swarm architectures for the same task to compare results
2. Adjusting agent prompts to improve specialization and collaboration
3. Fine-tuning model parameters like temperature and max_tokens
4. Combining swarms into larger workflows through scheduled execution

The Swarms API's flexibility allows for continuous refinement of your AI orchestration strategies, enabling increasingly sophisticated solutions to complex problems.

## The Future of AI Agent Orchestration

The Swarms API represents a significant evolution in how we deploy AI for complex tasks. As we look to the future, several trends are emerging in the field of agent orchestration:

### Specialized Agent Ecosystems

We're moving toward rich ecosystems of highly specialized agents designed for specific tasks and domains. These specialized agents will have deep expertise in narrow areas, enabling more sophisticated collaboration when combined in swarms.

### Dynamic Swarm Formation

Future swarm platforms will likely feature even more advanced capabilities for dynamic swarm formation, where the system automatically determines not only which agents to include but also how they should collaborate based on real-time task analysis.

### Cross-Modal Collaboration

As AI capabilities expand across modalities (text, image, audio, video), we'll see increasing collaboration between agents specialized in different data types. This cross-modal collaboration will enable more comprehensive analysis and content creation spanning multiple formats.

### Human-Swarm Collaboration

The next frontier in agent orchestration will be seamless collaboration between human teams and AI swarms, where human specialists and AI agents work together, each contributing their unique strengths to complex problems.

### Continuous Learning Swarms

Future swarms will likely incorporate more sophisticated mechanisms for continuous improvement, with agent capabilities evolving based on past performance and feedback.

## Conclusion

The Swarms API represents a significant leap forward in AI orchestration, moving beyond the limitations of single-agent systems to unlock the power of collaborative intelligence. By enabling specialized agents to work together in coordinated swarms, this enterprise-grade platform opens new possibilities for solving complex problems across industries.

From financial analysis to healthcare research, legal services to software development, the applications for agent swarms are as diverse as they are powerful. The Swarms API provides the infrastructure, tools, and flexibility needed to deploy these collaborative AI systems at scale, with the security, reliability, and cost management features essential for enterprise adoption.

As we continue to push the boundaries of what AI can accomplish, the ability to orchestrate collaborative intelligence will become increasingly crucial. The Swarms API is at the forefront of this evolution, providing a glimpse into the future of AI—a future where the most powerful AI systems aren't individual models but coordinated teams of specialized agents working together to solve our most challenging problems.

For organizations looking to harness the full potential of AI, the Swarms API offers a compelling path forward—one that leverages the power of collaboration to achieve results beyond what any single AI agent could accomplish alone.

To explore the Swarms API and begin building your own intelligent agent swarms, visit [swarms.world](https://swarms.world) today.

---

## Resources

* Website: [swarms.ai](https://swarms.ai)
* Marketplace: [swarms.world](https://swarms.world)
* Cloud Platform: [cloud.swarms.ai](https://cloud.swarms.ai)
* Documentation: [docs.swarms.world](https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/)

--------------------------------------------------

# File: concepts/limitations.md

# Limitations of Individual Agents

This section explores the fundamental limitations of individual AI agents and why multi-agent systems are necessary for complex tasks. Understanding these limitations is crucial for designing effective multi-agent architectures.

## Overview

```mermaid
graph TD
    A[Individual Agent Limitations] --> B[Context Window Limits]
    A --> C[Hallucination]
    A --> D[Single Task Execution]
    A --> E[Lack of Collaboration]
    A --> F[Accuracy Issues]
    A --> G[Processing Speed]
```

## 1. Context Window Limits

### The Challenge
Individual agents are constrained by fixed context windows, limiting their ability to process large amounts of information simultaneously.

```mermaid
graph LR
    subgraph "Context Window Limitation"
        Input[Large Document] --> Truncation[Truncation]
        Truncation --> ProcessedPart[Processed Part]
        Truncation --> UnprocessedPart[Unprocessed Part]
    end
```

### Impact
- Limited understanding of large documents
- Fragmented processing of long conversations
- Inability to maintain extended context
- Loss of important information

## 2. Hallucination

### The Challenge
Individual agents may generate plausible-sounding but incorrect information, especially when dealing with ambiguous or incomplete data.

```mermaid
graph TD
    Input[Ambiguous Input] --> Agent[AI Agent]
    Agent --> Valid[Valid Output]
    Agent --> Hallucination[Hallucinated Output]
    style Hallucination fill:#ff9999
```

### Impact
- Unreliable information generation
- Reduced trust in system outputs
- Potential for misleading decisions
- Need for extensive verification

## 3. Single Task Execution

### The Challenge
Most individual agents are optimized for specific tasks and struggle with multi-tasking or adapting to new requirements.

```mermaid
graph LR
    Task1[Task A] --> Agent1[Agent A]
    Task2[Task B] --> Agent2[Agent B]
    Task3[Task C] --> Agent3[Agent C]
    Agent1 --> Output1[Output A]
    Agent2 --> Output2[Output B]
    Agent3 --> Output3[Output C]
```

### Impact
- Limited flexibility
- Inefficient resource usage
- Complex integration requirements
- Reduced adaptability

## 4. Lack of Collaboration

### The Challenge
Individual agents operate in isolation, unable to share insights or coordinate actions with other agents.

```mermaid
graph TD
    A1[Agent 1] --> O1[Output 1]
    A2[Agent 2] --> O2[Output 2]
    A3[Agent 3] --> O3[Output 3]
    style A1 fill:#f9f,stroke:#333
    style A2 fill:#f9f,stroke:#333
    style A3 fill:#f9f,stroke:#333
```

### Impact
- No knowledge sharing
- Duplicate effort
- Missed optimization opportunities
- Limited problem-solving capabilities

## 5. Accuracy Issues

### The Challenge
Individual agents may produce inaccurate results due to:
- Limited training data
- Model biases
- Lack of cross-validation
- Incomplete context understanding

```mermaid
graph LR
    Input[Input Data] --> Processing[Processing]
    Processing --> Accurate[Accurate Output]
    Processing --> Inaccurate[Inaccurate Output]
    style Inaccurate fill:#ff9999
```

## 6. Processing Speed Limitations

### The Challenge
Individual agents may experience:
- Slow response times
- Resource constraints
- Limited parallel processing
- Bottlenecks in complex tasks

```mermaid
graph TD
    Input[Input] --> Queue[Processing Queue]
    Queue --> Processing[Sequential Processing]
    Processing --> Delay[Processing Delay]
    Delay --> Output[Delayed Output]
```

## Best Practices for Mitigation

1. **Use Multi-Agent Systems**
   - Distribute tasks across agents
   - Enable parallel processing
   - Implement cross-validation
   - Foster collaboration

2. **Implement Verification**
   - Cross-check results
   - Use consensus mechanisms
   - Monitor accuracy metrics
   - Track performance

3. **Optimize Resource Usage**
   - Balance load distribution
   - Cache frequent operations
   - Implement efficient queuing
   - Monitor system health

## Conclusion

Understanding these limitations is crucial for:
- Designing robust multi-agent systems
- Implementing effective mitigation strategies
- Optimizing system performance
- Ensuring reliable outputs

The next section explores how [Multi-Agent Architecture](architecture.md) addresses these limitations through collaborative approaches and specialized agent roles. 

--------------------------------------------------

# File: contributors/docs.md

# Contributing to Swarms Documentation

---

The Swarms documentation serves as the primary gateway for developer and user engagement within the Swarms ecosystem. Comprehensive, clear, and consistently updated documentation accelerates adoption, reduces support requests, and helps maintain a thriving developer community. This guide offers an in-depth, actionable framework for contributing to the Swarms documentation site, covering the full lifecycle from initial setup to the implementation of our bounty-based rewards program. 

This guide is designed for first-time contributors, experienced engineers, and technical writers alike. It emphasizes professional standards, collaborative development practices, and incentivized participation through our structured rewards program. Contributors play a key role in helping us scale and evolve our ecosystem by improving the clarity, accessibility, and technical depth of our documentation.

---

## 1. Introduction

Documentation in the Swarms ecosystem is not simply static text. It is a living, breathing system that guides users, developers, and enterprises in effectively utilizing our frameworks, SDKs, APIs, and tools. Whether you are documenting a new feature, refining an API call, writing a tutorial, or correcting existing information, every contribution has a direct impact on the product’s usability and user satisfaction. 

**Objectives of this Guide:**


- Define a standardized contribution workflow for Swarms documentation.

- Clarify documentation roles, responsibilities, and submission expectations.

- Establish quality benchmarks, review procedures, and formatting rules.

- Introduce the Swarms Documentation Bounty Program to incentivize excellence.

---

## 2. Why Documentation Is a Strategic Asset

1. **Accelerates Onboarding**: Reduces friction for new users, enabling faster adoption and integration.
2. **Improves Support Efficiency**: Decreases dependency on live support and helps automate resolution of common queries.
3. **Builds Community Trust**: Transparent documentation invites feedback and fosters a sense of shared ownership.
4. **Enables Scalability**: As Swarms evolves, up-to-date documentation ensures that teams across the globe can keep pace.

By treating documentation as a core product component, we ensure continuity, scalability, and user satisfaction.

---

## 3. Understanding the Swarms Ecosystem

The Swarms ecosystem consists of multiple tightly integrated components that serve developers and enterprise clients alike:


- **Core Documentation Repository**: The main documentation hub for all Swarms technologies [GitHub](https://github.com/kyegomez/swarms).

- **Rust SDK (`swarms_rs`)**: Official documentation for the Rust implementation. [Repo](https://github.com/The-Swarm-Corporation/swarms-rs).

- **Tools Documentation (`swarms_tools`)**: Guides for CLI and GUI utilities.

- **Hosted API Reference**: Up-to-date REST API documentation: [Swarms API Docs](https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/).

- **Marketplace & Chat**: Web platforms and communication interfaces [swarms.world](https://swarms.world).

All contributions funnel through the `docs/` directory in the core repo and are structured via MkDocs.

---

## 4. Documentation Tools and Platforms

Swarms documentation is powered by [MkDocs](https://www.mkdocs.org/), an extensible static site generator tailored for project documentation. To contribute, you should be comfortable with:

- **Markdown**: For formatting structure, code snippets, lists, and links.

- **MkDocs Configuration**: `mkdocs.yml` manages structure, theme, and navigation.

- **Version Control**: GitHub for branching, version tracking, and collaboration.

**Recommended Tooling:**

- Markdown linters to enforce syntax consistency.

- Spellcheckers to ensure grammatical accuracy.

- Doc generators for automated API reference extraction.

---

## 5. Getting Started with Contributions

### 5.1 System Requirements


- **Git** v2.30 or higher

- **Node.js** and **npm** for related dependency management

- **MkDocs** and **Material for MkDocs** theme (`pip install mkdocs mkdocs-material`)

- A GitHub account with permissions to fork and submit pull requests

### 5.2 Forking the Swarms Repository

1. Visit: `https://github.com/kyegomez/swarms`

2. Click on **Fork** to create your version of the repository

### 5.3 Clone and Configure Locally

```bash
git clone https://github.com/<your-username>/swarms.git
cd swarms/docs
git checkout -b feature/docs-<short-description>
```

---

## 6. Understanding the Repository Structure

Explore the documentation directory:

```text
docs/
├── index.md
├── mkdocs.yml
├── swarms_rs/
│   ├── overview.md
│   └── ...
└── swarms_tools/
    ├── install.md
    └── ...
```

### 6.1 SDK/Tools Directories

- **Rust SDK (`docs/swarms_rs`)**: Guides, references, and API walkthroughs for the Rust-based implementation.

- **Swarms Tools (`docs/swarms_tools`)**: CLI guides, GUI usage instructions, and architecture documentation.


Add new `.md` files in the folder corresponding to your documentation type.

### 6.2 Configuring Navigation in MkDocs

Update `mkdocs.yml` to integrate your new document:

```yaml
nav:
  - Home: index.md
  - Swarms Rust:
      - Overview: swarms_rs/overview.md
      - Your Topic: swarms_rs/your_file.md
  - Swarms Tools:
      - Installation: swarms_tools/install.md
      - Your Guide: swarms_tools/your_file.md
```

---

## 7. Writing and Editing Documentation

### 7.1 Content Standards


- **Clarity**: Explain complex ideas in simple, direct language.

- **Style Consistency**: Match the tone and structure of existing docs.

- **Accuracy**: Validate all technical content and code snippets.

- **Accessibility**: Include alt text for images and use semantic Markdown.

### 7.2 Markdown Best Practices

- Sequential heading levels (`#`, `##`, `###`)

- Use fenced code blocks with language identifiers

- Create readable line spacing and avoid unnecessary line breaks


### 7.3 File Placement Protocol

Place `.md` files into the correct subdirectory:


- **Rust SDK Docs**: `docs/swarms_rs/`

- **Tooling Docs**: `docs/swarms_tools/`

---

## 8. Updating Navigation Configuration

After writing your content:

1. Open `mkdocs.yml`
2. Identify where your file belongs
3. Add it to the `nav` hierarchy
4. Preview changes:

```bash
mkdocs serve
# Open http://127.0.0.1:8000 to verify output
```

---

## 9. Workflow: Branches, Commits, Pull Requests

### 9.1 Branch Naming Guidelines

- Use prefix and description, e.g.:
  - `feature/docs-api-pagination`

  - `fix/docs-typo-tooling`

### 9.2 Writing Clear Commits

Follow [Conventional Commits](https://www.conventionalcommits.org/):

```bash
docs(swarms_rs): add stream API tutorial
docs(swarms_tools): correct CLI usage example
```

### 9.3 Submitting a Pull Request

1. Push your feature branch
2. Open a new PR to the main repository
3. Use a descriptive title and include:
   - Summary of changes
   - Justification
   - Screenshots or previews
4. Tag relevant reviewers and apply labels (`documentation`, `bounty-eligible`)

---

## 10. Review, QA, and Merging

Every PR undergoes automated and human review:

- **CI Checks**: Syntax validation, link checking, and formatting

- **Manual Review**: Maintain clarity, completeness, and relevance

- **Iteration**: Collaborate through feedback and finalize changes

Once approved, maintainers will merge and deploy the updated documentation.

---

## 11. Swarms Documentation Bounty Initiative

To foster continuous improvement, we offer structured rewards for eligible contributions:

### 11.1 Contribution Types


- Creating comprehensive new tutorials and deep dives

- Updating outdated references and examples

- Fixing typos, grammar, and formatting errors

- Translating existing content

### 11.2 Reward Structure

| Tier     | Description                                            | Payout (USD)     |
|----------|--------------------------------------------------------|------------------|
| Bronze   | Typos or minor enhancements (< 100 words)             | $1 - $5        |
| Silver   | Small tutorials, API examples (100–500 words)         | $5 - $20       |
| Gold     | Major updates or guides (> 500 words)                 | $20 - $50      |
| Platinum | Multi-part guides or new documentation verticals      | $50 - 300          |

### 11.3 Claiming Bounties

1. Label your PR `bounty-eligible`
2. Describe expected tier and rationale
3. Review team assesses scope and assigns reward
4. Rewards paid post-merge via preferred method (PayPal, crypto, or wire)

---

## 12. Best Practices for Efficient Contribution

- **Stay Updated**: Sync your fork weekly to avoid merge conflicts

- **Atomic PRs**: Submit narrowly scoped changes for faster review

- **Use Visuals**: Support documentation with screenshots or diagrams

- **Cross-Reference**: Link to related documentation for completeness

- **Version Awareness**: Specify SDK/tool versions in code examples

---

## 13. Style Guide Snapshot


- **Voice**: Informative, concise, and respectful

- **Terminology**: Use standardized terms (`Swarm`, `Swarms`) consistently

- **Code**: Format snippets using language-specific linters

- **Accessibility**: Include alt attributes and avoid ambiguous links

---

## 14. Monitoring & Improving Documentation Health

We use analytics and community input to prioritize improvements:

- **Traffic Reports**: Track most/least visited pages

- **Search Logs**: Detect content gaps from common search terms

- **Feedback Forms**: Collect real-world user input

Schedule quarterly audits to refine structure and content across all repositories.

---

## 15. Community Promotion & Engagement

Promote your contributions via:


- **Swarms Discord**: https://discord.gg/jM3Z6M9uMq

- **Swarms Telegram**: https://t.me/swarmsgroupchat

- **Swarms Twitter**: https://x.com/swarms_corp

- **Startup Program Showcases**: https://www.swarms.xyz/programs/startups

Active contributors are often spotlighted for leadership roles and community awards.

---

## 16. Resource Index

- Core GitHub Repo: https://github.com/kyegomez/swarms

- Rust SDK Repo: https://github.com/The-Swarm-Corporation/swarms-rs

- Swarms API Docs: https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/

- Marketplace: https://swarms.world

Join our monthly Documentation Office Hours for real-time mentorship and Q&A.

---

## 17. Frequently Asked Questions

**Q1: Is MkDocs required to contribute?**  
A: It's recommended but not required; Markdown knowledge is sufficient to get started.

**Q2: Can I rework existing sections?**  
A: Yes, propose changes via issues first, or submit PRs with clear descriptions.

**Q3: When are bounties paid?**  
A: Within 30 days of merge, following internal validation.

---

## 18. Final Thoughts

The Swarms documentation is a critical piece of our technology stack. As a contributor, your improvements—big or small—directly impact adoption, user retention, and developer satisfaction. This guide aims to equip you with the tools, practices, and incentives to make meaningful contributions. Your work helps us deliver a more usable, scalable, and inclusive platform.

We look forward to your pull requests, feedback, and ideas.

---


--------------------------------------------------

# File: contributors/tools.md

# Contributing Tools and Plugins to the Swarms Ecosystem

## Introduction

The Swarms ecosystem is a modular, intelligent framework built to support the seamless integration, execution, and orchestration of dynamic tools that perform specific functions. These tools form the foundation for how autonomous agents operate, enabling them to retrieve data, communicate with APIs, conduct computational tasks, and respond intelligently to real-world requests. By contributing to Swarms Tools, developers can empower agents with capabilities that drive practical, enterprise-ready applications.

This guide provides a comprehensive roadmap for contributing tools and plugins to the [Swarms Tools repository](https://github.com/The-Swarm-Corporation/swarms-tools). It is written for software engineers, data scientists, platform architects, and technologists who seek to develop modular, production-grade functionality within the Swarms agent framework.

Whether your expertise lies in finance, security, machine learning, or developer tooling, this documentation outlines the essential standards, workflows, and integration patterns to make your contributions impactful and interoperable.

## Repository Architecture

The Swarms Tools GitHub repository is meticulously organized to maintain structure, scalability, and domain-specific clarity. Each folder within the repository represents a vertical where tools can be contributed and extended over time. These folders include:

- `finance/`: Market analytics, stock price retrievers, blockchain APIs, etc.

- `social/`: Sentiment analysis, engagement tracking, and media scraping utilities.

- `health/`: Interfaces for EHR systems, wearable device APIs, or health informatics.

- `ai/`: Model-serving utilities, embedding services, and prompt engineering functions.

- `security/`: Encryption libraries, risk scoring tools, penetration test interfaces.

- `devtools/`: Build tools, deployment utilities, code quality analyzers.

- `misc/`: General-purpose helpers or utilities that serve multiple domains.

Each tool inside these directories is implemented as a single, self-contained function. These functions are expected to adhere to Swarms-wide standards for clarity, typing, documentation, and API key handling.

## Tool Development Specifications

To ensure long-term maintainability and smooth agent-tool integration, each contribution must strictly follow the specifications below.

### 1. Function Structure and API Usage

```python
import requests
import os

def fetch_data(symbol: str, date_range: str) -> str:
    """
    Fetch financial data for a given symbol and date range.

    Args:
        symbol (str): Ticker symbol of the asset.
        date_range (str): Timeframe for the data (e.g., '1d', '1m', '1y').

    Returns:
        str: A string containing financial data or an error message.
    """
    api_key = os.getenv("FINANCE_API_KEY")
    url = f"https://api.financeprovider.com/data?symbol={symbol}&range={date_range}&apikey={api_key}"
    response = requests.get(url)
    if response.status_code == 200:
        return response.text
    return "Error fetching data."
```

All logic must be encapsulated inside a single callable function, written using pure Python. Where feasible, network requests should be stateless, side-effect-free, and gracefully handle errors or timeouts.

### 2. Type Hints and Input Validation

All function parameters must be typed using Python's type hinting system. Use built-in primitives where possible (e.g., `str`, `int`, `float`, `bool`) and make use of `Optional` or `Union` types when dealing with nullable parameters or multiple formats. This aids LLMs and type checkers in understanding expected input ranges.

### 3. Standardized Output Format

Regardless of internal logic or complexity, tools must return outputs in a consistent string format. This string can contain plain text or a serialized JSON object (as a string), but must not return raw objects, dictionaries, or binary blobs. This standardization ensures all downstream agents can interpret tool output predictably.

### 4. API Key Management Best Practices

Security and environment isolation are paramount. Never hardcode API keys or sensitive credentials inside source code. Always retrieve them dynamically using the `os.getenv("ENV_VAR")` approach. If a tool requires credentials, clearly document the required environment variable names in the function docstring.

### 5. Documentation Guidelines

Every tool must include a detailed docstring that describes:

- The function's purpose and operational scope

- All parameter types and formats

- A clear return type

- Usage examples or sample inputs/outputs

Example usage:
```python
result = fetch_data("AAPL", "1m")
print(result)
```

Well-documented code accelerates adoption and improves LLM interpretability.

## Contribution Workflow

To submit a tool, follow the workflow below. This ensures your code integrates cleanly and is easy for maintainers to review.

### Step 1: Fork the Repository
Navigate to the [Swarms Tools repository](https://github.com/The-Swarm-Corporation/swarms-tools) and fork it to your personal or organization’s GitHub account.

### Step 2: Clone Your Fork
```bash
git clone https://github.com/YOUR_USERNAME/swarms-tools.git
cd swarms-tools
```

### Step 3: Create a Feature Branch

```bash
git checkout -b feature/add-tool-<tool-name>
```

Use descriptive branch names. This is especially helpful when collaborating in teams or maintaining audit trails.

### Step 4: Build Your Tool
Navigate into the appropriate category folder (e.g., `finance/`, `ai/`, etc.) and implement your tool according to the defined schema.

If your tool belongs in a new category, you may create a new folder with a clear, lowercase name.

### Step 5: Run Local Tests (if applicable)
Ensure the function executes correctly and does not throw runtime errors. If feasible, test edge cases and verify consistent behavior across platforms.

### Step 6: Commit Your Changes

```bash
git add .
git commit -m "Add <tool_name> under <folder_name>: API-based tool for X"
```

### Step 7: Push to GitHub

```bash
git push origin feature/add-tool-<tool-name>
```

### Step 8: Submit a Pull Request

On GitHub, open a pull request from your fork to the main Swarms Tools repository. Your PR description should:
- Summarize the tool’s functionality
- Reference any related issues or enhancements
- Include usage notes or setup instructions (e.g., required API keys)

---

## Integration with Swarms Agents

Once your tool has been merged into the official repository, it can be utilized by Swarms agents as part of their available capabilities.

The example below illustrates how to embed a newly added tool into an autonomous agent:

```python
from swarms import Agent
from finance.stock_price import get_stock_price

agent = Agent(
    agent_name="Devin",
    system_prompt=(
        "Autonomous agent that can interact with humans and other agents."
        " Be helpful and kind. Use the tools provided to assist the user."
        " Return all code in markdown format."
    ),
    llm=llm,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    interactive=True,
    tools=[get_stock_price, terminal, browser, file_editor, create_file],
    metadata_output_type="json",
    function_calling_format_type="OpenAI",
    function_calling_type="json",
)

agent.run("Create a new file for a plan to take over the world.")
```

By registering tools in the `tools` parameter during agent creation, you enable dynamic function calling. The agent interprets natural language input, selects the appropriate tool, and invokes it with valid arguments.

This agent-tool paradigm enables highly flexible and responsive behavior across workflows involving research, automation, financial analysis, social listening, and more.

---

## Tool Maintenance and Long-Term Ownership

Contributors are expected to uphold the quality of their tools post-merge. This includes:

- Monitoring for issues or bugs reported by the community

- Updating tools when APIs deprecate or modify their behavior

- Improving efficiency, error handling, or documentation over time

If a tool becomes outdated or unsupported, maintainers may archive or revise it to maintain ecosystem integrity.

Contributors whose tools receive wide usage or demonstrate excellence in design may be offered elevated privileges or invited to maintain broader tool categories.

---

## Best Practices for Enterprise-Grade Contributions

To ensure your tool is production-ready and enterprise-compliant, observe the following practices:


- Run static type checking with `mypy`

- Use formatters like `black` and linters such as `flake8`

- Avoid unnecessary external dependencies

- Keep functions modular and readable

- Prefer named parameters over positional arguments for clarity

- Handle API errors gracefully and return user-friendly messages

- Document limitations or assumptions in the docstring

Optional but encouraged:
- Add unit tests to validate function output

- Benchmark performance if your tool operates on large datasets

---

## Conclusion

The Swarms ecosystem is built on the principle of extensibility through community-driven contributions. By submitting modular, typed, and well-documented tools to the Swarms Tools repository, you directly enhance the problem-solving power of intelligent agents.

This documentation serves as your blueprint for contributing high-quality, reusable functionality. From idea to implementation to integration, your efforts help shape the future of collaborative, agent-powered software.

We encourage all developers, data scientists, and domain experts to contribute meaningfully. Review existing tools for inspiration, or create something entirely novel.

To begin, fork the [Swarms Tools repository](https://github.com/The-Swarm-Corporation/swarms-tools) and start building impactful, reusable tools that can scale across agents and use cases.



--------------------------------------------------

# File: corporate/2024_2025_goals.md

# **Swarms Goals & Milestone Tracking: A Vision for 2024 and Beyond**

As we propel Swarms into a new frontier, we’ve set ambitious yet achievable goals for the coming years that will solidify Swarms as a leader in multi-agent 
orchestration. This document outlines our vision, the goals for 2024 and 2025, and how we track our progress through meticulously designed milestones and metrics.

## **Our Vision: The Agentic Ecosystem**

We envision an ecosystem where agents are pervasive and serve as integral collaborators in business processes, daily life, and complex problem-solving. By leveraging 
the collective intelligence of swarms, we believe we can achieve massive gains in productivity, scalability, and impact. Our target is to establish the Swarms platform as the go-to environment for deploying and managing agents at an unprecedented scale—making agents as common and indispensable as mobile apps are today. This future 
will see agents integrated into nearly every digital interaction, creating a seamless extension of human capability and reducing the cognitive load on individuals and organizations.

We believe that *agents* will transition from being simple tools to becoming full-fledged partners that can understand user needs, predict outcomes, and adapt to 
changes dynamically. Our vision is not just about increasing numbers; it’s about building a smarter, more interconnected agentic ecosystem where every agent has a purpose and contributes to a collective intelligence that continuously evolves. By cultivating a diverse array of agents capable of handling various specialized tasks, we aim to create an environment in which these digital collaborators function as a cohesive whole—one that can amplify human ingenuity and productivity beyond current limits.

## **Goals for 2024 and 2025**

To achieve our vision, we have laid out a structured growth trajectory for Swarms, driven by clear numerical targets:

1. **End of 2024: 500 Million Agents**  
   Currently, our platform hosts **45 million agents**. By the end of 2024, our goal is to reach **500 million agents** deployed on Swarms. This means achieving sustained exponential growth, which will require doubling or even tripling the total number of agents roughly **every month** from now until December 2024. Such growth will necessitate not only scaling infrastructure but also improving the ease with which users can develop and deploy agents, expanding educational resources, and fostering a vibrant community that drives innovation in agent design. To achieve this milestone, we plan to invest heavily in making our platform user-friendly, including simplifying onboarding processes and providing extensive educational content. Additionally, we aim to build out our infrastructure to support the necessary scalability and ensure the seamless operation of a growing number of agents. Beyond merely scaling in numbers, we are also focused on increasing the diversity of tasks that agents can perform, thereby enhancing the practical value of deploying agents on Swarms.

2. **End of 2025: 10 Billion+ Agents**  
   The long-term vision extends further to reach **10 billion agents** by the end of 2025. This ambitious goal reflects not only the organic growth of our user base but 
   also the increasing role of swarms in business applications, personal projects, and global problem-solving initiatives. This goal requires continuous monthly 
   doubling of agents and a clear roadmap of user engagement and deployment. By scaling to this level, we envision Swarms as a cornerstone of automation and productivity enhancement, where agents autonomously manage everything from mundane tasks to sophisticated strategic decisions, effectively enhancing human capabilities. This expansion will rely on the development of a robust ecosystem in which users can easily create, share, and enhance agents. We will foster partnerships with industries that can benefit from scalable agentic solutions—spanning healthcare, finance, education, and beyond. Our strategy includes developing domain-specific templates and specialized agents that cater to niche needs, thereby making Swarms an indispensable solution for businesses and individuals alike.

## **Tracking Progress: The Power of Metrics**

Achieving these goals is not just about reaching numerical targets but ensuring that our users are deriving tangible value from Swarms and deploying agents effectively. To measure success, we’ve defined several key performance indicators (KPIs) and milestones:

### 1. Growth in Agent Deployment

The **number of agents** deployed per month will be our primary growth metric. With our goal of **doubling agent count every month**, this metric serves as an overall health indicator for platform adoption and usage. Growth in deployment indicates that our platform is attracting users who see value in creating and deploying agents to solve diverse challenges.

**Key Milestones:**

- **November 2024**: Surpass 250 million agents.  

- **December 2024**: Reach 500 million agents.  

- **June 2025**: Break the 5 billion agents mark.  

- **December 2025**: Hit 10 billion agents.  


To accomplish this, we must continually expand our infrastructure, maintain scalability, and create a seamless user onboarding process. We’ll ensure that adding agents is frictionless and that our platform can accommodate this rapid growth. By integrating advanced orchestration capabilities, we will enable agents to form more complex collaborations and achieve tasks that previously seemed out of reach. Furthermore, we will develop analytics tools to track the success and efficiency of these agents, giving users real-time feedback to optimize their deployment strategies.


### 2. Agents Deployed Per User: Engagement Indicator

A core belief of Swarms is that agents are here to make life easier for their users—whether it’s automating mundane tasks, handling complex workflows, or enhancing creative endeavors. Therefore, we measure the **number of agents deployed per user per month** as a key metric for engagement. Tracking this metric allows us to understand how effectively our users are utilizing the platform, and how deeply agents are becoming embedded into their workflows.

This metric ensures that users aren’t just joining Swarms, but they are actively building and deploying agents to solve real problems. Our milestone for engagement is to see **increasing growth in agents deployed per user** month over month, which indicates a deeper integration of Swarms into daily workflows and business processes. We want our users to view Swarms as their go-to solution for any problem they face, which means ensuring that agents are providing real, tangible benefits.


**Key Milestones:**

- **November 2024**: Achieve an average of 20 agents deployed per user each month. 

- **June 2025**: Target 100-200+ agents deployed per user.  


To drive these numbers, we plan to improve user support, enhance educational materials, host workshops, and create an environment that empowers users to deploy agents for increasingly complex use-cases. Additionally, we will introduce templates and pre-built agents that users can customize, reducing the barriers to entry and enabling 
rapid deployment for new users. We are also developing gamified elements that reward users for deploying more agents and achieving milestones, fostering a competitive and engaging community atmosphere.

### 3. Active vs. Inactive Agents: Measuring Churn

The **number of inactive agents per user** is an essential metric for understanding our **churn rate**. An agent is considered inactive when it remains undeployed or unused for a prolonged period, indicating that it’s no longer delivering value to the user. Churn metrics provide valuable insights into the effectiveness of our agents and highlight areas where improvements are needed.

We aim to **minimize the number of inactive agents**, as this will be a direct reflection of how well our agents are designed, integrated, and supported. A low churn rate means that users are finding long-term utility in their agents, which is key to our mission. Our platform’s success depends on users consistently deploying agents 
that remain active and valuable over time.

**Key Milestones:**

- **December 2024**: Ensure that no more than **30%** of deployed agents are inactive.  

- **December 2025**: Aim for **10%** or lower, reflecting strong agent usefulness and consistent platform value delivery.  


Reducing churn will require proactive measures, such as automated notifications to users about inactive agents, recommending potential uses, and implementing agent retraining features to enhance their adaptability over time. Educating users on prompting engineering, tool engineering, and RAG engineering also helps decrease these numbers as the number of inactive agents is evident that the user is not automating a business operation with that agent. We will also integrate machine learning models to predict agent inactivity and take corrective actions before agents become dormant. By offering personalized recommendations to users on how to enhance or repurpose inactive agents, we hope to ensure that all deployed agents are actively contributing value.

## **Milestones and Success Criteria**

To reach these ambitious goals, we have broken our roadmap down into a series of actionable milestones:

1. **Infrastructure Scalability (Q1 2025)**  
   We will work on ensuring that our backend infrastructure can handle the scale required to reach 500 million agents by the end of 2024. This includes expanding server capacity, improving agent orchestration capabilities, and ensuring low latency across deployments. We will also focus on enhancing our database management systems to ensure efficient storage and retrieval of agent data, enabling seamless operation at a massive scale. Our infrastructure roadmap also includes implementing advanced load balancing techniques and predictive scaling mechanisms to ensure high availability and reliability.

2. **Improved User Experience (Q2 2025)**  
   To encourage agent deployment and reduce churn, we will introduce new onboarding flows, agent-building wizards, and intuitive user interfaces. We will also implement 
   in-depth tutorials and documentation to simplify agent creation for new users. By making agent-building accessible even to those without programming expertise, we 
   will open the doors to a broader audience and drive exponential growth in the number of agents deployed. Additionally, we will integrate AI-driven suggestions and 
   contextual help to assist users at every step of the process, making the platform as intuitive as possible.

3. **Agent Marketplace (Q3 2025)**  
   Launching the **Swarms Marketplace** for agents, prompts, and tools will allow users to share, discover, and even monetize their agents. This marketplace will be a crucial driver in both increasing the number of agents deployed and reducing inactive agents, as it will create an ecosystem of continuously evolving and highly useful agents. Users will have the opportunity to browse agents that others have developed, which can serve as inspiration or as a starting point for their own projects. We will also introduce ratings, reviews, and community feedback mechanisms to ensure that the most effective agents are highlighted and accessible.

4. **Community Engagement and Swarms Education (Ongoing)**  
   Workshops, webinars, and events will be conducted throughout 2024 and 2025 to engage new users and educate them on building effective agents. The goal is to ensure that every user becomes proficient in deploying swarms of agents for meaningful tasks. We will foster an active community where users can exchange ideas, get help, and collaborate on projects, ultimately driving forward the growth of the Swarms ecosystem. We also plan to establish a mentor program where experienced users can guide newcomers, helping them get up to speed more quickly and successfully deploy agents.

## **Actionable Strategies for Goal Achievement**

**1. Developer Incentives**  
One of our most important strategies will be the introduction of developer incentives. By providing rewards for creating agents, we foster an environment of creativity and encourage rapid growth in the number of useful agents on the platform. We will host hackathons, contests, and provide financial incentives to developers whose agents provide substantial value to the community. Additionally, we plan to create a tiered rewards system that acknowledges developers for the number of active deployments and the utility of their agents, motivating continuous improvement and innovation.

**2. Strategic Partnerships**  
We plan to form partnerships with major technology providers and industry players to scale Swarms adoption. Integrating Swarms into existing business software and industrial processes will drive significant growth in agent numbers and usage. These partnerships will allow Swarms to become embedded into existing workflows, making it easier for users to understand the value and immediately apply agents to solve real-world challenges. We are also targeting partnerships with educational 
institutions to provide Swarms as a learning platform for AI, encouraging students and researchers to contribute to our growing ecosystem.

**3. User Feedback Loop**  
To ensure we are on track, a continuous feedback loop with our user community will help us understand what agents are effective, which require improvements, and where we need to invest our resources to maximize engagement. Users’ experiences will shape our platform evolution. We will implement regular surveys, feedback forms, and user interviews to gather insights, and use this data to drive iterative development that is directly aligned with user needs. In addition, we will create an open feature request forum where users can vote on the most important features they want to see, ensuring that we are prioritizing our community’s needs.

**4. Marketing and Awareness Campaigns**  
Strategic campaigns to showcase the power of swarms in specific industries will highlight the versatility and impact of our agents. We plan to create case studies demonstrating how swarms solve complex problems in marketing, finance, customer service, and other verticals, and use these to attract a wider audience. Our content marketing strategy will include blogs, video tutorials, and success stories to help potential users visualize the transformative power of Swarms. We will also leverage social media campaigns and influencer partnerships to reach a broader audience and generate buzz around Swarms’ capabilities.

**5. Educational Initiatives**  
To lower the barrier to entry for new users, we will invest heavily in educational content. This includes video tutorials, comprehensive guides, and in-platform 
learning modules. By making the learning process easy and engaging, we ensure that users quickly become proficient in creating and deploying agents, thereby increasing user satisfaction and reducing churn. A well-educated user base will lead to more agents being deployed effectively, contributing to our overall growth targets. We are 
also developing certification programs for users and developers, providing a structured pathway to become proficient in Swarms technology and gain recognition for their skills.

## **The Path Ahead: Building Towards 10 Billion Agents**

To achieve our vision of **10 billion agents** by the end of 2025, it’s critical that we maintain an aggressive growth strategy while ensuring that agents are providing real value to users. This requires a deep focus on **scalability, community growth, and user-centric development**. It also demands a continuous feedback loop where 
insights from agent deployments and user interactions drive platform evolution. By creating an environment where agents are easy to develop, share, and integrate, we will achieve sustainable growth that benefits not just Swarms, but the broader AI community.

We envision swarms as a catalyst for *democratizing access to AI*. By enabling users across industries—from healthcare to education to manufacturing—to deploy agents that handle specialized tasks, we empower individuals and organizations to focus on creative, strategic endeavors rather than repetitive operational tasks. The journey to 10 billion agents is not just about scale; it’s about creating *meaningful and effective automation* that transforms how work gets done. We believe that Swarms will ultimately reshape industries by making sophisticated automation accessible to all, driving a shift toward higher productivity and innovation.

## **Community and Culture**

Swarms will also be emphasizing the **community aspect**, building a **culture of collaboration** among users, developers, and businesses. By fostering open communication and enabling the sharing of agents, we encourage **knowledge transfer** and **network effects**, which help drive overall growth. Our goal is to create an environment where agents not only work individually but evolve as a collective intelligence network—working towards a **post-scarcity civilization** where every problem 
can be tackled by the right combination of swarms.

We see the community as the heartbeat of Swarms, driving innovation, providing support, and expanding the use-cases for agents. Whether it’s through forums, community 
events, or user-generated content, we want Swarms to be the hub where people come together to solve the most pressing challenges of our time. By empowering our users 
and encouraging collaboration, we can ensure that the platform continuously evolves and adapts to new needs and opportunities. Additionally, we plan to establish local Swarms chapters worldwide, where users can meet in person to share knowledge, collaborate on projects, and build lasting relationships that strengthen the global Swarms community.

# **Conclusion: Measuring Success One Milestone at a Time**

The **path to 500 million agents by the end of 2024** and **10 billion agents by the end of 2025** is paved with strategic growth, infrastructure resilience, and user-centric improvements. Each milestone is a step closer to a fully realized vision of an agentic economy—one where agents are ubiquitous, assisting individuals, 
businesses, and entire industries in achieving their goals more efficiently.

By **tracking key metrics**, such as growth in agent numbers, the rate of agent deployment per user, and reducing churn, we ensure that Swarms not only grows in size but also in effectiveness, adoption, and user satisfaction. Through a combination of infrastructure development, community engagement, incentives, and constant user feedback, we will create an ecosystem where agents thrive, users are empowered, and the entire platform evolves towards our ambitious vision.

This is the journey of Swarms—**a journey towards redefining how we interact with AI, solve complex problems, and enhance productivity**. With each milestone, we get closer to a future where swarms of agents are the bedrock of human-machine collaboration and an integral part of our daily lives. The journey ahead is one of 
transformation, creativity, and collaboration, as we work together to create an AI-driven world that benefits everyone, enabling us to achieve more than we ever thought 
possible. Our commitment to building an agentic ecosystem is unwavering, and we are excited to see the incredible impact that swarms of agents will have on the future of work, innovation, and human potential.


--------------------------------------------------

# File: corporate/architecture.md

# Architecture 

## **1. Introduction**

In today's rapidly evolving digital world, harnessing the collaborative power of multiple computational agents is more crucial than ever. 'Swarms' represents a bold stride in this direction—a scalable and dynamic framework designed to enable swarms of agents to function in harmony and tackle complex tasks. This document serves as a comprehensive guide, elucidating the underlying architecture and strategies pivotal to realizing the Swarms vision.

---

## **2. The Vision**

At its heart, the Swarms framework seeks to emulate the collaborative efficiency witnessed in natural systems, like ant colonies or bird flocks. These entities, though individually simple, achieve remarkable outcomes through collaboration. Similarly, Swarms will unleash the collective potential of numerous agents, operating cohesively.

---

## **3. Architecture Overview**

### **3.1 Agent Level**
The base level that serves as the building block for all further complexity.

#### Mechanics:
* **Model**: At its core, each agent harnesses a powerful model like OpenAI's GPT.
* **Vectorstore**: A memory structure allowing agents to store and retrieve information.
* **Tools**: Utilities and functionalities that aid in the agent's task execution.

#### Interaction:
Agents interact with the external world through their model and tools. The Vectorstore aids in retaining knowledge and facilitating inter-agent communication.

### **3.2 Worker Infrastructure Level**
Building on the agent foundation, enhancing capability and readiness for swarm integration.

#### Mechanics:
* **Human Input Integration**: Enables agents to accept and understand human-provided instructions.
* **Unique Identifiers**: Assigns each agent a unique ID to facilitate tracking and communication.
* **Asynchronous Tools**: Bolsters agents' capability to multitask and interact in real-time.

#### Interaction:
Each worker is an enhanced agent, capable of operating independently or in sync with its peers, allowing for dynamic, scalable operations.

### **3.3 Swarm Level**
Multiple Worker Nodes orchestrated into a synchronized, collaborative entity.

#### Mechanics:
* **Orchestrator**: The maestro, responsible for directing the swarm, task allocation, and communication.
* **Scalable Communication Layer**: Facilitates interactions among nodes and between nodes and the orchestrator.
* **Task Assignment & Completion Protocols**: Structured procedures ensuring tasks are efficiently distributed and concluded.

#### Interaction:
Nodes collaborate under the orchestrator's guidance, ensuring tasks are partitioned appropriately, executed, and results consolidated.

### **3.4 Hivemind Level**
Envisioned as a 'Swarm of Swarms'. An upper echelon of collaboration.

#### Mechanics:
* **Hivemind Orchestrator**: Oversees multiple swarm orchestrators, ensuring harmony on a grand scale.
* **Inter-Swarm Communication Protocols**: Dictates how swarms interact, exchange information, and co-execute tasks.

#### Interaction:
Multiple swarms, each a formidable force, combine their prowess under the Hivemind. This level tackles monumental tasks by dividing them among swarms.

---

## **4. Building the Framework: A Task Checklist**

### **4.1 Foundations: Agent Level**
* Define and standardize agent properties.
* Integrate desired model (e.g., OpenAI's GPT) with agent.
* Implement Vectorstore mechanisms: storage, retrieval, and communication protocols.
* Incorporate essential tools and utilities.
* Conduct preliminary testing: Ensure agents can execute basic tasks and utilize the Vectorstore.

### **4.2 Enhancements: Worker Infrastructure Level**
* Interface agents with human input mechanisms.
* Assign and manage unique identifiers for each worker.
* Integrate asynchronous capabilities: Ensure real-time response and multitasking.
* Test worker nodes for both solitary and collaborative tasks.

### **4.3 Cohesion: Swarm Level**
* Design and develop the orchestrator: Ensure it can manage multiple worker nodes.
* Establish a scalable and efficient communication layer.
* Implement task distribution and retrieval protocols.
* Test swarms for efficiency, scalability, and robustness.

### **4.4 Apex Collaboration: Hivemind Level**
* Build the Hivemind Orchestrator: Ensure it can oversee multiple swarms.
* Define inter-swarm communication, prioritization, and task-sharing protocols.
* Develop mechanisms to balance loads and optimize resource utilization across swarms.
* Thoroughly test the Hivemind level for macro-task execution.

---

## **5. Integration and Communication Mechanisms**

### **5.1 Vectorstore as the Universal Communication Layer**
Serving as the memory and communication backbone, the Vectorstore must:
* Facilitate rapid storage and retrieval of high-dimensional vectors.
* Enable similarity-based lookups: Crucial for recognizing patterns or finding similar outputs.
* Scale seamlessly as agent count grows.

### **5.2 Orchestrator-Driven Communication**
* Orchestrators, both at the swarm and hivemind level, should employ adaptive algorithms to optimally distribute tasks.
* Ensure real-time monitoring of task execution and worker node health.
* Integrate feedback loops: Allow for dynamic task reassignment in case of node failures or inefficiencies.

---

## **6. Conclusion & Forward Path**

The Swarms framework, once realized, will usher in a new era of computational efficiency and collaboration. While the roadmap ahead is intricate, with diligent planning, development, and testing, Swarms will redefine the boundaries of collaborative computing.

--------


# Overview

### 1. Model

**Overview:**
The foundational level where a trained model (e.g., OpenAI GPT model) is initialized. It's the base on which further abstraction levels build upon. It provides the core capabilities to perform tasks, answer queries, etc.

**Diagram:**
```
[ Model (openai) ]
```

### 2. Agent Level

**Overview:**
At the agent level, the raw model is coupled with tools and a vector store, allowing it to be more than just a model. The agent can now remember, use tools, and become a more versatile entity ready for integration into larger systems.

**Diagram:**
```
+-----------+
|   Agent   |
| +-------+ |
| | Model | |
| +-------+ |
| +-----------+ |
| | VectorStore | |
| +-----------+ |
| +-------+ |
| | Tools | |
| +-------+ |
+-----------+
```

### 3. Worker Infrastructure Level

**Overview:**
The worker infrastructure is a step above individual agents. Here, an agent is paired with additional utilities like human input and other tools, making it a more advanced, responsive unit capable of complex tasks.

**Diagram:**
```
+----------------+
|  WorkerNode    |
| +-----------+  |
| |   Agent   |  |
| | +-------+ |  |
| | | Model | |  |
| | +-------+ |  |
| | +-------+ |  |
| | | Tools | |  |
| | +-------+ |  |
| +-----------+  |
|                |
| +-----------+  |
| |Human Input|  |
| +-----------+  |
|                |
| +-------+      |
| | Tools |      |
| +-------+      |
+----------------+
```

### 4. Swarm Level

**Overview:**
At the swarm level, the orchestrator is central. It's responsible for assigning tasks to worker nodes, monitoring their completion, and handling the communication layer (for example, through a vector store or another universal communication mechanism) between worker nodes.

**Diagram:**
```
                     +------------+
                     |Orchestrator|
                     +------------+
                           |
            +---------------------------+
            |                           |
            |   Swarm-level Communication|
            |          Layer (e.g.      |
            |        Vector Store)      |
            +---------------------------+
             /          |          \         
  +---------------+  +---------------+  +---------------+
  |WorkerNode 1   |  |WorkerNode 2   |  |WorkerNode n   |
  |               |  |               |  |               |
  +---------------+  +---------------+  +---------------+
   | Task Assigned   | Task Completed   | Communication |
```

### 5. Hivemind Level

**Overview:**
At the Hivemind level, it's a multi-swarm setup, with an upper-layer orchestrator managing multiple swarm-level orchestrators. The Hivemind orchestrator is responsible for broader tasks like assigning macro-tasks to swarms, handling inter-swarm communications, and ensuring the overall system is functioning smoothly.

**Diagram:**
```
                     +--------+
                     |Hivemind|
                     +--------+
                         |
                 +--------------+
                 |Hivemind      |
                 |Orchestrator  |
                 +--------------+
            /         |          \         
    +------------+  +------------+  +------------+
    |Orchestrator|  |Orchestrator|  |Orchestrator|
    +------------+  +------------+  +------------+
        |               |               |
+--------------+ +--------------+ +--------------+
|   Swarm-level| |   Swarm-level| |   Swarm-level|
|Communication| |Communication| |Communication|
|    Layer    | |    Layer    | |    Layer    |
+--------------+ +--------------+ +--------------+
    /    \         /    \         /     \
+-------+ +-------+ +-------+ +-------+ +-------+
|Worker | |Worker | |Worker | |Worker | |Worker |
| Node  | | Node  | | Node  | | Node  | | Node  |
+-------+ +-------+ +-------+ +-------+ +-------+
```

This setup allows the Hivemind level to operate at a grander scale, with the capability to manage hundreds or even thousands of worker nodes across multiple swarms efficiently.



-------
# **Swarms Framework Development Strategy Checklist**

## **Introduction**

The development of the Swarms framework requires a systematic and granular approach to ensure that each component is robust and that the overall framework is efficient and scalable. This checklist will serve as a guide to building Swarms from the ground up, breaking down tasks into small, manageable pieces.

---

## **1. Agent Level Development**

### **1.1 Model Integration**
- [ ] Research the most suitable models (e.g., OpenAI's GPT).
- [ ] Design an API for the agent to call the model.
- [ ] Implement error handling when model calls fail.
- [ ] Test the model with sample data for accuracy and speed.

### **1.2 Vectorstore Implementation**
- [ ] Design the schema for the vector storage system.
- [ ] Implement storage methods to add, delete, and update vectors.
- [ ] Develop retrieval methods with optimization for speed.
- [ ] Create protocols for vector-based communication between agents.
- [ ] Conduct stress tests to ascertain storage and retrieval speed.

### **1.3 Tools & Utilities Integration**
- [ ] List out essential tools required for agent functionality.
- [ ] Develop or integrate APIs for each tool.
- [ ] Implement error handling and logging for tool interactions.
- [ ] Validate tools integration with unit tests.

---

## **2. Worker Infrastructure Level Development**

### **2.1 Human Input Integration**
- [ ] Design a UI/UX for human interaction with worker nodes.
- [ ] Create APIs for input collection.
- [ ] Implement input validation and error handling.
- [ ] Test human input methods for clarity and ease of use.

### **2.2 Unique Identifier System**
- [ ] Research optimal formats for unique ID generation.
- [ ] Develop methods for generating and assigning IDs to agents.
- [ ] Implement a tracking system to manage and monitor agents via IDs.
- [ ] Validate the uniqueness and reliability of the ID system.

### **2.3 Asynchronous Operation Tools**
- [ ] Incorporate libraries/frameworks to enable asynchrony.
- [ ] Ensure tasks within an agent can run in parallel without conflict.
- [ ] Test asynchronous operations for efficiency improvements.

---

## **3. Swarm Level Development**

### **3.1 Orchestrator Design & Development**
- [ ] Draft a blueprint of orchestrator functionalities.
- [ ] Implement methods for task distribution among worker nodes.
- [ ] Develop communication protocols for the orchestrator to monitor workers.
- [ ] Create feedback systems to detect and address worker node failures.
- [ ] Test orchestrator with a mock swarm to ensure efficient task allocation.

### **3.2 Communication Layer Development**
- [ ] Select a suitable communication protocol/framework (e.g., gRPC, WebSockets).
- [ ] Design the architecture for scalable, low-latency communication.
- [ ] Implement methods for sending, receiving, and broadcasting messages.
- [ ] Test communication layer for reliability, speed, and error handling.

### **3.3 Task Management Protocols**
- [ ] Develop a system to queue, prioritize, and allocate tasks.
- [ ] Implement methods for real-time task status tracking.
- [ ] Create a feedback loop for completed tasks.
- [ ] Test task distribution, execution, and feedback systems for efficiency.

---

## **4. Hivemind Level Development**

### **4.1 Hivemind Orchestrator Development**
- [ ] Extend swarm orchestrator functionalities to manage multiple swarms.
- [ ] Create inter-swarm communication protocols.
- [ ] Implement load balancing mechanisms to distribute tasks across swarms.
- [ ] Validate hivemind orchestrator functionalities with multi-swarm setups.

### **4.2 Inter-Swarm Communication Protocols**
- [ ] Design methods for swarms to exchange data.
- [ ] Implement data reconciliation methods for swarms working on shared tasks.
- [ ] Test inter-swarm communication for efficiency and data integrity.

---

## **5. Scalability & Performance Testing**

- [ ] Simulate heavy loads to test the limits of the framework.
- [ ] Identify and address bottlenecks in both communication and computation.
- [ ] Conduct speed tests under different conditions.
- [ ] Test the system's responsiveness under various levels of stress.

---

## **6. Documentation & User Guide**

- [ ] Develop detailed documentation covering architecture, setup, and usage.
- [ ] Create user guides with step-by-step instructions.
- [ ] Incorporate visual aids, diagrams, and flowcharts for clarity.
- [ ] Update documentation regularly with new features and improvements.

---

## **7. Continuous Integration & Deployment**

- [ ] Setup CI/CD pipelines for automated testing and deployment.
- [ ] Ensure automatic rollback in case of deployment failures.
- [ ] Integrate code quality and security checks in the pipeline.
- [ ] Document deployment strategies and best practices.

---

## **Conclusion**

The Swarms framework represents a monumental leap in agent-based computation. This checklist provides a thorough roadmap for the framework's development, ensuring that every facet is addressed in depth. Through diligent adherence to this guide, the Swarms vision can be realized as a powerful, scalable, and robust system ready to tackle the challenges of tomorrow.

(Note: This document, given the word limit, provides a high-level overview. A full 5000-word document would delve into even more intricate details, nuances, potential pitfalls, and include considerations for security, user experience, compatibility, etc.)

--------------------------------------------------

# File: corporate/bounties.md

# Bounty Program

Our bounty program is an exciting opportunity for contributors to help us build the future of Swarms. By participating, you can earn rewards while contributing to a project that aims to revolutionize digital activity.

Here's how it works:

1. **Check out our Roadmap**: We've shared our roadmap detailing our short and long-term goals. These are the areas where we're seeking contributions.

2. **Pick a Task**: Choose a task from the roadmap that aligns with your skills and interests. If you're unsure, you can reach out to our team for guidance.

3. **Get to Work**: Once you've chosen a task, start working on it. Remember, quality is key. We're looking for contributions that truly make a difference.

4. **Submit your Contribution**: Once your work is complete, submit it for review. We'll evaluate your contribution based on its quality, relevance, and the value it brings to Swarms.

5. **Earn Rewards**: If your contribution is approved, you'll earn a bounty. The amount of the bounty depends on the complexity of the task, the quality of your work, and the value it brings to Swarms.

## The Three Phases of Our Bounty Program

### Phase 1: Building the Foundation
In the first phase, our focus is on building the basic infrastructure of Swarms. This includes developing key components like the Swarms class, integrating essential tools, and establishing task completion and evaluation logic. We'll also start developing our testing and evaluation framework during this phase. If you're interested in foundational work and have a knack for building robust, scalable systems, this phase is for you.

### Phase 2: Enhancing the System
In the second phase, we'll focus on enhancing Swarms by integrating more advanced features, improving the system's efficiency, and refining our testing and evaluation framework. This phase involves more complex tasks, so if you enjoy tackling challenging problems and contributing to the development of innovative features, this is the phase for you.

### Phase 3: Towards Super-Intelligence
The third phase of our bounty program is the most exciting - this is where we aim to achieve super-intelligence. In this phase, we'll be working on improving the swarm's capabilities, expanding its skills, and fine-tuning the system based on real-world testing and feedback. If you're excited about the future of AI and want to contribute to a project that could potentially transform the digital world, this is the phase for you.

Remember, our roadmap is a guide, and we encourage you to bring your own ideas and creativity to the table. We believe that every contribution, no matter how small, can make a difference. So join us on this exciting journey and help us create the future of Swarms.

**To participate in our bounty program, visit the [Swarms Bounty Program Page](https://swarms.ai/bounty).** Let's build the future together!





## Bounties for Roadmap Items

To accelerate the development of Swarms and to encourage more contributors to join our journey towards automating every digital activity in existence, we are announcing a Bounty Program for specific roadmap items. Each bounty will be rewarded based on the complexity and importance of the task. Below are the items available for bounty:

1. **Multi-Agent Debate Integration**: $2000
2. **Meta Prompting Integration**: $1500
3. **Swarms Class**: $1500
4. **Integration of Additional Tools**: $1000
5. **Task Completion and Evaluation Logic**: $2000
6. **Ocean Integration**: $2500
7. **Improved Communication**: $2000
8. **Testing and Evaluation**: $1500
9. **Worker Swarm Class**: $2000
10. **Documentation**: $500

For each bounty task, there will be a strict evaluation process to ensure the quality of the contribution. This process includes a thorough review of the code and extensive testing to ensure it meets our standards.

# 3-Phase Testing Framework

To ensure the quality and efficiency of the Swarm, we will introduce a 3-phase testing framework which will also serve as our evaluation criteria for each of the bounty tasks.

## Phase 1: Unit Testing
In this phase, individual modules will be tested to ensure that they work correctly in isolation. Unit tests will be designed for all functions and methods, with an emphasis on edge cases.

## Phase 2: Integration Testing
After passing unit tests, we will test the integration of different modules to ensure they work correctly together. This phase will also test the interoperability of the Swarm with external systems and libraries.

## Phase 3: Benchmarking & Stress Testing
In the final phase, we will perform benchmarking and stress tests. We'll push the limits of the Swarm under extreme conditions to ensure it performs well in real-world scenarios. This phase will measure the performance, speed, and scalability of the Swarm under high load conditions.

By following this 3-phase testing framework, we aim to develop a reliable, high-performing, and scalable Swarm that can automate all digital activities. 

# Reverse Engineering to Reach Phase 3

To reach the Phase 3 level, we need to reverse engineer the tasks we need to complete. Here's an example of what this might look like:

1. **Set Clear Expectations**: Define what success looks like for each task. Be clear about the outputs and outcomes we expect. This will guide our testing and development efforts.

2. **Develop Testing Scenarios**: Create a comprehensive list of testing scenarios that cover both common and edge cases. This will help us ensure that our Swarm can handle a wide range of situations.

3. **Write Test Cases**: For each scenario, write detailed test cases that outline the exact steps to be followed, the inputs to be used, and the expected outputs.

4. **Execute the Tests**: Run the test cases on our Swarm, making note of any issues or bugs that arise.

5. **Iterate and Improve**: Based on the results of our tests, iterate and improve our Swarm. This may involve fixing bugs, optimizing code, or redesigning parts of our system.

6. **Repeat**: Repeat this process until our Swarm meets our expectations and passes all test cases.

By following these steps, we will systematically build, test, and improve our Swarm until it reaches the Phase 3 level. This methodical approach will help us ensure that we create a reliable, high-performing, and scalable Swarm that can truly automate all digital activities.

Let's shape the future of digital automation together!


--------------------------------------------------

# File: corporate/bounty_program.md

# Swarms Bounty Program

The Swarms Bounty Program is an initiative designed to incentivize contributors to help us improve and expand the Swarms framework. With an impressive $150,000 allocated for bounties, contributors have the unique opportunity to earn generous rewards while gaining prestigious recognition in the Swarms community of over 9,000 agent engineers. This program offers more than just financial benefits; it allows contributors to play a pivotal role in advancing the field of multi-agent collaboration and AI automation, while also growing their professional skills and network. By joining the Swarms Bounty Program, you become part of an innovative movement shaping the future of technology.

## Why Contribute?

1. **Generous Rewards**: The bounty pool totals $150,000, ensuring that contributors are fairly compensated for their valuable work on successfully completed tasks. Each task comes with its own reward, reflecting its complexity and impact.

2. **Community Status**: Gain coveted recognition as a valued and active contributor within the thriving Swarms community. This status not only highlights your contributions but also builds your reputation among a network of AI engineers.

3. **Skill Development**: Collaborate on cutting-edge AI projects, hone your expertise in agent engineering, and learn practical skills that can be applied to real-world challenges in the AI domain.

4. **Networking Opportunities**: Work side-by-side with over 9,000 agent engineers in our active and supportive community. This network fosters collaboration, knowledge sharing, and mentorship opportunities that can significantly boost your career.

## How It Works

1. **Explore Issues and Tasks**:
   - Visit the [Swarms GitHub Issues](https://github.com/kyegomez/swarms/issues) to find a comprehensive list of open tasks requiring attention. These issues range from coding challenges to documentation improvements, offering opportunities for contributors with various skill sets.
   - Check the [Swarms Project Board](https://github.com/users/kyegomez/projects/1) for prioritized tasks and ongoing milestones. This board provides a clear view of project priorities and helps contributors align their efforts with the project's immediate goals.

2. **Claim a Bounty**:
   - Identify a task that aligns with your interests and expertise.
   - Comment on the issue to indicate your intent to work on it and describe your approach if necessary.
   - Await approval from the Swarms team before commencing work. Approval ensures clarity and avoids duplication of efforts by other contributors.

3. **Submit Your Work**:
   - Complete the task as per the outlined requirements in the issue description. Pay close attention to details to ensure your submission meets the expectations.
   - Submit your pull request (PR) on GitHub with all the required elements, including documentation, test cases, or any relevant files that demonstrate your work.
   - Engage with reviewers to refine your submission if requested.

4. **Earn Rewards**:
   - Once your PR is reviewed, accepted, and merged into the main project, you will receive the bounty payment associated with the task.
   - Your contributor status in the Swarms community will be updated, showcasing your involvement and accomplishments.

## Contribution Guidelines
To ensure high-quality contributions and streamline the process, please adhere to the following guidelines:
- Familiarize yourself with the [Swarms Contribution Guidelines](https://github.com/kyegomez/swarms/blob/main/CONTRIBUTING.md). These guidelines outline coding standards, best practices, and procedures for contributing effectively.

- Ensure your code is clean, modular, and well-documented. Contributions that adhere to the project's standards are more likely to be accepted.

- Actively communicate with the Swarms team and other contributors. Clear communication helps resolve uncertainties, avoids duplication, and fosters collaboration within the community.

## Get Involved

1. **Join the Community**:
   - Become an active member of the Swarms community by joining our Discord server: [Join Now](https://discord.gg/jM3Z6M9uMq). The Discord server serves as a hub for discussions, updates, and support.

2. **Stay Updated**:
   - Keep track of the latest updates, announcements, and bounty opportunities by regularly checking the Discord channel and the GitHub repository.

3. **Start Contributing**:
   - Dive into the Swarms GitHub repository: [Swarms GitHub](https://github.com/kyegomez/swarms). Explore the codebase, familiarize yourself with the project structure, and identify areas where you can make an impact.

## Additional Benefits

Beyond monetary rewards, contributors gain intangible benefits that elevate their professional journey:

- **Recognition**: Your contributions will be showcased to a community of over 9,000 engineers, increasing your visibility and credibility in the AI field.

- **Portfolio Building**: Add high-impact contributions to your portfolio, demonstrating your skills and experience to potential employers or collaborators.

- **Knowledge Sharing**: Learn from and collaborate with experts in agent engineering, gaining insights into the latest advancements and best practices in the field.

## Contact Us
For any questions, support, or clarifications, reach out to the Swarms team:

- **Discord**: Engage directly with the team and fellow contributors in our active channels.

- **GitHub**: Open an issue for specific questions or suggestions related to the project. We’re here to guide and assist you at every step of your contribution journey.

---

Join us in building the future of multi-agent collaboration and AI automation. With your contributions, we can create something truly extraordinary and transformative. Together, let’s pave the way for groundbreaking advancements in technology and innovation!



--------------------------------------------------

# File: corporate/checklist.md

# **Swarms Framework Development Strategy Checklist**

## **Introduction**

The development of the Swarms framework requires a systematic and granular approach to ensure that each component is robust and that the overall framework is efficient and scalable. This checklist will serve as a guide to building Swarms from the ground up, breaking down tasks into small, manageable pieces.

---

## **1. Agent Level Development**

### **1.1 Model Integration**
- [ ] Research the most suitable models (e.g., OpenAI's GPT).
- [ ] Design an API for the agent to call the model.
- [ ] Implement error handling when model calls fail.
- [ ] Test the model with sample data for accuracy and speed.

### **1.2 Vectorstore Implementation**
- [ ] Design the schema for the vector storage system.
- [ ] Implement storage methods to add, delete, and update vectors.
- [ ] Develop retrieval methods with optimization for speed.
- [ ] Create protocols for vector-based communication between agents.
- [ ] Conduct stress tests to ascertain storage and retrieval speed.

### **1.3 Tools & Utilities Integration**
- [ ] List out essential tools required for agent functionality.
- [ ] Develop or integrate APIs for each tool.
- [ ] Implement error handling and logging for tool interactions.
- [ ] Validate tools integration with unit tests.

---

## **2. Worker Infrastructure Level Development**

### **2.1 Human Input Integration**
- [ ] Design a UI/UX for human interaction with worker nodes.
- [ ] Create APIs for input collection.
- [ ] Implement input validation and error handling.
- [ ] Test human input methods for clarity and ease of use.

### **2.2 Unique Identifier System**
- [ ] Research optimal formats for unique ID generation.
- [ ] Develop methods for generating and assigning IDs to agents.
- [ ] Implement a tracking system to manage and monitor agents via IDs.
- [ ] Validate the uniqueness and reliability of the ID system.

### **2.3 Asynchronous Operation Tools**
- [ ] Incorporate libraries/frameworks to enable asynchrony.
- [ ] Ensure tasks within an agent can run in parallel without conflict.
- [ ] Test asynchronous operations for efficiency improvements.

---

## **3. Swarm Level Development**

### **3.1 Orchestrator Design & Development**
- [ ] Draft a blueprint of orchestrator functionalities.
- [ ] Implement methods for task distribution among worker nodes.
- [ ] Develop communication protocols for the orchestrator to monitor workers.
- [ ] Create feedback systems to detect and address worker node failures.
- [ ] Test orchestrator with a mock swarm to ensure efficient task allocation.

### **3.2 Communication Layer Development**
- [ ] Select a suitable communication protocol/framework (e.g., gRPC, WebSockets).
- [ ] Design the architecture for scalable, low-latency communication.
- [ ] Implement methods for sending, receiving, and broadcasting messages.
- [ ] Test communication layer for reliability, speed, and error handling.

### **3.3 Task Management Protocols**
- [ ] Develop a system to queue, prioritize, and allocate tasks.
- [ ] Implement methods for real-time task status tracking.
- [ ] Create a feedback loop for completed tasks.
- [ ] Test task distribution, execution, and feedback systems for efficiency.

---

## **4. Hivemind Level Development**

### **4.1 Hivemind Orchestrator Development**
- [ ] Extend swarm orchestrator functionalities to manage multiple swarms.
- [ ] Create inter-swarm communication protocols.
- [ ] Implement load balancing mechanisms to distribute tasks across swarms.
- [ ] Validate hivemind orchestrator functionalities with multi-swarm setups.

### **4.2 Inter-Swarm Communication Protocols**
- [ ] Design methods for swarms to exchange data.
- [ ] Implement data reconciliation methods for swarms working on shared tasks.
- [ ] Test inter-swarm communication for efficiency and data integrity.

---

## **5. Scalability & Performance Testing**

- [ ] Simulate heavy loads to test the limits of the framework.
- [ ] Identify and address bottlenecks in both communication and computation.
- [ ] Conduct speed tests under different conditions.
- [ ] Test the system's responsiveness under various levels of stress.

---

## **6. Documentation & User Guide**

- [ ] Develop detailed documentation covering architecture, setup, and usage.
- [ ] Create user guides with step-by-step instructions.
- [ ] Incorporate visual aids, diagrams, and flowcharts for clarity.
- [ ] Update documentation regularly with new features and improvements.

---

## **7. Continuous Integration & Deployment**

- [ ] Setup CI/CD pipelines for automated testing and deployment.
- [ ] Ensure automatic rollback in case of deployment failures.
- [ ] Integrate code quality and security checks in the pipeline.
- [ ] Document deployment strategies and best practices.

---

## **Conclusion**

The Swarms framework represents a monumental leap in agent-based computation. This checklist provides a thorough roadmap for the framework's development, ensuring that every facet is addressed in depth. Through diligent adherence to this guide, the Swarms vision can be realized as a powerful, scalable, and robust system ready to tackle the challenges of tomorrow.

(Note: This document, given the word limit, provides a high-level overview. A full 5000-word document would delve into even more intricate details, nuances, potential pitfalls, and include considerations for security, user experience, compatibility, etc.)

--------------------------------------------------

# File: corporate/cost_analysis.md

# Costs Structure of Deploying Autonomous Agents

## Table of Contents

1. Introduction
2. Our Time: Generating System Prompts and Custom Tools
3. Consultancy Fees
4. Model Inference Infrastructure
5. Deployment and Continual Maintenance
6. Output Metrics: Blogs Generation Rates

---

## 1. Introduction

Autonomous agents are revolutionizing various industries, from self-driving cars to chatbots and customer service solutions. The prospect of automation and improved efficiency makes these agents attractive investments. However, like any other technological solution, deploying autonomous agents involves several cost elements that organizations need to consider carefully. This comprehensive guide aims to provide an exhaustive outline of the costs associated with deploying autonomous agents.

---

## 2. Our Time: Generating System Prompts and Custom Tools

### Description

The deployment of autonomous agents often requires a substantial investment of time to develop system prompts and custom tools tailored to specific operational needs. 

### Costs

| Task                     | Time Required (Hours) | Cost per Hour ($) | Total Cost ($) |
| ------------------------ | --------------------- | ----------------- | -------------- |
| System Prompts Design    | 50                    | 100               | 5,000          |
| Custom Tools Development | 100                   | 100               | 10,000         |
| **Total**                | **150**               |                   | **15,000**     |

---

## 3. Consultancy Fees

### Description

Consultation is often necessary for navigating the complexities of autonomous agents. This includes system assessment, customization, and other essential services.

### Costs

| Service              | Fees ($)  |
| -------------------- | --------- |
| Initial Assessment   | 5,000     |
| System Customization | 7,000     |
| Training             | 3,000     |
| **Total**            | **15,000**|

---

## 4. Model Inference Infrastructure

### Description

The hardware and software needed for the agent's functionality, known as the model inference infrastructure, form a significant part of the costs.

### Costs

| Component            | Cost ($)  |
| -------------------- | --------- |
| Hardware             | 10,000    |
| Software Licenses    | 2,000     |
| Cloud Services       | 3,000     |
| **Total**            | **15,000**|

---

## 5. Deployment and Continual Maintenance

### Description

Once everything is in place, deploying the autonomous agents and their ongoing maintenance are the next major cost factors.

### Costs

| Task                | Monthly Cost ($) | Annual Cost ($) |
| ------------------- | ---------------- | --------------- |
| Deployment          | 5,000            | 60,000          |
| Ongoing Maintenance | 1,000            | 12,000          |
| **Total**           | **6,000**        | **72,000**      |

---

## 6. Output Metrics: Blogs Generation Rates

### Description

To provide a sense of what an investment in autonomous agents can yield, we offer the following data regarding blogs that can be generated as an example of output.

### Blogs Generation Rates

| Timeframe | Number of Blogs |
|-----------|-----------------|
| Per Day   | 20              |
| Per Week  | 140             |
| Per Month | 600             |




--------------------------------------------------

# File: corporate/culture.md

# Swarms Corp Culture Document

## **Our Mission and Purpose**
At Swarms Corp, we believe in more than just building technology. We are advancing humanity by pioneering systems that allow agents—both AI and human—to collaborate seamlessly, working toward the betterment of society and unlocking a future of abundance. Our mission is everything, and each of us is here because we understand the transformative potential of our work. We are not just a company; we are a movement aimed at reshaping the future. We strive to create systems that can tackle the most complex challenges facing humanity, from climate change to inequality, with solutions that are powered by collective intelligence. 

Our purpose goes beyond just technological advancement. We are here to create tools that empower people, uplift communities, and set a new standard for what technology can achieve when the mission is clear and the commitment is unwavering. We see every project as a step toward something greater—an abundant future where human potential is limitless and artificial intelligence serves as a powerful ally to mankind.

## **Values We Live By**

### 1. **Hard Work: No Stone Unturned**
We believe that hard work is the foundation of all great achievements. At Swarms Corp, each member of the team is dedicated to putting in the effort required to solve complex problems. This isn’t just about long hours—it’s about focused, intentional work that leads to breakthroughs. We hold each other to high standards, and we don’t shy away from the hard paths when the mission calls for it. Every challenge we face is an opportunity to demonstrate our resilience and our commitment to excellence. We understand that the pursuit of groundbreaking innovation demands not just effort, but a relentless curiosity and the courage to face the unknown.

At Swarms Corp, we respect the grind because we know that transformative change doesn’t happen overnight. It requires continuous effort, sacrifice, and an unwavering focus on the task at hand. We celebrate hard work, not because it’s difficult, but because we understand its potential to transform ambitious ideas into tangible solutions. We honor the sweat equity that goes into building something that can truly make a difference.

### 2. **Mission Above Everything**
Our mission is our guiding star. Every decision, every task, and every project must align with our overarching purpose: advancing humanity and creating a post-scarcity world. This means sometimes putting the collective goal ahead of individual preferences or comfort. We’re here to do something much larger than ourselves, and we prioritize the mission with relentless commitment. We know that personal sacrifices will often be necessary, and we embrace that reality because the rewards of our mission are far greater than any individual gain.

When we say "mission above everything," we mean that our focus is not just on immediate success, but on creating a lasting impact that will benefit future generations. Our mission provides meaning and direction to our daily efforts, and we see every task as a small yet crucial part of our broader vision. We remind ourselves constantly of why we are here and who we are working for—not just our customers or stakeholders, but humanity as a whole.

### 3. **Finding the Shortest Path**
Innovation thrives on efficiency. At Swarms Corp, we value finding the shortest, most effective paths to reach our goals. We encourage everyone to question the status quo, challenge existing processes, and ask, “Is there a better way to do this?” Creativity means finding new routes—whether by leveraging automation, questioning outdated steps, or collaborating to uncover insights faster. We honor those who seek smarter paths over conventional ones. Efficiency is not just about saving time—it’s about maximizing impact and ensuring that every ounce of effort drives meaningful progress.

Finding the shortest path is about eliminating unnecessary complexity and focusing our energy on what truly matters. We encourage a culture of continuous improvement, where each team member is empowered to innovate on processes, tools, and methodologies. The shortest path does not mean cutting corners—it means removing obstacles, optimizing workflows, and focusing on high-leverage activities that bring us closer to our mission. We celebrate those who find elegant, effective solutions that others might overlook.

### 4. **Advancing Humanity**
The ultimate goal of everything we do is to elevate humanity. We envision a world where intelligence—both human and artificial—works in harmony to improve lives, solve global challenges, and expand possibilities. This ethos drives our work, whether it’s developing advanced AI systems, collaborating with others to push technological boundaries, or thinking deeply about how our creations can impact society in positive ways. Every line of code, every idea, and every strategy should move us closer to this vision.

Advancing humanity means we always think about the ethical implications of our work. We are deeply aware that the technology we create has the power to transform lives, and with that power comes the responsibility to ensure our contributions are always positive. We seek not only to push the boundaries of what technology can do but also to ensure that these advancements are inclusive and equitable. Our focus is on building a future where every person has access to the tools and opportunities they need to thrive.

Our vision is to bridge the gap between technology and humanity’s most pressing needs. We aim to democratize intelligence, making it available for everyone, regardless of their background or resources. This is how we advance humanity—not just through technological feats, but by ensuring that our innovations serve the greater good and uplift everyone.

## **Our Way of Working**

- **Radical Ownership**: Each team member is not just a contributor but an owner of their domain. We take full responsibility for outcomes, follow through on our promises, and ensure that nothing falls through the cracks. We don’t wait for permission—we act, innovate, and lead. Radical ownership means understanding that our actions have a direct impact on the success of our mission. It’s about proactive problem-solving and always stepping up when we see an opportunity to make a difference.

- **Honesty and Respect**: We communicate openly and respect each other’s opinions. Tough conversations are a natural part of building something impactful. We face challenges head-on with honesty and directness while maintaining a respectful and supportive atmosphere. Honesty fosters trust, and trust is the foundation of any high-performing team. We value feedback and see it as an essential tool for growth—both for individuals and for the organization as a whole.

- **One Team, One Mission**: Collaboration isn’t just encouraged—it’s essential. We operate as a swarm, where each agent contributes to a greater goal, learning from each other, sharing knowledge, and constantly iterating together. We celebrate wins collectively and approach obstacles with a unified spirit. No one succeeds alone; every achievement is the result of collective effort. We lift each other up, and we know that our strength lies in our unity and shared purpose.

- **The Future is Ours to Shape**: Our work is inherently future-focused. We’re not satisfied with simply keeping up—we want to set the pace. Every day, we take one step closer to a future where humanity’s potential is limitless, where scarcity is eliminated, and where intelligence—human and machine—advances society. We are not passive participants in the future; we are active shapers of it. We imagine a better tomorrow, and then we take deliberate steps to create it. Our work today will define what the world looks like tomorrow.

## **Expectations**

- **Be Bold**: Don’t be afraid to take risks. Innovation requires experimentation, and sometimes that means making mistakes. We support each other in learning from failures and taking smart, calculated risks. Boldness is at the heart of progress. We want every member of Swarms Corp to feel empowered to think outside the box, propose unconventional ideas, and drive innovation. Mistakes are seen not as setbacks, but as opportunities for learning and growth.

- **Keep the Mission First**: Every decision we make should be with our mission in mind. Ask yourself how your work advances the cause of creating an abundant future. The mission is the yardstick against which we measure our efforts, ensuring that everything we do pushes us closer to our ultimate goals. We understand that the mission is bigger than any one of us, and we strive to contribute meaningfully every day.

- **Find Solutions, Not Problems**: While identifying issues is important, we value those who come with solutions. Embrace challenges as opportunities to innovate and find ways to make an impact. We foster a culture of proactive problem-solving where obstacles are seen as opportunities to exercise creativity. If something’s broken, we fix it. If there’s a better way, we find it. We expect our team members to be solution-oriented, always seeking ways to turn challenges into stepping stones for progress.

- **Think Big, Act Fast**: We’re not here to make small changes—we’re here to revolutionize how we think about intelligence, automation, and society. Dream big, but work with urgency. We are tackling problems of immense scale, and we must move with intention and speed. Thinking big means envisioning a world that is radically different and better, and acting fast means executing the steps to get us there without hesitation. We value ambition and the courage to move swiftly when the time is right.

## **Our Commitment to You**
Swarms Corp is a place for dreamers and doers, for those who are driven by purpose and are unafraid of the work required to achieve it. We commit to providing you with the tools, support, and environment you need to contribute meaningfully to our mission. We are here to advance humanity together, one agent, one solution, one breakthrough at a time. We pledge to nurture an environment that encourages creativity, collaboration, and bold thinking. Here, you will find a community that celebrates your wins, supports you through challenges, and pushes you to be your best self.

Our commitment also includes ensuring that your voice is heard. We are building the future together, and every perspective matters. We strive to create an inclusive space where diversity of thought is welcomed, and where each team member feels valued for their unique contributions. At Swarms Corp, you are not just part of a team—you are part of a mission that aims to change the course of humanity for the better. Together, we’ll make the impossible possible, one breakthrough at a time.



--------------------------------------------------

# File: corporate/data_room.md

# Swarms Data Room

## Table of Contents

**Introduction**

- Overview of the Company

- Vision and Mission Statement

- Executive Summary

**Corporate Documents**

- Articles of Incorporation

- Bylaws

- Shareholder Agreements

- Board Meeting Minutes

- Company Structure and Org Chart

**Financial Information**

- Historical Financial Statements
  
  - Income Statements

  - Balance Sheets

  - Cash Flow Statements

- Financial Projections and Forecasts

- Cap Table

- Funding History and Use of Funds

**Products and Services**

- Detailed Descriptions of Products/Services

- Product Development Roadmap

- User Manuals and Technical Specifications

- Case Studies and Use Cases


## **Introduction**
Swarms provides automation-as-a-service through swarms of autonomous agents that work together as a team. We enable our customers to build, deploy, and scale production-grade multi-agent applications to automate real-world tasks.

### **Vision**
Our vision for 2024 is to provide the most reliable infrastructure for deploying autonomous agents into the real world through the Swarm Cloud, our premier cloud platform for the scalable deployment of Multi-Modal Autonomous Agents. The platform focuses on delivering maximum value to users by only taking a small fee when utilizing the agents for the hosted compute power needed to host the agents.

### **Executive Summary**
The Swarm Corporation aims to enable AI models to automate complex workflows and operations, not just singular low-value tasks. We believe collaboration between multiple agents can overcome limitations of individual agents for reasoning, planning, etc. This will allow automation of processes in mission-critical industries like security, logistics, and manufacturing where AI adoption is currently low.  

We provide an open source framework to deploy production-grade multi-modal agents in just a few lines of code. This builds our user base, recruits talent, gets customer feedback to improve products, gains awareness and trust.

Our business model focuses on customer satisfaction, openness, integration with other tools/platforms, and production-grade reliability. 

Go-to-market strategy is to get the framework to product-market fit with over 50K weekly recurring users, then secure high-value contracts in target industries. Long-term monetization via microtransactions, usage-based pricing, subscriptions.

The team has thousands of hours building and optimizing autonomous agents. Leadership includes AI engineers, product experts, open source contributors and community builders.

Key milestones: get 80K framework users in January 2024, start contracts in target verticals, introduce commercial products in 2025 with various pricing models.

### **Resources**
- [Swarm Pre-Seed Deck](https://drive.google.com/file/d/1n8o2mjORbG96uDfx4TabjnyieludYaZz/view?usp=sharing)
- [Swarm Memo](https://docs.google.com/document/d/1hS_nv_lFjCqLfnJBoF6ULY9roTbSgSuCkvXvSUSc7Lo/edit?usp=sharing)




## **Financial Documents**
This section is dedicated entirely for corporate documents.

- [Cap Table](https://docs.google.com/spreadsheets/d/1wuTWbfhYaY5Xp6nSQ9R0wDtSpwSS9coHxsjKd0UbIDc/edit?usp=sharing)

- [Cashflow Prediction Sheet](https://docs.google.com/spreadsheets/d/1HQEHCIXXMHajXMl5sj8MEfcQtWfOnD7GjHtNiocpD60/edit?usp=sharing)


------

## **Product**
Swarms is an open source framework for developers in python to enable seamless, reliable, and scalable multi-agent orchestration through modularity, customization, and precision.

- [Swarms Github Page:](https://github.com/kyegomez/swarms)
- [Swarms Memo](https://docs.google.com/document/d/1hS_nv_lFjCqLfnJBoF6ULY9roTbSgSuCkvXvSUSc7Lo/edit)
- [Swarms Project Board](https://github.com/users/kyegomez/projects/1)
- [Swarms Website](https://www.swarms.world/g)
- [Swarm Ecosystem](https://github.com/kyegomez/swarm-ecosystem)
- [Swarm Core](https://github.com/kyegomez/swarms-core)

### Product Growth Metrics
| Name                             | Description                                                                                                   | Link                                                                                      |
|----------------------------------|---------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| Total Downloads of all time      | Total number of downloads for the product over its entire lifespan.                                           | [![Downloads](https://static.pepy.tech/badge/swarms)](https://pepy.tech/project/swarms)   |
| Downloads this month             | Number of downloads for the product in the current month.                                                     | [![Downloads](https://static.pepy.tech/badge/swarms/month)](https://pepy.tech/project/swarms) |
| Total Downloads this week        | Total number of downloads for the product in the current week.                                                | [![Downloads](https://static.pepy.tech/badge/swarms/week)](https://pepy.tech/project/swarms) |
| Github Forks                     | Number of times the product's codebase has been copied for optimization, contribution, or usage.              | [![GitHub forks](https://img.shields.io/github/forks/kyegomez/swarms)](https://github.com/kyegomez/swarms/network) |
| Github Stars                     | Number of users who have 'liked' the project.                                                                 | [![GitHub stars](https://img.shields.io/github/stars/kyegomez/swarms)](https://github.com/kyegomez/swarms/stargazers) |
| Pip Module Metrics               | Various project statistics such as watchers, number of contributors, date repository was created, and more.   | [CLICK HERE](https://libraries.io/github/kyegomez/swarms)                                |
| Contribution Based Statistics    | Statistics like number of contributors, lines of code changed, etc.                                           | [HERE](https://github.com/kyegomez/swarms/graphs/contributors)                           |
| Github Community insights        | Insights into the Github community around the product.                                                        | [Github Community insights](https://github.com/kyegomez/swarms/graphs/community)         |
| Github Traffic Metrics           | Metrics related to traffic, such as views and clones on Github.                                               | [Github Traffic Metrics](https://github.com/kyegomez/swarms/graphs/traffic)               |
| Issues with the framework        | Current open issues for the product on Github.                                                                | [![GitHub issues](https://img.shields.io/github/issues/kyegomez/swarms)](https://github.com/kyegomez/swarms/issues) |




--------------------------------------------------

# File: corporate/demos.md

# Demo Ideas

* We could also try to create an AI influencer run by a swarm, let it create a whole identity and generate images, memes, and other content for Twitter, Reddit, etc.

* had a thought that we should have either a more general one of these or a swarm or both -- need something connecting all the calendars, events, and initiatives of all the AI communities, langchain, laion, eluther, lesswrong, gato, rob miles, chatgpt hackers, etc etc

* Swarm of AI influencers to spread marketing

* Delegation System to better organize teams: Start with a team of passionate humans and let them self-report their skills/strengths so the agent has a concept of who to delegate to, then feed the agent a huge task list (like the bullet list a few messages above) that it breaks down into actionable steps and "prompts" specific team members to complete tasks. Could even suggest breakout teams of a few people with complementary skills to tackle more complex tasks. There can also be a live board that updates each time a team member completes something, to encourage momentum and keep track of progress


--------------------------------------------------

# File: corporate/design.md

# Design Philosophy Document for Swarms

## Usable

### Objective

Our goal is to ensure that Swarms is intuitive and easy to use for all users, regardless of their level of technical expertise. This includes the developers who implement Swarms in their applications, as well as end users who interact with the implemented systems.

### Tactics

- Clear and Comprehensive Documentation: We will provide well-written and easily accessible documentation that guides users through using and understanding Swarms.
- User-Friendly APIs: We'll design clean and self-explanatory APIs that help developers to understand their purpose quickly.
- Prompt and Effective Support: We will ensure that support is readily available to assist users when they encounter problems or need help with Swarms.

## Reliable

### Objective

Swarms should be dependable and trustworthy. Users should be able to count on Swarms to perform consistently and without error or failure.

### Tactics

- Robust Error Handling: We will focus on error prevention, detection, and recovery to minimize failures in Swarms.
- Comprehensive Testing: We will apply various testing methodologies such as unit testing, integration testing, and stress testing to validate the reliability of our software.
- Continuous Integration/Continuous Delivery (CI/CD): We will use CI/CD pipelines to ensure that all changes are tested and validated before they're merged into the main branch.

## Fast

### Objective

Swarms should offer high performance and rapid response times. The system should be able to handle requests and tasks swiftly.

### Tactics

- Efficient Algorithms: We will focus on optimizing our algorithms and data structures to ensure they run as quickly as possible.
- Caching: Where appropriate, we will use caching techniques to speed up response times.
- Profiling and Performance Monitoring: We will regularly analyze the performance of Swarms to identify bottlenecks and opportunities for improvement.

## Scalable

### Objective

Swarms should be able to grow in capacity and complexity without compromising performance or reliability. It should be able to handle increased workloads gracefully.

### Tactics

- Modular Architecture: We will design Swarms using a modular architecture that allows for easy scaling and modification.
- Load Balancing: We will distribute tasks evenly across available resources to prevent overload and maximize throughput.
- Horizontal and Vertical Scaling: We will design Swarms to be capable of both horizontal (adding more machines) and vertical (adding more power to an existing machine) scaling.

### Philosophy

Swarms is designed with a philosophy of simplicity and reliability. We believe that software should be a tool that empowers users, not a hurdle that they need to overcome. Therefore, our focus is on usability, reliability, speed, and scalability. We want our users to find Swarms intuitive and dependable, fast and adaptable to their needs. This philosophy guides all of our design and development decisions.

# Swarm Architecture Design Document

## Overview

The goal of the Swarm Architecture is to provide a flexible and scalable system to build swarm intelligence models that can solve complex problems. This document details the proposed design to create a plug-and-play system, which makes it easy to create custom swarms, and provides pre-configured swarms with multi-modal agents.

## Design Principles

- **Modularity**: The system will be built in a modular fashion, allowing various components to be easily swapped or upgraded.
- **Interoperability**: Different swarm classes and components should be able to work together seamlessly.
- **Scalability**: The design should support the growth of the system by adding more components or swarms.
- **Ease of Use**: Users should be able to easily create their own swarms or use pre-configured ones with minimal configuration.

## Design Components

### BaseSwarm

The BaseSwarm is an abstract base class which defines the basic structure of a swarm and the methods that need to be implemented. Any new swarm should inherit from this class and implement the required methods.

### Swarm Classes

Various Swarm classes can be implemented inheriting from the BaseSwarm class. Each swarm class should implement the required methods for initializing the components, worker nodes, and boss node, and running the swarm.

Pre-configured swarm classes with multi-modal agents can be provided for ease of use. These classes come with a default configuration of tools and agents, which can be used out of the box.

### Tools and Agents

Tools and agents are the components that provide the actual functionality to the swarms. They can be language models, AI assistants, vector stores, or any other components that can help in problem solving.

To make the system plug-and-play, a standard interface should be defined for these components. Any new tool or agent should implement this interface, so that it can be easily plugged into the system.

## Usage

Users can either use pre-configured swarms or create their own custom swarms.

To use a pre-configured swarm, they can simply instantiate the corresponding swarm class and call the run method with the required objective.

To create a custom swarm, they need to:

1. Define a new swarm class inheriting from BaseSwarm.
2. Implement the required methods for the new swarm class.
3. Instantiate the swarm class and call the run method.

### Example

```python
# Using pre-configured swarm
swarm = PreConfiguredSwarm(openai_api_key)
swarm.run_swarms(objective)

# Creating custom swarm
class CustomSwarm(BaseSwarm):
    # Implement required methods

swarm = CustomSwarm(openai_api_key)
swarm.run_swarms(objective)
```

## Conclusion

This Swarm Architecture design provides a scalable and flexible system for building swarm intelligence models. The plug-and-play design allows users to easily use pre-configured swarms or create their own custom swarms.


# Swarming Architectures
Sure, below are five different swarm architectures with their base requirements and an abstract class that processes these components:

1. **Hierarchical Swarm**: This architecture is characterized by a boss/worker relationship. The boss node takes high-level decisions and delegates tasks to the worker nodes. The worker nodes perform tasks and report back to the boss node. 
    - Requirements: Boss node (can be a large language model), worker nodes (can be smaller language models), and a task queue for task management.

2. **Homogeneous Swarm**: In this architecture, all nodes in the swarm are identical and contribute equally to problem-solving. Each node has the same capabilities.
    - Requirements: Homogeneous nodes (can be language models of the same size), communication protocol for nodes to share information.

3. **Heterogeneous Swarm**: This architecture contains different types of nodes, each with its specific capabilities. This diversity can lead to more robust problem-solving.
    - Requirements: Different types of nodes (can be different types and sizes of language models), a communication protocol, and a mechanism to delegate tasks based on node capabilities.

4. **Competitive Swarm**: In this architecture, nodes compete with each other to find the best solution. The system may use a selection process to choose the best solutions.
    - Requirements: Nodes (can be language models), a scoring mechanism to evaluate node performance, a selection mechanism.

5. **Cooperative Swarm**: In this architecture, nodes work together and share information to find solutions. The focus is on cooperation rather than competition.
    - Requirements: Nodes (can be language models), a communication protocol, a consensus mechanism to agree on solutions.


6. **Grid-based Swarm**: This architecture positions agents on a grid, where they can only interact with their neighbors. This is useful for simulations, especially in fields like ecology or epidemiology.
    - Requirements: Agents (can be language models), a grid structure, and a neighborhood definition (i.e., how to identify neighboring agents).

7. **Particle Swarm Optimization (PSO) Swarm**: In this architecture, each agent represents a potential solution to an optimization problem. Agents move in the solution space based on their own and their neighbors' past performance. PSO is especially useful for continuous numerical optimization problems.
    - Requirements: Agents (each representing a solution), a definition of the solution space, an evaluation function to rate the solutions, a mechanism to adjust agent positions based on performance.

8. **Ant Colony Optimization (ACO) Swarm**: Inspired by ant behavior, this architecture has agents leave a pheromone trail that other agents follow, reinforcing the best paths. It's useful for problems like the traveling salesperson problem.
    - Requirements: Agents (can be language models), a representation of the problem space, a pheromone updating mechanism.

9. **Genetic Algorithm (GA) Swarm**: In this architecture, agents represent potential solutions to a problem. They can 'breed' to create new solutions and can undergo 'mutations'. GA swarms are good for search and optimization problems.
    - Requirements: Agents (each representing a potential solution), a fitness function to evaluate solutions, a crossover mechanism to breed solutions, and a mutation mechanism.

10. **Stigmergy-based Swarm**: In this architecture, agents communicate indirectly by modifying the environment, and other agents react to such modifications. It's a decentralized method of coordinating tasks.
    - Requirements: Agents (can be language models), an environment that agents can modify, a mechanism for agents to perceive environment changes.

These architectures all have unique features and requirements, but they share the need for agents (often implemented as language models) and a mechanism for agents to communicate or interact, whether it's directly through messages, indirectly through the environment, or implicitly through a shared solution space. Some also require specific data structures, like a grid or problem space, and specific algorithms, like for evaluating solutions or updating agent positions.


--------------------------------------------------

# File: corporate/distribution.md



# Swarms Monetization Strategy 

This strategy includes a variety of business models, potential revenue streams, cashflow structures, and customer identification methods. Let's explore these further.

## Business Models 

1. **Platform as a Service (PaaS):** Provide the Swarms AI platform on a subscription basis, charged monthly or annually. This could be tiered based on usage and access to premium features. 

2. **API Usage-based Pricing:** Charge customers based on their usage of the Swarms API. The more requests made, the higher the fee.

3. **Managed Services:** Offer complete end-to-end solutions where you manage the entire AI infrastructure for the clients. This could be on a contract basis with a recurring fee.

4. **Training and Certification:** Provide Swarms AI training and certification programs for interested developers and businesses. These could be monetized as separate courses or subscription-based access.

5. **Partnerships:** Collaborate with large enterprises and offer them dedicated Swarm AI services. These could be performance-based contracts, ensuring a mutually beneficial relationship.

6. **Data as a Service (DaaS):** Leverage the data generated by Swarms for insights and analytics, providing valuable business intelligence to clients.

## Potential Revenue Streams 

1. **Subscription Fees:** This would be the main revenue stream from providing the Swarms platform as a service.

2. **Usage Fees:** Additional revenue can come from usage fees for businesses that have high demand for Swarms API.

3. **Contract Fees:** From offering managed services and bespoke solutions to businesses.

4. **Training Fees:** Revenue from providing training and certification programs to developers and businesses.

5. **Partnership Contracts:** Large-scale projects with enterprises, involving dedicated Swarm AI services, could provide substantial income.

6. **Data Insights:** Revenue from selling valuable business intelligence derived from Swarm's aggregated and anonymized data.

## Potential Customers 

1. **Businesses Across Sectors:** Any business seeking to leverage AI for automation, efficiency, and data insights could be a potential customer. This includes sectors like finance, eCommerce, logistics, healthcare, and more.

2. **Developers:** Both freelance and those working in organizations could use Swarms to enhance their projects and services. 

3. **Enterprises:** Large enterprises looking to automate and optimize their operations could greatly benefit from Swarms.

4. **Educational Institutions:** Universities and research institutions could leverage Swarms for research and teaching purposes.

## Roadmap 

1. **Landing Page Creation:** Develop a dedicated product page on apac.ai for Swarms.

2. **Hosted Swarms API:** Launch a cloud-based Swarms API service. It should be highly reliable, with robust documentation to attract daily users.

3. **Consumer and Enterprise Subscription Service:** Launch a comprehensive subscription service on The Domain. This would provide users with access to a wide array of APIs and data streams.

4. **Dedicated Capacity Deals:** Partner with large enterprises to offer them dedicated Swarm AI solutions for automating their operations.

5. **Enterprise Partnerships:** Develop partnerships with large enterprises for extensive contract-based projects.

6. **Integration with Collaboration Platforms:** Develop Swarms bots for platforms like Discord and Slack, charging users a subscription fee for access.

7. **Personal Data Instances:** Offer users dedicated instances of all their data that the Swarm can query as needed.

8. **Browser Extension:** Develop a browser extension that integrates with the Swarms platform, offering users a more seamless experience.

Remember, customer satisfaction and a value-centric approach are at the core of any successful monetization strategy. It's essential to continuously iterate and improve the product based on customer feedback and evolving market needs.

----

# Other ideas

1. **Platform as a Service (PaaS):** Create a cloud-based platform that allows users to build, run, and manage applications without the complexity of maintaining the infrastructure. You could charge users a subscription fee for access to the platform and provide different pricing tiers based on usage levels. This could be an attractive solution for businesses that do not have the capacity to build or maintain their own swarm intelligence solutions.

2. **Professional Services:** Offer consultancy and implementation services to businesses looking to utilize the Swarm technology. This could include assisting with integration into existing systems, offering custom development services, or helping customers to build specific solutions using the framework.

3. **Education and Training:** Create a certification program for developers or companies looking to become proficient with the Swarms framework. This could be sold as standalone courses, or bundled with other services. 

4. **Managed Services:** Some companies may prefer to outsource the management of their Swarm-based systems. A managed services solution could take care of all the technical aspects, from hosting the solution to ensuring it runs smoothly, allowing the customer to focus on their core business.

5. **Data Analysis and Insights:** Swarm intelligence can generate valuable data and insights. By anonymizing and aggregating this data, you could provide industry reports, trend analysis, and other valuable insights to businesses.

As for the type of platform, Swarms can be offered as a cloud-based solution given its scalability and flexibility. This would also allow you to apply a SaaS/PaaS type monetization model, which provides recurring revenue.

Potential customers could range from small to large enterprises in various sectors such as logistics, eCommerce, finance, and technology, who are interested in leveraging artificial intelligence and machine learning for complex problem solving, optimization, and decision-making.

**Product Brief Monetization Strategy:**

Product Name: Swarms.AI Platform

Product Description: A cloud-based AI and ML platform harnessing the power of swarm intelligence. 

1. **Platform as a Service (PaaS):** Offer tiered subscription plans (Basic, Premium, Enterprise) to accommodate different usage levels and business sizes. 

2. **Professional Services:** Offer consultancy and custom development services to tailor the Swarms solution to the specific needs of the business.

3. **Education and Training:** Launch an online Swarms.AI Academy with courses and certifications for developers and businesses. 

4. **Managed Services:** Provide a premium, fully-managed service offering that includes hosting, maintenance, and 24/7 support.

5. **Data Analysis and Insights:** Offer industry reports and customized insights generated from aggregated and anonymized Swarm data.

Potential Customers: Enterprises in sectors such as logistics, eCommerce, finance, and technology. This can be sold globally, provided there's an internet connection.

Marketing Channels: Online marketing (SEO, Content Marketing, Social Media), Partnerships with tech companies, Direct Sales to Enterprises.

This strategy is designed to provide multiple revenue streams, while ensuring the Swarms.AI platform is accessible and useful to a range of potential customers.

1. **AI Solution as a Service:** By offering the Swarms framework as a service, businesses can access and utilize the power of multiple LLM agents without the need to maintain the infrastructure themselves. Subscription can be tiered based on usage and additional features.

2. **Integration and Custom Development:** Offer integration services to businesses wanting to incorporate the Swarms framework into their existing systems. Also, you could provide custom development for businesses with specific needs not met by the standard framework.

3. **Training and Certification:** Develop an educational platform offering courses, webinars, and certifications on using the Swarms framework. This can serve both developers seeking to broaden their skills and businesses aiming to train their in-house teams.

4. **Managed Swarms Solutions:** For businesses that prefer to outsource their AI needs, provide a complete solution which includes the development, maintenance, and continuous improvement of swarms-based applications.

5. **Data Analytics Services:** Leveraging the aggregated insights from the AI swarms, you could offer data analytics services. Businesses can use these insights to make informed decisions and predictions.

**Type of Platform:**

Cloud-based platform or Software as a Service (SaaS) will be a suitable model. It offers accessibility, scalability, and ease of updates. 

**Target Customers:**

The technology can be beneficial for businesses across sectors like eCommerce, technology, logistics, finance, healthcare, and education, among others.

**Product Brief Monetization Strategy:**

Product Name: Swarms.AI

1. **AI Solution as a Service:** Offer different tiered subscriptions (Standard, Premium, and Enterprise) each with varying levels of usage and features.

2. **Integration and Custom Development:** Offer custom development and integration services, priced based on the scope and complexity of the project.

3. **Training and Certification:** Launch the Swarms.AI Academy with courses and certifications, available for a fee. 

4. **Managed Swarms Solutions:** Offer fully managed solutions tailored to business needs, priced based on scope and service level agreements.

5. **Data Analytics Services:** Provide insightful reports and data analyses, which can be purchased on a one-off basis or through a subscription.

By offering a variety of services and payment models, Swarms.AI will be able to cater to a diverse range of business needs, from small start-ups to large enterprises. Marketing channels would include digital marketing, partnerships with technology companies, presence in tech events, and direct sales to targeted industries.



# Roadmap

* Create a landing page for swarms apac.ai/product/swarms

* Create Hosted Swarms API for anybody to just use without need for mega gpu infra, charge usage based pricing. Prerequisites for success => Swarms has to be extremely reliable + we need world class documentation and many daily users => how do we get many daily users? We provide a seamless and fluid experience, how do we create a seamless and fluid experience? We write good code that is modular, provides feedback to the user in times of distress, and ultimately accomplishes the user's tasks.

* Hosted consumer and enterprise subscription as a service on The Domain, where users can interact with 1000s of APIs and ingest 1000s of different data streams.

* Hosted dedicated capacity deals with mega enterprises on automating many operations with Swarms for monthly subscription 300,000+$ 

* Partnerships with enterprises, massive contracts with performance based fee

* Have discord bot and or slack bot with users personal data, charge subscription + browser extension

* each user gets a dedicated ocean instance of all their data so the swarm can query it as needed.




---
---


# Swarms Monetization Strategy: A Revolutionary AI-powered Future

Swarms is a powerful AI platform leveraging the transformative potential of Swarm Intelligence. Our ambition is to monetize this groundbreaking technology in ways that generate significant cashflow while providing extraordinary value to our customers. 

Here we outline our strategic monetization pathways and provide a roadmap that plots our course to future success.

---

## I. Business Models

1. **Platform as a Service (PaaS):** We provide the Swarms platform as a service, billed on a monthly or annual basis. Subscriptions can range from $50 for basic access, to $500+ for premium features and extensive usage.

2. **API Usage-based Pricing:** Customers are billed according to their use of the Swarms API. Starting at $0.01 per request, this creates a cashflow model that rewards extensive platform usage.

3. **Managed Services:** We offer end-to-end solutions, managing clients' entire AI infrastructure. Contract fees start from $100,000 per month, offering both a sustainable cashflow and considerable savings for our clients.

4. **Training and Certification:** A Swarms AI training and certification program is available for developers and businesses. Course costs can range from $200 to $2,000, depending on course complexity and duration.

5. **Partnerships:** We forge collaborations with large enterprises, offering dedicated Swarm AI services. These performance-based contracts start from $1,000,000, creating a potentially lucrative cashflow stream.

6. **Data as a Service (DaaS):** Swarms generated data are mined for insights and analytics, with business intelligence reports offered from $500 each. 

---

## II. Potential Revenue Streams 

1. **Subscription Fees:** From $50 to $500+ per month for platform access.

2. **Usage Fees:** From $0.01 per API request, generating income from high platform usage.

3. **Contract Fees:** Starting from $100,000 per month for managed services.

4. **Training Fees:** From $200 to $2,000 for individual courses or subscription access.

5. **Partnership Contracts:** Contracts starting from $100,000, offering major income potential.

6. **Data Insights:** Business intelligence reports starting from $500.

---

## III. Potential Customers 

1. **Businesses Across Sectors:** Our offerings cater to businesses across finance, eCommerce, logistics, healthcare, and more.

2. **Developers:** Both freelancers and organization-based developers can leverage Swarms for their projects.

3. **Enterprises:** Swarms offers large enterprises solutions for optimizing operations.

4. **Educational Institutions:** Universities and research institutions can use Swarms for research and teaching.

---

## IV. Roadmap 

1. **Landing Page Creation:** Develop a dedicated Swarms product page on apac.ai.

2. **Hosted Swarms API:** Launch a reliable, well-documented cloud-based Swarms API service.

3. **Consumer and Enterprise Subscription Service:** Launch an extensive subscription service on The Domain, providing wide-ranging access to APIs and data streams.

4. **Dedicated Capacity Deals:** Offer large enterprises dedicated Swarm AI solutions, starting from $300,000 monthly subscription.

5. **Enterprise Partnerships:** Develop performance-based contracts with large enterprises.

6. **Integration with Collaboration Platforms:** Develop Swarms bots for platforms like Discord and Slack, charging a subscription fee for access.

7. **Personal Data Instances:** Offer users dedicated data instances that the Swarm can query as needed.

8. **Browser Extension:** Develop a browser extension that integrates with the Swarms platform for seamless user experience.

---

Our North Star remains customer satisfaction and value provision. 
As we embark on this journey, we continuously refine our product based on customer feedback and evolving market needs, ensuring we lead in the age of AI-driven solutions.

## **Platform Distribution Strategy for Swarms**

*Note: This strategy aims to diversify the presence of 'Swarms' across various platforms and mediums while focusing on monetization and value creation for its users.

---

### **1. Framework:**

#### **Objective:**
To offer Swarms as an integrated solution within popular frameworks to ensure that developers and businesses can seamlessly incorporate its functionalities.

#### **Strategy:**

* **Language/Framework Integration:** 
    * Target popular frameworks like Django, Flask for Python, Express.js for Node, etc. 
    * Create SDKs or plugins for easy integration. 

* **Monetization:** 
    * Freemium Model: Offer basic integration for free, and charge for additional features or advanced integrations.
    * Licensing: Allow businesses to purchase licenses for enterprise-level integrations.

* **Promotion:**
    * Engage in partnerships with popular online coding platforms like Udemy, Coursera, etc., offering courses and tutorials on integrating Swarms.
    * Host webinars and write technical blogs to promote the integration benefits.

---

### **2. Paid API:**

#### **Objective:**
To provide a scalable solution for developers and businesses that want direct access to Swarms' functionalities without integrating the entire framework.

#### **Strategy:**

* **API Endpoints:**
    * Offer various endpoints catering to different functionalities.
    * Maintain robust documentation to ensure ease of use.

* **Monetization:**
    * Usage-based Pricing: Charge based on the number of API calls.
    * Subscription Tiers: Provide tiered packages based on usage limits and advanced features.

* **Promotion:**
    * List on API marketplaces like RapidAPI.
    * Engage in SEO to make the API documentation discoverable.

---

### **3. Domain Hosted:**

#### **Objective:**
To provide a centralized web platform where users can directly access and engage with Swarms' offerings.

#### **Strategy:**

* **User-Friendly Interface:**
    * Ensure a seamless user experience with intuitive design.
    * Incorporate features like real-time chat support, tutorials, and an FAQ section.

* **Monetization:**
    * Subscription Model: Offer monthly/annual subscriptions for premium features.
    * Affiliate Marketing: Partner with related tech products/services and earn through referrals.

* **Promotion:**
    * Invest in PPC advertising on platforms like Google Ads.
    * Engage in content marketing, targeting keywords related to Swarms' offerings.

---

### **4. Build Your Own (No-Code Platform):**

#### **Objective:**
To cater to the non-developer audience, allowing them to leverage Swarms' features without any coding expertise.

#### **Strategy:**

* **Drag-and-Drop Interface:**
    * Offer customizable templates.
    * Ensure integration with popular platforms and apps.

* **Monetization:**
    * Freemium Model: Offer basic features for free, and charge for advanced functionalities.
    * Marketplace for Plugins: Allow third-party developers to sell their plugins/extensions on the platform.

* **Promotion:**
    * Partner with no-code communities and influencers.
    * Offer promotions and discounts to early adopters.

---

### **5. Marketplace for the No-Code Platform:**

#### **Objective:**
To create an ecosystem where third-party developers can contribute, and users can enhance their Swarms experience.

#### **Strategy:**

* **Open API for Development:**
    * Offer robust documentation and developer support.
    * Ensure a strict quality check for marketplace additions.

* **Monetization:**
    * Revenue Sharing: Take a percentage cut from third-party sales.
    * Featured Listings: Charge developers for premium listings.

* **Promotion:**
    * Host hackathons and competitions to boost developer engagement.
    * Promote top plugins/extensions through email marketing and on the main platform.

---

### **Future Outlook & Expansion:**

* **Hosted Dedicated Capacity:** Hosted dedicated capacity deals for enterprises starting at 399,999$
* **Decentralized Free Peer to peer endpoint hosted on The Grid:** Hosted endpoint by the people for the people.
* **Browser Extenision:** Athena browser extension for deep browser automation, subscription, usage, 


* **Mobile Application:** Develop a mobile app version for Swarms to tap into the vast mobile user base.
* **Global Expansion:** Localize the platform for non-English speaking regions to tap into global markets.
* **Continuous Learning:** Regularly collect user feedback and iterate on the product features.

---



### **50 Creative Distribution Platforms for Swarms**

1. **E-commerce Integrations:** Platforms like Shopify, WooCommerce, where Swarms can add value to sellers.
 
2. **Web Browser Extensions:** Chrome, Firefox, and Edge extensions that bring Swarms features directly to users.

3. **Podcasting Platforms:** Swarms-themed content on platforms like Spotify, Apple Podcasts to reach aural learners.

4. **Virtual Reality (VR) Platforms:** Integration with VR experiences on Oculus or Viveport.

5. **Gaming Platforms:** Tools or plugins for game developers on Steam, Epic Games.

6. **Decentralized Platforms:** Using blockchain, create decentralized apps (DApps) versions of Swarms.

7. **Chat Applications:** Integrate with popular messaging platforms like WhatsApp, Telegram, Slack.

8. **AI Assistants:** Integration with Siri, Alexa, Google Assistant to provide Swarms functionalities via voice commands.

9. **Freelancing Websites:** Offer tools or services for freelancers on platforms like Upwork, Fiverr.

10. **Online Forums:** Platforms like Reddit, Quora, where users can discuss or access Swarms.

11. **Educational Platforms:** Sites like Khan Academy, Udacity where Swarms can enhance learning experiences.

12. **Digital Art Platforms:** Integrate with platforms like DeviantArt, Behance.

13. **Open-source Repositories:** Hosting Swarms on GitHub, GitLab, Bitbucket with open-source plugins.

14. **Augmented Reality (AR) Apps:** Create AR experiences powered by Swarms.

15. **Smart Home Devices:** Integrate Swarms' functionalities into smart home devices.

16. **Newsletters:** Platforms like Substack, where Swarms insights can be shared.

17. **Interactive Kiosks:** In malls, airports, and other public places.

18. **IoT Devices:** Incorporate Swarms in devices like smart fridges, smartwatches.

19. **Collaboration Tools:** Platforms like Trello, Notion, offering Swarms-enhanced productivity.

20. **Dating Apps:** An AI-enhanced matching algorithm powered by Swarms.

21. **Music Platforms:** Integrate with Spotify, SoundCloud for music-related AI functionalities.

22. **Recipe Websites:** Platforms like AllRecipes, Tasty with AI-recommended recipes.

23. **Travel & Hospitality:** Integrate with platforms like Airbnb, Tripadvisor for AI-based recommendations.

24. **Language Learning Apps:** Duolingo, Rosetta Stone integrations.

25. **Virtual Events Platforms:** Websites like Hopin, Zoom where Swarms can enhance the virtual event experience.

26. **Social Media Management:** Tools like Buffer, Hootsuite with AI insights by Swarms.

27. **Fitness Apps:** Platforms like MyFitnessPal, Strava with AI fitness insights.

28. **Mental Health Apps:** Integration into apps like Calm, Headspace for AI-driven wellness.

29. **E-books Platforms:** Amazon Kindle, Audible with AI-enhanced reading experiences.

30. **Sports Analysis Tools:** Websites like ESPN, Sky Sports where Swarms can provide insights.

31. **Financial Tools:** Integration into platforms like Mint, Robinhood for AI-driven financial advice.

32. **Public Libraries:** Digital platforms of public libraries for enhanced reading experiences.

33. **3D Printing Platforms:** Websites like Thingiverse, Shapeways with AI customization.

34. **Meme Platforms:** Websites like Memedroid, 9GAG where Swarms can suggest memes.

35. **Astronomy Apps:** Platforms like Star Walk, NASA's Eyes with AI-driven space insights.

36. **Weather Apps:** Integration into Weather.com, AccuWeather for predictive analysis.

37. **Sustainability Platforms:** Websites like Ecosia, GoodGuide with AI-driven eco-tips.

38. **Fashion Apps:** Platforms like ASOS, Zara with AI-based style recommendations.

39. **Pet Care Apps:** Integration into PetSmart, Chewy for AI-driven pet care tips.

40. **Real Estate Platforms:** Websites like Zillow, Realtor with AI-enhanced property insights.

41. **DIY Platforms:** Websites like Instructables, DIY.org with AI project suggestions.

42. **Genealogy Platforms:** Ancestry, MyHeritage with AI-driven family tree insights.

43. **Car Rental & Sale Platforms:** Integration into AutoTrader, Turo for AI-driven vehicle suggestions.

44. **Wedding Planning Websites:** Platforms like Zola, The Knot with AI-driven planning.

45. **Craft Platforms:** Websites like Etsy, Craftsy with AI-driven craft suggestions.

46. **Gift Recommendation Platforms:** AI-driven gift suggestions for websites like Gifts.com.

47. **Study & Revision Platforms:** Websites like Chegg, Quizlet with AI-driven study guides.

48. **Local Business Directories:** Yelp, Yellow Pages with AI-enhanced reviews.

49. **Networking Platforms:** LinkedIn, Meetup with AI-driven connection suggestions.

50. **Lifestyle Magazines' Digital Platforms:** Websites like Vogue, GQ with AI-curated fashion and lifestyle insights.

---

*Endnote: Leveraging these diverse platforms ensures that Swarms becomes an integral part of multiple ecosystems, enhancing its visibility and user engagement.*

--------------------------------------------------

# File: corporate/failures.md

# Failure Root Cause Analysis for Langchain

## 1. Introduction

Langchain is an open-source software that has gained massive popularity in the artificial intelligence ecosystem, serving as a tool for connecting different language models, especially GPT based models. However, despite its popularity and substantial investment, Langchain has shown several weaknesses that hinder its use in various projects, especially in complex and large-scale implementations. This document provides an analysis of the identified issues and proposes potential mitigation strategies.

## 2. Analysis of Weaknesses

### 2.1 Tool Lock-in

Langchain tends to enforce tool lock-in, which could prove detrimental for developers. Its design heavily relies on specific workflows and architectures, which greatly limits flexibility. Developers may find themselves restricted to certain methodologies, impeding their freedom to implement custom solutions or integrate alternative tools.

#### Mitigation

An ideal AI framework should not be restrictive but should instead offer flexibility for users to integrate any agent on any architecture. Adopting an open architecture that allows for seamless interaction between various agents and workflows can address this issue.

### 2.2 Outdated Workflows

Langchain's current workflows and prompt engineering, mainly based on InstructGPT, are out of date, especially compared to newer models like ChatGPT/GPT-4.

#### Mitigation

Keeping up with the latest AI models and workflows is crucial. The framework should have a mechanism for regular updates and seamless integration of up-to-date models and workflows.

### 2.3 Debugging Difficulties

Debugging in Langchain is reportedly very challenging, even with verbose output enabled, making it hard to determine what is happening under the hood.

#### Mitigation

The introduction of a robust debugging and logging system would help users understand the internals of the models, thus enabling them to pinpoint and rectify issues more effectively.

### 2.4 Limited Customization

Langchain makes it extremely hard to deviate from documented workflows. This becomes a challenge when developers need custom workflows for their specific use-cases.

#### Mitigation

An ideal framework should support custom workflows and allow developers to hack and adjust the framework according to their needs.

### 2.5 Documentation

Langchain's documentation is reportedly missing relevant details, making it difficult for users to understand the differences between various agent types, among other things.

#### Mitigation

Providing detailed and comprehensive documentation, including examples, FAQs, and best practices, is crucial. This will help users understand the intricacies of the framework, making it easier for them to implement it in their projects.

### 2.6 Negative Influence on AI Ecosystem

The extreme popularity of Langchain seems to be warping the AI ecosystem to the point of causing harm, with other AI entities shifting their operations to align with Langchain's 'magic AI' approach.

#### Mitigation

It's essential for any widely adopted framework to promote healthy practices in the broader ecosystem. One approach could be promoting open dialogue, inviting criticism, and being open to change based on feedback.

## 3. Conclusion

While Langchain has made significant contributions to the AI landscape, these challenges hinder its potential. Addressing these issues will not only improve Langchain but also foster a healthier AI ecosystem. It's important to note that criticism, when approached constructively, can be a powerful tool for growth and innovation.


# List of weaknesses in gLangchain and Potential Mitigations

1. **Tool Lock-in**: Langchain encourages the use of specific tools, creating a lock-in problem with minimal benefits for developers. 

   *Mitigation Strategy*: Langchain should consider designing the architecture to be more versatile and allow for the inclusion of a variety of tools. An open architecture will provide developers with more freedom and customization options.

2. **Outdated Workflow**: The current workflow and prompt engineering of Langchain rely on outdated models like InstructGPT, which fall short compared to newer alternatives such as ChatGPT/GPT-4.

   *Mitigation Strategy*: Regular updates and adaptation of more recent models should be integrated into the Langchain framework.

3. **Debugging Difficulty**: Debugging a Langchain error is a complicated task, even with verbose=True, leading to a discouraging developer experience.

   *Mitigation Strategy*: Develop a comprehensive debugging tool or improve current debugging processes for clearer and more accessible error detection and resolution.

4. **Lack of Customizability**: Customizing workflows that are not documented in Langchain is quite challenging.

   *Mitigation Strategy*: Improve documentation and provide guides on how to customize workflows to enhance developer flexibility.

5. **Poor Documentation**: Langchain's documentation misses key details that developers have to manually search for in the codebase.

   *Mitigation Strategy*: Enhance and improve the documentation of Langchain to provide clarity for developers and make navigation easier.

6. **Harmful Ecosystem Influence**: Langchain's extreme popularity is influencing the AI ecosystem towards the workflows, potentially harming development and code clarity.

   *Mitigation Strategy*: Encourage diverse and balanced adoption of AI tools in the ecosystem.

7. **Suboptimal Performances**: Langchain's performance is sometimes underwhelming, and there are no clear benefits in terms of performance or abstraction.

   *Mitigation Strategy*: Enhance the performance optimization of Langchain. Benchmarking against other tools can also provide performance improvement insights.

8. **Rigid General Interface**: Langchain tries to do too many things, resulting in a rigid interface not suitable for practical use, especially in production.

   *Mitigation Strategy*: Focus on core features and allow greater flexibility in the interface. Adopting a modular approach where developers can pick and choose the features they want could also be helpful.

9. **Leaky Abstraction Problem**: Langchain’s full-on framework approach has created a leaky abstraction problem leading to a disappointing developer experience.

   *Mitigation Strategy*: Adopt a more balanced approach between a library and a framework. Provide a solid core feature set with the possibility to extend it according to the developers' needs. 

10. **Excessive Focus on Third-party Services**: Langchain overly focuses on supporting every single third-party service at the expense of customizability and fine-tuning for actual applications.

   *Mitigation Strategy*: Prioritize fine-tuning and customizability for developers, limiting the focus on third-party services unless they provide substantial value.
   
Remember, any mitigation strategy will need to be tailored to Langchain's particular circumstances and developer feedback. It's also important to consider potential trade-offs and unintended consequences when implementing these strategies.

--------------------------------------------------

# File: corporate/faq.md

### FAQ on Swarm Intelligence and Multi-Agent Systems

#### What is an agent in the context of AI and swarm intelligence?

In artificial intelligence (AI), an agent refers to an LLM with some objective to accomplish.

In swarm intelligence, each agent interacts with other agents and possibly the environment to achieve complex collective behaviors or solve problems more efficiently than individual agents could on their own.


#### What do you need Swarms at all?
Individual agents are limited by a vast array of issues such as context window loss, single task execution, hallucination, and no collaboration.


#### How does a swarm work?

A swarm works through the principles of decentralized control, local interactions, and simple rules followed by each agent. Unlike centralized systems, where a single entity dictates the behavior of all components, in a swarm, each agent makes its own decisions based on local information and interactions with nearby agents. These local interactions lead to the emergence of complex, organized behaviors or solutions at the collective level, enabling the swarm to tackle tasks efficiently.

#### Why do you need more agents in a swarm?

More agents in a swarm can enhance its problem-solving capabilities, resilience, and efficiency. With more agents:

- **Diversity and Specialization**: The swarm can leverage a wider range of skills, knowledge, and perspectives, allowing for more creative and effective solutions to complex problems.
- **Scalability**: Adding more agents can increase the swarm's capacity to handle larger tasks or multiple tasks simultaneously.
- **Robustness**: A larger number of agents enhances the system's redundancy and fault tolerance, as the failure of a few agents has a minimal impact on the overall performance of the swarm.

#### Isn't it more expensive to use more agents?

While deploying more agents can initially increase costs, especially in terms of computational resources, hosting, and potentially API usage, there are several factors and strategies that can mitigate these expenses:

- **Efficiency at Scale**: Larger swarms can often solve problems more quickly or effectively, reducing the overall computational time and resources required.
- **Optimization and Caching**: Implementing optimizations and caching strategies can reduce redundant computations, lowering the workload on individual agents and the overall system.
- **Dynamic Scaling**: Utilizing cloud services that offer dynamic scaling can ensure you only pay for the resources you need when you need them, optimizing cost-efficiency.

#### Can swarms make decisions better than individual agents?

Yes, swarms can make better decisions than individual agents for several reasons:

- **Collective Intelligence**: Swarms combine the knowledge and insights of multiple agents, leading to more informed and well-rounded decision-making processes.
- **Error Correction**: The collaborative nature of swarms allows for error checking and correction among agents, reducing the likelihood of mistakes.
- **Adaptability**: Swarms are highly adaptable to changing environments or requirements, as the collective can quickly reorganize or shift strategies based on new information.

#### How do agents in a swarm communicate?

Communication in a swarm can vary based on the design and purpose of the system but generally involves either direct or indirect interactions:

- **Direct Communication**: Agents exchange information directly through messaging, signals, or other communication protocols designed for the system.
- **Indirect Communication**: Agents influence each other through the environment, a method known as stigmergy. Actions by one agent alter the environment, which in turn influences the behavior of other agents.

#### Are swarms only useful in computational tasks?

While swarms are often associated with computational tasks, their applications extend far beyond. Swarms can be utilized in:

- **Robotics**: Coordinating multiple robots for tasks like search and rescue, exploration, or surveillance.
- **Environmental Monitoring**: Using sensor networks to monitor pollution, wildlife, or climate conditions.
- **Social Sciences**: Modeling social behaviors or economic systems to understand complex societal dynamics.
- **Healthcare**: Coordinating care strategies in hospital settings or managing pandemic responses through distributed data analysis.

#### How do you ensure the security of a swarm system?

Security in swarm systems involves:

- **Encryption**: Ensuring all communications between agents are encrypted to prevent unauthorized access or manipulation.
- **Authentication**: Implementing strict authentication mechanisms to verify the identity of each agent in the swarm.
- **Resilience to Attacks**: Designing the swarm to continue functioning effectively even if some agents are compromised or attacked, utilizing redundancy and fault tolerance strategies.

#### How do individual agents within a swarm share insights without direct learning mechanisms like reinforcement learning?

In the context of pre-trained Large Language Models (LLMs) that operate within a swarm, sharing insights typically involves explicit communication and data exchange protocols rather than direct learning mechanisms like reinforcement learning. Here's how it can work:

- **Shared Databases and Knowledge Bases**: Agents can write to and read from a shared database or knowledge base where insights, generated content, and relevant data are stored. This allows agents to benefit from the collective experience of the swarm by accessing information that other agents have contributed.
  
- **APIs for Information Exchange**: Custom APIs can facilitate the exchange of information between agents. Through these APIs, agents can request specific information or insights from others within the swarm, effectively sharing knowledge without direct learning.

#### How do you balance the autonomy of individual LLMs with the need for coherent collective behavior in a swarm?

Balancing autonomy with collective coherence in a swarm of LLMs involves:

- **Central Coordination Mechanism**: Implementing a lightweight central coordination mechanism that can assign tasks, distribute information, and collect outputs from individual LLMs. This ensures that while each LLM operates autonomously, their actions are aligned with the swarm's overall objectives.

- **Standardized Communication Protocols**: Developing standardized protocols for how LLMs communicate and share information ensures that even though each agent works autonomously, the information exchange remains coherent and aligned with the collective goals.

#### How do LLM swarms adapt to changing environments or tasks without machine learning techniques?

Adaptation in LLM swarms, without relying on machine learning techniques for dynamic learning, can be achieved through:

- **Dynamic Task Allocation**: A central system or distributed algorithm can dynamically allocate tasks to different LLMs based on the changing environment or requirements. This ensures that the most suitable LLMs are addressing tasks for which they are best suited as conditions change.

- **Pre-trained Versatility**: Utilizing a diverse set of pre-trained LLMs with different specialties or training data allows the swarm to select the most appropriate agent for a task as the requirements evolve.

- **In Context Learning**: In context learning is another mechanism that can be employed within LLM swarms to adapt to changing environments or tasks. This approach involves leveraging the collective knowledge and experiences of the swarm to facilitate learning and improve performance. Here's how it can work:


#### Can LLM swarms operate in physical environments, or are they limited to digital spaces?

LLM swarms primarily operate in digital spaces, given their nature as software entities. However, they can interact with physical environments indirectly through interfaces with sensors, actuaries, or other devices connected to the Internet of Things (IoT). For example, LLMs can process data from physical sensors and control devices based on their outputs, enabling applications like smart home management or autonomous vehicle navigation.

#### Without direct learning from each other, how do agents in a swarm improve over time?

Improvement over time in a swarm of pre-trained LLMs, without direct learning from each other, can be achieved through:

- **Human Feedback**: Incorporating feedback from human operators or users can guide adjustments to the usage patterns or selection criteria of LLMs within the swarm, optimizing performance based on observed outcomes.

- **Periodic Re-training and Updating**: The individual LLMs can be periodically re-trained or updated by their developers based on collective insights and feedback from their deployment within swarms. While this does not involve direct learning from each encounter, it allows the LLMs to improve over time based on aggregated experiences.

These adjustments to the FAQ reflect the specific context of pre-trained LLMs operating within a swarm, focusing on communication, coordination, and adaptation mechanisms that align with their capabilities and constraints.


#### Conclusion

Swarms represent a powerful paradigm in AI, offering innovative solutions to complex, dynamic problems through collective intelligence and decentralized control. While challenges exist, particularly regarding cost and security, strategic design and management can leverage the strengths of swarm intelligence to achieve remarkable efficiency, adaptability, and robustness in a wide range of applications.

--------------------------------------------------

# File: corporate/flywheel.md

# The Swarms Flywheel

1. **Building a Supportive Community:** Initiate by establishing an engaging and inclusive open-source community for both developers and sales freelancers around Swarms. Regular online meetups, webinars, tutorials, and sales training can make them feel welcome and encourage contributions and sales efforts.

2. **Increased Contributions and Sales Efforts:** The more engaged the community, the more developers will contribute to Swarms and the more effort sales freelancers will put into selling Swarms.

3. **Improvement in Quality and Market Reach:** More developer contributions mean better quality, reliability, and feature offerings from Swarms. Simultaneously, increased sales efforts from freelancers boost Swarms' market penetration and visibility.

4. **Rise in User Base:** As Swarms becomes more robust and more well-known, the user base grows, driving more revenue.

5. **Greater Financial Incentives:** Increased revenue can be redirected to offer more significant financial incentives to both developers and salespeople. Developers can be incentivized based on their contribution to Swarms, and salespeople can be rewarded with higher commissions.

6. **Attract More Developers and Salespeople:** These financial incentives, coupled with the recognition and experience from participating in a successful project, attract more developers and salespeople to the community.

7. **Wider Adoption of Swarms:** An ever-improving product, a growing user base, and an increasing number of passionate salespeople accelerate the adoption of Swarms.

8. **Return to Step 1:** As the community, user base, and sales network continue to grow, the cycle repeats, each time speeding up the flywheel.


```markdown
               +---------------------+
               |   Building a       |
               |  Supportive        | <--+
               |   Community        |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               |   Increased        |    |
               | Contributions &    |    |
               |   Sales Efforts    |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               |   Improvement in   |    |
               | Quality & Market   |    |
               |       Reach        |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               |   Rise in User     |    |
               |        Base        |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               |  Greater Financial |    |
               |     Incentives     |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               | Attract More        |    |
               | Developers &       |    |
               | Salespeople         |    |
               +--------+-----------+    |
                        |                |
                        v                |
               +--------+-----------+    |
               |  Wider Adoption of  |    |
               |       Swarms        |----+
               +---------------------+
```


# Potential Risks and Mitigations:

1. **Insufficient Contributions or Quality of Work**: Open-source efforts rely on individuals being willing and able to spend time contributing. If not enough people participate, or the work they produce is of poor quality, the product development could stall. 
   * **Mitigation**: Create a robust community with clear guidelines, support, and resources. Provide incentives for quality contributions, such as a reputation system, swag, or financial rewards. Conduct thorough code reviews to ensure the quality of contributions.

2. **Lack of Sales Results**: Commission-based salespeople will only continue to sell the product if they're successful. If they aren't making enough sales, they may lose motivation and cease their efforts.
   * **Mitigation**: Provide adequate sales training and resources. Ensure the product-market fit is strong, and adjust messaging or sales tactics as necessary. Consider implementing a minimum commission or base pay to reduce risk for salespeople.

3. **Poor User Experience or User Adoption**: If users don't find the product useful or easy to use, they won't adopt it, and the user base won't grow. This could also discourage salespeople and contributors.
   * **Mitigation**: Prioritize user experience in the product development process. Regularly gather and incorporate user feedback. Ensure robust user support is in place.

4. **Inadequate Financial Incentives**: If the financial rewards don't justify the time and effort contributors and salespeople are putting in, they will likely disengage.
   * **Mitigation**: Regularly review and adjust financial incentives as needed. Ensure that the method for calculating and distributing rewards is transparent and fair.

5. **Security and Compliance Risks**: As the user base grows and the software becomes more complex, the risk of security issues increases. Moreover, as contributors from various regions join, compliance with various international laws could become an issue.
   * **Mitigation**: Establish strong security practices from the start. Regularly conduct security audits. Seek legal counsel to understand and adhere to international laws and regulations.

## Activation Plan for the Flywheel:

1. **Community Building**: Begin by fostering a supportive community around Swarms. Encourage early adopters to contribute and provide feedback. Create comprehensive documentation, community guidelines, and a forum for discussion and support.

2. **Sales and Development Training**: Provide resources and training for salespeople and developers. Make sure they understand the product, its value, and how to effectively contribute or sell.

3. **Increase Contributions and Sales Efforts**: Encourage increased participation by highlighting successful contributions and sales, rewarding top contributors and salespeople, and regularly communicating about the project's progress and impact.

4. **Iterate and Improve**: Continually gather and implement feedback to improve Swarms and its market reach. The better the product and its alignment with the market, the more the user base will grow.

5. **Expand User Base**: As the product improves and sales efforts continue, the user base should grow. Ensure you have the infrastructure to support this growth and maintain a positive user experience.

6. **Increase Financial Incentives**: As the user base and product grow, so too should the financial incentives. Make sure rewards continue to be competitive and attractive.

7. **Attract More Contributors and Salespeople**: As the financial incentives and success of the product increase, this should attract more contributors and salespeople, further feeding the flywheel.

Throughout this process, it's important to regularly reassess and adjust your strategy as necessary. Stay flexible and responsive to changes in the market, user feedback, and the evolving needs of the community.

--------------------------------------------------

# File: corporate/front_end_contributors.md

# Frontend Contributor Guide

## Mission
At the heart of Swarms is the mission to democratize multi-agent technology, making it accessible to businesses of all sizes around the globe. This technology, which allows for the orchestration of multiple autonomous agents to achieve complex goals, has the potential to revolutionize industries by enhancing efficiency, scalability, and innovation. Swarms is committed to leading this charge by developing a platform that empowers businesses and individuals to harness the power of multi-agent systems without the need for specialized knowledge or resources.


## Understanding Your Impact as a Frontend Engineer 
Crafting User Experiences: As a frontend engineer at Swarms, you play a crucial role in making multi-agent technology understandable and usable for businesses worldwide. Your work involves translating complex systems into intuitive interfaces, ensuring users can easily navigate, manage, and benefit from multi-agent solutions. By focusing on user-centric design and seamless integration, you help bridge the gap between advanced technology and practical business applications.

Skills and Attributes for Success: Successful frontend engineers at Swarms combine technical expertise with a passion for innovation and a deep understanding of user needs. Proficiency in modern frontend technologies, such as React, NextJS, and Tailwind, is just the beginning. You also need a strong grasp of usability principles, accessibility standards, and the ability to work collaboratively with cross-functional teams. Creativity, problem-solving skills, and a commitment to continuous learning are essential for developing solutions that meet diverse business needs.


## Joining the Team
As you contribute to Swarms, you become part of a collaborative effort to change the world. We value each contribution and provide constructive feedback to help you grow. Outstanding contributors who share our vision and demonstrate exceptional skill and dedication are invited to join our team, where they can have an even greater impact on our mission.


### Becoming a Full-Time Swarms Engineer:
Swarms is radically devoted to open source and transparency. To join the full time team, you must first contribute to the open source repository so we can assess your technical capability and general way of working. After a series of quality contributions, we'll offer you a full time position!

Joining Swarms full-time means more than just a job. It's an opportunity to be at the forefront of technological innovation, working alongside passionate professionals dedicated to making a difference. We look for individuals who are not only skilled but also driven by the desire to make multi-agent technology accessible and beneficial to businesses worldwide.


## Resources
- **Project Management Details**
  - **Linear**: Our projects and tasks at a glance. Get a sense of our workflow and priorities.
    - [View on Linear](https://linear.app/swarms/join/e7f4c6c560ffa0e1395820682f4e110a?s=1)  

- **Design System and UI/UX Guidelines**
  - **Figma**: Dive into our design system to grasp the aesthetics and user experience objectives of Swarms.
    - [View on Figma](https://www.figma.com/file/KL4VIXfZKwwLgAes2WbGNa/Swarms-Cloud-Platform?type=design&node-id=0%3A1&mode=design&t=MkrM0mBQa6qsTDtJ-1)

- **Swarms Platform Repository**
  - **GitHub**: The hub of our development activities. Familiarize yourself with our codebase and current projects.
    - [Visit GitHub Repository](https://github.com/kyegomez/swarms-platform)

- **[Swarms Community](https://discord.gg/pSTSxqDk)**


### Design Style & User Experience
- [How to build great products with game design, not gamification](https://blog.superhuman.com/game-design-not-gamification/)

--------------------------------------------------

# File: corporate/hiring.md

# Careers at Swarms

We are a team of engineers, developers, and visionaries on a mission to build the future of AI by orchestrating multi-agent collaboration. We move fast, think ambitiously, and deliver with urgency. Join us if you want to be part of building the next generation of multi-agent systems, redefining how businesses automate operations and leverage AI.

**We offer none of the following benefits Yet:**

- No medical, dental, or vision insurance

- No paid time off

- No life or AD&D insurance

- No short-term or long-term disability insurance

- No 401(k) plan

**Working hours:** 9 AM to 10 PM, every day, 7 days a week. This is not for people who seek work-life balance.

---

### Hiring Process: How to Join Swarms
We have a simple 3-step hiring process:

**NOTE** We do not consider applicants who have not previously submitted a PR, to be considered a PR containing a new feature of a bug fixed must be submitted.

1. **Submit a pull request (PR)**: Start by submitting an approved PR to the [Swarms GitHub repository](https://github.com/kyegomez/swarms) or the appropriate repository .
2. **Code review**: Our technical team will review your PR. If it meets our standards, you will be invited for a quick interview.
3. **Final interview**: Discuss your contributions and approach with our team. If you pass, you're in!

There are no recruiters. All evaluations are done by our technical team.

--- 

# Location

- **Palo Alto** CA Our Palo Alto office houses the majority of our core research teams including our prompting, agent design, and model training

- **Miami** Our miami office holds prompt engineering, agent design, and more.


### Open Roles at Swarms

**Infrastructure Engineer**

- Build and maintain the systems that run our AI multi-agent infrastructure.

- Expertise in Skypilot, AWS, Terraform.

- Ensure seamless, high-availability environments for agent operations.

**Agent Engineer**

- Design, develop, and orchestrate complex swarms of AI agents.

- Extensive experience with Python, multi-agent systems, and neural networks.

- Ability to create dynamic and efficient agent architectures from scratch.

**Prompt Engineer**

- Craft highly optimized prompts that drive our LLM-based agents.

- Specialize in instruction-based prompts, multi-shot examples, and production-grade deployment.

- Collaborate with agents to deliver state-of-the-art solutions.

**Front-End Engineer**

- Build sleek, intuitive interfaces for interacting with swarms of agents.

- Proficiency in Next.js, FastAPI, and modern front-end technologies.

- Design with the user experience in mind, integrating complex AI features into simple workflows.


--------------------------------------------------

# File: corporate/metric.md

# The Golden Metric: 95% User-Task-Completion-Satisfaction Rate

In the world of Swarms, there’s one metric that stands above the rest: the User-Task-Completion-Satisfaction (UTCS) rate. This metric is the heart of our system, the pulse that keeps us moving forward. It’s not just a number; it’s a reflection of our commitment to our users and a measure of our success.

## What is the UTCS Rate?
The UTCS rate is a measure of how reliably and quickly Swarms can satisfy a user demand. It’s calculated by dividing the number of tasks completed to the user’s satisfaction by the total number of tasks. Multiply that by 100, and you’ve got your UTCS rate.

But what does it mean to complete a task to the user’s satisfaction? It means that the task is not only completed, but completed in a way that meets or exceeds the user’s expectations. It’s about quality, speed, and reliability.

## Why is the UTCS Rate Important?
The UTCS rate is a direct reflection of the user experience. A high UTCS rate means that users are getting what they need from Swarms, and they’re getting it quickly and reliably. It means that Swarms is doing its job, and doing it well.

But the UTCS rate is not just about user satisfaction. It’s also a measure of Swarms’ efficiency and effectiveness. A high UTCS rate means that Swarms is able to complete tasks quickly and accurately, with minimal errors or delays. It’s a sign of a well-oiled machine.

## How Do We Achieve a 95% UTCS Rate?
Achieving a 95% UTCS rate is no small feat. It requires a deep understanding of our users and their needs, a robust and reliable system, and a commitment to continuous improvement.

### Here are some strategies we’re implementing to reach our goal:

* Understanding User Needs: We must have agents that gain an understanding of the user's objective and break it up into it's most fundamental building blocks

* Improving System Reliability: We’re working to make Swarms more reliable, reducing errors and improving the accuracy of task completion. This includes improving our algorithms, refining our processes, and investing in quality assurance.

* Optimizing for Speed: We’re optimizing Swarms to complete tasks as quickly as possible, without sacrificing quality. This includes improving our infrastructure, streamlining our workflows, and implementing performance optimizations.

*Iterating and Improving: We’re committed to continuous improvement. We’re constantly monitoring our UTCS rate and other key metrics, and we’re always looking for ways to improve. We’re not afraid to experiment, iterate, and learn from our mistakes.

Achieving a 95% UTCS rate is a challenging goal, but it’s a goal worth striving for. It’s a goal that will drive us to improve, innovate, and deliver the best possible experience for our users. And in the end, that’s what Swarms is all about.



# Your Feedback Matters: Help Us Optimize the UTCS Rate

As we initiate the journey of Swarms, we seek your feedback to better guide our growth and development. Your opinions and suggestions are crucial for us, helping to mold our product, pricing, branding, and a host of other facets that influence your experience.

## Your Insights on the UTCS Rate
Our goal is to maintain a UTCS (User-Task-Completion-Satisfaction) rate of 95%. This metric is integral to the success of Swarms, indicating the efficiency and effectiveness with which we satisfy user requests. However, it's a metric that we can't optimize alone - we need your help.

Here's what we want to understand from you:

1. **Satisfaction:** What does a "satisfactorily completed task" mean to you? Are there specific elements that contribute to a task being carried out to your satisfaction? 
2. **Timeliness:** How important is speed in the completion of a task? What would you consider a reasonable timeframe for a task to be completed?
3. **Usability:** How intuitive and user-friendly do you find the Swarms platform? Are there any aspects of the platform that you believe could be enhanced?
4. **Reliability:** How much does consistency in performance matter to you? Can you share any experiences where Swarms either met or fell short of your expectations?
5. **Value for Money:** How do you perceive our pricing? Does the value Swarms provides align with the costs?

We invite you to share your experiences, thoughts, and ideas. Whether it's a simple suggestion or an in-depth critique, we appreciate and value your input.

## Your Feedback: The Backbone of our Growth
Your feedback is the backbone of Swarms' evolution. It drives us to refine our strategies, fuels our innovative spirit, and, most importantly, enables us to serve you better.

As we launch, we open the conversation around these key aspects of Swarms, and we look forward to understanding your expectations, your needs, and how we can deliver the best experience for you.

So, let's start this conversation - how can we make Swarms work best for you?


Guide Our Growth: Help Optimize Swarms
As we launch Swarms, your feedback is critical for enhancing our product, pricing, and branding. A key aim for us is a User-Task-Completion-Satisfaction (UTCS) rate of 95% - indicating our efficiency and effectiveness in meeting user needs. However, we need your insights to optimize this.

Here's what we're keen to understand:

Satisfaction: Your interpretation of a "satisfactorily completed task".
Timeliness: The importance of speed in task completion for you.
Usability: Your experiences with our platform’s intuitiveness and user-friendliness.
Reliability: The significance of consistent performance to you.
Value for Money: Your thoughts on our pricing and value proposition.
We welcome your thoughts, experiences, and suggestions. Your feedback fuels our evolution, driving us to refine strategies, boost innovation, and enhance your experience.

Let's start the conversation - how can we make Swarms work best for you?


--------

**The Golden Metric Analysis: The Ultimate UTCS Paradigm for Swarms**

### Introduction

In our ongoing journey to perfect Swarms, understanding how our product fares in the eyes of the end-users is paramount. Enter the User-Task-Completion-Satisfaction (UTCS) rate - our primary metric that gauges how reliably and swiftly Swarms can meet user demands. As we steer Swarms towards achieving a UTCS rate of 95%, understanding this metric's core and how to refine it becomes vital.

### Decoding UTCS: An Analytical Overview

The UTCS rate is not merely about task completion; it's about the comprehensive experience. Therefore, its foundations lie in:

1. **Quality**: Ensuring tasks are executed flawlessly.
2. **Speed**: Delivering results in the shortest possible time.
3. **Reliability**: Consistency in quality and speed across all tasks.

We can represent the UTCS rate with the following equation:

```latex
\[ UTCS Rate = \frac{(Completed Tasks \times User Satisfaction)}{(Total Tasks)} \times 100 \]
```

Where:
- Completed Tasks refer to the number of tasks Swarms executes without errors.
- User Satisfaction is the subjective component, gauged through feedback mechanisms. This could be on a scale of 1-10 (or a percentage).
- Total Tasks refer to all tasks processed by Swarms, regardless of the outcome.

### The Golden Metric: Swarm Efficiency Index (SEI)

However, this basic representation doesn't factor in a critical component: system performance. Thus, we introduce the Swarm Efficiency Index (SEI). The SEI encapsulates not just the UTCS rate but also system metrics like memory consumption, number of tasks, and time taken. By blending these elements, we aim to present a comprehensive view of Swarm's prowess.

Here’s the formula:

```latex
\[ SEI = \frac{UTCS Rate}{(Memory Consumption + Time Window + Task Complexity)} \]
```

Where:
- Memory Consumption signifies the system resources used to accomplish tasks.
- Time Window is the timeframe in which the tasks were executed.
- Task Complexity could be a normalized scale that defines how intricate a task is (e.g., 1-5, with 5 being the most complex).

Rationale:
- **Incorporating Memory Consumption**: A system that uses less memory but delivers results is more efficient. By inverting memory consumption in the formula, we emphasize that as memory usage goes down, SEI goes up.
  
- **Considering Time**: Time is of the essence. The faster the results without compromising quality, the better. By adding the Time Window, we emphasize that reduced task execution time increases the SEI.
  
- **Factoring in Task Complexity**: Not all tasks are equal. A system that effortlessly completes intricate tasks is more valuable. By integrating task complexity, we can normalize the SEI according to the task's nature.

### Implementing SEI & Improving UTCS

Using feedback from elder-plinius, we can better understand and improve SEI and UTCS:

1. **Feedback Across Skill Levels**: By gathering feedback from users with different skill levels, we can refine our metrics, ensuring Swarms caters to all.

2. **Simplifying Setup**: Detailed guides can help newcomers swiftly get on board, thus enhancing user satisfaction.

3. **Enhancing Workspace and Agent Management**: A clearer view of the Swarm's internal structure, combined with on-the-go adjustments, can improve both the speed and quality of results.

4. **Introducing System Suggestions**: A proactive Swarms that provides real-time insights and recommendations can drastically enhance user satisfaction, thus pushing up the UTCS rate.

### Conclusion

The UTCS rate is undeniably a pivotal metric for Swarms. However, with the introduction of the Swarm Efficiency Index (SEI), we have an opportunity to encapsulate a broader spectrum of performance indicators, leading to a more holistic understanding of Swarms' efficiency. By consistently optimizing for SEI, we can ensure that Swarms not only meets user expectations but also operates at peak system efficiency.


----------------
**Research Analysis: Tracking and Ensuring Reliability of Swarm Metrics at Scale**

### 1. Introduction

In our pursuit to optimize the User-Task-Completion-Satisfaction (UTCS) rate and Swarm Efficiency Index (SEI), reliable tracking of these metrics at scale becomes paramount. This research analysis delves into methodologies, technologies, and practices that can be employed to monitor these metrics accurately and efficiently across vast data sets.

### 2. Why Tracking at Scale is Challenging

The primary challenges include:

- **Volume of Data**: As Swarms grows, the data generated multiplies exponentially.
- **Variability of Data**: Diverse user inputs lead to myriad output scenarios.
- **System Heterogeneity**: Different configurations and deployments can yield variable results.

### 3. Strategies for Scalable Tracking

#### 3.1. Distributed Monitoring Systems

**Recommendation**: Implement distributed systems like Prometheus or InfluxDB.

**Rationale**: 
- Ability to collect metrics from various Swarm instances concurrently.
- Scalable and can handle vast data influxes.
  
#### 3.2. Real-time Data Processing

**Recommendation**: Use stream processing systems like Apache Kafka or Apache Flink.

**Rationale**: 
- Enables real-time metric calculation.
- Can handle high throughput and low-latency requirements.

#### 3.3. Data Sampling

**Recommendation**: Random or stratified sampling of user sessions.

**Rationale**: 
- Reduces the data volume to be processed.
- Maintains representativeness of overall user experience.

### 4. Ensuring Reliability in Data Collection

#### 4.1. Redundancy

**Recommendation**: Integrate redundancy into data collection nodes.

**Rationale**:
- Ensures no single point of failure.
- Data loss prevention in case of system malfunctions.

#### 4.2. Anomaly Detection

**Recommendation**: Implement AI-driven anomaly detection systems.

**Rationale**: 
- Identifies outliers or aberrations in metric calculations.
- Ensures consistent and reliable data interpretation.

#### 4.3. Data Validation

**Recommendation**: Establish automated validation checks.

**Rationale**:
- Ensures only accurate and relevant data is considered.
- Eliminates inconsistencies arising from corrupted or irrelevant data.

### 5. Feedback Loops and Continuous Refinement

#### 5.1. User Feedback Integration

**Recommendation**: Develop an in-built user feedback mechanism.

**Rationale**: 
- Helps validate the perceived vs. actual performance.
- Allows for continuous refining of tracking metrics and methodologies.

#### 5.2. A/B Testing

**Recommendation**: Regularly conduct A/B tests for new tracking methods or adjustments.

**Rationale**: 
- Determines the most effective methods for data collection.
- Validates new tracking techniques against established ones.

### 6. Conclusion

To successfully and reliably track the UTCS rate and SEI at scale, it's essential to combine robust monitoring tools, data processing methodologies, and validation techniques. By doing so, Swarms can ensure that the metrics collected offer a genuine reflection of system performance and user satisfaction. Regular feedback and iterative refinement, rooted in a culture of continuous improvement, will further enhance the accuracy and reliability of these essential metrics.

--------------------------------------------------

# File: corporate/purpose.md


## Purpose
Artificial Intelligence has grown at an exponential rate over the past decade. Yet, we are far from fully harnessing its potential. Today's AI operates in isolation, each working separately in their corner. But life doesn't work like that. The world doesn't work like that. Success isn't built in silos; it's built in teams.

Imagine a world where AI models work in unison. Where they can collaborate, interact, and pool their collective intelligence to achieve more than any single model could. This is the future we envision. But today, we lack a framework for AI to collaborate effectively, to form a true swarm of intelligent agents.


This is a difficult problem, one that has eluded solution. It requires sophisticated systems that can allow individual models to not just communicate but also understand each other, pool knowledge and resources, and create collective intelligence. This is the next frontier of AI.

But here at Swarms, we have a secret sauce. It's not just a technology or a breakthrough invention. It's a way of thinking - the philosophy of rapid iteration. With each cycle, we make massive progress. We experiment, we learn, and we grow. We have developed a pioneering framework that can enable AI models to work together as a swarm, combining their strengths to create richer, more powerful outputs.

We are uniquely positioned to take on this challenge with 1,500+ devoted researchers in Agora. We have assembled a team of world-class experts, experienced and driven, united by a shared vision. Our commitment to breaking barriers, pushing boundaries, and our belief in the power of collective intelligence makes us the best team to usher in this future to fundamentally advance our species, Humanity.

---

--------------------------------------------------

# File: corporate/research.md

# Research Lists 
A compilation of projects, papers, blogs in autonomous agents.

## Table of Contents

- [Introduction](#introduction)
- [Projects](#projects)
- [Articles](#articles)
- [Talks](#talks)


## Projects

### Developer tools
- [2023/8/10]  [ModelScope-Agent](https://github.com/modelscope/modelscope-agent) - An Agent Framework Connecting Models in ModelScope with the World
- [2023/05/25] [Gorilla](https://github.com/ShishirPatil/gorilla) - An API store for LLMs
- [2023/03/31] [BMTools](https://github.com/OpenBMB/BMTools) - Tool Learning for Big Models, Open-Source Solutions of ChatGPT-Plugins
- [2023/03/09] [LMQL](https://github.com/eth-sri/lmql) - A query language for programming (large) language models.
- [2022/10/25] [Langchain](https://github.com/hwchase17/langchain) - ⚡ Building applications with LLMs through composability ⚡

### Applications
- [2023/07/08] [ShortGPT](https://github.com/RayVentura/ShortGPT) - 🚀🎬 ShortGPT - An experimental AI framework for automated short/video content creation. Enables creators to rapidly produce, manage, and deliver content using AI and automation.
- [2023/07/05] [gpt-researcher](https://github.com/assafelovic/gpt-researcher) - GPT based autonomous agent that does online comprehensive research on any given topic
- [2023/07/04] [DemoGPT](https://github.com/melih-unsal/DemoGPT) - 🧩DemoGPT enables you to create quick demos by just using prompts. [[demo]](demogpt.io)
- [2023/06/30] [MetaGPT](https://github.com/geekan/MetaGPT) - 🌟 The Multi-Agent Framework: Given one line Requirement, return PRD, Design, Tasks, Repo
- [2023/06/11] [gpt-engineer](https://github.com/AntonOsika/gpt-engineer) - Specify what you want it to build, the AI asks for clarification, and then builds it.
- [2023/05/16] [SuperAGI](https://github.com/TransformerOptimus/SuperAGI) - <⚡️> SuperAGI - A dev-first open source autonomous AI agent framework. Enabling developers to build, manage & run useful autonomous agents quickly and reliably.
- [2023/05/13] [Developer](https://github.com/smol-ai/developer) - Human-centric & Coherent Whole Program Synthesis aka your own personal junior developer
- [2023/04/07] [AgentGPT](https://github.com/reworkd/AgentGPT) - 🤖 Assemble, configure, and deploy autonomous AI Agents in your browser. [[demo]](agentgpt.reworkd.ai)
- [2023/04/03] [BabyAGI](https://github.com/yoheinakajima/babyagi) - an example of an AI-powered task management system
- [2023/03/30] [AutoGPT](https://github.com/Significant-Gravitas/Auto-GPT) - An experimental open-source attempt to make GPT-4 fully autonomous.

### Benchmarks
- [2023/08/07] [AgentBench](https://github.com/THUDM/AgentBench) - A Comprehensive Benchmark to Evaluate LLMs as Agents. [paper](https://arxiv.org/abs/2308.03688)
- [2023/06/18] [Auto-GPT-Benchmarks](https://github.com/Significant-Gravitas/Auto-GPT-Benchmarks) - A repo built for the purpose of benchmarking the performance of agents, regardless of how they are set up and how they work.
- [2023/05/28] [ToolBench](https://github.com/OpenBMB/ToolBench) - An open platform for training, serving, and evaluating large language model for tool learning.

## Articles
### Research Papers
- [2023/08/11] [BOLAA: Benchmarking and Orchestrating LLM-Augmented Autonomous Agents](https://arxiv.org/pdf/2308.05960v1.pdf), Zhiwei Liu, et al.
- [2023/07/31] [ToolLLM: Facilitating Large Language Models to Master 16000+ Real-world APIs](https://arxiv.org/abs/2307.16789), Yujia Qin, et al.
- [2023/07/16] [Communicative Agents for Software Development](https://arxiv.org/abs/2307.07924), Chen Qian, et al.
- [2023/06/09] [Mind2Web: Towards a Generalist Agent for the Web](https://arxiv.org/pdf/2306.06070.pdf), Xiang Deng, et al. [[code]](https://github.com/OSU-NLP-Group/Mind2Web) [[demo]](https://osu-nlp-group.github.io/Mind2Web/)
- [2023/06/05] [Orca: Progressive Learning from Complex Explanation Traces of GPT-4](https://arxiv.org/pdf/2306.02707.pdf), Subhabrata Mukherjee et al.
- [2023/05/25] [Voyager: An Open-Ended Embodied Agent with Large Language Models](https://arxiv.org/pdf/2305.16291.pdf), Guanzhi Wang, et al. [[code]](https://github.com/MineDojo/Voyager) [[website]](https://voyager.minedojo.org/)
- [2023/05/23] [ReWOO: Decoupling Reasoning from Observations for Efficient Augmented Language Models](https://arxiv.org/pdf/2305.18323.pdf), Binfeng Xu, et al. [[code]](https://github.com/billxbf/ReWOO)
- [2023/05/17] [Tree of Thoughts: Deliberate Problem Solving with Large Language Models](https://arxiv.org/abs/2305.10601), Shunyu Yao, et al.[[code]](https://github.com/kyegomez/tree-of-thoughts) [[code-orig]](https://github.com/ysymyth/tree-of-thought-llm) 
- [2023/05/12] [MEGABYTE: Predicting Million-byte Sequences with Multiscale Transformers](https://arxiv.org/abs/2305.07185), Lili Yu, et al.
- [2023/05/19] [FrugalGPT: How to Use Large Language Models While Reducing Cost and Improving Performance](https://arxiv.org/abs/2305.05176), Lingjiao Chen, et al.
- [2023/05/06] [Plan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning by Large Language Models](https://arxiv.org/abs/2305.04091), Lei Wang, et al.
- [2023/05/01] [Learning to Reason and Memorize with Self-Notes](https://arxiv.org/abs/2305.00833), Jack Lanchantin, et al.
- [2023/04/24] [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244), Can Xu, et al.
- [2023/04/22] [LLM+P: Empowering Large Language Models with Optimal Planning Proficiency](https://arxiv.org/abs/2304.11477), Bo Liu, et al.
- [2023/04/07] [Generative Agents: Interactive Simulacra of Human Behavior](https://arxiv.org/abs/2304.03442), Joon Sung Park, et al. [[code]](https://github.com/mkturkcan/generative-agents)
- [2023/03/30] [Self-Refine: Iterative Refinement with Self-Feedback](https://arxiv.org/abs/2303.17651), Aman Madaan, et al.[[code]](https://github.com/madaan/self-refine)
- [2023/03/30] [HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace](https://arxiv.org/pdf/2303.17580.pdf), Yongliang Shen, et al. [[code]](https://github.com/microsoft/JARVIS) [[demo]](https://huggingface.co/spaces/microsoft/HuggingGPT)
- [2023/03/20] [Reflexion: Language Agents with Verbal Reinforcement Learning](https://arxiv.org/pdf/2303.11366.pdf), Noah Shinn, et al. [[code]](https://github.com/noahshinn024/reflexion)
- [2023/03/04] [Towards A Unified Agent with Foundation Models](https://openreview.net/pdf?id=JK_B1tB6p-), Norman Di Palo et al.
- [2023/02/23] [Not what you've signed up for: Compromising Real-World LLM-Integrated Applications with Indirect Prompt Injection](https://arxiv.org/abs/2302.12173), Sahar Abdelnab, et al.
- [2023/02/09] [Toolformer: Language Models Can Teach Themselves to Use Tools](https://arxiv.org/pdf/2302.04761.pdf), Timo Schick, et al. [[code]](https://github.com/lucidrains/toolformer-pytorch)
- [2022/12/12] [LMQL: Prompting Is Programming: A Query Language for Large Language Models](https://arxiv.org/abs/2212.06094), Luca Beurer-Kellner, et al.
- [2022/10/06] [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/pdf/2210.03629.pdf), Shunyu Yao, et al. [[code]](https://github.com/ysymyth/ReAct)
- [2022/07/20] [Inner Monologue: Embodied Reasoning through Planning with Language Models](https://arxiv.org/pdf/2207.05608.pdf), Wenlong Huang, et al. [[demo]](https://innermonologue.github.io/)
- [2022/04/04] [Do As I Can, Not As I Say: Grounding Language in Robotic Affordances](), Michael Ahn, e al. [[demo]](https://say-can.github.io/)
- [2021/12/17] [WebGPT: Browser-assisted question-answering with human feedback](https://arxiv.org/pdf/2112.09332.pdf), Reiichiro Nakano, et al.
- [2021/06/17] [LoRA: Low-Rank Adaptation of Large Language Models](https://arxiv.org/abs/2106.09685), Edward J. Hu, et al.


### Blog Articles

- [2023/08/14] [A Roadmap of AI Agents(Chinese)](https://zhuanlan.zhihu.com/p/649916692) By Haojie Pan
- [2023/06/23] [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) By Lilian Weng
- [2023/06/11] [A CRITICAL LOOK AT AI-GENERATED SOFTWARE](https://spectrum.ieee.org/ai-software) By JAIDEEP VAIDYAHAFIZ ASIF
- [2023/04/29] [AUTO-GPT: UNLEASHING THE POWER OF AUTONOMOUS AI AGENTS](https://www.leewayhertz.com/autogpt/) By Akash Takyar
- [2023/04/20] [Conscious Machines: Experiments, Theory, and Implementations(Chinese)](https://pattern.swarma.org/article/230) By Jiang Zhang
- [2023/04/18] [Autonomous Agents & Agent Simulations](https://blog.langchain.dev/agents-round/) By Langchain
- [2023/04/16] [4 Autonomous AI Agents you need to know](https://towardsdatascience.com/4-autonomous-ai-agents-you-need-to-know-d612a643fa92) By Sophia Yang
- [2023/03/31] [ChatGPT that learns to use tools(Chinese)](https://zhuanlan.zhihu.com/p/618448188) By Haojie Pan

### Talks
- [2023/06/05] [Two Paths to Intelligence](https://www.youtube.com/watch?v=rGgGOccMEiY&t=1497s) by Geoffrey Hinton
- [2023/05/24] [State of GPT](https://www.youtube.com/watch?v=bZQun8Y4L2A) by Andrej Karpathy | OpenAI 


--------------------------------------------------

# File: corporate/roadmap.md

## The Plan

### Phase 1: Building the Foundation
In the first phase, our focus is on building the basic infrastructure of Swarms. This includes developing key components like the Swarms class, integrating essential tools, and establishing task completion and evaluation logic. We'll also start developing our testing and evaluation framework during this phase. If you're interested in foundational work and have a knack for building robust, scalable systems, this phase is for you.

### Phase 2: Optimizing the System
In the second phase, we'll focus on optimizng Swarms by integrating more advanced features, improving the system's efficiency, and refining our testing and evaluation framework. This phase involves more complex tasks, so if you enjoy tackling challenging problems and contributing to the development of innovative features, this is the phase for you.

### Phase 3: Towards Super-Intelligence
The third phase of our bounty program is the most exciting - this is where we aim to achieve super-intelligence. In this phase, we'll be working on improving the swarm's capabilities, expanding its skills, and fine-tuning the system based on real-world testing and feedback. If you're excited about the future of AI and want to contribute to a project that could potentially transform the digital world, this is the phase for you.

Remember, our roadmap is a guide, and we encourage you to bring your own ideas and creativity to the table. We believe that every contribution, no matter how small, can make a difference. So join us on this exciting journey and help us create the future of Swarms.



--------------------------------------------------

# File: corporate/swarm_cloud.md

# The Swarm Cloud

### Business Model Plan for Autonomous Agent Swarm Service

#### Service Description
- **Overview:** A platform allowing users to deploy swarms of autonomous agents in production-grade environments.
- **Target Users:** Industries requiring automation, monitoring, data collection, and more, such as manufacturing, logistics, agriculture, and surveillance.

#### Operational Strategy
- **Infrastructure:** Robust cloud infrastructure to support agent deployment and data processing.
- **Support and Maintenance:** Continuous support for software updates, troubleshooting, and user assistance.
- **Technology Development:** Ongoing R&D for enhancing agent capabilities and efficiency.

#### Financial Projections
- **Revenue Streams:** Mainly from per agent usage fees and hosting services.
- **Cost Structure:** Includes development, maintenance, infrastructure, marketing, and administrative costs.
- **Break-even Analysis:** Estimation based on projected user adoption rates and cost per agent.

# Revnue Streams
```markdown
| Pricing Structure         | Description | Details |
| ------------------------- | ----------- | ------- |
| Usage-Based Per Agent     | Fees are charged based on the number of agents deployed and their usage duration. | - Ideal for clients needing a few agents for specific tasks. <br> - More agents or longer usage results in higher fees. |
| Swarm Coverage Pricing    | Pricing based on the coverage area or scope of the swarm deployment. | - Suitable for tasks requiring large area coverage. <br> - Price scales with the size or complexity of the area covered. |
| Performance-Based Pricing | Fees are tied to the performance or outcomes achieved by the agents. | - Clients pay for the effectiveness or results achieved by the agents. <br> - Higher fees for more complex or high-value tasks. |
```

1. **Pay-Per-Mission Pricing:** Clients are charged for each specific task or mission completed by the agents.

- **Per Agent Usage Fee:** Charged based on the number of agents and the duration of their deployment.
- **Hosting Fees:** Based on the data usage and processing requirements of the agents.
- **Volume Discounts:** Available for large-scale deployments.


2. **Time-Based Subscription:** A subscription model where clients pay a recurring fee for continuous access to a set number of agents.

3. **Dynamic Pricing:** Prices fluctuate based on demand, time of day, or specific conditions.

4. **Tiered Usage Levels:** Different pricing tiers based on the number of agents used or the complexity of tasks.

5. **Freemium Model:** Basic services are free, but premium features or additional agents are paid.

6. **Outcome-Based Pricing:** Charges are based on the success or quality of the outcomes achieved by the agents.

7. **Feature-Based Pricing:** Different prices for different feature sets or capabilities of the agents.

8. **Volume Discounts:** Reduced per-agent price for bulk deployments or long-term contracts.

9. **Peak Time Premiums:** Higher charges during peak usage times or for emergency deployment.

10. **Bundled Services:** Combining agent services with other products or services for a comprehensive package deal.

11. **Custom Solution Pricing:** Tailor-made pricing for unique or specialized requirements.

12. **Data Analysis Fee:** Charging for the data processing and analytics provided by the agents.

13. **Performance Tiers:** Different pricing for varying levels of agent efficiency or performance.

14. **License Model:** Clients purchase a license to deploy and use a certain number of agents.

15. **Cost-Plus Pricing:** Pricing based on the cost of deployment plus a markup.

16. **Service Level Agreement (SLA) Pricing:** Higher prices for higher levels of service guarantees.

17. **Pay-Per-Save Model:** Charging based on the cost savings or value created by the agents for the client.

18. **Revenue Sharing:** Sharing a percentage of the revenue generated through the use of agents.

19. **Geographic Pricing:** Different pricing for different regions or markets.

20. **User-Based Pricing:** Charging based on the number of users accessing and controlling the agents.

21. **Energy Usage Pricing:** Prices based on the amount of energy consumed by the agents during operation.

22. **Event-Driven Pricing:** Charging for specific events or triggers during the agent's operation.

23. **Seasonal Pricing:** Adjusting prices based on seasonal demand or usage patterns.

24. **Partnership Models:** Collaborating with other businesses and sharing revenue from combined services.

25. **Customizable Packages:** Allowing clients to build their own package of services and capabilities, priced accordingly.

These diverse pricing strategies can be combined or tailored to fit different business models, client needs, and market dynamics. They also provide various methods of value extraction, ensuring flexibility and scalability in revenue generation.


# ICP Analysis
### Ideal Customer Profile (ICP) Map

#### 1. Manufacturing and Industrial Automation
   - **Characteristics:** Large-scale manufacturers, high automation needs, emphasis on efficiency and precision.
   - **Needs:** Process automation, quality control, predictive maintenance.

#### 2. Agriculture and Farming
   - **Characteristics:** Large agricultural enterprises, focus on modern farming techniques.
   - **Needs:** Crop monitoring, automated harvesting, pest control.

#### 3. Logistics and Supply Chain
   - **Characteristics:** Companies with extensive logistics operations, warehousing, and supply chain management.
   - **Needs:** Inventory tracking, automated warehousing, delivery optimization.

#### 4. Energy and Utilities
   - **Characteristics:** Energy providers, utility companies, renewable energy farms.
   - **Needs:** Infrastructure monitoring, predictive maintenance, efficiency optimization.

#### 5. Environmental Monitoring and Conservation
   - **Characteristics:** Organizations focused on environmental protection, research institutions.
   - **Needs:** Wildlife tracking, pollution monitoring, ecological research.

#### 6. Smart Cities and Urban Planning
   - **Characteristics:** Municipal governments, urban development agencies.
   - **Needs:** Traffic management, infrastructure monitoring, public safety.

#### 7. Defense and Security
   - **Characteristics:** Defense contractors, security firms, government agencies.
   - **Needs:** Surveillance, reconnaissance, threat assessment.

#### 8. Healthcare and Medical Facilities
   - **Characteristics:** Large hospitals, medical research centers.
   - **Needs:** Facility management, patient monitoring, medical logistics.

#### 9. Entertainment and Event Management
   - **Characteristics:** Large-scale event organizers, theme parks.
   - **Needs:** Crowd management, entertainment automation, safety monitoring.

#### 10. Construction and Infrastructure
    - **Characteristics:** Major construction firms, infrastructure developers.
    - **Needs:** Site monitoring, material tracking, safety compliance.

### Potential Market Size Table (in Markdown)

```markdown
| Customer Segment             | Estimated Market Size (USD) | Notes |
| ---------------------------- | --------------------------- | ----- |
| Manufacturing and Industrial | $100 Billion                | High automation and efficiency needs drive demand. |
| Agriculture and Farming      | $75 Billion                 | Growing adoption of smart farming technologies. |
| Logistics and Supply Chain   | $90 Billion                 | Increasing need for automation in warehousing and delivery. |
| Energy and Utilities         | $60 Billion                 | Focus on infrastructure monitoring and maintenance. |
| Environmental Monitoring     | $30 Billion                 | Rising interest in climate and ecological data collection. |
| Smart Cities and Urban Planning | $50 Billion              | Growing investment in smart city technologies. |
| Defense and Security         | $120 Billion                | High demand for surveillance and reconnaissance tech. |
| Healthcare and Medical       | $85 Billion                 | Need for efficient hospital management and patient care. |
| Entertainment and Event Management | $40 Billion          | Innovative uses in crowd control and event safety. |
| Construction and Infrastructure | $70 Billion              | Use in monitoring and managing large construction projects. |
```

#### Risk Analysis
- **Market Risks:** Adaptation rate and competition.
- **Operational Risks:** Reliability and scalability of infrastructure.
- **Regulatory Risks:** Compliance with data security and privacy laws.

# Business Model
---

### The Swarm Cloud: Business Model

#### Unlocking the Potential of Autonomous Agent Technology

**1. Our Vision:**
   - Revolutionize industries through scalable, intelligent swarms of autonomous agents.
   - Enable real-time data collection, analysis, and automated task execution.

**2. Service Offering:**
   - **The Swarm Cloud Platform:** Deploy and manage swarms of autonomous agents in production-grade environments.
   - **Applications:** Versatile across industries – from smart agriculture to urban planning, logistics, and beyond.

**3. Key Features:**
   - **High Scalability:** Tailored solutions from small-scale deployments to large industrial operations.
   - **Real-Time Analytics:** Instant data processing and actionable insights.
   - **User-Friendly Interface:** Simplified control and monitoring of agent swarms.
   - **Robust Security:** Ensuring data integrity and operational safety.

**4. Revenue Streams:**
   - **Usage-Based Pricing:** Charges based on the number of agents and operation duration.
   - **Subscription Models:** Recurring revenue through scalable packages.
   - **Custom Solutions:** Tailored pricing for bespoke deployments.

**5. Market Opportunity:**
   - **Expansive Market:** Addressing needs in a \$500 billion global market spanning multiple sectors.
   - **Competitive Edge:** Advanced technology offering superior efficiency and adaptability.

**6. Growth Strategy:**
   - **R&D Investment:** Continuous enhancement of agent capabilities and platform features.
   - **Strategic Partnerships:** Collaborations with industry leaders for market penetration.
   - **Marketing and Sales:** Focused approach on high-potential sectors with tailored marketing strategies.

**7. Why Invest in The Swarm Cloud?**
   - **Pioneering Technology:** At the forefront of autonomous agent systems.
   - **Scalable Business Model:** Designed for rapid expansion and adaptation to diverse market needs.
   - **Strong Market Demand:** Positioned to capitalize on the growing trend of automation and AI.

"Empowering industries with intelligent, autonomous solutions – The Swarm Cloud is set to redefine efficiency and innovation."

#### Conclusion
The business model aims to provide a scalable, efficient, and cost-effective solution for industries looking to leverage the power of autonomous agent technology. With a structured pricing plan and a focus on continuous development and support, the service is positioned to meet diverse industry needs.



--------------------------------------------------

# File: corporate/swarm_memo.md

# [Go To Market Strategy][GTM]

Our vision is to become the world leader in real-world production grade autonomous agent deployment through open-source product development, Deep Verticalization, and unmatched value delivery to the end user.

We will focus on first accelerating the open source framework to PMF where it will serve as the backend for upstream products and services such as the Swarm Cloud which will enable enterprises to deploy autonomous agents with long term memory and tools in the cloud and a no-code platform for users to build their own swarm by dragging and dropping blocks.

Our target user segment for the framework is AI engineers looking to deploy agents into high risk environments where reliability is crucial. 

Once PMF has been achieved and the framework has been extensively benchmarked we aim to establish high value contracts with customers in Security, Logistics, Manufacturing, Health and various other untapped industries.

Our growth strategy for the OS framework can be summarized by:

- Educating developers on value of autonomous agent usage.
- Tutorial Walkthrough on various applications like deploying multi-modal agents through cameras or building custom swarms for a specific business operation.
- Demonstrate unmatched reliability by delighting users.
- Staying up to date with trends and integrating the latest models, frameworks, and methodologies.
- Building a loyal and devoted community for long term user retention. [Join here](https://codex.apac.ai)

As we continuously deliver value with the open framework we will strategically position ourselves to acquire leads for high value contracts by demonstrating the power, reliability, and performance of our framework openly.

Acquire Full Access to the memo here: [TSC Memo](https://docs.google.com/document/d/1hS_nv_lFjCqLfnJBoF6ULY9roTbSgSuCkvXvSUSc7Lo/edit?usp=sharing)

--------------------------------------------------

# File: corporate/swarms_bounty_system.md

# **The Swarms Bounty System: Get Paid to Contribute to Open Source**

In today's fast-paced world of software development, open source has become a driving force for innovation. Every single business and organization on the planet is dependent on open source software.

The power of collaboration and community has proven to be a potent catalyst for creating robust, cutting-edge solutions. At Swarms, we recognize the immense value that open source contributors bring to the table, and we're thrilled to introduce our Bounty System – a program designed to reward developers for their invaluable contributions to the Swarms ecosystem.

The Swarms Bounty System is a groundbreaking initiative that encourages developers from all walks of life to actively participate in the development and improvement of our suite of products, including the Swarms Python framework, Swarm Cloud, and Swarm Core. By leveraging the collective intelligence and expertise of the global developer community, we aim to foster a culture of continuous innovation and excellence.

[**All bounties with rewards can be found here:**](https://github.com/users/kyegomez/projects/1)

## **The Power of Collaboration**

At the heart of the Swarms Bounty System lies the belief that collaboration is the key to unlocking the true potential of software development. By opening up our codebase to the vast talent pool of developers around the world, we're not only tapping into a wealth of knowledge and skills, but also fostering a sense of ownership and investment in the Swarms ecosystem.

Whether you're a seasoned developer with years of experience or a passionate newcomer eager to learn and grow, the Swarms Bounty System offers a unique opportunity to contribute to cutting-edge projects and leave your mark on the technological landscape.

## **How the Bounty System Works**

The Swarms Bounty System is designed to be simple, transparent, and rewarding. Here's how it works:

1. **Explore the Bounties**: We maintain a comprehensive list of bounties, ranging from bug fixes and feature enhancements to entirely new projects. These bounties are categorized based on their complexity and potential impact, ensuring that there's something for everyone, regardless of their skill level or area of expertise. [Bounties will be listed here](https://github.com/users/kyegomez/projects/1)

2. **Submit Your Contributions**: Once you've identified a bounty that piques your interest, you can start working on it. When you're ready, submit your contribution in the form of a pull request, following our established guidelines and best practices.

3. **Review and Approval**: Our dedicated team of reviewers will carefully evaluate your submission, ensuring that it meets our rigorous quality standards and aligns with the project's vision. They'll provide feedback and guidance, fostering a collaborative environment where you can learn and grow.

4. **Get Rewarded**: Upon successful acceptance of your contribution, you'll be rewarded with a combination of cash and or stock incentives. The rewards are based on a tiered system, reflecting the complexity and impact of your contribution.

## **The Rewards System**

At Swarms, we believe in recognizing and rewarding exceptional contributions. Our tiered rewards system is designed to incentivize developers to push the boundaries of innovation and drive the Swarms ecosystem forward. Here's how the rewards are structured:

### Tier 1: Bug Fixes and Minor Enhancements

| Reward                 | Description                                                  |
|------------------------|--------------------------------------------------------------|
| Cash Reward            | $50 - $150                                                   |
| Stock Reward           | N/A                                                          |

This tier covers minor bug fixes, documentation improvements, and small enhancements to existing features. While these contributions may seem insignificant, they play a crucial role in maintaining the stability and usability of our products.

### Tier 2: Moderate Enhancements and New Features

| Reward                 | Description                                                  |
|------------------------|--------------------------------------------------------------|
| Cash Reward            | $151 - $300                                                  |
| Stock Reward           | 10+          |

This tier encompasses moderate enhancements to existing features, as well as the implementation of new, non-critical features. Contributions in this tier demonstrate a deeper understanding of the project's architecture and a commitment to improving the overall user experience.

### Tier 3: Major Features and Groundbreaking Innovations

| Reward                 | Description                                                  |
|------------------------|--------------------------------------------------------------|
| Cash Reward            | $301 - $++                                                  |
| Stock Reward           | 25+           |

This tier is reserved for truly exceptional contributions that have the potential to revolutionize the Swarms ecosystem. Major feature additions, innovative architectural improvements, and groundbreaking new projects fall under this category. Developers who contribute at this level will be recognized as thought leaders and pioneers in their respective fields.

It's important to note that the cash and stock rewards are subject to change based on the project's requirements, complexity, and overall impact. Additionally, we may introduce special bounties with higher reward tiers for particularly challenging or critical projects.

## **The Benefits of Contributing**

Participating in the Swarms Bounty System offers numerous benefits beyond the financial incentives. By contributing to our open source projects, you'll have the opportunity to:

1. **Expand Your Skills**: Working on real-world projects with diverse challenges will help you hone your existing skills and acquire new ones, making you a more versatile and valuable developer.

2. **Build Your Portfolio**: Your contributions will become part of your professional portfolio, showcasing your expertise and dedication to the open source community.

3. **Network with Industry Experts**: Collaborate with our team of seasoned developers and gain invaluable insights and mentorship from industry leaders.

4. **Shape the Future**: Your contributions will directly impact the direction and evolution of the Swarms ecosystem, shaping the future of our products and services.

5. **Gain Recognition**: Stand out in the crowded field of software development by having your contributions acknowledged and celebrated by the Swarms community.

## **Join the Movement**

The Swarms Bounty System is more than just a program; it's a movement that embraces the spirit of open source and fosters a culture of collaboration, innovation, and excellence. By joining our ranks, you'll become part of a vibrant community of developers who share a passion for pushing the boundaries of what's possible.

Whether you're a seasoned veteran or a newcomer eager to make your mark, the Swarms Bounty System offers a unique opportunity to contribute to cutting-edge projects, earn rewards, and shape the future of software development.

So, what are you waiting for? Explore our bounties, find your niche, and start contributing today. Together, we can build a brighter, more innovative future for the Swarms ecosystem and the entire software development community.

[Join the swarm community now:](https://discord.gg/F4GGT5DERD)


## Resources
- [Bounty Board](https://github.com/users/kyegomez/projects/1/views/1)
- [Swarm Community](https://discord.gg/F4GGT5DERD)
- [Swarms Framework](https://github.com/kyegomez/swarms)
- [Swarm Cloud](https://github.com/kyegomez/swarms-cloud)
- [Swarm Ecosystem](https://github.com/kyegomez/swarm-ecosystem)

--------------------------------------------------

# File: governance/main.md

# 🔗 Links & Resources

Welcome to the Swarms ecosystem. Click any tile below to explore our products, community, documentation, and social platforms.

---

<style>
.resource-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 1rem;
  margin-top: 1.5rem;
}

.resource-card {
  display: block;
  padding: 1.2rem;
  border-radius: 12px;
  background: #1e1e2f;
  color: white;
  text-decoration: none;
  text-align: center;
  font-weight: 600;
  transition: transform 0.2s ease, background 0.3s ease;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
}

.resource-card:hover {
  transform: translateY(-4px);
  background: #2a2a3d;
}
</style>

<div class="resource-grid">

<a class="resource-card" href="https://swarms.world/platform/chat" target="_blank">🗣️ Swarms Chat</a>

<a class="resource-card" href="https://swarms.world" target="_blank">🛍️ Swarms Marketplace</a>

<a class="resource-card" href="https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/" target="_blank">📚 Swarms API Docs</a>

<a class="resource-card" href="https://www.swarms.xyz/programs/startups" target="_blank">🚀 Swarms Startup Program</a>

<a class="resource-card" href="https://github.com/kyegomez/swarms" target="_blank">💻 GitHub: Swarms (Python)</a>

<a class="resource-card" href="https://github.com/The-Swarm-Corporation/swarms-rs" target="_blank">🦀 GitHub: Swarms (Rust)</a>

<a class="resource-card" href="https://discord.gg/jM3Z6M9uMq" target="_blank">💬 Join Our Discord</a>

<a class="resource-card" href="https://t.me/swarmsgroupchat" target="_blank">📱 Telegram Group</a>

<a class="resource-card" href="https://x.com/swarms_corp" target="_blank">🐦 Twitter / X</a>

<a class="resource-card" href="https://medium.com/@kyeg" target="_blank">✍️ Swarms Blog on Medium</a>

</div>

---

## 💡 Quick Summary

| Category     | Link                                                                 |
|--------------|----------------------------------------------------------------------|
| API Docs     | [docs.swarms.world](https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/) |
| GitHub       | [kyegomez/swarms](https://github.com/kyegomez/swarms)               |
| GitHub (Rust)| [The-Swarm-Corporation/swarms-rs](https://github.com/The-Swarm-Corporation/swarms-rs) |
| Chat UI      | [swarms.world/platform/chat](https://swarms.world/platform/chat)     |
| Marketplace  | [swarms.world](https://swarms.world)                                 |
| Startup App  | [Apply Here](https://www.swarms.xyz/programs/startups)               |
| Discord      | [Join Now](https://discord.gg/jM3Z6M9uMq)                            |
| Telegram     | [Group Chat](https://t.me/swarmsgroupchat)                           |
| Twitter/X    | [@swarms_corp](https://x.com/swarms_corp)                            |
| Blog         | [medium.com/@kyeg](https://medium.com/@kyeg)                         |

---

> 🐝 Swarms is building the agentic internet. Join the movement and build the future with us.


--------------------------------------------------

# File: guides/agent_evals.md

### Understanding Agent Evaluation Mechanisms

Agent evaluation mechanisms play a crucial role in ensuring that autonomous agents, particularly in multi-agent systems, perform their tasks effectively and efficiently. This blog delves into the intricacies of agent evaluation, the importance of accuracy tracking, and the methodologies used to measure and visualize agent performance. We'll use Mermaid graphs to provide clear visual representations of these processes.

#### 1. Introduction to Agent Evaluation Mechanisms

Agent evaluation mechanisms refer to the processes and criteria used to assess the performance of agents within a system. These mechanisms are essential for:

- **Ensuring Reliability:** Agents must consistently perform their designated tasks correctly.
- **Improving Performance:** Evaluation helps in identifying areas where agents can improve.
- **Maintaining Accountability:** It provides a way to hold agents accountable for their actions.

### 2. Key Components of Agent Evaluation

To effectively evaluate agents, several components and metrics are considered:

#### a. Performance Metrics

These are quantitative measures used to assess how well an agent is performing. Common performance metrics include:

- **Accuracy:** The percentage of correct actions or decisions made by the agent.
- **Precision and Recall:** Precision measures the number of true positive results divided by the number of all positive results, while recall measures the number of true positive results divided by the number of positives that should have been retrieved.
- **F1 Score:** The harmonic mean of precision and recall.
- **Response Time:** How quickly an agent responds to a given task or query.

#### b. Evaluation Criteria

Evaluation criteria define the standards or benchmarks against which agent performance is measured. These criteria are often task-specific and may include:

- **Task Completion Rate:** The percentage of tasks successfully completed by the agent.
- **Error Rate:** The frequency of errors made by the agent during task execution.
- **Resource Utilization:** How efficiently an agent uses resources such as memory and CPU.

### 3. The Process of Agent Evaluation

The evaluation process involves several steps, which can be visualized using Mermaid graphs:

#### a. Define Evaluation Metrics

The first step is to define the metrics that will be used to evaluate the agent. This involves identifying the key performance indicators (KPIs) relevant to the agent's tasks.

```mermaid
graph TD
    A[Define Evaluation Metrics] --> B[Identify KPIs]
    B --> C[Accuracy]
    B --> D[Precision and Recall]
    B --> E[F1 Score]
    B --> F[Response Time]
```

#### b. Collect Data

Data collection involves gathering information on the agent's performance. This data can come from logs, user feedback, or direct observations.

```mermaid
graph TD
    A[Collect Data] --> B[Logs]
    A --> C[User Feedback]
    A --> D[Direct Observations]
```

#### c. Analyze Performance

Once data is collected, it is analyzed to assess the agent's performance against the defined metrics. This step may involve statistical analysis, machine learning models, or other analytical techniques.

```mermaid
graph TD
    A[Analyze Performance] --> B[Statistical Analysis]
    A --> C[Machine Learning Models]
    A --> D[Other Analytical Techniques]
```

#### d. Generate Reports

After analysis, performance reports are generated. These reports provide insights into how well the agent is performing and identify areas for improvement.

```mermaid
graph TD
    A[Generate Reports] --> B[Performance Insights]
    B --> C[Identify Areas for Improvement]
```

### 4. Tracking Agent Accuracy

Accuracy tracking is a critical aspect of agent evaluation. It involves measuring how often an agent's actions or decisions are correct. The following steps outline the process of tracking agent accuracy:

#### a. Define Correctness Criteria

The first step is to define what constitutes a correct action or decision for the agent.

```mermaid
graph TD
    A[Define Correctness Criteria] --> B[Task-Specific Standards]
    B --> C[Action Accuracy]
    B --> D[Decision Accuracy]
```

#### b. Monitor Agent Actions

Agents' actions are continuously monitored to track their performance. This monitoring can be done in real-time or through periodic evaluations.

```mermaid
graph TD
    A[Monitor Agent Actions] --> B[Real-Time Monitoring]
    A --> C[Periodic Evaluations]
```

#### c. Compare Against Correctness Criteria

Each action or decision made by the agent is compared against the defined correctness criteria to determine its accuracy.

```mermaid
graph TD
    A[Compare Against Correctness Criteria] --> B[Evaluate Each Action]
    B --> C[Correct or Incorrect?]
```

#### d. Calculate Accuracy Metrics

Accuracy metrics are calculated based on the comparison results. These metrics provide a quantitative measure of the agent's accuracy.

```mermaid
graph TD
    A[Calculate Accuracy Metrics] --> B[Accuracy Percentage]
    A --> C[Error Rate]
```

### 5. Measuring Agent Accuracy

Measuring agent accuracy involves several steps and considerations:

#### a. Data Labeling

To measure accuracy, the data used for evaluation must be accurately labeled. This involves annotating the data with the correct actions or decisions.

```mermaid
graph TD
    A[Data Labeling] --> B[Annotate Data with Correct Actions]
    B --> C[Ensure Accuracy of Labels]
```

#### b. Establish Baseline Performance

A baseline performance level is established by evaluating a sample set of data. This baseline serves as a reference point for measuring improvements or declines in accuracy.

```mermaid
graph TD
    A[Establish Baseline Performance] --> B[Evaluate Sample Data]
    B --> C[Set Performance Benchmarks]
```

#### c. Regular Evaluations

Agents are regularly evaluated to measure their accuracy over time. This helps in tracking performance trends and identifying any deviations from the expected behavior.

```mermaid
graph TD
    A[Regular Evaluations] --> B[Track Performance Over Time]
    B --> C[Identify Performance Trends]
    B --> D[Detect Deviations]
```

#### d. Feedback and Improvement

Feedback from evaluations is used to improve the agent's performance. This may involve retraining the agent, adjusting its algorithms, or refining its decision-making processes.

```mermaid
graph TD
    A[Feedback and Improvement] --> B[Use Evaluation Feedback]
    B --> C[Retrain Agent]
    B --> D[Adjust Algorithms]
    B --> E[Refine Decision-Making Processes]
```

### 6. Visualizing Agent Evaluation with Mermaid Graphs

Mermaid graphs provide a clear and concise way to visualize the agent evaluation process. Here are some examples of how Mermaid graphs can be used:

#### a. Overall Evaluation Process

```mermaid
graph TD
    A[Define Evaluation Metrics] --> B[Collect Data]
    B --> C[Analyze Performance]
    C --> D[Generate Reports]
```

#### b. Accuracy Tracking

```mermaid
graph TD
    A[Define Correctness Criteria] --> B[Monitor Agent Actions]
    B --> C[Compare Against Correctness Criteria]
    C --> D[Calculate Accuracy Metrics]
```

#### c. Continuous Improvement Cycle

```mermaid
graph TD
    A[Regular Evaluations] --> B[Track Performance Over Time]
    B --> C[Identify Performance Trends]
    C --> D[Detect Deviations]
    D --> E[Feedback and Improvement]
    E --> A
```

### 7. Case Study: Evaluating a Chatbot Agent

To illustrate the agent evaluation process, let's consider a case study involving a chatbot agent designed to assist customers in an e-commerce platform.

#### a. Define Evaluation Metrics

For the chatbot, key performance metrics might include:

- **Response Accuracy:** The percentage of correct responses provided by the chatbot.
- **Response Time:** The average time taken by the chatbot to respond to user queries.
- **Customer Satisfaction:** Measured through user feedback and ratings.

#### b. Collect Data

Data is collected from chatbot interactions, including user queries, responses, and feedback.

#### c. Analyze Performance

Performance analysis involves comparing the chatbot's responses against a predefined set of correct responses and calculating accuracy metrics.

#### d. Generate Reports

Reports are generated to provide insights into the chatbot's performance, highlighting areas where it excels and areas needing improvement.

### 8. Best Practices for Agent Evaluation

Here are some best practices to ensure effective agent evaluation:

#### a. Use Realistic Scenarios

Evaluate agents in realistic scenarios that closely mimic real-world conditions. This ensures that the evaluation results are relevant and applicable.

#### b. Continuous Monitoring

Continuously monitor agent performance to detect and address issues promptly. This helps in maintaining high performance levels.

#### c. Incorporate User Feedback

User feedback is invaluable for improving agent performance. Incorporate feedback into the evaluation process to identify and rectify shortcomings.

#### d. Regular Updates

Regularly update the evaluation metrics and criteria to keep pace with evolving tasks and requirements.

### Conclusion

Agent evaluation mechanisms are vital for ensuring the reliability, efficiency, and effectiveness of autonomous agents. By defining clear evaluation metrics, continuously monitoring performance, and using feedback for improvement, we can develop agents that consistently perform at high levels. Visualizing the evaluation process with tools like Mermaid graphs further aids in understanding and communication. Through diligent evaluation and continuous improvement, we can harness the full potential of autonomous agents in various applications.

--------------------------------------------------

# File: guides/financial_analysis_swarm_mm.md

# Building a Multi-Agent System for Real-Time Financial Analysis: A Comprehensive Tutorial

In this tutorial, we'll walk through the process of building a sophisticated multi-agent system for real-time financial analysis using the Swarms framework. This system is designed for financial analysts and developer analysts who want to leverage AI and multiple data sources to gain deeper insights into stock performance, market trends, and economic indicators.

Before we dive into the code, let's briefly introduce the Swarms framework. Swarms is an innovative open-source project that simplifies the creation and management of AI agents. It's particularly well-suited for complex tasks like financial analysis, where multiple specialized agents can work together to provide comprehensive insights.

For more information and to contribute to the project, visit the [Swarms GitHub repository](https://github.com/kyegomez/swarms). We highly recommend exploring the documentation for a deeper understanding of Swarms' capabilities.

Additional resources:
- [Swarms Discord](https://discord.gg/swarms) for community discussions
- [Swarms Twitter](https://x.com/swarms_corp) for updates
- [Swarms Spotify](https://open.spotify.com/show/2HLiswhmUaMdjHC8AUHcCF?si=c831ef10c5ef4994) for podcasts
- [Swarms Blog](https://medium.com/@kyeg) for in-depth articles
- [Swarms Website](https://swarms.xyz) for an overview of the project

Now, let's break down our financial analysis system step by step.

## Step 1: Setting Up the Environment
First install the necessary packages:

```bash
$ pip3 install -U swarms yfiance swarm_models fredapi pandas 
```

First, we need to set up our environment and import the necessary libraries:

```python
import os
import time
from datetime import datetime, timedelta
import yfinance as yf
import requests
from fredapi import Fred
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from swarms import Agent, AgentRearrange
from swarm_models import OpenAIChat
import logging
from dotenv import load_dotenv
import asyncio
import aiohttp
from ratelimit import limits, sleep_and_retry

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# API keys
POLYGON_API_KEY = os.getenv('POLYGON_API_KEY')
FRED_API_KEY = os.getenv('FRED_API_KEY')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

# Initialize FRED client
fred_client = Fred(api_key=FRED_API_KEY)

# Polygon API base URL
POLYGON_BASE_URL = "https://api.polygon.io"
```

This section sets up our environment, imports necessary libraries, and initializes our API keys and clients. We're using `dotenv` to securely manage our API keys, and we've set up logging to track the execution of our script.

## Step 2: Implementing Rate Limiting

To respect API rate limits, we implement rate limiting decorators:

```python
@sleep_and_retry
@limits(calls=5, period=60)  # Adjust these values based on your Polygon API tier
async def call_polygon_api(session, endpoint, params=None):
    url = f"{POLYGON_BASE_URL}{endpoint}"
    params = params or {}
    params['apiKey'] = POLYGON_API_KEY
    async with session.get(url, params=params) as response:
        response.raise_for_status()
        return await response.json()

@sleep_and_retry
@limits(calls=120, period=60)  # FRED allows 120 requests per minute
def call_fred_api(func, *args, **kwargs):
    return func(*args, **kwargs)
```

These decorators ensure that we don't exceed the rate limits for our API calls. The `call_polygon_api` function is designed to work with asynchronous code, while `call_fred_api` is a wrapper for synchronous FRED API calls.

## Step 3: Implementing Data Fetching Functions

Next, we implement functions to fetch data from various sources:

### Yahoo Finance Integration

```python
async def get_yahoo_finance_data(session, ticker, period="1d", interval="1m"):
    try:
        stock = yf.Ticker(ticker)
        hist = await asyncio.to_thread(stock.history, period=period, interval=interval)
        info = await asyncio.to_thread(lambda: stock.info)
        return hist, info
    except Exception as e:
        logger.error(f"Error fetching Yahoo Finance data for {ticker}: {e}")
        return None, None

async def get_yahoo_finance_realtime(session, ticker):
    try:
        stock = yf.Ticker(ticker)
        return await asyncio.to_thread(lambda: stock.fast_info)
    except Exception as e:
        logger.error(f"Error fetching Yahoo Finance realtime data for {ticker}: {e}")
        return None
```

These functions fetch historical and real-time data from Yahoo Finance. We use `asyncio.to_thread` to run the synchronous `yfinance` functions in a separate thread, allowing our main event loop to continue running.

### Polygon.io Integration

```python
async def get_polygon_realtime_data(session, ticker):
    try:
        trades = await call_polygon_api(session, f"/v2/last/trade/{ticker}")
        quotes = await call_polygon_api(session, f"/v2/last/nbbo/{ticker}")
        return trades, quotes
    except Exception as e:
        logger.error(f"Error fetching Polygon.io realtime data for {ticker}: {e}")
        return None, None

async def get_polygon_news(session, ticker, limit=10):
    try:
        news = await call_polygon_api(session, f"/v2/reference/news", params={"ticker": ticker, "limit": limit})
        return news.get('results', [])
    except Exception as e:
        logger.error(f"Error fetching Polygon.io news for {ticker}: {e}")
        return []
```

These functions fetch real-time trade and quote data, as well as news articles from Polygon.io. We use our `call_polygon_api` function to make these requests, ensuring we respect rate limits.

### FRED Integration

```python
async def get_fred_data(session, series_id, start_date, end_date):
    try:
        data = await asyncio.to_thread(call_fred_api, fred_client.get_series, series_id, start_date, end_date)
        return data
    except Exception as e:
        logger.error(f"Error fetching FRED data for {series_id}: {e}")
        return None

async def get_fred_realtime(session, series_ids):
    try:
        data = {}
        for series_id in series_ids:
            series = await asyncio.to_thread(call_fred_api, fred_client.get_series, series_id)
            data[series_id] = series.iloc[-1]  # Get the most recent value
        return data
    except Exception as e:
        logger.error(f"Error fetching FRED realtime data: {e}")
        return {}
```

These functions fetch historical and real-time economic data from FRED. Again, we use `asyncio.to_thread` to run the synchronous FRED API calls in a separate thread.

## Step 4: Creating Specialized Agents

Now we create our specialized agents using the Swarms framework:

```python
stock_agent = Agent(
    agent_name="StockAgent",
    system_prompt="""You are an expert stock analyst. Your task is to analyze real-time stock data and provide insights. 
    Consider price movements, trading volume, and any available company information. 
    Provide a concise summary of the stock's current status and any notable trends or events.""",
    llm=OpenAIChat(api_key=OPENAI_API_KEY),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
)

market_agent = Agent(
    agent_name="MarketAgent",
    system_prompt="""You are a market analysis expert. Your task is to analyze overall market conditions using real-time data. 
    Consider major indices, sector performance, and market-wide trends. 
    Provide a concise summary of current market conditions and any significant developments.""",
    llm=OpenAIChat(api_key=OPENAI_API_KEY),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
)

macro_agent = Agent(
    agent_name="MacroAgent",
    system_prompt="""You are a macroeconomic analysis expert. Your task is to analyze key economic indicators and provide insights on the overall economic situation. 
    Consider GDP growth, inflation rates, unemployment figures, and other relevant economic data. 
    Provide a concise summary of the current economic situation and any potential impacts on financial markets.""",
    llm=OpenAIChat(api_key=OPENAI_API_KEY),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
)

news_agent = Agent(
    agent_name="NewsAgent",
    system_prompt="""You are a financial news analyst. Your task is to analyze recent news articles related to specific stocks or the overall market. 
    Consider the potential impact of news events on stock prices or market trends. 
    Provide a concise summary of key news items and their potential market implications.""",
    llm=OpenAIChat(api_key=OPENAI_API_KEY),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
)
```

Each agent is specialized in a different aspect of financial analysis. The `system_prompt` for each agent defines its role and the type of analysis it should perform.

## Step 5: Building the Multi-Agent System

We then combine our specialized agents into a multi-agent system:

```python
agents = [stock_agent, market_agent, macro_agent, news_agent]
flow = "StockAgent -> MarketAgent -> MacroAgent -> NewsAgent"

agent_system = AgentRearrange(agents=agents, flow=flow)
```

The `flow` variable defines the order in which our agents will process information. This allows for a logical progression from specific stock analysis to broader market and economic analysis.

## Step 6: Implementing Real-Time Analysis

Now we implement our main analysis function:

```python
async def real_time_analysis(session, ticker):
    logger.info(f"Starting real-time analysis for {ticker}")
    
    # Fetch real-time data
    yf_data, yf_info = await get_yahoo_finance_data(session, ticker)
    yf_realtime = await get_yahoo_finance_realtime(session, ticker)
    polygon_trades, polygon_quotes = await get_polygon_realtime_data(session, ticker)
    polygon_news = await get_polygon_news(session, ticker)
    fred_data = await get_fred_realtime(session, ['GDP', 'UNRATE', 'CPIAUCSL'])

    # Prepare input for the multi-agent system
    input_data = f"""
    Yahoo Finance Data:
    {yf_realtime}

    Recent Stock History:
    {yf_data.tail().to_string() if yf_data is not None else 'Data unavailable'}

    Polygon.io Trade Data:
    {polygon_trades}

    Polygon.io Quote Data:
    {polygon_quotes}

    Recent News:
    {polygon_news[:3] if polygon_news else 'No recent news available'}

    Economic Indicators:
    {fred_data}

    Analyze this real-time financial data for {ticker}. Provide insights on the stock's performance, overall market conditions, relevant economic factors, and any significant news that might impact the stock or market.
    """

    # Run the multi-agent analysis
    try:
        analysis = agent_system.run(input_data)
        logger.info(f"Analysis completed for {ticker}")
        return analysis
    except Exception as e:
        logger.error(f"Error during multi-agent analysis for {ticker}: {e}")
        return f"Error during analysis: {e}"
```

This function fetches data from all our sources, prepares it as input for our multi-agent system, and then runs the analysis. The result is a comprehensive analysis of the stock, considering individual performance, market conditions, economic factors, and relevant news.

## Step 7: Implementing Advanced Use Cases

We then implement more advanced analysis functions:

### Compare Stocks

```python
async def compare_stocks(session, tickers):
    results = {}
    for ticker in tickers:
        results[ticker] = await real_time_analysis(session, ticker)
    
    comparison_prompt = f"""
    Compare the following stocks based on the provided analyses:
    {results}

    Highlight key differences and similarities. Provide a ranking of these stocks based on their current performance and future prospects.
    """
    
    try:
        comparison = agent_system.run(comparison_prompt)
        logger.info(f"Stock comparison completed for {tickers}")
        return comparison
    except Exception as e:
        logger.error(f"Error during stock comparison: {e}")
        return f"Error during comparison: {e}"
```

This function compares multiple stocks by running a real-time analysis on each and then prompting our multi-agent system to compare the results.

### Sector Analysis

```python
async def sector_analysis(session, sector):
    sector_stocks = {
        'Technology': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA'],
        'Finance': ['JPM', 'BAC', 'WFC', 'C', 'GS'],
        'Healthcare': ['JNJ', 'UNH', 'PFE', 'ABT', 'MRK'],
        'Consumer Goods': ['PG', 'KO', 'PEP', 'COST', 'WMT'],
        'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'EOG']
    }
    
    if sector not in sector_stocks:
        return f"Sector '{sector}' not found. Available sectors: {', '.join(sector_stocks.keys())}"
    
    stocks = sector_stocks[sector][:5]
    
    sector_data = {}
    for stock in stocks:
        sector_data[stock] = await real_time_analysis(session, stock)
    
    sector_prompt = f"""
    Analyze the {sector} sector based on the following data from its top stocks:
    {sector_data}

    Provide insights on:
    1. Overall sector performance
    2. Key trends within the sector
    3. Top performing stocks and why they're outperforming
    4. Any challenges or opportunities facing the sector
    """
    
    try:
        analysis = agent_system.run(sector_prompt)
        logger.info(f"Sector analysis completed for {sector}")
        return analysis
    except Exception as e:
        logger.error(f"Error during sector analysis for {sector}: {e}")
        return f"Error during sector analysis: {e}"
```

This function analyzes an entire sector by running real-time analysis on its top stocks and then prompting our multi-agent system to provide sector-wide insights.

### Economic Impact Analysis

```python
async def economic_impact_analysis(session, indicator, threshold):
    # Fetch historical data for the indicator
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')
    indicator_data = await get_fred_data(session, indicator, start_date, end_date)
    
    if indicator_data is None or len(indicator_data) < 2:
        return f"Insufficient data for indicator {indicator}"
    
    # Check if the latest value crosses the threshold
    latest_value = indicator_data.iloc[-1]
    previous_value = indicator_data.iloc[-2]
    crossed_threshold = (latest_value > threshold and previous_value <= threshold) or (latest_value < threshold and previous_value >= threshold)
    
    if crossed_threshold:
        impact_prompt = f"""
        The economic indicator {indicator} has crossed the threshold of {threshold}. Its current value is {latest_value}.

        Historical data:
        {indicator_data.tail().to_string()}

        Analyze the potential impacts of this change on:
        1. Overall economic conditions
        2. Different market
        2. Different market sectors
        3. Specific types of stocks (e.g., growth vs. value)
        4. Other economic indicators

        Provide a comprehensive analysis of the potential consequences and any recommended actions for investors.
        """
        
        try:
            analysis = agent_system.run(impact_prompt)
            logger.info(f"Economic impact analysis completed for {indicator}")
            return analysis
        except Exception as e:
            logger.error(f"Error during economic impact analysis for {indicator}: {e}")
            return f"Error during economic impact analysis: {e}"
    else:
        return f"The {indicator} indicator has not crossed the threshold of {threshold}. Current value: {latest_value}"
```

This function analyzes the potential impact of significant changes in economic indicators. It fetches historical data, checks if a threshold has been crossed, and if so, prompts our multi-agent system to provide a comprehensive analysis of the potential consequences.

## Step 8: Running the Analysis

Finally, we implement our main function to run all of our analyses:

```python
async def main():
    async with aiohttp.ClientSession() as session:
        # Example usage
        analysis_result = await real_time_analysis(session, 'AAPL')
        print("Single Stock Analysis:")
        print(analysis_result)

        comparison_result = await compare_stocks(session, ['AAPL', 'GOOGL', 'MSFT'])
        print("\nStock Comparison:")
        print(comparison_result)

        tech_sector_analysis = await sector_analysis(session, 'Technology')
        print("\nTechnology Sector Analysis:")
        print(tech_sector_analysis)

        gdp_impact = await economic_impact_analysis(session, 'GDP', 22000)
        print("\nEconomic Impact Analysis:")
        print(gdp_impact)

if __name__ == "__main__":
    asyncio.run(main())
```

This `main` function demonstrates how to use all of our analysis functions. It runs a single stock analysis, compares multiple stocks, performs a sector analysis, and conducts an economic impact analysis.

## Conclusion and Next Steps

This tutorial has walked you through the process of building a sophisticated multi-agent system for real-time financial analysis using the Swarms framework. Here's a summary of what we've accomplished:

1. Set up our environment and API connections
2. Implemented rate limiting to respect API constraints
3. Created functions to fetch data from multiple sources (Yahoo Finance, Polygon.io, FRED)
4. Designed specialized AI agents for different aspects of financial analysis
5. Combined these agents into a multi-agent system
6. Implemented advanced analysis functions including stock comparison, sector analysis, and economic impact analysis

This system provides a powerful foundation for financial analysis, but there's always room for expansion and improvement. Here are some potential next steps:

1. **Expand data sources**: Consider integrating additional financial data providers for even more comprehensive analysis.

2. **Enhance agent specialization**: You could create more specialized agents, such as a technical analysis agent or a sentiment analysis agent for social media data.

3. **Implement a user interface**: Consider building a web interface or dashboard to make the system more user-friendly for non-technical analysts.

4. **Add visualization capabilities**: Integrate data visualization tools to help interpret complex financial data more easily.

5. **Implement a backtesting system**: Develop a system to evaluate your multi-agent system's performance on historical data.

6. **Explore advanced AI models**: The Swarms framework supports various AI models. Experiment with different models to see which performs best for your specific use case.

7. **Implement real-time monitoring**: Set up a system to continuously monitor markets and alert you to significant changes or opportunities.

Remember, the Swarms framework is a powerful and flexible tool that can be adapted to a wide range of complex tasks beyond just financial analysis. We encourage you to explore the [Swarms GitHub repository](https://github.com/kyegomez/swarms) for more examples and inspiration.

For more in-depth discussions and community support, consider joining the [Swarms Discord](https://discord.gg/swarms). You can also stay updated with the latest developments by following [Swarms on Twitter](https://x.com/swarms_corp).

If you're interested in learning more about AI and its applications in various fields, check out the [Swarms Spotify podcast](https://open.spotify.com/show/2HLiswhmUaMdjHC8AUHcCF?si=c831ef10c5ef4994) and the [Swarms Blog](https://medium.com/@kyeg) for insightful articles and discussions.

Lastly, don't forget to visit the [Swarms Website](https://swarms.xyz) for a comprehensive overview of the project and its capabilities.

By leveraging the power of multi-agent AI systems, you're well-equipped to navigate the complex world of financial markets. Happy analyzing!



## Swarm Resources:


* [Swarms Github](https://github.com/kyegomez/swarms)
* [Swarms Discord](https://discord.gg/swarms)
* [Swarms Twitter](https://x.com/swarms_corp)
* [Swarms Spotify](https://open.spotify.com/show/2HLiswhmUaMdjHC8AUHcCF?si=c831ef10c5ef4994)
* [Swarms Blog](https://medium.com/@kyeg)
* [Swarms Website](https://swarms.xyz)

--------------------------------------------------

# File: guides/financial_data_api.md

# Analyzing Financial Data with AI Agents using Swarms Framework

In the rapidly evolving landscape of quantitative finance, the integration of artificial intelligence with financial data analysis has become increasingly crucial. This blog post will explore how to leverage the power of AI agents, specifically using the Swarms framework, to analyze financial data from various top-tier data providers. We'll demonstrate how to connect these agents with different financial APIs, enabling sophisticated analysis and decision-making processes.

## Table of Contents

1. [Introduction to Swarms Framework](#introduction-to-swarms-framework)
2. [Setting Up the Environment](#setting-up-the-environment)
3. [Connecting AI Agents with Financial Data Providers](#connecting-ai-agents-with-financial-data-providers)
   - [Polygon.io](#polygonio)
   - [Alpha Vantage](#alpha-vantage)
   - [Yahoo Finance](#yahoo-finance)
   - [IEX Cloud](#iex-cloud)
   - [Finnhub](#finnhub)
4. [Advanced Analysis Techniques](#advanced-analysis-techniques)
5. [Best Practices and Considerations](#best-practices-and-considerations)
6. [Conclusion](#conclusion)

## Introduction to Swarms Framework

The Swarms framework is a powerful tool for building and deploying AI agents that can interact with various data sources and perform complex analyses. In the context of financial data analysis, Swarms can be used to create intelligent agents that can process large volumes of financial data, identify patterns, and make data-driven decisions. Explore our github for examples, applications, and more.

## Setting Up the Environment

Before we dive into connecting AI agents with financial data providers, let's set up our environment:

1. Install the Swarms framework:

```bash
pip install -U swarms
```

2. Install additional required libraries:

```bash
pip install requests pandas numpy matplotlib
```

3. Set up your API keys for the various financial data providers. It's recommended to use environment variables or a secure configuration file to store these keys.

## Connecting AI Agents with Financial Data Providers

Now, let's explore how to connect AI agents using the Swarms framework with different financial data providers.

### Polygon.io

First, we'll create an AI agent that can fetch and analyze stock data from Polygon.io.

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import requests
import pandas as pd

load_dotenv()

# Polygon.io API setup
POLYGON_API_KEY = os.getenv("POLYGON_API_KEY")
POLYGON_BASE_URL = "https://api.polygon.io/v2"

# OpenAI API setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant. Your task is to analyze stock data and provide insights.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_stock_data(symbol, from_date, to_date):
    endpoint = f"{POLYGON_BASE_URL}/aggs/ticker/{symbol}/range/1/day/{from_date}/{to_date}"
    params = {
        'apiKey': POLYGON_API_KEY,
        'adjusted': 'true'
    }
    response = requests.get(endpoint, params=params)
    data = response.json()
    return pd.DataFrame(data['results'])

# Example usage
symbol = "AAPL"
from_date = "2023-01-01"
to_date = "2023-12-31"

stock_data = get_stock_data(symbol, from_date, to_date)

analysis_request = f"""
Analyze the following stock data for {symbol} from {from_date} to {to_date}:

{stock_data.to_string()}

Provide insights on the stock's performance, including trends, volatility, and any notable events.
"""

analysis = agent.run(analysis_request)
print(analysis)
```

In this example, we've created an AI agent that can fetch stock data from Polygon.io and perform an analysis based on that data. The agent uses the GPT-4 model to generate insights about the stock's performance.

### Alpha Vantage

Next, let's create an agent that can work with Alpha Vantage data to perform fundamental analysis.

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import requests

load_dotenv()

# Alpha Vantage API setup
ALPHA_VANTAGE_API_KEY = os.getenv("ALPHA_VANTAGE_API_KEY")
ALPHA_VANTAGE_BASE_URL = "https://www.alphavantage.co/query"

# OpenAI API setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Fundamental-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in fundamental analysis. Your task is to analyze company financials and provide insights.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_income_statement(symbol):
    params = {
        'function': 'INCOME_STATEMENT',
        'symbol': symbol,
        'apikey': ALPHA_VANTAGE_API_KEY
    }
    response = requests.get(ALPHA_VANTAGE_BASE_URL, params=params)
    return response.json()

# Example usage
symbol = "MSFT"

income_statement = get_income_statement(symbol)

analysis_request = f"""
Analyze the following income statement data for {symbol}:

{income_statement}

Provide insights on the company's financial health, profitability trends, and any notable observations.
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example demonstrates an AI agent that can fetch income statement data from Alpha Vantage and perform a fundamental analysis of a company's financials.

### Yahoo Finance

Now, let's create an agent that can work with Yahoo Finance data to perform technical analysis.

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import yfinance as yf
import pandas as pd

load_dotenv()

# OpenAI API setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Technical-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in technical analysis. Your task is to analyze stock price data and provide insights on trends and potential trading signals.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_stock_data(symbol, start_date, end_date):
    stock = yf.Ticker(symbol)
    data = stock.history(start=start_date, end=end_date)
    return data

# Example usage
symbol = "GOOGL"
start_date = "2023-01-01"
end_date = "2023-12-31"

stock_data = get_stock_data(symbol, start_date, end_date)

# Calculate some technical indicators
stock_data['SMA_20'] = stock_data['Close'].rolling(window=20).mean()
stock_data['SMA_50'] = stock_data['Close'].rolling(window=50).mean()

analysis_request = f"""
Analyze the following stock price data and technical indicators for {symbol} from {start_date} to {end_date}:

{stock_data.tail(30).to_string()}

Provide insights on the stock's price trends, potential support and resistance levels, and any notable trading signals based on the moving averages.
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example shows an AI agent that can fetch stock price data from Yahoo Finance, calculate some basic technical indicators, and perform a technical analysis.

### IEX Cloud

Let's create an agent that can work with IEX Cloud data to analyze company news sentiment.

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import requests

load_dotenv()

# IEX Cloud API setup
IEX_CLOUD_API_KEY = os.getenv("IEX_CLOUD_API_KEY")
IEX_CLOUD_BASE_URL = "https://cloud.iexapis.com/stable"

# OpenAI API setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="News-Sentiment-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in news sentiment analysis. Your task is to analyze company news and provide insights on the overall sentiment and potential impact on the stock.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_company_news(symbol, last_n):
    endpoint = f"{IEX_CLOUD_BASE_URL}/stock/{symbol}/news/last/{last_n}"
    params = {'token': IEX_CLOUD_API_KEY}
    response = requests.get(endpoint, params=params)
    return response.json()

# Example usage
symbol = "TSLA"
last_n = 10

news_data = get_company_news(symbol, last_n)

analysis_request = f"""
Analyze the following recent news articles for {symbol}:

{news_data}

Provide insights on the overall sentiment of the news, potential impact on the stock price, and any notable trends or events mentioned.
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example demonstrates an AI agent that can fetch recent news data from IEX Cloud and perform a sentiment analysis on the company news.

### Finnhub

Finally, let's create an agent that can work with Finnhub data to analyze earnings estimates and recommendations.

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import finnhub

load_dotenv()

# Finnhub API setup
FINNHUB_API_KEY = os.getenv("FINNHUB_API_KEY")
finnhub_client = finnhub.Client(api_key=FINNHUB_API_KEY)

# OpenAI API setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Earnings-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in earnings analysis. Your task is to analyze earnings estimates and recommendations to provide insights on a company's financial outlook.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_earnings_estimates(symbol):
    return finnhub_client.earnings_calendar(symbol=symbol, from_date="2023-01-01", to_date="2023-12-31")

def get_recommendations(symbol):
    return finnhub_client.recommendation_trends(symbol)

# Example usage
symbol = "NVDA"

earnings_estimates = get_earnings_estimates(symbol)
recommendations = get_recommendations(symbol)

analysis_request = f"""
Analyze the following earnings estimates and recommendations for {symbol}:

Earnings Estimates:
{earnings_estimates}

Recommendations:
{recommendations}

Provide insights on the company's expected financial performance, analyst sentiment, and any notable trends in the recommendations.
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example shows an AI agent that can fetch earnings estimates and analyst recommendations from Finnhub and perform an analysis on the company's financial outlook.

## Advanced Analysis Techniques

To further enhance the capabilities of our AI agents, we can implement more advanced analysis techniques:

1. Multi-source analysis: Combine data from multiple providers to get a more comprehensive view of a stock or market.

2. Time series forecasting: Implement machine learning models for price prediction.

3. Sentiment analysis of social media: Incorporate data from social media platforms to gauge market sentiment.

4. Portfolio optimization: Use AI agents to suggest optimal portfolio allocations based on risk tolerance and investment goals.

5. Anomaly detection: Implement algorithms to detect unusual patterns or events in financial data.

Here's an example of how we might implement a multi-source analysis:

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import yfinance as yf
import requests
import pandas as pd

load_dotenv()

# API setup
POLYGON_API_KEY = os.getenv("POLYGON_API_KEY")
ALPHA_VANTAGE_API_KEY = os.getenv("ALPHA_VANTAGE_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Multi-Source-Analysis-Agent",
    system_prompt="You are a financial analysis AI assistant capable of analyzing data from multiple sources. Your task is to provide comprehensive insights on a stock based on various data points.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_stock_data_yf(symbol, start_date, end_date):
    stock = yf.Ticker(symbol)
    return stock.history(start=start_date, end=end_date)

def get_stock_data_polygon(symbol, from_date, to_date):
    endpoint = f"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{from_date}/{to_date}"
    params = {'apiKey': POLYGON_API_KEY, 'adjusted': 'true'}
    response = requests.get(endpoint, params=params)
    data = response.json()
    return pd.DataFrame(data['results'])

def get_company_overview_av(symbol):
    params = {
        'function': 'OVERVIEW',
        'symbol': symbol,
        'apikey': ALPHA_VANTAGE_API_KEY
    }
    response = requests.get("https://www.alphavantage.co/query", params=params)
    return response.json()

# Example usage
symbol = "AAPL"
start_date = "2023-01-01"
end_date = "2023-12-31"

yf_data = get_stock_data_yf(symbol, start_date, end_date)
polygon_data = get_stock_data_polygon(symbol, start_date, end_date)
av_overview = get_company_overview_av(symbol)

analysis_request = f"""
Analyze the following data for {symbol} from {start_date} to {end_date}:

Yahoo Finance Data:
{yf_data.tail().to_string()}

Polygon.io Data:
{polygon_data.tail().to_string()}

Alpha Vantage Company Overview:
{av_overview}

Provide a comprehensive analysis of the stock, including:
1. Price trends and volatility
2. Trading volume analysis
3. Fundamental analysis based on the company overview
4. Any discrepancies between data sources and potential reasons
5. Overall outlook and potential risks/opportunities
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This multi-source analysis example combines data from Yahoo Finance, Polygon.io, and Alpha Vantage to provide a more comprehensive view of a stock. The AI agent can then analyze this diverse set of data to provide deeper insights.

Now, let's explore some additional advanced analysis techniques:

### Time Series Forecasting

We can implement a simple time series forecasting model using the Prophet library and integrate it with our AI agent:

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import yfinance as yf
import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

agent = Agent(
    agent_name="Time-Series-Forecast-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in time series forecasting. Your task is to analyze stock price predictions and provide insights.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_stock_data(symbol, start_date, end_date):
    stock = yf.Ticker(symbol)
    data = stock.history(start=start_date, end=end_date)
    return data

def forecast_stock_price(data, periods=30):
    df = data.reset_index()[['Date', 'Close']]
    df.columns = ['ds', 'y']
    
    model = Prophet()
    model.fit(df)
    
    future = model.make_future_dataframe(periods=periods)
    forecast = model.predict(future)
    
    fig = model.plot(forecast)
    plt.savefig('forecast_plot.png')
    plt.close()
    
    return forecast

# Example usage
symbol = "MSFT"
start_date = "2020-01-01"
end_date = "2023-12-31"

stock_data = get_stock_data(symbol, start_date, end_date)
forecast = forecast_stock_price(stock_data)

analysis_request = f"""
Analyze the following time series forecast for {symbol}:

Forecast Data:
{forecast.tail(30).to_string()}

The forecast plot has been saved as 'forecast_plot.png'.

Provide insights on:
1. The predicted trend for the stock price
2. Any seasonal patterns observed
3. Potential factors that might influence the forecast
4. Limitations of this forecasting method
5. Recommendations for investors based on this forecast
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example demonstrates how to integrate a time series forecasting model (Prophet) with our AI agent. The agent can then provide insights based on the forecasted data.

### Sentiment Analysis of Social Media

We can use a pre-trained sentiment analysis model to analyze tweets about a company and integrate this with our AI agent:

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import tweepy
from textblob import TextBlob
import pandas as pd

load_dotenv()

# Twitter API setup
TWITTER_API_KEY = os.getenv("TWITTER_API_KEY")
TWITTER_API_SECRET = os.getenv("TWITTER_API_SECRET")
TWITTER_ACCESS_TOKEN = os.getenv("TWITTER_ACCESS_TOKEN")
TWITTER_ACCESS_TOKEN_SECRET = os.getenv("TWITTER_ACCESS_TOKEN_SECRET")

auth = tweepy.OAuthHandler(TWITTER_API_KEY, TWITTER_API_SECRET)
auth.set_access_token(TWITTER_ACCESS_TOKEN, TWITTER_ACCESS_TOKEN_SECRET)
api = tweepy.API(auth)

# OpenAI setup
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

agent = Agent(
    agent_name="Social-Media-Sentiment-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in social media sentiment analysis. Your task is to analyze sentiment data from tweets and provide insights on market perception.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_tweets(query, count=100):
    tweets = api.search_tweets(q=query, count=count, tweet_mode="extended")
    return [tweet.full_text for tweet in tweets]

def analyze_sentiment(tweets):
    sentiments = [TextBlob(tweet).sentiment.polarity for tweet in tweets]
    return pd.DataFrame({'tweet': tweets, 'sentiment': sentiments})

# Example usage
symbol = "TSLA"
query = f"${symbol} stock"

tweets = get_tweets(query)
sentiment_data = analyze_sentiment(tweets)

analysis_request = f"""
Analyze the following sentiment data for tweets about {symbol} stock:

Sentiment Summary:
Positive tweets: {sum(sentiment_data['sentiment'] > 0)}
Negative tweets: {sum(sentiment_data['sentiment'] < 0)}
Neutral tweets: {sum(sentiment_data['sentiment'] == 0)}

Average sentiment: {sentiment_data['sentiment'].mean()}

Sample tweets and their sentiments:
{sentiment_data.head(10).to_string()}

Provide insights on:
1. The overall sentiment towards the stock
2. Any notable trends or patterns in the sentiment
3. Potential reasons for the observed sentiment
4. How this sentiment might impact the stock price
5. Limitations of this sentiment analysis method
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example shows how to perform sentiment analysis on tweets about a stock and integrate the results with our AI agent for further analysis.

### Portfolio Optimization

We can use the PyPortfolioOpt library to perform portfolio optimization and have our AI agent provide insights:

```python
import os
from swarms import Agent
from swarms.models import OpenAIChat
from dotenv import load_dotenv
import yfinance as yf
import pandas as pd
import numpy as np
from pypfopt import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

model = OpenAIChat(
    openai_api_key=OPENAI_API_KEY,
    model_name="gpt-4",
    temperature=0.1
)

agent = Agent(
    agent_name="Portfolio-Optimization-Agent",
    system_prompt="You are a financial analysis AI assistant specializing in portfolio optimization. Your task is to analyze optimized portfolio allocations and provide investment advice.",
    llm=model,
    max_loops=1,
    dashboard=False,
    verbose=True
)

def get_stock_data(symbols, start_date, end_date):
    data = yf.download(symbols, start=start_date, end=end_date)['Adj Close']
    return data

def optimize_portfolio(data):
    mu = expected_returns.mean_historical_return(data)
    S = risk_models.sample_cov(data)
    
    ef = EfficientFrontier(mu, S)
    weights = ef.max_sharpe()
    cleaned_weights = ef.clean_weights()
    
    return cleaned_weights

# Example usage
symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "FB"]
start_date = "2018-01-01"
end_date = "2023-12-31"

stock_data = get_stock_data(symbols, start_date, end_date)
optimized_weights = optimize_portfolio(stock_data)

analysis_request = f"""
Analyze the following optimized portfolio allocation:

{pd.Series(optimized_weights).to_string()}

The optimization aimed to maximize the Sharpe ratio based on historical data from {start_date} to {end_date}.

Provide insights on:
1. The recommended allocation and its potential benefits
2. Any notable concentrations or diversification in the portfolio
3. Potential risks associated with this allocation
4. How this portfolio might perform in different market conditions
5. Recommendations for an investor considering this allocation
6. Limitations of this optimization method
"""

analysis = agent.run(analysis_request)
print(analysis)
```

This example demonstrates how to perform portfolio optimization using the PyPortfolioOpt library and have our AI agent provide insights on the optimized allocation.

## Best Practices and Considerations

When using AI agents for financial data analysis, consider the following best practices:

1. Data quality: Ensure that the data you're feeding into the agents is accurate and up-to-date.

2. Model limitations: Be aware of the limitations of both the financial models and the AI models being used.

3. Regulatory compliance: Ensure that your use of AI in financial analysis complies with relevant regulations.

4. Ethical considerations: Be mindful of potential biases in AI models and strive for fair and ethical analysis.

5. Continuous monitoring: Regularly evaluate the performance of your AI agents and update them as needed.

6. Human oversight: While AI agents can provide valuable insights, human judgment should always play a role in financial decision-making.

7. Privacy and security: Implement robust security measures to protect sensitive financial data.

## Conclusion

The integration of AI agents with financial data APIs opens up exciting possibilities for advanced financial analysis. By leveraging the power of the Swarms framework and connecting it with various financial data providers, analysts and quants can gain deeper insights, automate complex analyses, and potentially make more informed investment decisions.

However, it's crucial to remember that while AI agents can process vast amounts of data and identify patterns that humans might miss, they should be used as tools to augment human decision-making rather than replace it entirely. The financial markets are complex systems influenced by numerous factors, many of which may not be captured in historical data or current models.

As the field of AI in finance continues to evolve, we can expect even more sophisticated analysis techniques and integrations. Staying updated with the latest developments in both AI and financial analysis will be key to leveraging these powerful tools effectively.

--------------------------------------------------

# File: guides/healthcare_blog.md

# Unlocking Efficiency and Cost Savings in Healthcare: How Swarms of LLM Agents Can Revolutionize Medical Operations and Save Millions

The healthcare industry is a complex ecosystem where time and money are critical. From administrative tasks to patient care, medical professionals often struggle to keep up with mounting demands, leading to inefficiencies that cost both time and money. Swarms of Large Language Model (LLM) agents represent a groundbreaking solution to these problems. By leveraging artificial intelligence in the form of swarms, healthcare organizations can automate various tasks, optimize processes, and dramatically improve both the quality of care and operational efficiency.

In this comprehensive analysis, we will explore how swarms of LLM agents can help healthcare and medical organizations save millions of dollars and thousands of hours annually. We will provide precise estimations based on industry data, calculate potential savings, and outline various use cases. Additionally, mermaid diagrams will be provided to illustrate swarm architectures, and reference links to Swarms GitHub and other resources will be included.

### 1. Administrative Automation

#### Use Case: Billing and Claims Processing

Administrative work is a major time drain in the healthcare sector, especially when it comes to billing and claims processing. The process is traditionally labor-intensive, requiring human staff to manually review and process claims, which often results in errors, delays, and higher operational costs.

**How Swarms of LLM Agents Can Help:**
Swarms of LLM agents can automate the entire billing and claims process, from coding procedures to filing claims with insurance companies. These agents can read medical records, understand the diagnosis codes (ICD-10), and automatically generate billing forms. With intelligent claims management, LLM agents can also follow up with insurance companies to ensure timely payment.

**Estimated Savings:**

- Average cost per manual claim: $25

- Average claims per hospital: 10,000 per month

- Swarms of LLM agents can reduce processing time by 90% and errors by 95%

- Estimated annual savings per hospital: 

    - Savings per claim: $22.5 (90% reduction)

    - Total annual savings: 10,000 claims/month × 12 months × $22.5 = **$2.7 million**


#### Billing and Claims Processing Swarm
```mermaid
graph TD;
    A[Medical Records] --> B[ICD-10 Coding Agent];
    B --> C[Billing Form Agent];
    C --> D[Claims Submission Agent];
    D --> E[Insurance Follow-up Agent];
    E --> F[Payment Processing];
```

### 2. Enhancing Clinical Decision Support

#### Use Case: Diagnostic Assistance

Doctors are increasingly turning to AI to assist in diagnosing complex medical conditions. Swarms of LLM agents can be trained to analyze patient data, laboratory results, and medical histories to assist doctors in making more accurate diagnoses.

**How Swarms of LLM Agents Can Help:**
A swarm of LLM agents can scan through thousands of medical records, journals, and patient histories to identify patterns or suggest rare diagnoses. These agents work collaboratively to analyze test results, compare symptoms with a vast medical knowledge base, and provide doctors with a list of probable diagnoses and recommended tests.

**Estimated Savings:**

- Time saved per diagnosis: 2 hours per patient

- Average patient cases per hospital: 5,000 per year

- Time saved annually: 2 × 5,000 = 10,000 hours

- Doctor's hourly rate: $150

- Total annual savings: 10,000 × $150 = **$1.5 million**


#### Diagnostic Swarm
```mermaid
graph TD;
    A[Patient Data] --> B[Lab Results];
    A --> C[Medical History];
    B --> D[Symptom Analysis Agent];
    C --> E[Pattern Recognition Agent];
    D --> F[Diagnosis Suggestion Agent];
    E --> F;
    F --> G[Doctor];
```

### 3. Streamlining Patient Communication

#### Use Case: Patient Follow-ups and Reminders

Timely communication with patients is critical for maintaining healthcare quality, but it can be extremely time-consuming for administrative staff. Missed appointments and delayed follow-ups lead to poor patient outcomes and lost revenue.

**How Swarms of LLM Agents Can Help:**
LLM agents can handle patient follow-ups by sending reminders for appointments, check-ups, and medication refills. Additionally, these agents can answer common patient queries, thereby reducing the workload for human staff. These agents can be connected to Electronic Health Record (EHR) systems to monitor patient data and trigger reminders based on predefined criteria.

**Estimated Savings:**

- Average cost per patient follow-up: $5

- Number of follow-ups: 20,000 annually per hospital

- Swarm efficiency: 90% reduction in manual effort

- Total annual savings: 20,000 × $4.5 = **$90,000**


#### Patient Follow-up Swarm
```mermaid
graph TD;
    A[Patient Data from EHR] --> B[Appointment Reminder Agent];
    A --> C[Medication Reminder Agent];
    B --> D[Automated Text/Email];
    C --> D;
    D --> E[Patient];
```

### 4. Optimizing Inventory Management

#### Use Case: Pharmaceutical Stock Management

Hospitals often struggle with managing pharmaceutical inventory efficiently. Overstocking leads to wasted resources, while understocking can be a critical problem for patient care.

**How Swarms of LLM Agents Can Help:**
A swarm of LLM agents can predict pharmaceutical needs by analyzing patient data, historical inventory usage, and supplier delivery times. These agents can dynamically adjust stock levels, automatically place orders, and ensure that hospitals have the right medications at the right time.

**Estimated Savings:**

- Annual waste due to overstocking: $500,000 per hospital

- Swarm efficiency: 80% reduction in overstocking

- Total annual savings: $500,000 × 0.8 = **$400,000**


#### Inventory Management Swarm
```mermaid
graph TD;
    A[Patient Admission Data] --> B[Inventory Prediction Agent];
    B --> C[Stock Adjustment Agent];
    C --> D[Supplier Ordering Agent];
    D --> E[Pharmacy];
```

### 5. Improving Clinical Research

#### Use Case: Literature Review and Data Analysis

Medical researchers spend a significant amount of time reviewing literature and analyzing clinical trial data. Swarms of LLM agents can assist by rapidly scanning through research papers, extracting relevant information, and even suggesting areas for further investigation.

**How Swarms of LLM Agents Can Help:**
These agents can be trained to perform literature reviews, extract relevant data, and cross-reference findings with ongoing clinical trials. LLM agents can also simulate clinical trial results by analyzing historical data, offering valuable insights before actual trials commence.

**Estimated Savings:**

- Average time spent on literature review per paper: 5 hours

- Number of papers reviewed annually: 1,000

- Time saved: 80% reduction in review time

- Total time saved: 1,000 × 5 × 0.8 = 4,000 hours

- Researcher's hourly rate: $100

- Total annual savings: 4,000 × $100 = **$400,000**


#### Clinical Research Swarm
```mermaid
graph TD;
    A[Research Papers] --> B[Data Extraction Agent];
    B --> C[Cross-reference Agent];
    C --> D[Simulation Agent];
    D --> E[Researcher];
```

### 6. Automating Medical Record Keeping

#### Use Case: EHR Management and Documentation

Healthcare providers spend a significant amount of time inputting and managing Electronic Health Records (EHR). Manual entry often results in errors and takes away from the time spent with patients.

**How Swarms of LLM Agents Can Help:**
Swarms of LLM agents can automate the documentation process by transcribing doctor-patient interactions, updating EHRs in real-time, and even detecting errors in the documentation. These agents can integrate with voice recognition systems to create seamless workflows, freeing up more time for healthcare providers to focus on patient care.

**Estimated Savings:**

- Average time spent on EHR per patient: 20 minutes

- Number of patients annually: 30,000

- Time saved: 80% reduction in manual effort

- Total time saved: 30,000 × 20 minutes × 0.8 = 480,000 minutes or 8,000 hours

- Provider's hourly rate: $150

- Total annual savings: 8,000 × $150 = **$1.2 million**


#### EHR Management Swarm
```mermaid
graph TD;
    A[Doctor-Patient Interaction] --> B[Voice-to-Text Agent];
    B --> C[EHR Update Agent];
    C --> D[Error Detection Agent];
    D --> E[EHR System];
```

### 7. Reducing Diagnostic Errors

#### Use Case: Medical Imaging Analysis

Medical imaging, such as MRI and CT scans, requires expert interpretation, which can be both time-consuming and prone to errors. Misdiagnoses or delays in interpretation can lead to prolonged treatment times and increased costs.

**How Swarms of LLM Agents Can Help:**
Swarms of LLM agents trained in computer vision can analyze medical images more accurately and faster than human radiologists. These agents can compare current scans with historical data, detect anomalies, and provide a diagnosis within minutes. Additionally, the swarm can escalate complex cases to human experts when necessary.

**Estimated Savings:**

- Time saved per scan: 30 minutes

- Number of scans annually: 10,000

- Time saved: 10,000 × 30 minutes = 5,000 hours

- Radiologist's hourly rate: $200

- Total annual savings: 5,000 × $


200 = **$1 million**

#### Medical Imaging Swarm
```mermaid
graph TD;
    A[Medical Image] --> B[Anomaly Detection Agent];
    B --> C[Comparison with Historical Data Agent];
    C --> D[Diagnosis Suggestion Agent];
    D --> E[Radiologist Review];
```

### Conclusion: The Financial and Time-Saving Impact of LLM Swarms in Healthcare


In this comprehensive analysis, we explored how swarms of LLM agents can revolutionize the healthcare and medical industries by automating complex, labor-intensive tasks that currently drain both time and resources. From billing and claims processing to diagnostic assistance, patient communication, and medical imaging analysis, these intelligent agents can work collaboratively to significantly improve efficiency while reducing costs. Through our detailed calculations, it is evident that healthcare organizations could save upwards of $7.29 million annually, along with thousands of hours in administrative and clinical work.

Swarms of LLM agents not only promise financial savings but also lead to improved patient outcomes, streamlined research, and enhanced operational workflows. By adopting these agentic solutions, healthcare organizations can focus more on their mission of providing high-quality care while ensuring their systems run seamlessly and efficiently.

To explore more about how swarms of agents can be tailored to your healthcare operations, you can visit the [Swarms GitHub](https://github.com/kyegomez/swarms) for code and documentation, explore our [Swarms Website](https://swarms.world) for further insights, and if you're ready to implement these solutions in your organization, feel free to [book a call](https://cal.com/swarms) for a personalized consultation.

The future of healthcare is agentic, and by embracing swarms of LLM agents, your organization can unlock unprecedented levels of productivity and savings.

Swarms of LLM agents offer a powerful solution for medical and healthcare organizations looking to reduce costs and save time. Through automation, these agents can optimize everything from administrative tasks to clinical decision-making and inventory management. Based on the estimates provided, healthcare organizations can potentially save millions of dollars annually, all while improving the quality of care provided to patients.

The table below summarizes the estimated savings for each use case:

| Use Case                          | Estimated Annual Savings |
|------------------------------------|--------------------------|
| Billing and Claims Processing      | $2.7 million             |
| Diagnostic Assistance              | $1.5 million             |
| Patient Follow-ups and Reminders   | $90,000                  |
| Pharmaceutical Stock Management    | $400,000                 |
| Clinical Research                  | $400,000                 |
| EHR Management and Documentation   | $1.2 million             |
| Medical Imaging Analysis           | $1 million               |
| **Total Estimated Savings**        | **$7.29 million**        |

### References
- [Swarms GitHub](https://github.com/kyegomez/swarms)

- [Swarms Website](https://swarms.xyz)

- [book a call](https://cal.com/swarms) 

- Swarms Discord: https://discord.gg/swarms

- Swarms Twitter: https://x.com/swarms_corp

- Swarms Spotify: https://open.spotify.com/show/2HLiswhmUaMdjHC8AUHcCF?si=c831ef10c5ef4994

Swarms Blog: https://medium.com/@kyeg
Swarms Website: https://swarms.xyz 

By adopting swarms of LLM agents, healthcare organizations can streamline operations, reduce inefficiencies, and focus on what truly matters—delivering top-notch patient care.



--------------------------------------------------

# File: guides/pricing.md

# Comparing LLM Provider Pricing: A Guide for Enterprises

Large language models (LLMs) have become a cornerstone of innovation for enterprises across various industries. 

As executives contemplate which model to integrate into their operations, understanding the intricacies of LLM provider pricing is crucial. 

This comprehensive guide delves into the tactical business considerations, unit economics, profit margins, and ROI calculations that will empower decision-makers to deploy the right AI solution for their organization.

## Table of Contents

1. [Introduction to LLM Pricing Models](#introduction-to-llm-pricing-models)
2. [Understanding Unit Economics in LLM Deployment](#understanding-unit-economics-in-llm-deployment)
3. [Profit Margins and Cost Structures](#profit-margins-and-cost-structures)
4. [LLM Pricing in Action: Case Studies](#llm-pricing-in-action-case-studies)
5. [Calculating ROI for LLM Integration](#calculating-roi-for-llm-integration)
6. [Comparative Analysis of Major LLM Providers](#comparative-analysis-of-major-llm-providers)
7. [Hidden Costs and Considerations](#hidden-costs-and-considerations)
8. [Optimizing LLM Usage for Cost-Efficiency](#optimizing-llm-usage-for-cost-efficiency)
9. [Future Trends in LLM Pricing](#future-trends-in-llm-pricing)
10. [Strategic Decision-Making Framework](#strategic-decision-making-framework)
11. [Conclusion: Navigating the LLM Pricing Landscape](#conclusion-navigating-the-llm-pricing-landscape)

## 1. Introduction to LLM Pricing Models

The pricing of Large Language Models (LLMs) is a complex landscape that can significantly impact an enterprise's bottom line. As we dive into this topic, it's crucial to understand the various pricing models employed by LLM providers and how they align with different business needs.

### Pay-per-Token Model

The most common pricing structure in the LLM market is the pay-per-token model. In this system, businesses are charged based on the number of tokens processed by the model. A token can be as short as one character or as long as one word, depending on the language and the specific tokenization method used by the model.

**Advantages:**
- Scalability: Costs scale directly with usage, allowing for flexibility as demand fluctuates.
- Transparency: Easy to track and attribute costs to specific projects or departments.

**Disadvantages:**
- Unpredictability: Costs can vary significantly based on the verbosity of inputs and outputs.
- Potential for overruns: Without proper monitoring, costs can quickly escalate.

### Subscription-Based Models

Some providers offer subscription tiers that provide a set amount of compute resources or tokens for a fixed monthly or annual fee.

**Advantages:**
- Predictable costs: Easier budgeting and financial planning.
- Potential cost savings: Can be more economical for consistent, high-volume usage.

**Disadvantages:**
- Less flexibility: May lead to underutilization or overages.
- Commitment required: Often involves longer-term contracts.

### Custom Enterprise Agreements

For large-scale deployments, providers may offer custom pricing agreements tailored to the specific needs of an enterprise.

**Advantages:**
- Optimized for specific use cases: Can include specialized support, SLAs, and pricing structures.
- Potential for significant cost savings at scale.

**Disadvantages:**
- Complexity: Negotiating and managing these agreements can be resource-intensive.
- Less standardization: Difficult to compare across providers.

### Hybrid Models

Some providers are beginning to offer hybrid models that combine elements of pay-per-token and subscription-based pricing.

**Advantages:**
- Flexibility: Can adapt to varying usage patterns.
- Risk mitigation: Balances the benefits of both main pricing models.

**Disadvantages:**
- Complexity: Can be more challenging to understand and manage.
- Potential for suboptimal pricing if not carefully structured.

As we progress through this guide, we'll explore how these pricing models interact with various business considerations and how executives can leverage this understanding to make informed decisions.

## 2. Understanding Unit Economics in LLM Deployment

To make informed decisions about LLM deployment, executives must have a clear grasp of the unit economics involved. This section breaks down the components that contribute to the cost per unit of LLM usage and how they impact overall business economics.

### Defining the Unit

In the context of LLMs, a "unit" can be defined in several ways:

1. **Per Token**: The most granular unit, often used in pricing models.
2. **Per Request**: A single API call to the LLM, which may process multiple tokens.
3. **Per Task**: A complete operation, such as generating a summary or answering a question, which may involve multiple requests.
4. **Per User Interaction**: In customer-facing applications, this could be an entire conversation or session.

Understanding which unit is most relevant to your use case is crucial for accurate economic analysis.

### Components of Unit Cost

1. **Direct LLM Costs**
   - Token processing fees
   - API call charges
   - Data transfer costs

2. **Indirect Costs**
   - Compute resources for pre/post-processing
   - Storage for inputs, outputs, and fine-tuning data
   - Networking costs

3. **Operational Costs**
   - Monitoring and management tools
   - Integration and maintenance engineering time
   - Customer support related to AI functions

4. **Overhead**
   - Legal and compliance costs
   - Training and documentation
   - Risk management and insurance

### Calculating Unit Economics

To calculate the true unit economics, follow these steps:

1. **Determine Total Costs**: Sum all direct, indirect, operational, and overhead costs over a fixed period (e.g., monthly).

2. **Measure Total Units**: Track the total number of relevant units processed in the same period.

3. **Calculate Cost per Unit**: Divide total costs by total units.

   ```
   Cost per Unit = Total Costs / Total Units
   ```

4. **Analyze Revenue per Unit**: If the LLM is part of a revenue-generating product, calculate the revenue attributed to each unit.

5. **Determine Profit per Unit**: Subtract the cost per unit from the revenue per unit.

   ```
   Profit per Unit = Revenue per Unit - Cost per Unit
   ```

### Example Calculation

Let's consider a hypothetical customer service AI chatbot:

- Monthly LLM API costs: $10,000
- Indirect and operational costs: $5,000
- Total monthly interactions: 100,000

```
Cost per Interaction = ($10,000 + $5,000) / 100,000 = $0.15
```

If each interaction generates an average of $0.50 in value (through cost savings or revenue):

```
Profit per Interaction = $0.50 - $0.15 = $0.35
```

### Economies of Scale

As usage increases, unit economics often improve due to:

- Volume discounts from LLM providers
- Amortization of fixed costs over more units
- Efficiency gains through learning and optimization

However, it's crucial to model how these economies of scale manifest in your specific use case, as they may plateau or even reverse at very high volumes due to increased complexity and support needs.

### Diseconomies of Scale

Conversely, be aware of potential diseconomies of scale:

- Increased complexity in managing large-scale deployments
- Higher costs for specialized talent as operations grow
- Potential for diminishing returns on very large language models

By thoroughly understanding these unit economics, executives can make more informed decisions about which LLM provider and pricing model best aligns with their business objectives and scale.

## 3. Profit Margins and Cost Structures

Understanding profit margins and cost structures is crucial for executives evaluating LLM integration. This section explores how different pricing models and operational strategies can impact overall profitability.

### Components of Profit Margin

1. **Gross Margin**: The difference between revenue and the direct costs of LLM usage.
   ```
   Gross Margin = Revenue - Direct LLM Costs
   Gross Margin % = (Gross Margin / Revenue) * 100
   ```

2. **Contribution Margin**: Gross margin minus variable operational costs.
   ```
   Contribution Margin = Gross Margin - Variable Operational Costs
   ```

3. **Net Margin**: The final profit after all costs, including fixed overheads.
   ```
   Net Margin = Contribution Margin - Fixed Costs
   Net Margin % = (Net Margin / Revenue) * 100
   ```

### Cost Structures in LLM Deployment

1. **Fixed Costs**
   - Subscription fees for LLM access (if using a subscription model)
   - Base infrastructure costs
   - Core team salaries
   - Licensing fees for essential software

2. **Variable Costs**
   - Per-token or per-request charges
   - Scaling infrastructure costs
   - Usage-based API fees
   - Performance-based team bonuses

3. **Step Costs**
   - Costs that increase in chunks as usage scales
   - Examples: Adding new server clusters, hiring additional support staff

### Analyzing Profit Margins Across Different Pricing Models

Let's compare how different LLM pricing models might affect profit margins for a hypothetical AI-powered writing assistant service:

**Scenario**: The service charges users $20/month and expects to process an average of 100,000 tokens per user per month.

1. **Pay-per-Token Model**
   - LLM cost: $0.06 per 1,000 tokens
   - Monthly LLM cost per user: $6
   - Gross margin per user: $14 (70%)

2. **Subscription Model**
   - Fixed monthly fee: $5,000 for up to 10 million tokens
   - At 1,000 users: $5 per user
   - Gross margin per user: $15 (75%)

3. **Hybrid Model**
   - Base fee: $2,000 per month
   - Reduced per-token rate: $0.04 per 1,000 tokens
   - Monthly LLM cost per user: $6 ($2 base + $4 usage)
   - Gross margin per user: $14 (70%)

### Strategies for Improving Profit Margins

1. **Optimize Token Usage**
   - Implement efficient prompting techniques
   - Cache common responses
   - Use compression algorithms for inputs and outputs

2. **Leverage Economies of Scale**
   - Negotiate better rates at higher volumes
   - Spread fixed costs across a larger user base

3. **Implement Tiered Pricing**
   - Offer different service levels to capture more value from power users
   - Example: Basic ($10/month, 50K tokens), Pro ($30/month, 200K tokens)

4. **Vertical Integration**
   - Invest in proprietary LLM development for core functionalities
   - Reduce dependency on third-party providers for critical operations

5. **Smart Caching and Pre-computation**
   - Store and reuse common LLM outputs
   - Perform batch processing during off-peak hours

6. **Hybrid Cloud Strategies**
   - Use on-premises solutions for consistent workloads
   - Leverage cloud elasticity for demand spikes

### Case Study: Margin Improvement

Consider a company that initially used a pay-per-token model:

**Initial State:**
- Revenue per user: $20
- LLM cost per user: $6
- Other variable costs: $4
- Fixed costs per user: $5
- Net margin per user: $5 (25%)

**After Optimization:**
- Implemented efficient prompting: Reduced token usage by 20%
- Negotiated volume discount: 10% reduction in per-token price
- Introduced tiered pricing: Average revenue per user increased to $25
- Optimized operations: Reduced other variable costs to $3

**Result:**
- New LLM cost per user: $4.32
- New net margin per user: $12.68 (50.7%)

This case study demonstrates how a holistic approach to margin improvement, addressing both revenue and various cost components, can significantly enhance profitability.

Understanding these profit margin dynamics and cost structures is essential for executives to make informed decisions about LLM integration and to continuously optimize their AI-powered services for maximum profitability.

## 4. LLM Pricing in Action: Case Studies

To provide a concrete understanding of how LLM pricing models work in real-world scenarios, let's examine several case studies across different industries and use cases. These examples will illustrate the interplay between pricing models, usage patterns, and business outcomes.

### Case Study 1: E-commerce Product Description Generator

**Company**: GlobalMart, a large online retailer
**Use Case**: Automated generation of product descriptions
**LLM Provider**: GPT-4o

**Pricing Model**: Pay-per-token
- Input: $5.00 per 1M tokens
- Output: $15.00 per 1M tokens

**Usage Pattern**:
- Average input: 50 tokens per product (product attributes)
- Average output: 200 tokens per product (generated description)
- Daily products processed: 10,000

**Daily Cost Calculation**:
1. Input cost: (50 tokens * 10,000 products) / 1M * $5.00 = $2.50
2. Output cost: (200 tokens * 10,000 products) / 1M * $15.00 = $30.00
3. Total daily cost: $32.50

**Business Impact**:
- Reduced time to market for new products by 70%
- Improved SEO performance due to unique, keyword-rich descriptions
- Estimated daily value generated: $500 (based on increased sales and efficiency)

**ROI Analysis**:
- Daily investment: $32.50
- Daily return: $500
- ROI = (Return - Investment) / Investment * 100 = 1,438%

**Key Takeaway**: The pay-per-token model works well for this use case due to the predictable and moderate token usage per task. The high ROI justifies the investment in a more advanced model like GPT-4o.

### Case Study 2: Customer Service Chatbot

**Company**: TechSupport Inc., a software company
**Use Case**: 24/7 customer support chatbot
**LLM Provider**: Claude 3.5 Sonnet

**Pricing Model**: Input: $3 per 1M tokens, Output: $15 per 1M tokens

**Usage Pattern**:
- Average conversation: 500 tokens input (customer queries + context), 1000 tokens output (bot responses)
- Daily conversations: 5,000

**Daily Cost Calculation**:
1. Input cost: (500 tokens * 5,000 conversations) / 1M * $3 = $7.50
2. Output cost: (1000 tokens * 5,000 conversations) / 1M * $15 = $75.00
3. Total daily cost: $82.50

**Business Impact**:
- Reduced customer wait times by 90%
- Resolved 70% of queries without human intervention
- Estimated daily cost savings: $2,000 (based on reduced human support hours)

**ROI Analysis**:
- Daily investment: $82.50
- Daily return: $2,000
- ROI = (Return - Investment) / Investment * 100 = 2,324%

**Key Takeaway**: The higher cost of Claude 3.5 Sonnet is justified by its superior performance in handling complex customer queries, resulting in significant cost savings and improved customer satisfaction.

### Case Study 3: Financial Report Summarization

**Company**: FinAnalyze, a financial services firm
**Use Case**: Automated summarization of lengthy financial reports
**LLM Provider**: GPT-3.5 Turbo

**Pricing Model**: Input: $0.50 per 1M tokens, Output: $1.50 per 1M tokens

**Usage Pattern**:
- Average report: 20,000 tokens input, 2,000 tokens output
- Daily reports processed: 100

**Daily Cost Calculation**:
1. Input cost: (20,000 tokens * 100 reports) / 1M * $0.50 = $100
2. Output cost: (2,000 tokens * 100 reports) / 1M * $1.50 = $30
3. Total daily cost: $130

**Business Impact**:
- Reduced analysis time by 80%
- Improved consistency in report summaries
- Enabled analysts to focus on high-value tasks
- Estimated daily value generated: $1,000 (based on time savings and improved decision-making)

**ROI Analysis**:
- Daily investment: $130
- Daily return: $1,000
- ROI = (Return - Investment) / Investment * 100 = 669%

**Key Takeaway**: The lower cost of GPT-3.5 Turbo is suitable for this task, which requires processing large volumes of text but doesn't necessarily need the most advanced language understanding. The high input token count makes the input pricing a significant factor in model selection.

### Case Study 4: AI-Powered Language Learning App

**Company**: LinguaLeap, an edtech startup
**Use Case**: Personalized language exercises and conversations
**LLM Provider**: Claude 3 Haiku

**Pricing Model**: Input: $0.25 per 1M tokens, Output: $1.25 per 1M tokens

**Usage Pattern**:
- Average session: 300 tokens input (user responses + context), 500 tokens output (exercises + feedback)
- Daily active users: 50,000
- Average sessions per user per day: 3

**Daily Cost Calculation**:
1. Input cost: (300 tokens * 3 sessions * 50,000 users) / 1M * $0.25 = $11.25
2. Output cost: (500 tokens * 3 sessions * 50,000 users) / 1M * $1.25 = $93.75
3. Total daily cost: $105

**Business Impact**:
- Increased user engagement by 40%
- Improved learning outcomes, leading to higher user retention
- Enabled scaling to new languages without proportional increase in human tutors
- Estimated daily revenue: $5,000 (based on subscription fees and in-app purchases)

**ROI Analysis**:
- Daily investment: $105
- Daily revenue: $5,000
- ROI = (Revenue - Investment) / Investment * 100 = 4,662%

**Key Takeaway**: The high-volume, relatively simple interactions in this use case make Claude 3 Haiku an excellent choice. Its low cost allows for frequent interactions without prohibitive expenses, which is crucial for an app relying on regular user engagement.

### Case Study 5: Legal Document Analysis

**Company**: LegalEagle LLP, a large law firm
**Use Case**: Contract review and risk assessment
**LLM Provider**: Claude 3 Opus

**Pricing Model**: Input: $15 per 1M tokens, Output: $75 per 1M tokens

**Usage Pattern**:
- Average contract: 10,000 tokens input, 3,000 tokens output (analysis and risk assessment)
- Daily contracts processed: 50

**Daily Cost Calculation**:
1. Input cost: (10,000 tokens * 50 contracts) / 1M * $15 = $7.50
2. Output cost: (3,000 tokens * 50 contracts) / 1M * $75 = $11.25
3. Total daily cost: $18.75

**Business Impact**:
- Reduced contract review time by 60%
- Improved accuracy in identifying potential risks
- Enabled handling of more complex cases
- Estimated daily value: $10,000 (based on time savings and improved risk management)

**ROI Analysis**:
- Daily investment: $18.75
- Daily value: $10,000
- ROI = (Value - Investment) / Investment * 100 = 53,233%

**Key Takeaway**: Despite the high cost per token, Claude 3 Opus's advanced capabilities justify its use in this high-stakes environment where accuracy and nuanced understanding are critical. The high value generated per task offsets the higher token costs.

These case studies demonstrate how different LLM providers and pricing models can be optimal for various use cases, depending on factors such as token volume, task complexity, and the value generated by the AI application. Executives should carefully consider these factors when selecting an LLM provider and pricing model for their specific needs.

## 5. Calculating ROI for LLM Integration

Calculating the Return on Investment (ROI) for LLM integration is crucial for executives to justify the expenditure and assess the business value of AI implementation. This section will guide you through the process of calculating ROI, considering both tangible and intangible benefits.

### The ROI Formula

The basic ROI formula is:

```
ROI = (Net Benefit / Cost of Investment) * 100
```

For LLM integration, we can expand this to:

```
ROI = ((Total Benefits - Total Costs) / Total Costs) * 100
```

### Identifying Benefits

1. **Direct Cost Savings**
   - Reduced labor costs
   - Decreased operational expenses
   - Lower error-related costs

2. **Revenue Increases**
   - New product offerings enabled by LLM
   - Improved customer acquisition and retention
   - Upselling and cross-selling opportunities

3. **Productivity Gains**
   - Time saved on repetitive tasks
   - Faster decision-making processes
   - Improved employee efficiency

4. **Quality Improvements**
   - Enhanced accuracy in outputs
   - Consistency in service delivery
   - Reduced error rates

5. **Strategic Advantages**
   - Market differentiation
   - Faster time-to-market for new offerings
   - Improved competitive positioning

### Calculating Costs

1. **Direct LLM Costs**
   - API usage fees
   - Subscription costs

2. **Infrastructure Costs**
   - Cloud computing resources
   - Data storage
   - Networking expenses

3. **Integration and Development Costs**
   - Initial setup and integration
   - Ongoing maintenance and updates
   - Custom feature development

4. **Training and Support**
   - Employee training programs
   - User support and documentation
   - Change management initiatives

5. **Compliance and Security**
   - Data privacy measures
   - Security audits and implementations
   - Regulatory compliance efforts

### Step-by-Step ROI Calculation

1. **Define the Time Period**: Determine the timeframe for your ROI calculation (e.g., 1 year, 3 years).

2. **Estimate Total Benefits**:
   - Quantify direct cost savings and revenue increases
   - Assign monetary values to productivity gains and quality improvements
   - Estimate the value of strategic advantages (this may be more subjective)

3. **Calculate Total Costs**:
   - Sum up all direct and indirect costs related to LLM integration

4. **Apply the ROI Formula**:
   ```
   ROI = ((Total Benefits - Total Costs) / Total Costs) * 100
   ```

5. **Consider Time Value of Money**: For longer-term projections, use Net Present Value (NPV) to account for the time value of money.

### Example ROI Calculation

Let's consider a hypothetical customer service chatbot implementation:

**Time Period**: 1 year

**Benefits**:
- Labor cost savings: $500,000
- Increased sales from improved customer satisfaction: $300,000
- Productivity gains from faster query resolution: $200,000

Total Benefits: $1,000,000

**Costs**:
- LLM API fees: $100,000
- Integration and development: $150,000
- Training and support: $50,000
- Infrastructure: $50,000

Total Costs: $350,000

**ROI Calculation**:
```
ROI = (($1,000,000 - $350,000) / $350,000) * 100 = 185.7%
```

This indicates a strong positive return on investment, with benefits outweighing costs by a significant margin.

### Considerations for Accurate ROI Calculation

1. **Be Conservative in Estimates**: It's better to underestimate benefits and overestimate costs to provide a more realistic view.

2. **Account for Ramp-Up Time**: Full benefits may not be realized immediately. Consider a phased approach in your calculations.

3. **Include Opportunity Costs**: Consider the potential returns if the investment were made elsewhere.

4. **Factor in Risk**: Adjust your ROI based on the likelihood of achieving projected benefits.

5. **Consider Non-Financial Benefits**: Some benefits, like improved employee satisfaction or enhanced brand perception, may not have direct financial equivalents but are still valuable.

6. **Perform Sensitivity Analysis**: Calculate ROI under different scenarios (best case, worst case, most likely) to understand the range of possible outcomes.

7. **Benchmark Against Alternatives**: Compare the ROI of LLM integration against other potential investments or solutions.

### Long-Term ROI Considerations

While initial ROI calculations are crucial for decision-making, it's important to consider long-term implications:

1. **Scalability**: How will ROI change as usage increases?
2. **Technological Advancements**: Will newer, more efficient models become available?
3. **Market Changes**: How might shifts in the competitive landscape affect the value proposition?
4. **Regulatory Environment**: Could future regulations impact the cost or feasibility of LLM use?

By thoroughly calculating and analyzing the ROI of LLM integration, executives can make data-driven decisions about AI investments and set realistic expectations for the value these technologies can bring to their organizations.

## 6. Comparative Analysis of Major LLM Providers

In this section, we'll compare the offerings of major LLM providers, focusing on their pricing structures, model capabilities, and unique selling points. This analysis will help executives understand the landscape and make informed decisions about which provider best suits their needs.

### OpenAI

**Models**: GPT-4o, GPT-3.5 Turbo

**Pricing Structure**:
- Pay-per-token model
- Different rates for input and output tokens
- Bulk discounts available for high-volume users

**Key Features**:
- State-of-the-art performance on a wide range of tasks
- Regular model updates and improvements
- Extensive documentation and community support

**Considerations**:
- Higher pricing compared to some competitors
- Potential for rapid price changes as technology evolves
- Usage limits and approval process for higher-tier models

### Anthropic

**Models**: Claude 3.5 Sonnet, Claude 3 Opus, Claude 3 Haiku

**Pricing Structure**:
- Pay-per-token model
- Different rates for input and output tokens
- Tiered pricing based on model capabilities

**Key Features**:
- Strong focus on AI safety and ethics
- Long context windows (200K tokens)
- Specialized models for different use cases (e.g., Haiku for speed, Opus for complex tasks)

**Considerations**:
- Newer to the market compared to OpenAI
- Potentially more limited third-party integrations
- Strong emphasis on responsible AI use

### Google (Vertex AI)

**Models**: PaLM 2 for Chat, PaLM 2 for Text

**Pricing Structure**:
- Pay-per-thousand characters model
- Different rates for input and output
- Additional charges for advanced features (e.g., semantic retrieval)

**Key Features**:
- Integration with Google Cloud ecosystem
- Multi-modal capabilities (text, image, audio)
- Enterprise-grade security and compliance features

**Considerations**:
- Pricing can be complex due to additional Google Cloud costs
- Strong performance in specialized domains (e.g., coding, mathematical reasoning)
- Potential for integration with other Google services

### Amazon (Bedrock)

**Models**: Claude (Anthropic), Titan

**Pricing Structure**:
- Pay-per-second of compute time
- Additional charges for data transfer and storage

**Key Features**:
- Seamless integration with AWS services
- Access to multiple model providers through a single API
- Fine-tuning and customization options

**Considerations**:
- Pricing model can be less predictable for inconsistent workloads
- Strong appeal for existing AWS customers
- Potential for cost optimizations through AWS ecosystem

### Microsoft (Azure OpenAI Service)

**Models**: GPT-4, GPT-3.5 Turbo

**Pricing Structure**:
- Similar to OpenAI's pricing, but with Azure integration
- Additional costs for Azure services (e.g., storage, networking)

**Key Features**:
- Enterprise-grade security and compliance
- Integration with Azure AI services
- Access to fine-tuning and customization options

**Considerations**:
- Attractive for organizations already using Azure
- Potential for volume discounts through Microsoft Enterprise Agreements
- Additional overhead for Azure management

### Comparative Analysis

| Provider | Pricing Model | Strengths | Considerations |
|----------|---------------|-----------|----------------|
| OpenAI   | Pay-per-token | - Top performance<br>- Regular updates<br>- Strong community | - Higher costs<br>- Usage limits |
| Anthropic| Pay-per-token | - Ethical focus<br>- Long context<br>- Specialized models | - Newer provider<br>- Limited integrations |
| Google   | Pay-per-character | - Google Cloud integration<br>- Multi-modal<br>- Enterprise features | - Complex pricing<br>- Google ecosystem lock-in |
| Amazon   | Pay-per-compute time | - AWS integration<br>- Multiple providers<br>- Customization options | - Less predictable costs<br>- AWS ecosystem focus |
| Microsoft| Pay-per-token (Azure-based) | - Enterprise security<br>- Azure integration<br>- Fine-tuning options | - Azure overhead<br>- Potential lock-in |

### Factors to Consider in Provider Selection

1. **Performance Requirements**: Assess whether you need state-of-the-art performance or if a less advanced (and potentially cheaper) model suffices.

2. **Pricing Predictability**: Consider whether your usage patterns align better with token-based or compute-time-based pricing.

3. **Integration Needs**: Evaluate how well each provider integrates with your existing technology stack.

4. **Scalability**: Assess each provider's ability to handle your expected growth in usage.

5. **Customization Options**: Determine if you need fine-tuning or specialized model development capabilities.

6. **Compliance and Security**: Consider your industry-specific regulatory requirements and each provider's security offerings.

7. **Support and Documentation**: Evaluate the quality of documentation, community support, and enterprise-level assistance.

8. **Ethical Considerations**: Assess each provider's stance on AI ethics and responsible use.

9. **Lock-In Concerns**: Consider the long-term implications of committing to a specific provider or cloud ecosystem.

10. **Multi-Provider Strategy**: Evaluate the feasibility and benefits of using multiple providers for different use cases.

By carefully comparing these providers and considering the factors most relevant to your organization, you can make an informed decision that balances cost, performance, and strategic fit. Remember that the LLM landscape is rapidly evolving, so it's important to regularly reassess your choices and stay informed about new developments and pricing changes.

## 7. Hidden Costs and Considerations

When evaluating LLM providers and calculating the total cost of ownership, it's crucial to look beyond the advertised pricing and consider the hidden costs and additional factors that can significantly impact your budget and overall implementation success. This section explores these often-overlooked aspects to help executives make more comprehensive and accurate assessments.

### 1. Data Preparation and Cleaning

**Considerations**:
- Cost of data collection and aggregation
- Expenses related to data cleaning and normalization
- Ongoing data maintenance and updates

**Impact**:
- Can be time-consuming and labor-intensive
- May require specialized tools or personnel
- Critical for model performance and accuracy

### 2. Fine-Tuning and Customization

**Considerations**:
- Costs associated with creating custom datasets
- Compute resources required for fine-tuning
- Potential need for specialized ML expertise

**Impact**:
- Can significantly improve model performance for specific tasks
- May lead to better ROI in the long run
- Increases initial implementation costs

### 3. Integration and Development

**Considerations**:
- Engineering time for API integration
- Development of custom interfaces or applications
- Ongoing maintenance and updates

**Impact**:
- Can be substantial, especially for complex integrations
- May require hiring additional developers or consultants
- Critical for seamless user experience and workflow integration

### 4. Monitoring and Optimization

**Considerations**:
- Tools and systems for performance monitoring
- Regular audits and optimizations
- Costs associated with debugging and troubleshooting

**Impact**:
- Ongoing expense that increases with scale
- Essential for maintaining efficiency and cost-effectiveness
- Can lead to significant savings through optimized usage

### 5. Compliance and Security

**Considerations**:
- Legal counsel for data privacy and AI regulations
- Implementation of security measures (e.g., encryption, access controls)
- Regular audits and certifications

**Impact**:
- Can be substantial, especially in heavily regulated industries
- Critical for risk management and maintaining customer trust
- May limit certain use cases or require additional safeguards

### 6. Training and Change Management

- Employee training programs
- Development of user guides and documentation
- Change management initiatives

**Impact**:
- Often underestimated but crucial for adoption
- Can affect productivity during the transition period
- Important for realizing the full potential of LLM integration

### 7. Scaling Costs

**Considerations**:
- Potential price increases as usage grows
- Need for additional infrastructure or resources
- Costs associated with managing increased complexity

**Impact**:
- Can lead to unexpected expenses if not properly forecasted
- May require renegotiation of contracts or switching providers
- Important to consider in long-term planning

### 8. Opportunity Costs

**Considerations**:
- Time and resources diverted from other projects
- Potential missed opportunities due to focus on LLM implementation
- Learning curve and productivity dips during adoption

**Impact**:
- Difficult to quantify but important to consider
- Can affect overall business strategy and priorities
- May influence timing and scope of LLM integration

### 9. Vendor Lock-in

**Considerations**:
- Costs associated with switching providers
- Dependency on provider-specific features or integrations
- Potential for price increases once deeply integrated

**Impact**:
- Can limit flexibility and negotiating power
- May affect long-term costs and strategic decisions
- Important to consider multi-provider or portable implementation strategies

### 10. Ethical and Reputational Considerations

**Considerations**:
- Potential backlash from AI-related controversies
- Costs of ensuring ethical AI use and transparency
- Investments in responsible AI practices

**Impact**:
- Can affect brand reputation and customer trust
- May require ongoing public relations efforts
- Important for long-term sustainability and social responsibility

By carefully considering these hidden costs and factors, executives can develop a more comprehensive understanding of the total investment required for successful LLM integration. This holistic approach allows for better budgeting, risk management, and strategic planning.

## Conclusion: Navigating the LLM Pricing Landscape

As we've explored throughout this guide, the landscape of LLM provider pricing is complex and multifaceted. From understanding the basic pricing models to calculating ROI and considering hidden costs, there are numerous factors that executives must weigh when making decisions about AI integration.

Key takeaways include:

1. The importance of aligning LLM selection with specific business needs and use cases.
2. The need for thorough ROI analysis that goes beyond simple cost calculations.
3. The value of considering both short-term implementation costs and long-term scalability.
4. The critical role of hidden costs in determining the true total cost of ownership.
5. The potential for significant business value when LLMs are strategically implemented and optimized.

As the AI landscape continues to evolve rapidly, staying informed and adaptable is crucial. What may be the best choice today could change as new models are released, pricing structures shift, and your organization's needs evolve.

To help you navigate these complexities and make the most informed decisions for your enterprise, we invite you to take the next steps in your AI journey:

1. **Book a Consultation**: Speak with our enterprise-grade LLM specialists who can provide personalized insights and recommendations tailored to your specific needs. Schedule a 15-minute call at [https://cal.com/swarms/15min](https://cal.com/swarms/15min).

2. **Join Our Community**: Connect with fellow AI executives, share experiences, and stay updated on the latest developments in the LLM space. Join our Discord community at [https://discord.gg/yxU9t9da](https://discord.gg/yxU9t9da).

By leveraging expert guidance and peer insights, you can position your organization to make the most of LLM technologies while optimizing costs and maximizing value. The future of AI in enterprise is bright, and with the right approach, your organization can be at the forefront of this transformative technology.

--------------------------------------------------

# File: index.md

# Welcome to Swarms Docs Home

[![Join our Discord](https://img.shields.io/badge/Discord-Join%20our%20server-5865F2?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/jM3Z6M9uMq) [![Subscribe on YouTube](https://img.shields.io/badge/YouTube-Subscribe-red?style=for-the-badge&logo=youtube&logoColor=white)](https://www.youtube.com/@kyegomez3242) [![Connect on LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?style=for-the-badge&logo=linkedin&logoColor=white)](https://www.linkedin.com/in/kye-g-38759a207/) [![Follow on X.com](https://img.shields.io/badge/X.com-Follow-1DA1F2?style=for-the-badge&logo=x&logoColor=white)](https://x.com/kyegomezb)

## Swarms Installation

```bash
pip3 install swarms
```

## Update Swarms


```bash
pip3 install -U swarms
```

### **Get Started Building Production-Grade Multi-Agent Applications**

## Onboarding

| Section              | Links                                                                                      |
|----------------------|--------------------------------------------------------------------------------------------|
| Installation    | [Installation](https://docs.swarms.world/en/latest/swarms/install/install/)                                                            |
| Quickstart | [Get Started](https://docs.swarms.world/en/latest/swarms/install/quickstart/)                                                 |
| Environment Setup | [Environment Configuration](https://docs.swarms.world/en/latest/swarms/install/workspace_manager/)                                                 |
| Environment Variables | [Environment Variables](https://docs.swarms.world/en/latest/swarms/install/env/)                                                 |
| Swarms CLI | [CLI Documentation](https://docs.swarms.world/en/latest/swarms/cli/main/)                                                 |
| Agent Internal Mechanisms | [Agent Architecture](https://docs.swarms.world/en/latest/swarms/framework/agents_explained/)                                                 |
| Agent API | [Agent API](https://docs.swarms.world/en/latest/swarms/structs/agent/)                                                 |
| Managing Prompts in Production | [Prompts Management](https://docs.swarms.world/en/latest/swarms/prompts/main/)                                                 |
| Integrating External Agents | [External Agents Integration](https://docs.swarms.world/en/latest/swarms/agents/external_party_agents/)                                                 |
| Creating Agents from YAML | [YAML Agent Creation](https://docs.swarms.world/en/latest/swarms/agents/create_agents_yaml/)                                                 |
| Why You Need Swarms | [Why MultiAgent Collaboration](https://docs.swarms.world/en/latest/swarms/concept/why/)                                                 |
| Swarm Architectures Analysis | [Swarm Architectures](https://docs.swarms.world/en/latest/swarms/concept/swarm_architectures/)                                                 |
| Choosing the Right Swarm | [How to Choose Swarms](https://docs.swarms.world/en/latest/swarms/concept/how_to_choose_swarms/)                                                 |
| Full API Reference | [API Reference](https://docs.swarms.world/en/latest/swarms/framework/reference/)                                                 |
| AgentRearrange Docs | [AgentRearrange](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)                                                 |


## Ecosystem

Here you'll find references about the Swarms framework, marketplace, community, and more to enable you to build your multi-agent applications.

| Section              | Links                                                                                      |
|----------------------|--------------------------------------------------------------------------------------------|
| Swarms Python Framework Docs     | [Framework Docs](https://docs.swarms.world/en/latest/swarms/install/install/)                                                            |
| Swarms Cloud API     | [Cloud API](https://docs.swarms.world/en/latest/swarms_cloud/launch/)                                                            |
| Swarms Marketplace API     | [Marketplace API](https://docs.swarms.world/en/latest/swarms_platform/)                                                            |
| Swarms Memory Systems     | [Memory Systems](https://docs.swarms.world/en/latest/swarms_memory/)                                                            |
| Available Models     | [Models Overview](https://docs.swarms.world/en/latest/swarms/models/)                                                            |
| Swarms Tools     | [Tools Overview](https://docs.swarms.world/en/latest/swarms_tools/overview/)                                                            |
| Example Applications     | [Examples](https://docs.swarms.world/en/latest/swarms/examples/unique_swarms/)                                                            |
| Swarms Corp Github     | [Swarms Corp GitHub](https://github.com/The-Swarm-Corporation)                      |


## Community
| Section              | Links                                                                                      |
|----------------------|--------------------------------------------------------------------------------------------|
| Community            | [Discord](https://discord.gg/swarms)                            |
| Blog                 | [Blog](https://medium.com/@kyeg)                                                           |
| Event Calendar       | [LUMA](https://lu.ma/swarms_calendar)                                                       |
| Twitter     | [Twitter](https://x.com/swarms_corp)                                                       |
| Agent Marketplace     | [Website](https://swarms.world)                                                       |
| Docs     | [Website](https://docs.swarms.world)                                                       |
| Swarms Website   | [Website](https://swarms.ai)                                                       |

## Get Support

Want to get in touch with the Swarms team? Open an issue on [GitHub](https://github.com/kyegomez/swarms/issues/new) or reach out to us via [email](mailto:kye@swarms.world). We're here to help!


--------------------------------------------------

# File: misc/features/20swarms.md

```markdown
# Swarm Alpha: Data Cruncher
**Overview**: Processes large datasets.  
**Strengths**: Efficient data handling.  
**Weaknesses**: Requires structured data.  

**Pseudo Code**:
```sql
FOR each data_entry IN dataset:
    result = PROCESS(data_entry)
    STORE(result)
END FOR
RETURN aggregated_results
```

# Swarm Beta: Artistic Ally
**Overview**: Generates art pieces.  
**Strengths**: Creativity.  
**Weaknesses**: Somewhat unpredictable.  

**Pseudo Code**:
```scss
INITIATE canvas_parameters
SELECT art_style
DRAW(canvas_parameters, art_style)
RETURN finished_artwork
```

# Swarm Gamma: Sound Sculptor
**Overview**: Crafts audio sequences.  
**Strengths**: Diverse audio outputs.  
**Weaknesses**: Complexity in refining outputs.  

**Pseudo Code**:
```sql
DEFINE sound_parameters
SELECT audio_style
GENERATE_AUDIO(sound_parameters, audio_style)
RETURN audio_sequence
```

# Swarm Delta: Web Weaver
**Overview**: Constructs web designs.  
**Strengths**: Modern design sensibility.  
**Weaknesses**: Limited to web interfaces.  

**Pseudo Code**:
```scss
SELECT template
APPLY user_preferences(template)
DESIGN_web(template, user_preferences)
RETURN web_design
```

# Swarm Epsilon: Code Compiler
**Overview**: Writes and compiles code snippets.  
**Strengths**: Quick code generation.  
**Weaknesses**: Limited to certain programming languages.  

**Pseudo Code**:
```scss
DEFINE coding_task
WRITE_CODE(coding_task)
COMPILE(code)
RETURN executable
```

# Swarm Zeta: Security Shield
**Overview**: Detects system vulnerabilities.  
**Strengths**: High threat detection rate.  
**Weaknesses**: Potential false positives.  

**Pseudo Code**:
```sql
MONITOR system_activity
IF suspicious_activity_detected:
    ANALYZE threat_level
    INITIATE mitigation_protocol
END IF
RETURN system_status
```

# Swarm Eta: Researcher Relay
**Overview**: Gathers and synthesizes research data.  
**Strengths**: Access to vast databases.  
**Weaknesses**: Depth of research can vary.  

**Pseudo Code**:
```sql
DEFINE research_topic
SEARCH research_sources(research_topic)
SYNTHESIZE findings
RETURN research_summary
```

---

# Swarm Theta: Sentiment Scanner
**Overview**: Analyzes text for sentiment and emotional tone.  
**Strengths**: Accurate sentiment detection.  
**Weaknesses**: Contextual nuances might be missed.  

**Pseudo Code**:
```arduino
INPUT text_data
ANALYZE text_data FOR emotional_tone
DETERMINE sentiment_value
RETURN sentiment_value
```

# Swarm Iota: Image Interpreter
**Overview**: Processes and categorizes images.  
**Strengths**: High image recognition accuracy.  
**Weaknesses**: Can struggle with abstract visuals.  

**Pseudo Code**:
```objective-c
LOAD image_data
PROCESS image_data FOR features
CATEGORIZE image_based_on_features
RETURN image_category
```

# Swarm Kappa: Language Learner
**Overview**: Translates and interprets multiple languages.  
**Strengths**: Supports multiple languages.  
**Weaknesses**: Nuances in dialects might pose challenges.  

**Pseudo Code**:
```vbnet
RECEIVE input_text, target_language
TRANSLATE input_text TO target_language
RETURN translated_text
```

# Swarm Lambda: Trend Tracker
**Overview**: Monitors and predicts trends based on data.  
**Strengths**: Proactive trend identification.  
**Weaknesses**: Requires continuous data stream.  

**Pseudo Code**:
```sql
COLLECT data_over_time
ANALYZE data_trends
PREDICT upcoming_trends
RETURN trend_forecast
```

# Swarm Mu: Financial Forecaster
**Overview**: Analyzes financial data to predict market movements.  
**Strengths**: In-depth financial analytics.  
**Weaknesses**: Market volatility can affect predictions.  

**Pseudo Code**:
```sql
GATHER financial_data
COMPUTE statistical_analysis
FORECAST market_movements
RETURN financial_projections
```

# Swarm Nu: Network Navigator
**Overview**: Optimizes and manages network traffic.  
**Strengths**: Efficient traffic management.  
**Weaknesses**: Depends on network infrastructure.  

**Pseudo Code**:
```sql
MONITOR network_traffic
IDENTIFY congestion_points
OPTIMIZE traffic_flow
RETURN network_status
```

# Swarm Xi: Content Curator
**Overview**: Gathers and presents content based on user preferences.  
**Strengths**: Personalized content delivery.  
**Weaknesses**: Limited by available content sources.  

**Pseudo Code**:
```sql
DEFINE user_preferences
SEARCH content_sources
FILTER content_matching_preferences
DISPLAY curated_content
```



--------------------------------------------------

# File: misc/features/SMAPS.md

# Swarms Multi-Agent Permissions System (SMAPS)

## Description
SMAPS is a robust permissions management system designed to integrate seamlessly with Swarm's multi-agent AI framework. Drawing inspiration from Amazon's IAM, SMAPS ensures secure, granular control over agent actions while allowing for collaborative human-in-the-loop interventions.

## Technical Specification

### 1. Components

- **User Management**: Handle user registrations, roles, and profiles.
- **Agent Management**: Register, monitor, and manage AI agents.
- **Permissions Engine**: Define and enforce permissions based on roles.
- **Multiplayer Interface**: Allows multiple human users to intervene, guide, or collaborate on tasks being executed by AI agents.

### 2. Features

- **Role-Based Access Control (RBAC)**:
  - Users can be assigned predefined roles (e.g., Admin, Agent Supervisor, Collaborator).
  - Each role has specific permissions associated with it, defining what actions can be performed on AI agents or tasks.

- **Dynamic Permissions**:
  - Create custom roles with specific permissions.
  - Permissions granularity: From broad (e.g., view all tasks) to specific (e.g., modify parameters of a particular agent).

- **Multiplayer Collaboration**:
  - Multiple users can join a task in real-time.
  - Collaborators can provide real-time feedback or guidance to AI agents.
  - A voting system for decision-making when human intervention is required.

- **Agent Supervision**:
  - Monitor agent actions in real-time.
  - Intervene, if necessary, to guide agent actions based on permissions.

- **Audit Trail**:
  - All actions, whether performed by humans or AI agents, are logged.
  - Review historical actions, decisions, and interventions for accountability and improvement.

### 3. Security

- **Authentication**: Secure login mechanisms with multi-factor authentication options.
- **Authorization**: Ensure users and agents can only perform actions they are permitted to.
- **Data Encryption**: All data, whether at rest or in transit, is encrypted using industry-standard protocols.

### 4. Integration

- **APIs**: Expose APIs for integrating SMAPS with other systems or for extending its capabilities.
- **SDK**: Provide software development kits for popular programming languages to facilitate integration and extension.

## Documentation Description
Swarms Multi-Agent Permissions System (SMAPS) offers a sophisticated permissions management mechanism tailored for multi-agent AI frameworks. It combines the robustness of Amazon IAM-like permissions with a unique "multiplayer" feature, allowing multiple humans to collaboratively guide AI agents in real-time. This ensures not only that tasks are executed efficiently but also that they uphold the highest standards of accuracy and ethics. With SMAPS, businesses can harness the power of swarms with confidence, knowing that they have full control and transparency over their AI operations.


--------------------------------------------------

# File: misc/features/agent_archive.md

# AgentArchive Documentation
## Swarms Multi-Agent Framework

**AgentArchive is an advanced feature crafted to archive, bookmark, and harness the transcripts of agent runs. It promotes the storing and leveraging of successful agent interactions, offering a powerful means for users to derive "recipes" for future agents. Furthermore, with its public archive feature, users can contribute to and benefit from the collective wisdom of the community.**

---

## Overview:

AgentArchive empowers users to:
1. Preserve complete transcripts of agent instances.
2. Bookmark and annotate significant runs.
3. Categorize runs using various tags.
4. Transform successful runs into actionable "recipes".
5. Publish and access a shared knowledge base via a public archive.

---

## Features:

### 1. Archiving:

- **Save Transcripts**: Retain the full narrative of an agent's interaction and choices.
- **Searchable Database**: Dive into archives using specific keywords, timestamps, or tags.

### 2. Bookmarking:

- **Highlight Essential Runs**: Designate specific agent runs for future reference.
- **Annotations**: Embed notes or remarks to bookmarked runs for clearer understanding.

### 3. Tagging:

Organize and classify agent runs via:
- **Prompt**: The originating instruction that triggered the agent run.
- **Tasks**: Distinct tasks or operations executed by the agent.
- **Model**: The specific AI model or iteration used during the interaction.
- **Temperature (Temp)**: The set randomness or innovation level for the agent.

### 4. Recipe Generation:

- **Standardization**: Convert successful run transcripts into replicable "recipes".
- **Guidance**: Offer subsequent agents a structured approach, rooted in prior successes.
- **Evolution**: Periodically refine recipes based on newer, enhanced runs.

### 5. Public Archive & Sharing:

- **Publish Successful Runs**: Users can choose to share their successful agent runs.
- **Collaborative Knowledge Base**: Access a shared repository of successful agent interactions from the community.
- **Ratings & Reviews**: Users can rate and review shared runs, highlighting particularly effective "recipes."
- **Privacy & Redaction**: Ensure that any sensitive information is automatically redacted before publishing.

---

## Benefits:

1. **Efficiency**: Revisit past agent activities to inform and guide future decisions.
2. **Consistency**: Guarantee a uniform approach to recurring challenges, leading to predictable and trustworthy outcomes.
3. **Collaborative Learning**: Tap into a reservoir of shared experiences, fostering community-driven learning and growth.
4. **Transparency**: By sharing successful runs, users can build trust and contribute to the broader community's success.

---

## Usage:

1. **Access AgentArchive**: Navigate to the dedicated section within the Swarms Multi-Agent Framework dashboard.
2. **Search, Filter & Organize**: Utilize the search bar and tagging system for precise retrieval.
3. **Bookmark, Annotate & Share**: Pin important runs, add notes, and consider sharing with the broader community.
4. **Engage with Public Archive**: Explore, rate, and apply shared knowledge to enhance agent performance.

---

With AgentArchive, users not only benefit from their past interactions but can also leverage the collective expertise of the Swarms community, ensuring continuous improvement and shared success.



--------------------------------------------------

# File: misc/features/fail_protocol.md

# Swarms Multi-Agent Framework Documentation

## Table of Contents
- Agent Failure Protocol
- Swarm Failure Protocol

---

## Agent Failure Protocol

### 1. Overview
Agent failures may arise from bugs, unexpected inputs, or external system changes. This protocol aims to diagnose, address, and prevent such failures.

### 2. Root Cause Analysis
- **Data Collection**: Record the task, inputs, and environmental variables present during the failure.
- **Diagnostic Tests**: Run the agent in a controlled environment replicating the failure scenario.
- **Error Logging**: Analyze error logs to identify patterns or anomalies.

### 3. Solution Brainstorming
- **Code Review**: Examine the code sections linked to the failure for bugs or inefficiencies.
- **External Dependencies**: Check if external systems or data sources have changed.
- **Algorithmic Analysis**: Evaluate if the agent's algorithms were overwhelmed or faced an unhandled scenario.

### 4. Risk Analysis & Solution Ranking
- Assess the potential risks associated with each solution.
- Rank solutions based on:
  - Implementation complexity
  - Potential negative side effects
  - Resource requirements
- Assign a success probability score (0.0 to 1.0) based on the above factors.

### 5. Solution Implementation
- Implement the top 3 solutions sequentially, starting with the highest success probability.
- If all three solutions fail, trigger the "Human-in-the-Loop" protocol.

---

## Swarm Failure Protocol

### 1. Overview
Swarm failures are more complex, often resulting from inter-agent conflicts, systemic bugs, or large-scale environmental changes. This protocol delves deep into such failures to ensure the swarm operates optimally.

### 2. Root Cause Analysis
- **Inter-Agent Analysis**: Examine if agents were in conflict or if there was a breakdown in collaboration.
- **System Health Checks**: Ensure all system components supporting the swarm are operational.
- **Environment Analysis**: Investigate if external factors or systems impacted the swarm's operation.

### 3. Solution Brainstorming
- **Collaboration Protocols**: Review and refine how agents collaborate.
- **Resource Allocation**: Check if the swarm had adequate computational and memory resources.
- **Feedback Loops**: Ensure agents are effectively learning from each other.

### 4. Risk Analysis & Solution Ranking
- Assess the potential systemic risks posed by each solution.
- Rank solutions considering:
  - Scalability implications
  - Impact on individual agents
  - Overall swarm performance potential
- Assign a success probability score (0.0 to 1.0) based on the above considerations.

### 5. Solution Implementation
- Implement the top 3 solutions sequentially, prioritizing the one with the highest success probability.
- If all three solutions are unsuccessful, invoke the "Human-in-the-Loop" protocol for expert intervention.

---

By following these protocols, the Swarms Multi-Agent Framework can systematically address and prevent failures, ensuring a high degree of reliability and efficiency.


--------------------------------------------------

# File: misc/features/human_in_loop.md

# Human-in-the-Loop Task Handling Protocol

## Overview

The Swarms Multi-Agent Framework recognizes the invaluable contributions humans can make, especially in complex scenarios where nuanced judgment is required. The "Human-in-the-Loop Task Handling Protocol" ensures that when agents encounter challenges they cannot handle autonomously, the most capable human collaborator is engaged to provide guidance, based on their skills and expertise.

## Protocol Steps

### 1. Task Initiation & Analysis

- When a task is initiated, agents first analyze the task's requirements.
- The system maintains an understanding of each task's complexity, requirements, and potential challenges.

### 2. Automated Resolution Attempt

- Agents first attempt to resolve the task autonomously using their algorithms and data.
- If the task can be completed without issues, it progresses normally.

### 3. Challenge Detection

- If agents encounter challenges or uncertainties they cannot resolve, the "Human-in-the-Loop" protocol is triggered.
  
### 4. Human Collaborator Identification

- The system maintains a dynamic profile of each human collaborator, cataloging their skills, expertise, and past performance on related tasks.
- Using this profile data, the system identifies the most capable human collaborator to assist with the current challenge.

### 5. Real-time Collaboration

- The identified human collaborator is notified and provided with all the relevant information about the task and the challenge.
- Collaborators can provide guidance, make decisions, or even take over specific portions of the task.
  
### 6. Task Completion & Feedback Loop

- Once the challenge is resolved, agents continue with the task until completion.
- Feedback from human collaborators is used to update agent algorithms, ensuring continuous learning and improvement.

## Best Practices

1. **Maintain Up-to-date Human Profiles**: Ensure that the skillsets, expertise, and performance metrics of human collaborators are updated regularly.
2. **Limit Interruptions**: Implement mechanisms to limit the frequency of human interventions, ensuring collaborators are not overwhelmed with requests.
3. **Provide Context**: When seeking human intervention, provide collaborators with comprehensive context to ensure they can make informed decisions.
4. **Continuous Training**: Regularly update and train agents based on feedback from human collaborators.
5. **Measure & Optimize**: Monitor the efficiency of the "Human-in-the-Loop" protocol, aiming to reduce the frequency of interventions while maximizing the value of each intervention.
6. **Skill Enhancement**: Encourage human collaborators to continuously enhance their skills, ensuring that the collective expertise of the group grows over time.

## Conclusion

The integration of human expertise with AI capabilities is a cornerstone of the Swarms Multi-Agent Framework. This "Human-in-the-Loop Task Handling Protocol" ensures that tasks are executed efficiently, leveraging the best of both human judgment and AI automation. Through collaborative synergy, we can tackle challenges more effectively and drive innovation.


--------------------------------------------------

# File: misc/features/info_sec.md

# Secure Communication Protocols

## Overview

The Swarms Multi-Agent Framework prioritizes the security and integrity of data, especially personal and sensitive information. Our Secure Communication Protocols ensure that all communications between agents are encrypted, authenticated, and resistant to tampering or unauthorized access.

## Features

### 1. End-to-End Encryption

- All inter-agent communications are encrypted using state-of-the-art cryptographic algorithms.
- This ensures that data remains confidential and can only be read by the intended recipient agent.

### 2. Authentication

- Before initiating communication, agents authenticate each other using digital certificates.
- This prevents impersonation attacks and ensures that agents are communicating with legitimate counterparts.

### 3. Forward Secrecy

- Key exchange mechanisms employ forward secrecy, meaning that even if a malicious actor gains access to an encryption key, they cannot decrypt past communications.
  
### 4. Data Integrity

- Cryptographic hashes ensure that the data has not been altered in transit.
- Any discrepancies in data integrity result in the communication being rejected.

### 5. Zero-Knowledge Protocols

- When handling especially sensitive data, agents use zero-knowledge proofs to validate information without revealing the actual data.
  
### 6. Periodic Key Rotation

- To mitigate the risk of long-term key exposure, encryption keys are periodically rotated.
- Old keys are securely discarded, ensuring that even if they are compromised, they cannot be used to decrypt communications.

## Best Practices for Handling Personal and Sensitive Information

1. **Data Minimization**: Agents should only request and process the minimum amount of personal data necessary for the task.
2. **Anonymization**: Whenever possible, agents should anonymize personal data, stripping away identifying details.
3. **Data Retention Policies**: Personal data should be retained only for the period necessary to complete the task, after which it should be securely deleted.
4. **Access Controls**: Ensure that only authorized agents have access to personal and sensitive information. Implement strict access control mechanisms.
5. **Regular Audits**: Conduct regular security audits to ensure compliance with privacy regulations and to detect any potential vulnerabilities.
6. **Training**: All agents should be regularly updated and trained on the latest security protocols and best practices for handling sensitive data.

## Conclusion

Secure communication is paramount in the Swarms Multi-Agent Framework, especially when dealing with personal and sensitive information. Adhering to these protocols and best practices ensures the safety, privacy, and trust of all stakeholders involved.


--------------------------------------------------

# File: misc/features/promptimizer.md

# Promptimizer Documentation
## Swarms Multi-Agent Framework

**The Promptimizer Tool stands as a cornerstone innovation within the Swarms Multi-Agent Framework, meticulously engineered to refine and supercharge prompts across diverse categories. Capitalizing on extensive libraries of best-practice prompting techniques, this tool ensures your prompts are razor-sharp, tailored, and primed for optimal outcomes.**

---

## Overview:

The Promptimizer Tool is crafted to:
1. Rigorously analyze and elevate the quality of provided prompts.
2. Furnish best-in-class recommendations rooted in proven prompting strategies.
3. Serve a spectrum of categories, from technical operations to expansive creative ventures.

---

## Core Features:

### 1. Deep Prompt Analysis:

- **Clarity Matrix**: A proprietary algorithm assessing prompt clarity, removing ambiguities and sharpening focus.
- **Efficiency Gauge**: Evaluates the prompt's structure to ensure swift and precise desired results.

### 2. Adaptive Recommendations:

- **Technique Engine**: Suggests techniques aligned with the gold standard for the chosen category.
- **Exemplar Database**: Offers an extensive array of high-quality prompt examples for comparison and inspiration.

### 3. Versatile Category Framework:

- **Tech Suite**: Optimizes prompts for technical tasks, ensuring actionable clarity.
- **Narrative Craft**: Hones prompts to elicit vivid and coherent stories.
- **Visual Visionary**: Shapes prompts for precise and dynamic visual generation.
- **Sonic Sculptor**: Orchestrates prompts for audio creation, tuning into desired tones and moods.

### 4. Machine Learning Integration:

- **Feedback Dynamo**: Harnesses user feedback, continually refining the tool's recommendation capabilities.
- **Live Library Updates**: Periodic syncing with the latest in prompting techniques, ensuring the tool remains at the cutting edge.

### 5. Collaboration & Sharing:

- **TeamSync**: Allows teams to collaborate on prompt optimization in real-time.
- **ShareSpace**: Share and access a community-driven repository of optimized prompts, fostering collective growth.

---

## Benefits:

1. **Precision Engineering**: Harness the power of refined prompts, ensuring desired outcomes are achieved with surgical precision.
2. **Learning Hub**: Immerse in a tool that not only refines but educates, enhancing the user's prompting acumen.
3. **Versatile Mastery**: Navigate seamlessly across categories, ensuring top-tier prompt quality regardless of the domain.
4. **Community-driven Excellence**: Dive into a world of shared knowledge, elevating the collective expertise of the Swarms community.

---

## Usage Workflow:

1. **Launch the Prompt Optimizer**: Access the tool directly from the Swarms Multi-Agent Framework dashboard.
2. **Prompt Entry**: Input the initial prompt for refinement.
3. **Category Selection**: Pinpoint the desired category for specialized optimization.
4. **Receive & Review**: Engage with the tool's recommendations, comparing original and optimized prompts.
5. **Collaborate, Implement & Share**: Work in tandem with team members, deploy the refined prompt, and consider contributing to the community repository.

---

By integrating the Promptimizer Tool into their workflow, Swarms users stand poised to redefine the boundaries of what's possible, turning each prompt into a beacon of excellence and efficiency.



--------------------------------------------------

# File: misc/features/shorthand.md

# Shorthand Communication System
## Swarms Multi-Agent Framework

**The Enhanced Shorthand Communication System is designed to streamline agent-agent communication within the Swarms Multi-Agent Framework. This system employs concise alphanumeric notations to relay task-specific details to agents efficiently.**

---

## Format:

The shorthand format is structured as `[AgentType]-[TaskLayer].[TaskNumber]-[Priority]-[Status]`.

---

## Components:

### 1. Agent Type:
- Denotes the specific agent role, such as:
  * `C`: Code agent
  * `D`: Data processing agent
  * `M`: Monitoring agent
  * `N`: Network agent
  * `R`: Resource management agent
  * `I`: Interface agent
  * `S`: Security agent

### 2. Task Layer & Number:
- Represents the task's category.
  * Example: `1.8` signifies Task layer 1, task number 8.

### 3. Priority:
- Indicates task urgency.
  * `H`: High
  * `M`: Medium
  * `L`: Low

### 4. Status:
- Gives a snapshot of the task's progress.
  * `I`: Initialized
  * `P`: In-progress
  * `C`: Completed
  * `F`: Failed
  * `W`: Waiting

---

## Extended Features:

### 1. Error Codes (for failures): 
- `E01`: Resource issues
- `E02`: Data inconsistency
- `E03`: Dependency malfunction
... and more as needed.

### 2. Collaboration Flag: 
- `+`: Denotes required collaboration.

---

## Example Codes:

- `C-1.8-H-I`: A high-priority coding task that's initializing.
- `D-2.3-M-P`: A medium-priority data task currently in-progress.
- `M-3.5-L-P+`: A low-priority monitoring task in progress needing collaboration.

---

By leveraging the Enhanced Shorthand Communication System, the Swarms Multi-Agent Framework can ensure swift interactions, concise communications, and effective task management.



--------------------------------------------------

# File: swarms/agents/abstractagent.md

# swarms.agents

## 1. Introduction

`AbstractAgent` is an abstract class that serves as a foundation for implementing AI agents. An agent is an entity that can communicate with other agents and perform actions. The `AbstractAgent` class allows for customization in the implementation of the `receive` method, enabling different agents to define unique actions for receiving and processing messages.

`AbstractAgent` provides capabilities for managing tools and accessing memory, and has methods for running, chatting, and stepping through communication with other agents.

## 2. Class Definition

```python
class AbstractAgent:
    """An abstract class for AI agent.

    An agent can communicate with other agents and perform actions.
    Different agents can differ in what actions they perform in the `receive` method.

    Agents are full and completed:

    Agents = llm + tools + memory
    """

    def __init__(self, name: str):
        """
        Args:
            name (str): name of the agent.
        """
        self._name = name

    @property
    def name(self):
        """Get the name of the agent."""
        return self._name

    def tools(self, tools):
        """init tools"""

    def memory(self, memory_store):
        """init memory"""

    def reset(self):
        """(Abstract method) Reset the agent."""

    def run(self, task: str):
        """Run the agent once"""

    def _arun(self, taks: str):
        """Run Async run"""

    def chat(self, messages: List[Dict]):
        """Chat with the agent"""

    def _achat(self, messages: List[Dict]):
        """Asynchronous Chat"""

    def step(self, message: str):
        """Step through the agent"""

    def _astep(self, message: str):
        """Asynchronous step"""
```

## 3. Functionality and Usage

The `AbstractAgent` class represents a generic AI agent and provides a set of methods to interact with it.

To create an instance of an agent, the `name` of the agent should be specified.

### Core Methods

#### 1. `reset`

The `reset` method allows the agent to be reset to its initial state.

```python
agent.reset()
```

#### 2. `run`

The `run` method allows the agent to perform a specific task.

```python
agent.run("some_task")
```

#### 3. `chat`

The `chat` method enables communication with the agent through a series of messages.

```python
messages = [{"id": 1, "text": "Hello, agent!"}, {"id": 2, "text": "How are you?"}]
agent.chat(messages)
```

#### 4. `step`

The `step` method allows the agent to process a single message.

```python
agent.step("Hello, agent!")
```

### Asynchronous Methods

The class also provides asynchronous variants of the core methods.

### Additional Functionality

Additional functionalities for agent initialization and management of tools and memory are also provided.

```python
agent.tools(some_tools)
agent.memory(some_memory_store)
```

## 4. Additional Information and Tips

When implementing a new agent using the `AbstractAgent` class, ensure that the `receive` method is overridden to define the specific behavior of the agent upon receiving messages.

## 5. References and Resources

For further exploration and understanding of AI agents and agent communication, refer to the relevant literature and research on this topic.


--------------------------------------------------

# File: swarms/agents/agent_judge.md

# Agent Judge

The AgentJudge is a specialized agent designed to evaluate and judge outputs from other agents or systems. It acts as a quality control mechanism, providing objective assessments and feedback on various types of content, decisions, or outputs.


The AgentJudge serves as an impartial evaluator that can:
- Assess the quality and correctness of agent outputs

- Provide structured feedback and scoring

- Maintain context across multiple evaluations

- Generate detailed analysis reports

## Architecture

```mermaid
graph TD
    A[Input Tasks] --> B[AgentJudge]
    B --> C[Agent Core]
    C --> D[LLM Model]
    D --> E[Response Generation]
    E --> F[Context Management]
    F --> G[Output]
    
    subgraph "Evaluation Flow"
    H[Task Analysis] --> I[Quality Assessment]
    I --> J[Feedback Generation]
    J --> K[Score Assignment]
    end
    
    B --> H
    K --> G
```

## Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `agent_name` | str | "agent-judge-01" | Unique identifier for the judge agent |
| `system_prompt` | str | AGENT_JUDGE_PROMPT | System instructions for the agent |
| `model_name` | str | "openai/o1" | LLM model to use for evaluation |
| `max_loops` | int | 1 | Maximum number of evaluation iterations |

## Methods

| Method | Description | Parameters | Returns |
|--------|-------------|------------|---------|
| `step()` | Processes a single batch of tasks | `tasks: List[str]` | `str` |
| `run()` | Executes multiple evaluation iterations | `tasks: List[str]` | `List[str]` |

## Code Example

```python
from swarms import AgentJudge


judge = AgentJudge(model_name="gpt-4o", max_loops=1)


outputs = [
    "1. Agent CalculusMaster: After careful evaluation, I have computed the integral of the polynomial function. The result is ∫(x^2 + 3x + 2)dx = (1/3)x^3 + (3/2)x^2 + 5, where I applied the power rule for integration and added the constant of integration.",
    "2. Agent DerivativeDynamo: In my analysis of the function sin(x), I have derived it with respect to x. The derivative is d/dx (sin(x)) = cos(x). However, I must note that the additional term '+ 2' is not applicable in this context as it does not pertain to the derivative of sin(x).",
    "3. Agent LimitWizard: Upon evaluating the limit as x approaches 0 for the function (sin(x)/x), I conclude that lim (x -> 0) (sin(x)/x) = 1. The additional '+ 3' is incorrect and should be disregarded as it does not relate to the limit calculation.",
    "4. Agent IntegralGenius: I have computed the integral of the exponential function e^x. The result is ∫(e^x)dx = e^x + C, where C is the constant of integration. The extra '+ 1' is unnecessary and does not belong in the final expression.",
    "5. Agent FunctionFreak: Analyzing the cubic function f(x) = x^3 - 3x + 2, I determined that it has a maximum at x = 1. However, the additional '+ 2' is misleading and should not be included in the maximum value statement.",
]

print(judge.run(outputs))

```

## Enterprise Applications

1. **Code Review Automation**
   - Evaluate code quality

   - Check for best practices
   
   - Assess documentation completeness

2. **Content Quality Control**
   
   - Review marketing copy
   
   - Validate technical documentation
   
   - Assess user support responses

3. **Decision Validation**
   - Evaluate business decisions
   
   - Assess risk assessments
   
   - Review compliance reports

4. **Performance Assessment**
   
   - Evaluate agent performance
   
   - Assess system outputs
   
   - Review automated processes

## Best Practices

1. **Task Formulation**
   - Provide clear, specific evaluation criteria
   
   - Include context when necessary

   - Structure tasks for consistent evaluation

2. **System Configuration**
   
   - Use appropriate model for task complexity
   
   - Adjust max_loops based on evaluation depth needed
   
   - Customize system prompt for specific use cases

3. **Output Management**
   
   - Store evaluation results systematically
   
   - Track evaluation patterns over time
   
   - Use results for continuous improvement

4. **Integration Tips**
   - Implement as part of CI/CD pipelines

   - Use for automated quality gates
   
   - Integrate with monitoring systems

## Use Cases

```mermaid
graph LR
    A[AgentJudge] --> B[Code Review]
    A --> C[Content QA]
    A --> D[Decision Validation]
    A --> E[Performance Metrics]
    
    B --> F[Quality Gates]
    C --> G[Compliance]
    D --> H[Risk Assessment]
    E --> I[System Optimization]
```

## Tips for Implementation

1. Start with simple evaluation tasks and gradually increase complexity

2. Maintain consistent evaluation criteria across similar tasks

3. Use the context management feature for multi-step evaluations

4. Implement proper error handling and logging

5. Regular calibration of evaluation criteria


--------------------------------------------------

# File: swarms/agents/consistency_agent.md

# Consistency Agent Documentation


The `SelfConsistencyAgent` is a specialized agent designed for generating multiple independent responses to a given task and aggregating them into a single, consistent final answer. It leverages concurrent processing to enhance efficiency and employs a majority voting mechanism to ensure the reliability of the aggregated response.

## Purpose

The primary objective of the `SelfConsistencyAgent` is to provide a robust mechanism for decision-making and problem-solving by generating diverse responses and synthesizing them into a coherent final answer. This approach is particularly useful in scenarios where consistency and reliability are critical.

## Class: `SelfConsistencyAgent`

### Initialization

- **`__init__`**: Initializes the `SelfConsistencyAgent` with specified parameters.

#### Arguments

| Argument               | Type    | Default | Description                                                                 |
|------------------------|---------|---------|-----------------------------------------------------------------------------|
| `num_samples`          | `int`   | `5`     | Number of independent responses to sample.                                  |
| `return_list`          | `bool`  | `False` | Whether to return the conversation as a list.                               |
| `max_loops`            | `int`   | `1`     | Maximum number of loops for the agent to run.                               |
| `return_dict`          | `bool`  | `False` | Whether to return the conversation as a dictionary.                         |
| `return_json`          | `bool`  | `False` | Whether to return the conversation as JSON.                                 |
| `majority_voting_prompt` | `str` | `None`  | Custom prompt for majority voting.                                          |

### Methods

- **`run`**: Generates multiple responses for the given task and aggregates them.
  - **Arguments**:
    - `task` (`str`): The input prompt.
    - `answer` (`str`, optional): The expected answer to validate responses against.
  - **Returns**: `str` - The aggregated final answer.

- **`aggregate`**: Aggregates a list of responses into a single final answer using majority voting.
  - **Arguments**:
    - `responses` (`List[str]`): The list of responses.
  - **Returns**: `str` - The aggregated answer.

- **`check_responses_for_answer`**: Checks if a specified answer is present in any of the provided responses.
  - **Arguments**:
    - `responses` (`List[str]`): A list of responses to check.
    - `answer` (`str`): The answer to look for in the responses.
  - **Returns**: `bool` - `True` if the answer is found, `False` otherwise.

### Examples

#### Example 1: Basic Usage

```python
from swarms.agents.consistency_agent import SelfConsistencyAgent

# Initialize the agent
agent = SelfConsistencyAgent(
    agent_name="Reasoning-Agent",
    model_name="gpt-4o-mini",
    max_loops=1,
    num_samples=5
)

# Define a task
task = "What is the 40th prime number?"

# Run the agent
final_answer = agent.run(task)

# Print the final aggregated answer
print("Final aggregated answer:", final_answer)
```

#### Example 2: Using Custom Majority Voting Prompt

```python
from swarms.agents.consistency_agent import SelfConsistencyAgent

# Initialize the agent with a custom majority voting prompt
agent = SelfConsistencyAgent(
    agent_name="Reasoning-Agent",
    model_name="gpt-4o-mini",
    max_loops=1,
    num_samples=5,
    majority_voting_prompt="Please provide the most common response."
)

# Define a task
task = "Explain the theory of relativity in simple terms."

# Run the agent
final_answer = agent.run(task)

# Print the final aggregated answer
print("Final aggregated answer:", final_answer)
```

---


--------------------------------------------------

# File: swarms/agents/create_agents_yaml.md

# Building Agents from a YAML File

The `create_agents_from_yaml` function is designed to dynamically create agents and orchestrate swarms based on configurations defined in a YAML file. It is particularly suited for enterprise use-cases, offering scalability and reliability for agent-based workflows.

### Key Features:
- **Multi-Agent Creation**: Automatically instantiate multiple agents from a YAML file.
- **Swarm Architecture**: Supports swarm architectures where agents collaborate to solve complex tasks.
- **Logging with Loguru**: Includes robust logging for tracking operations and diagnosing issues.
- **Flexible Return Types**: Offers several return types based on the requirements of the system.
- **Customizable**: Supports additional arguments (`*args` and `**kwargs`) for fine-tuning agent behavior.
- **Error Handling**: Handles missing configurations and invalid inputs with meaningful error messages.

---

### Parameters

| Parameter    | Description                                                                                                                                       | Type        | Default Value | Example                             |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-------------|---------------|-------------------------------------|
| `model`      | A callable representing the model (LLM or other) that agents will use.                                                                             | Callable    | None          | `OpenAIChat(model_name="gpt-4")`    |
| `yaml_file`  | Path to the YAML file containing agent configurations.                                                                                            | String      | "agents.yaml" | `"config/agents.yaml"`              |
| `return_type`| Determines the type of return object. Options: `"auto"`, `"swarm"`, `"agents"`, `"both"`, `"tasks"`, `"run_swarm"`.                                | String      | "auto"        | `"both"`                            |
| `*args`      | Additional positional arguments for further customization (e.g., agent behavior).                                                                  | List        | N/A           | N/A                                 |
| `**kwargs`   | Additional keyword arguments for customization (e.g., specific parameters passed to the agents or swarm).                                           | Dict        | N/A           | N/A                                 |

---

### Return Types

| Return Type     | Description                                                                                                                                   |
|-----------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `SwarmRouter`   | Returns a `SwarmRouter` object, orchestrating the created agents, only if swarm architecture is defined in YAML.                               |
| `Agent`         | Returns a single agent if only one is defined.                                                                                                |
| `List[Agent]`   | Returns a list of agents if multiple are defined.                                                                                             |
| `Tuple`         | If both agents and a swarm are present, returns both as a tuple (`SwarmRouter, List[Agent]`).                                                  |
| `List[Dict]`    | Returns a list of task results if tasks were executed.                                                                                        |
| `None`          | Returns nothing if an invalid return type is provided or an error occurs.                                                                     |

---

### Detailed Return Types

| Return Type        | Condition                                                          | Example Return Value                          |
|--------------------|---------------------------------------------------------------------|-----------------------------------------------|
| `"auto"`           | Automatically determines the return based on YAML content.          | `SwarmRouter` if swarm architecture is defined, otherwise `Agent` or `List[Agent]`. |
| `"swarm"`          | Returns `SwarmRouter` if present; otherwise returns agents.         | `<SwarmRouter>`                               |
| `"agents"`         | Returns a list of agents (or a single agent if only one is defined).| `[<Agent>, <Agent>]` or `<Agent>`             |
| `"both"`           | Returns both `SwarmRouter` and agents in a tuple.                  | `(<SwarmRouter>, [<Agent>, <Agent>])`         |
| `"tasks"`          | Returns the task results, if tasks were executed by agents.         | `[{'task': 'task_output'}, {'task2': 'output'}]` |
| `"run_swarm"`      | Executes the swarm (if defined) and returns the result.             | `'Swarm task output here'`                    |

---

### Example Use Cases

1. **Creating Multiple Agents for Financial Analysis**

```yaml
agents:
  - agent_name: "Financial-Analysis-Agent"
    system_prompt: "Analyze the best investment strategy for 2024."
    max_loops: 1
    autosave: true
    verbose: false
    context_length: 100000
    output_type: "str"
    task: "Analyze stock options for long-term gains."

  - agent_name: "Risk-Analysis-Agent"
    system_prompt: "Evaluate the risk of tech stocks in 2024."
    max_loops: 2
    autosave: false
    verbose: true
    context_length: 50000
    output_type: "json"
    task: "What are the riskiest stocks in the tech sector?"
```

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_router import SwarmRouter

# Model representing your LLM
def model(prompt):
    return f"Processed: {prompt}"

# Create agents and return them as a list
agents = create_agents_from_yaml(model=model, yaml_file="agents.yaml", return_type="agents")
print(agents)
```

2. **Running a Swarm of Agents to Solve a Complex Task**

```yaml
agents:
  - agent_name: "Legal-Agent"
    system_prompt: "Provide legal advice on corporate structuring."
    task: "How to incorporate a business as an LLC?"

swarm_architecture:
  name: "Corporate-Swarm"
  description: "A swarm for helping businesses with legal and tax advice."
  swarm_type: "ConcurrentWorkflow"
  task: "How can we optimize a business structure for maximum tax efficiency?"
  max_loops: 3
```

```python
import os

from dotenv import load_dotenv
from loguru import logger
from swarm_models import OpenAIChat

from swarms.agents.create_agents_from_yaml import (
    create_agents_from_yaml,
)

# Load environment variables
load_dotenv()

# Path to your YAML file
yaml_file = "agents_multi_agent.yaml"


# Get the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Model
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)

try:
    # Create agents and run tasks (using 'both' to return agents and task results)
    task_results = create_agents_from_yaml(
        model=model, yaml_file=yaml_file, return_type="run_swarm"
    )

    logger.info(f"Results from agents: {task_results}")
except Exception as e:
    logger.error(f"An error occurred: {e}")

```

3. **Returning Both Agents and Tasks**

```yaml
agents:
  - agent_name: "Market-Research-Agent"
    system_prompt: "What are the latest trends in AI?"
    task: "Provide a market analysis for AI technologies in 2024."
```

```python
from swarms.structs.agent import Agent

# Model representing your LLM
def model(prompt):
    return f"Processed: {prompt}"

# Create agents and run tasks, return both agents and task results
swarm, agents = create_agents_from_yaml(model=model, yaml_file="agents.yaml", return_type="both")
print(swarm, agents)
```

---



---

### YAML Schema Overview:

Below is a breakdown of the attributes expected in the YAML configuration file, which governs how agents and swarms are created.

### YAML Attributes Table:

| Attribute Name                   | Description                                                | Type          | Required | Default/Example Value                    |
|-----------------------------------|------------------------------------------------------------|---------------|----------|------------------------------------------|
| `agents`                          | List of agents to be created. Each agent must have specific configurations. | List of dicts | Yes      |                                          |
| `agent_name`                      | The name of the agent.                                     | String        | Yes      | `"Stock-Analysis-Agent"`                 |
| `system_prompt`                   | The system prompt that the agent will use.                 | String        | Yes      | `"Your full system prompt here"`         |
| `max_loops`                       | Maximum number of iterations or loops for the agent.       | Integer       | No       | 1                                        |
| `autosave`                        | Whether the agent should automatically save its state.     | Boolean       | No       | `true`                                   |
| `dashboard`                       | Whether to enable a dashboard for the agent.               | Boolean       | No       | `false`                                  |
| `verbose`                         | Whether to run the agent in verbose mode (for debugging).  | Boolean       | No       | `false`                                  |
| `dynamic_temperature_enabled`     | Enable dynamic temperature adjustments during agent execution. | Boolean       | No       | `false`                                  |
| `saved_state_path`                | Path where the agent's state is saved for recovery.        | String        | No       | `"path_to_save_state.json"`              |
| `user_name`                       | Name of the user interacting with the agent.               | String        | No       | `"default_user"`                         |
| `retry_attempts`                  | Number of times to retry an operation in case of failure.  | Integer       | No       | 1                                        |
| `context_length`                  | Maximum context length for agent interactions.             | Integer       | No       | 100000                                   |
| `return_step_meta`                | Whether to return metadata for each step of the task.      | Boolean       | No       | `false`                                  |
| `output_type`                     | The type of output the agent will return (e.g., `str`, `json`). | String        | No       | `"str"`                                  |
| `task`                            | Task to be executed by the agent (optional).               | String        | No       | `"What is the best strategy for long-term stock investment?"` |

#### Swarm Architecture (Optional):

| Attribute Name                   | Description                                                | Type          | Required | Default/Example Value                    |
|-----------------------------------|------------------------------------------------------------|---------------|----------|------------------------------------------|
| `swarm_architecture`              | Defines the swarm configuration. For more information on what can be added to the swarm architecture, please refer to the [Swarm Router documentation](https://docs.swarms.world/en/latest/swarms/structs/swarm_router/). | Dict          | No       |                                          |
| `name`                            | The name of the swarm.                                     | String        | Yes      | `"MySwarm"`                              |
| `description`                     | Description of the swarm and its purpose.                  | String        | No       | `"A swarm for collaborative task solving"`|
| `max_loops`                       | Maximum number of loops for the swarm.                     | Integer       | No       | 5                                        |
| `swarm_type`                      | The type of swarm (e.g., `ConcurrentWorkflow`) `SequentialWorkflow`.            | String        | Yes      | `"ConcurrentWorkflow"`                   |
| `task`                            | The primary task assigned to the swarm.                    | String        | No       | `"How can we trademark concepts as a delaware C CORP for free?"` |

---
### YAML Schema Example:

Below is an updated YAML schema that conforms to the function's expectations:

```yaml
agents:
  - agent_name: "Financial-Analysis-Agent"
    system_prompt: "Your full system prompt here"
    max_loops: 1
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: true
    saved_state_path: "finance_agent.json"
    user_name: "swarms_corp"
    retry_attempts: 1
    context_length: 200000
    return_step_meta: false
    output_type: "str"
    # task: "How can I establish a ROTH IRA to buy stocks and get a tax break?" # Turn off if using swarm

  - agent_name: "Stock-Analysis-Agent"
    system_prompt: "Your full system prompt here"
    max_loops: 2
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: false
    saved_state_path: "stock_agent.json"
    user_name: "stock_user"
    retry_attempts: 3
    context_length: 150000
    return_step_meta: true
    output_type: "json"
    # task: "What is the best strategy for long-term stock investment?"

# Optional Swarm Configuration
swarm_architecture:
  name: "MySwarm"
  description: "A swarm for collaborative task solving"
  max_loops: 5
  swarm_type: "ConcurrentWorkflow"
  task: "How can we trademark concepts as a delaware C CORP for free?" # Main task 
```

# Diagram
```mermaid
graph TD;
    A[Task] -->|Send to| B[Financial-Analysis-Agent]
    A -->|Send to| C[Stock-Analysis-Agent]
```

---

### How to Use `create_agents_from_yaml` Function with YAML:

- You need to plug in your specific model until we can create a model router that can fetch any model and set specific settings

#### Example Code:
```python
import os

from dotenv import load_dotenv
from loguru import logger
from swarm_models import OpenAIChat

from swarms.agents.create_agents_from_yaml import (
    create_agents_from_yaml,
)

# Load environment variables
load_dotenv()

# Path to your YAML file
yaml_file = "agents.yaml"


# Get the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Model
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)

try:
    # Create agents and run tasks (using 'both' to return agents and task results)
    task_results = create_agents_from_yaml(
        model=model, yaml_file=yaml_file, return_type="run_swarm" # 
    )

    logger.info(f"Results from agents: {task_results}")
except Exception as e:
    logger.error(f"An error occurred: {e}")

```

---

### Error Handling:

1. **FileNotFoundError**: If the specified YAML file does not exist.
2. **ValueError**: Raised if there are invalid or missing configurations in the YAML file.
3. **Invalid Return Type**: If an invalid return type is specified, the function will raise a `ValueError`.

### Conclusion:
The `create_agents_from_yaml` function provides a flexible and powerful way to dynamically configure and execute agents, supporting a wide range of tasks and configurations for enterprise-level use cases. By following the YAML schema and function signature, users can easily define and manage their agents and swarms.

--------------------------------------------------

# File: swarms/agents/external_party_agents.md



# **Swarms External Agent Integration**

Integrating external agents from other frameworks like **Langchain**, **Griptape**, and more is straightforward using **Swarms**. Below are step-by-step guides on how to bring these agents into Swarms by creating a new class, implementing the required methods, and ensuring compatibility.

---

## **Quick Overview**

- **Step 1**: Create a new class that inherits the `Agent` class from Swarms.
- **Step 2**: Override the `.run(task: str) -> str` method that will execute the agent and return a string response.
- **Step 3**: Optionally, add methods to save outputs to other formats like JSON, logs, or databases.

### **Agent Class**

The primary structure you'll need to integrate any external agent is the `Agent` class from **Swarms**. Here’s a template for how your new agent class should be structured:

```python
from swarms import Agent

class ExternalAgent(Agent):
    def run(self, task: str) -> str:
        # Implement logic to run external agent
        pass

    def save_to_json(self, output: str, filepath: str):
        # Optionally save the result to a JSON file
        with open(filepath, "w") as file:
            json.dump({"response": output}, file)
```

---

## **Griptape Agent Integration Example**

In this example, we will create a **Griptape** agent by inheriting from the Swarms `Agent` class and implementing the `run` method.

### **Griptape Integration Steps**:

1. **Inherit from Swarms Agent**: Inherit from the `SwarmsAgent` class.
2. **Create Griptape Agent**: Initialize the **Griptape** agent inside your class and provide it with the necessary tools.
3. **Override the `run()` method**: Implement logic to process a task string and execute the Griptape agent.

## **Griptape Example Code**:

```python
from swarms import (
    Agent as SwarmsAgent,
)  # Import the base Agent class from Swarms
from griptape.structures import Agent as GriptapeAgent
from griptape.tools import (
    WebScraperTool,
    FileManagerTool,
    PromptSummaryTool,
)

# Create a custom agent class that inherits from SwarmsAgent
class GriptapeSwarmsAgent(SwarmsAgent):
    def __init__(self, *args, **kwargs):
        # Initialize the Griptape agent with its tools
        self.agent = GriptapeAgent(
            input="Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.",
            tools=[
                WebScraperTool(off_prompt=True),
                PromptSummaryTool(off_prompt=True),
                FileManagerTool(),
            ],
            *args,
            **kwargs,
        )

    # Override the run method to take a task and execute it using the Griptape agent
    def run(self, task: str) -> str:
        # Extract URL and filename from task
        url, filename = task.split(",")  # Example task string: "https://example.com, output.txt"
        # Execute the Griptape agent
        result = self.agent.run(url.strip(), filename.strip())
        # Return the final result as a string
        return str(result)


# Example usage:
griptape_swarms_agent = GriptapeSwarmsAgent()
output = griptape_swarms_agent.run("https://griptape.ai, griptape.txt")
print(output)
```

### **Explanation**:
1. **GriptapeSwarmsAgent**: The custom class that integrates **Griptape** into **Swarms**.
2. **run(task: str)**: This method extracts inputs from the task string and runs the agent using **Griptape** tools.
3. **Tools**: The **Griptape** agent is equipped with web scraping, summarization, and file management tools.


## **Additional Features**:
You can enhance your external agents with additional features such as:

- **Saving outputs** to JSON, databases, or logs.

- **Handling errors** and retry mechanisms for robustness.

- **Custom logging** with tools like **Loguru** for extensive debugging.

---

## **Langchain Agent Integration Example**

Next, we demonstrate how to integrate a **Langchain** agent with **Swarms** by following similar steps.

### **Langchain Integration Steps**:

1. **Inherit from Swarms Agent**: Inherit from the `SwarmsAgent` class.
2. **Create Langchain Agent**: Initialize a Langchain agent with the necessary components (like language models or memory modules).
3. **Override the `run()` method**: Pass tasks to the Langchain agent and return the response.

## **Langchain Example Code**:

```python
from swarms import Agent as SwarmsAgent
from langchain import LLMChain
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate

# Create a custom agent class that inherits from SwarmsAgent
class LangchainSwarmsAgent(SwarmsAgent):
    def __init__(self, *args, **kwargs):
        # Initialize the Langchain agent with LLM and prompt
        prompt_template = PromptTemplate(template="Answer the question: {question}")
        llm = OpenAI(model="gpt-3.5-turbo")
        self.chain = LLMChain(llm=llm, prompt=prompt_template)
        super().__init__(*args, **kwargs)

    # Override the run method to take a task and execute it using the Langchain agent
    def run(self, task: str) -> str:
        # Pass the task to the Langchain agent
        result = self.chain.run({"question": task})
        # Return the final result as a string
        return result

# Example usage:
langchain_swarms_agent = LangchainSwarmsAgent()
output = langchain_swarms_agent.run("What is the capital of France?")
print(output)
```

### **Explanation**:
1. **LangchainSwarmsAgent**: The custom class integrates **Langchain** into **Swarms**.
2. **run(task: str)**: The task is passed to a language model via Langchain and returns a result.


### Additional Examples from other providers


### 1. **OpenAI Function Calling Agents**
- **Description**: OpenAI models like GPT-4 can now call functions programmatically. This makes it possible to create agents that execute external functions, APIs, or code snippets.
  
  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  import openai

  # Custom OpenAI Function Calling Agent
  class OpenAIFunctionAgent(SwarmsAgent):
      def __init__(self, *args, **kwargs):
          # Initialize OpenAI API credentials and settings
          self.api_key = "your_openai_api_key"
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          # Example task: "summarize, 'Provide a short summary of this text...'"
          command, input_text = task.split(", ")
          response = openai.Completion.create(
              model="gpt-4",
              prompt=f"{command}: {input_text}",
              temperature=0.5,
              max_tokens=100,
          )
          return response.choices[0].text.strip()

  # Example usage:
  openai_agent = OpenAIFunctionAgent()
  output = openai_agent.run("summarize, Provide a short summary of this text...")
  print(output)
  ```

### 2. **Rasa Agents**
- **Description**: **Rasa** is a popular open-source framework for building conversational AI agents. You can integrate **Rasa** to build dialogue-based agents with **Swarms**.

  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  from rasa.core.agent import Agent as RasaAgent
  from rasa.core.interpreter import RasaNLUInterpreter

  # Custom Rasa Swarms Agent
  class RasaSwarmsAgent(SwarmsAgent):
      def __init__(self, model_path: str, *args, **kwargs):
          # Initialize the Rasa agent with a pre-trained model
          self.agent = RasaAgent.load(model_path)
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          # Pass user input to the Rasa agent
          result = self.agent.handle_text(task)
          # Return the final response from the agent
          return result[0]["text"] if result else "No response."

  # Example usage:
  rasa_swarms_agent = RasaSwarmsAgent("path/to/rasa_model")
  output = rasa_swarms_agent.run("Hello, how can I get a refund?")
  print(output)
  ```

### 3. **Hugging Face Transformers**
- **Description**: **Hugging Face** offers a variety of pre-trained models, including transformers for NLP tasks. These can be easily integrated into **Swarms** for various tasks like text generation, question answering, and more.

  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  from transformers import pipeline

  # Custom Hugging Face Agent
  class HuggingFaceSwarmsAgent(SwarmsAgent):
      def __init__(self, model_name: str, *args, **kwargs):
          # Initialize a pre-trained pipeline from Hugging Face
          self.pipeline = pipeline("text-generation", model=model_name)
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          # Generate text based on the task input
          result = self.pipeline(task, max_length=50)
          return result[0]["generated_text"]

  # Example usage:
  hf_swarms_agent = HuggingFaceSwarmsAgent("gpt2")
  output = hf_swarms_agent.run("Once upon a time in a land far, far away...")
  print(output)
  ```

### 4. **AutoGPT or BabyAGI**
- **Description**: **AutoGPT** and **BabyAGI** are agent frameworks designed to be autonomous, where agents can recursively execute tasks and create new tasks based on previous outputs.
  
  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  from autogpt import AutoGPT

  # Custom AutoGPT Agent
  class AutoGPTSwarmsAgent(SwarmsAgent):
      def __init__(self, config, *args, **kwargs):
          # Initialize AutoGPT with configuration
          self.agent = AutoGPT(config)
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          # Execute task recursively using AutoGPT
          result = self.agent.run(task)
          return result

  # Example usage:
  autogpt_swarms_agent = AutoGPTSwarmsAgent({"goal": "Solve world hunger"})
  output = autogpt_swarms_agent.run("Develop a plan to solve world hunger.")
  print(output)
  ```

### 5. **DialogFlow Agents**
- **Description**: **DialogFlow** by Google is used to build conversational agents. These agents can process user intents and deliver responses based on predefined conversation flows.
  
  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  from google.cloud import dialogflow

  # Custom DialogFlow Agent
  class DialogFlowSwarmsAgent(SwarmsAgent):
      def __init__(self, project_id: str, session_id: str, *args, **kwargs):
          # Initialize DialogFlow session client
          self.session_client = dialogflow.SessionsClient()
          self.project_id = project_id
          self.session_id = session_id
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          session = self.session_client.session_path(self.project_id, self.session_id)
          text_input = dialogflow.TextInput(text=task, language_code="en-US")
          query_input = dialogflow.QueryInput(text=text_input)
          response = self.session_client.detect_intent(
              request={"session": session, "query_input": query_input}
          )
          return response.query_result.fulfillment_text

  # Example usage:
  dialogflow_swarms_agent = DialogFlowSwarmsAgent("your_project_id", "your_session_id")
  output = dialogflow_swarms_agent.run("Book me a flight to Paris.")
  print(output)
  ```

### 6. **ChatterBot Agents**
- **Description**: **ChatterBot** is a Python-based machine-learning conversational agent. It learns from previous conversations to generate intelligent responses.
  
  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  from chatterbot import ChatBot

  # Custom ChatterBot Agent
  class ChatterBotSwarmsAgent(SwarmsAgent):
      def __init__(self, name: str, *args, **kwargs):
          # Initialize ChatterBot
          self.agent = ChatBot(name)
          super().__init__(*args, **kwargs)

      def run(self, task: str) -> str:
          # Get a response from ChatterBot based on user input
          response = self.agent.get_response(task)
          return str(response)

  # Example usage:
  chatterbot_swarms_agent = ChatterBotSwarmsAgent("Assistant")
  output = chatterbot_swarms_agent.run("What is the capital of Italy?")
  print(output)
  ```

### 7. **Custom APIs as Agents**
- **Description**: You can create agents that integrate with any REST or GraphQL API by defining them as a task runner within Swarms. This allows for interaction with third-party services.
  
  ## Example Integration:
  ```python
  from swarms import Agent as SwarmsAgent
  import requests

  # Custom API Agent
  class APIAgent(SwarmsAgent):
      def run(self, task: str) -> str:
          # Parse task for API endpoint and parameters
          endpoint, params = task.split(", ")
          response = requests.get(endpoint, params={"q": params})
          return response.text

  # Example usage:
  api_swarms_agent = APIAgent()
  output = api_swarms_agent.run("https://api.example.com/search, python")
  print(output)
  ```

---

### **Summary of Integrations**:

- **Griptape**: Integrate with tools for web scraping, summarization, etc.

- **Langchain**: Use powerful language model orchestration.

- **OpenAI Function Calling**: Directly run OpenAI API-based agents.

- **Rasa**: Build and integrate conversational agents.

- **Hugging Face**: Leverage transformer models.

- **AutoGPT/BabyAGI**: Recursive, autonomous task execution.

- **DialogFlow**: Integrate conversational flows for voice/chat-based systems.

- **ChatterBot**: Machine-learning conversational agents.

- **Custom APIs**: Leverage external APIs as agents for custom workflows.


---


## **Conclusion**:

By following the steps outlined above, you can seamlessly integrate external agent frameworks like **Griptape** and **Langchain** into **Swarms**. This makes Swarms a highly versatile platform for orchestrating various agentic workflows and leveraging the unique capabilities of different frameworks.

For more examples and use cases, please refer to the official Swarms documentation site.



--------------------------------------------------

# File: swarms/agents/gkp_agent.md

# Generated Knowledge Prompting (GKP) Agent

The GKP Agent is a sophisticated reasoning system that enhances its capabilities by generating relevant knowledge before answering queries. This approach, inspired by Liu et al. 2022, is particularly effective for tasks requiring commonsense reasoning and factual information.

## Overview

The GKP Agent consists of three main components:
1. Knowledge Generator - Creates relevant factual information
2. Reasoner - Uses generated knowledge to form answers
3. Coordinator - Synthesizes multiple reasoning paths into a final answer

## Architecture

```mermaid
graph TD
    A[Input Query] --> B[Knowledge Generator]
    B --> C[Generate Knowledge Items]
    C --> D[Reasoner]
    D --> E[Multiple Reasoning Paths]
    E --> F[Coordinator]
    F --> G[Final Answer]
    
    subgraph "Knowledge Generation"
        B
        C
    end
    
    subgraph "Reasoning"
        D
        E
    end
    
    subgraph "Coordination"
        F
        G
    end
```

## Use Cases

```mermaid
graph LR
    A[GKP Agent] --> B[Commonsense Reasoning]
    A --> C[Factual Question Answering]
    A --> D[Complex Problem Solving]
    A --> E[Multi-step Reasoning]
    
    B --> B1[Everyday Logic]
    B --> B2[Social Situations]
    
    C --> C1[Historical Facts]
    C --> C2[Scientific Information]
    
    D --> D1[Technical Analysis]
    D --> D2[Decision Making]
    
    E --> E1[Chain of Thought]
    E --> E2[Multi-perspective Analysis]
```

## API Reference

### GKPAgent

The main agent class that orchestrates the knowledge generation and reasoning process.

#### Initialization Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| agent_name | str | "gkp-agent" | Name identifier for the agent |
| model_name | str | "openai/o1" | LLM model to use for all components |
| num_knowledge_items | int | 6 | Number of knowledge snippets to generate per query |

#### Methods

| Method | Description | Parameters | Returns |
|--------|-------------|------------|---------|
| process(query: str) | Process a single query through the GKP pipeline | query: str | Dict[str, Any] containing full processing results |
| run(queries: List[str], detailed_output: bool = False) | Process multiple queries | queries: List[str], detailed_output: bool | Union[List[str], List[Dict[str, Any]]] |

### KnowledgeGenerator

Component responsible for generating relevant knowledge for queries.

#### Initialization Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| agent_name | str | "knowledge-generator" | Name identifier for the knowledge generator agent |
| model_name | str | "openai/o1" | Model to use for knowledge generation |
| num_knowledge_items | int | 2 | Number of knowledge items to generate per query |

#### Methods

| Method | Description | Parameters | Returns |
|--------|-------------|------------|---------|
| generate_knowledge(query: str) | Generate relevant knowledge for a query | query: str | List[str] of generated knowledge statements |

### Reasoner

Component that uses generated knowledge to reason about and answer queries.

#### Initialization Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| agent_name | str | "knowledge-reasoner" | Name identifier for the reasoner agent |
| model_name | str | "openai/o1" | Model to use for reasoning |

#### Methods

| Method | Description | Parameters | Returns |
|--------|-------------|------------|---------|
| reason_and_answer(query: str, knowledge: str) | Reason about a query using provided knowledge | query: str, knowledge: str | Dict[str, str] containing explanation, confidence, and answer |

## Example Usage

```python
from swarms.agents.gkp_agent import GKPAgent

# Initialize the GKP Agent
agent = GKPAgent(
    agent_name="gkp-agent",
    model_name="gpt-4",  # Using OpenAI's model
    num_knowledge_items=6,  # Generate 6 knowledge items per query
)

# Example queries
queries = [
    "What are the implications of quantum entanglement on information theory?",
]

# Run the agent
results = agent.run(queries)

# Print results
for i, result in enumerate(results):
    print(f"\nQuery {i+1}: {queries[i]}")
    print(f"Answer: {result}")
```

## Best Practices

1. **Knowledge Generation**
   - Set appropriate number of knowledge items based on query complexity
   - Monitor knowledge quality and relevance
   - Adjust model parameters for optimal performance

2. **Reasoning Process**
   - Ensure diverse reasoning paths for complex queries
   - Validate confidence levels
   - Consider multiple perspectives

3. **Coordination**
   - Review coordination logic for complex scenarios
   - Validate final answers against source knowledge
   - Monitor processing time and optimize if needed

## Performance Considerations

- Processing time increases with number of knowledge items
- Complex queries may require more knowledge items
- Consider caching frequently used knowledge
- Monitor token usage for cost optimization

## Error Handling

The agent includes robust error handling for:
- Invalid queries
- Failed knowledge generation
- Reasoning errors
- Coordination failures


--------------------------------------------------

# File: swarms/agents/iterative_agent.md

# Iterative Reflective Expansion (IRE) Algorithm Documentation

The Iterative Reflective Expansion (IRE) Algorithm is a sophisticated reasoning framework that employs iterative hypothesis generation, simulation, and refinement to solve complex problems. It leverages a multi-step approach where an AI agent generates initial solution paths, evaluates their effectiveness through simulation, reflects on errors, and dynamically revises reasoning strategies. Through continuous cycles of hypothesis testing and meta-cognitive reflection, the algorithm progressively converges on optimal solutions by learning from both successful and unsuccessful reasoning attempts.


## Architecture

```mermaid
graph TD
    Problem_Input["🧩 Problem Input"] --> Generate_Hypotheses
    Generate_Hypotheses["Generate Initial Hypotheses"] --> Simulate
    subgraph Iterative Reflective Expansion Loop
        Simulate["Simulate Reasoning Paths"] --> Evaluate
        Evaluate["Evaluate Outcomes"] --> Reflect{Is solution satisfactory?}
        Reflect -->|No, issues found| Meta_Reflect
        Reflect -->|Yes| Promising
        Meta_Reflect["Meta-Cognitive Reflection"] --> Revise_Paths
        Meta_Reflect --> Memory[(Reasoning Memory)]
        Meta_Reflect --> Memory
        Revise_Paths["Revise Paths Based on Feedback"] --> Expand_Paths
        Meta_Reflect --> Revise_Path
        Revise_Path["Revise Paths"] --> Expand_Paths
        Expand_Paths["Iterative Expansion & Pruning"] --> Simulate
    end
    Promising["Promising Paths Selected"] --> Memory
    Memory["Memory Integration"] --> Synthesize
    Synthesize["Synthesize Final Solution"] --> Final["Final Solution ✅"]

```

---

## Workflow

1. Generate initial hypotheses
2. Simulate paths
3. Reflect on errors
4. Revise paths
5. Select promising paths
6. Synthesize solution

## Class: IterativeReflectiveExpansion

### Arguments

| Argument       | Type   | Default | Description |
|----------------|--------|---------|-------------|
| agent          | Agent  | None    | The Swarms agent instance used to perform reasoning tasks. |
| max_iterations | int    | 5       | Maximum number of iterations for the reasoning process. |
| return_list    | bool   | False   | If True, returns the conversation as a list of messages. |
| return_dict    | bool   | False   | If True, returns the conversation as a dictionary of messages. |
| prompt         | str    | GENERAL_REASONING_AGENT_SYS_PROMPT | The system prompt for the agent. |

### Methods

| Method                        | Description |
|-------------------------------|-------------|
| generate_initial_hypotheses   | Generates an initial set of reasoning hypotheses based on the problem input. |
| simulate_path                 | Simulates a given reasoning path and evaluates its effectiveness. |
| meta_reflect                  | Performs meta-cognitive reflection on the provided error information. |
| revise_path                   | Revises the reasoning path based on the provided feedback. |
| select_promising_paths        | Selects the most promising reasoning paths from a list of candidates. |
| synthesize_solution           | Synthesizes a final solution from the promising reasoning paths and historical memory. |
| run                           | Executes the Iterative Reflective Expansion process on the provided problem. |

## Use-Cases

### Example 1: Solving a Mathematical Problem

```python
from swarms import IterativeReflectiveExpansion

agent = IterativeReflectiveExpansion(
    max_iterations=3,
)

agent.run("What is the 40th prime number?")
```

## Conclusion

The Iterative Reflective Expansion (IRE) Algorithm is a powerful tool for solving complex problems through iterative reasoning and reflection. By leveraging the capabilities of a Swarms agent, it can dynamically adapt and refine its approach to converge on optimal solutions.


--------------------------------------------------

# File: swarms/agents/message.md

# The Module/Class Name: Message

In the swarms.agents framework, the class `Message` is used to represent a message with timestamp and optional metadata.

## Overview and Introduction

The `Message` class is a fundamental component that enables the representation of messages within an agent system. Messages contain essential information such as the sender, content, timestamp, and optional metadata.

## Class Definition

### Constructor: `__init__`

The constructor of the `Message` class takes three parameters:

1. `sender` (str): The sender of the message.
2. `content` (str): The content of the message.
3. `metadata` (dict or None): Optional metadata associated with the message.

### Methods

1. `__repr__(self)`: Returns a string representation of the `Message` object, including the timestamp, sender, and content.

```python
class Message:
    """
    Represents a message with timestamp and optional metadata.

    Usage
    --------------
    mes = Message(
        sender = "Kye",
        content = "message"
    )

    print(mes)
    """

    def __init__(self, sender, content, metadata=None):
        self.timestamp = datetime.datetime.now()
        self.sender = sender
        self.content = content
        self.metadata = metadata or {}

    def __repr__(self):
        """
        __repr__ represents the string representation of the Message object.

        Returns:
        (str) A string containing the timestamp, sender, and content of the message.
        """
        return f"{self.timestamp} - {self.sender}: {self.content}"
```

## Functionality and Usage

The `Message` class represents a message in the agent system. Upon initialization, the `timestamp` is set to the current date and time, and the `metadata` is set to an empty dictionary if no metadata is provided.

### Usage Example 1

Creating a `Message` object and displaying its string representation.

```python
mes = Message(sender="Kye", content="Hello! How are you?")

print(mes)
```

Output:
```
2023-09-20 13:45:00 - Kye: Hello! How are you?
```

### Usage Example 2

Creating a `Message` object with metadata.

```python
metadata = {"priority": "high", "category": "urgent"}
mes_with_metadata = Message(
    sender="Alice", content="Important update", metadata=metadata
)

print(mes_with_metadata)
```

Output:
```
2023-09-20 13:46:00 - Alice: Important update
```

### Usage Example 3

Creating a `Message` object without providing metadata.

```python
mes_no_metadata = Message(sender="Bob", content="Reminder: Meeting at 2PM")

print(mes_no_metadata)
```

Output:
```
2023-09-20 13:47:00 - Bob: Reminder: Meeting at 2PM
```

## Additional Information and Tips

When creating a new `Message` object, ensure that the required parameters `sender` and `content` are provided. The `timestamp` will automatically be assigned the current date and time. Optional `metadata` can be included to provide additional context or information associated with the message.

## References and Resources

For further information on the `Message` class and its usage, refer to the official swarms.agents documentation and relevant tutorials related to message handling and communication within the agent system.


--------------------------------------------------

# File: swarms/agents/new_agent.md

# How to Create Good Agents

This guide will walk you through the steps to build high-quality agents by extending the `Agent` class. It emphasizes best practices, the use of type annotations, comprehensive documentation, and modular design to ensure maintainability and scalability. Additionally, you will learn how to incorporate a callable `llm` parameter or specify a `model_name` attribute to enhance flexibility and functionality. These principles ensure that agents are not only functional but also robust and adaptable to future requirements.

## Overview

A good agent is a modular and reusable component designed to perform specific tasks efficiently. By inheriting from the base `Agent` class, developers can extend its functionality while adhering to standardized principles. Each custom agent should:

- Inherit from the `Agent` class to maintain compatibility with swarms.
- Define a `run(task: str, img: str)` method to execute tasks effectively.
- Include descriptive attributes such as `name`, `system_prompt`, and `description` to enhance clarity.
- Optionally, include an `llm` parameter (callable) or a `model_name` to enable seamless integration with language models.
- Emphasize modularity, allowing the agent to be reused across various contexts and tasks.

By following these guidelines, you can create agents that integrate well with broader systems and exhibit high reliability in real-world applications.

---

## Creating a Custom Agent

Here is a detailed template for creating a custom agent by inheriting the `Agent` class. This template demonstrates how to structure an agent with extendable and reusable features:

```python
from typing import Callable, Any
from swarms import Agent

class MyNewAgent(Agent):
    """
    A custom agent class for specialized tasks.

    Attributes:
        name (str): The name of the agent.
        system_prompt (str): The prompt guiding the agent's behavior.
        description (str): A brief description of the agent's purpose.
        llm (Callable, optional): A callable representing the language model to use.
    """

    def __init__(self, name: str, system_prompt: str, model_name: str = None, description: str, llm: Callable = None):
        """
        Initialize the custom agent.

        Args:
            name (str): The name of the agent.
            system_prompt (str): The prompt guiding the agent.
            model_name (str): The name of your model can use litellm [openai/gpt-4o]
            description (str): A description of the agent's purpose.
            llm (Callable, optional): A callable representing the language model to use.
        """
        super().__init__(agent_name=name, system_prompt=system_prompt, model_name=model_name)
        self.agent_name = agent_name
        self.system_prompt system_prompt
        self.description = description
        self.model_name = model_name

    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -> Any:
        """
        Execute the task assigned to the agent.

        Args:
            task (str): The task description.
            img (str): The image input for processing.
            *args: Additional positional arguments.
            **kwargs: Additional keyword arguments.

        Returns:
            Any: The result of the task execution.
        """
        # Your custom logic 
        ...
```

This design ensures a seamless extension of functionality while maintaining clear and maintainable code.

---

## Key Considerations

### 1. **Type Annotations**
Always use type hints for method parameters and return values. This improves code readability, supports static analysis tools, and reduces bugs, ensuring long-term reliability.

### 2. **Comprehensive Documentation**
Provide detailed docstrings for all classes, methods, and attributes. Clear documentation ensures that your agent's functionality is understandable to both current and future collaborators.

### 3. **Modular Design**
Keep the agent logic modular and reusable. Modularity simplifies debugging, testing, and extending functionalities, making the code more adaptable to diverse scenarios.

### 4. **Flexible Model Integration**
Use either an `llm` callable or `model_name` attribute for integrating language models. This flexibility ensures your agent can adapt to various tasks, environments, and system requirements.

### 5. **Error Handling**
Incorporate robust error handling to manage unexpected inputs or issues during execution. This not only ensures reliability but also builds user trust in your system.

### 6. **Scalability Considerations**
Ensure your agent design can scale to accommodate increased complexity or a larger number of tasks without compromising performance.

---

## Example Usage

Here is an example of how to use your custom agent effectively:

```python
# Example LLM callable
class MockLLM:
    """
    A mock language model class for simulating LLM behavior.

    Methods:
        run(task: str, img: str, *args: Any, **kwargs: Any) -> str:
            Processes the task and image input to return a simulated response.
    """

    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -> str:
        return f"Processed task '{task}' with image '{img}'"

# Create an instance of MyNewAgent
agent = MyNewAgent(
    name="ImageProcessor",
    system_prompt="Process images and extract relevant details.",
    description="An agent specialized in processing images and extracting insights.",
    llm=MockLLM().run
)

# Run a task
result = agent.run(task="Analyze content", img="path/to/image.jpg")
print(result)
```

This example showcases the practical application of the `MyNewAgent` class and highlights its extensibility.


## Production-Grade Example with **Griptape Agent Integration Example**

In this example, we will create a **Griptape** agent by inheriting from the Swarms `Agent` class and implementing the `run` method.

### **Griptape Integration Steps**:

1. **Inherit from Swarms Agent**: Inherit from the `SwarmsAgent` class.
2. **Create Griptape Agent**: Initialize the **Griptape** agent inside your class and provide it with the necessary tools.
3. **Override the `run()` method**: Implement logic to process a task string and execute the Griptape agent.

## **Griptape Example Code**:

```python
from swarms import (
    Agent as SwarmsAgent,
)  # Import the base Agent class from Swarms
from griptape.structures import Agent as GriptapeAgent
from griptape.tools import (
    WebScraperTool,
    FileManagerTool,
    PromptSummaryTool,
)

# Create a custom agent class that inherits from SwarmsAgent
class GriptapeSwarmsAgent(SwarmsAgent):
    def __init__(self, name: str, system_prompt: str: str, *args, **kwargs):
        super().__init__(agent_name=name, system_prompt=system_prompt)
        # Initialize the Griptape agent with its tools
        self.agent = GriptapeAgent(
            input="Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.",
            tools=[
                WebScraperTool(off_prompt=True),
                PromptSummaryTool(off_prompt=True),
                FileManagerTool(),
            ],
            *args,
            **kwargs,
        )

    # Override the run method to take a task and execute it using the Griptape agent
    def run(self, task: str) -> str:
        # Extract URL and filename from task
        url, filename = task.split(",")  # Example task string: "https://example.com, output.txt"
        # Execute the Griptape agent
        result = self.agent.run(url.strip(), filename.strip())
        # Return the final result as a string
        return str(result)


# Example usage:
griptape_swarms_agent = GriptapeSwarmsAgent()
output = griptape_swarms_agent.run("https://griptape.ai, griptape.txt")
print(output)
```


---

## Best Practices

1. **Test Extensively:**
   Validate your agent with various task inputs to ensure it performs as expected under different conditions.

2. **Follow the Single Responsibility Principle:**
   Design each agent to focus on a specific task or role, ensuring clarity and modularity in implementation.

3. **Log Actions:**
   Include detailed logging within the `run` method to capture key actions, inputs, and results for debugging and monitoring.

4. **Use Open-Source Contributions:**
   Contribute your custom agents to the Swarms repository at [https://github.com/kyegomez/swarms](https://github.com/kyegomez/swarms). Sharing your innovations helps advance the ecosystem and encourages collaboration.

5. **Iterate and Refactor:**
   Continuously improve your agents based on feedback, performance evaluations, and new requirements to maintain relevance and functionality.

---

## Conclusion

By following these guidelines, you can create powerful and flexible agents tailored to specific tasks. Leveraging inheritance from the `Agent` class ensures compatibility and standardization across swarms. Emphasize modularity, thorough testing, and clear documentation to build agents that are robust, scalable, and easy to integrate. Collaborate with the community by submitting your innovative agents to the Swarms repository, contributing to a growing ecosystem of intelligent solutions. With a well-designed agent, you are equipped to tackle diverse challenges efficiently and effectively.



--------------------------------------------------

# File: swarms/agents/openai_assistant.md

# OpenAI Assistant

The OpenAI Assistant class provides a wrapper around OpenAI's Assistants API, integrating it with the swarms framework.

## Overview

The `OpenAIAssistant` class allows you to create and interact with OpenAI Assistants, providing a simple interface for:

- Creating assistants with specific roles and capabilities
- Adding custom functions that the assistant can call
- Managing conversation threads
- Handling tool calls and function execution
- Getting responses from the assistant

## Insstallation

```bash
pip install swarms
```
## Basic Usage

```python

from swarms import OpenAIAssistant

#Create an assistant
assistant = OpenAIAssistant(
    name="Math Tutor",
    instructions="You are a helpful math tutor.",
    model="gpt-4o",
    tools=[{"type": "code_interpreter"}]
)

#Run a Task
response = assistant.run("Solve the equation: 3x + 11 = 14")
print(response)

# Continue the conversation in the same thread
follow_up = assistant.run("Now explain how you solved it")
print(follow_up)
```

## Function Calling

The assistant supports custom function integration:

```python

def get_weather(location: str, unit: str = "celsius") -> str:
    # Mock weather function
    return f"The weather in {location} is 22 degrees {unit}"

# Add function to assistant
assistant.add_function(
    description="Get the current weather in a location",
    parameters={
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "City name"
            },
            "unit": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"],
                "default": "celsius"
            }
        },
        "required": ["location"]
    }
)
```

## API Reference

### Constructor

```python
OpenAIAssistant(
    name: str,
    instructions: Optional[str] = None,
    model: str = "gpt-4o",
    tools: Optional[List[Dict[str, Any]]] = None,
    file_ids: Optional[List[str]] = None,
    metadata: Optional[Dict[str, Any]] = None,
    functions: Optional[List[Dict[str, Any]]] = None,
)
```

### Methods

#### run(task: str) -> str
Sends a task to the assistant and returns its response. The conversation thread is maintained between calls.

#### add_function(func: Callable, description: str, parameters: Dict[str, Any]) -> None
Adds a callable function that the assistant can use during conversations.

#### add_message(content: str, file_ids: Optional[List[str]] = None) -> None
Adds a message to the current conversation thread.

## Error Handling

The assistant implements robust error handling:
- Retries on rate limits
- Graceful handling of API errors
- Clear error messages for debugging
- Status monitoring for runs and completions

## Best Practices

1. Thread Management
   - Use the same assistant instance for related conversations
   - Create new instances for unrelated tasks
   - Monitor thread status during long-running operations

2. Function Integration
   - Keep functions simple and focused
   - Provide clear descriptions and parameter schemas
   - Handle errors gracefully in custom functions
   - Test functions independently before integration

3. Performance
   - Reuse assistant instances when possible
   - Monitor and handle rate limits appropriately
   - Use appropriate polling intervals for status checks
   - Consider implementing timeouts for long-running operations

## References

- [OpenAI Assistants API Documentation](https://platform.openai.com/docs/assistants/overview)
- [OpenAI Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- [OpenAI Rate Limits](https://platform.openai.com/docs/guides/rate-limits)





--------------------------------------------------

# File: swarms/agents/reasoning_agent_router.md

# ReasoningAgentRouter Documentation

The ReasoningAgentRouter is a sophisticated agent routing system that enables dynamic selection and execution of different reasoning strategies based on the task requirements. It provides a flexible interface to work with multiple reasoning approaches including Reasoning Duo, Self-Consistency, and Iterative Reflective Expansion (IRE).

## Architecture

```mermaid
graph TD
    Task[Task Input] --> Router[ReasoningAgentRouter]
    Router --> SelectSwarm{Select Swarm Type}
    SelectSwarm -->|Reasoning Duo| RD[ReasoningDuo]
    SelectSwarm -->|Self Consistency| SC[SelfConsistencyAgent]
    SelectSwarm -->|IRE| IRE[IterativeReflectiveExpansion]
    RD --> Output[Task Output]
    SC --> Output
    IRE --> Output
```

## Class: ReasoningAgentRouter

### Arguments

| Argument | Type | Default | Description |
|----------|------|---------|-------------|
| agent_name | str | "reasoning_agent" | Name identifier for the agent |
| description | str | "A reasoning agent..." | Description of the agent's capabilities |
| model_name | str | "gpt-4o-mini" | The underlying language model to use |
| system_prompt | str | "You are a helpful..." | System prompt for the agent |
| max_loops | int | 1 | Maximum number of reasoning loops |
| swarm_type | agent_types | "reasoning_duo" | Type of reasoning swarm to use |
| num_samples | int | 1 | Number of samples for self-consistency |
| output_type | OutputType | "dict" | Format of the output |

### Methods

| Method | Description |
|--------|-------------|
| select_swarm() | Selects and initializes the appropriate reasoning swarm based on specified type |
| run(task: str) | Executes the selected swarm's reasoning process on the given task |
| batched_run(tasks: List[str]) | Executes the reasoning process on a batch of tasks |

### Swarm Types

1. **ReasoningDuo**
   - Uses two agents working together
   - One for reasoning, one for execution
   - Best for tasks requiring both analysis and action

2. **SelfConsistencyAgent**
   - Generates multiple samples
   - Ensures consistency across reasoning paths
   - Ideal for tasks requiring high reliability

3. **IterativeReflectiveExpansion (IRE)**
   - Uses iterative refinement
   - Reflects on and improves reasoning paths
   - Best for complex problem-solving

## Usage Examples

### Basic Usage

```python
from swarms.agents.reasoning_agents import ReasoningAgentRouter

# Initialize the router
router = ReasoningAgentRouter(
    agent_name="reasoning-agent",
    description="A reasoning agent that can answer questions and help with tasks.",
    model_name="gpt-4o-mini",
    system_prompt="You are a helpful assistant that can answer questions and help with tasks.",
    max_loops=1,
    swarm_type="self-consistency",
    num_samples=1,
    output_type="list"
)

# Run a single task
result = router.run("What is the best approach to solve this problem?")
```

### Batch Processing

```python
# Process multiple tasks
tasks = [
    "What is the optimal solution for X?",
    "How should we approach problem Y?"
]
results = router.batched_run(tasks)
```

### Using Different Swarm Types

#### ReasoningDuo

```python
router = ReasoningAgentRouter(
    swarm_type="reasoning-duo",
    model_name="gpt-4o-mini"
)
```

#### Self-Consistency

```python
router = ReasoningAgentRouter(
    swarm_type="self-consistency",
    num_samples=3,
    model_name="gpt-4o-mini"
)
```

#### IRE

```python
router = ReasoningAgentRouter(
    swarm_type="ire",
    max_loops=5,
    model_name="gpt-4o-mini"
)
```

## Best Practices

1. **Swarm Type Selection**
   - Use ReasoningDuo for tasks requiring both analysis and action
   - Use SelfConsistency for tasks requiring high reliability
   - Use IRE for complex problem-solving requiring iterative refinement

2. **Performance Optimization**
   - Adjust max_loops based on task complexity
   - Increase num_samples for higher reliability
   - Choose appropriate model_name based on task requirements

3. **Output Handling**
   - Use appropriate output_type for your needs
   - Process batched results appropriately
   - Handle errors gracefully

## Error Handling

The ReasoningAgentRouter includes built-in error handling for:
- Invalid swarm types
- Model execution failures
- Task processing errors

## Limitations

1. Processing time increases with:
   - Higher num_samples
   - Larger max_loops
   - More complex tasks

2. Model-specific limitations based on:
   - Token limits
   - Model capabilities
   - API rate limits

## Contributing

When extending the ReasoningAgentRouter:
1. Follow the existing swarm interface
2. Add comprehensive tests
3. Update documentation
4. Maintain error handling


--------------------------------------------------

# File: swarms/agents/reasoning_duo.md

# ReasoningDuo

The ReasoningDuo class implements a dual-agent reasoning system that combines a reasoning agent and a main agent to provide well-thought-out responses to complex tasks. This architecture enables more robust and reliable outputs by separating the reasoning process from the final response generation.


## Class Overview

### Constructor Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| model_name | str | "reasoning-agent-01" | Name identifier for the reasoning agent |
| description | str | "A highly intelligent..." | Description of the reasoning agent's capabilities |
| model_names | list[str] | ["gpt-4o-mini", "gpt-4o"] | Model names for reasoning and main agents |
| system_prompt | str | "You are a helpful..." | System prompt for the main agent |

### Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| run | task: str | str | Processes a single task through both agents |
| batched_run | tasks: List[str] | List[str] | Processes multiple tasks sequentially |



## Quick Start

```python
from swarms.agents.reasoning_duo import ReasoningDuo

# Initialize the ReasoningDuo
duo = ReasoningDuo(
    model_name="reasoning-agent-01",
    model_names=["gpt-4o-mini", "gpt-4o"]
)

# Run a single task
result = duo.run("Explain the concept of gravitational waves")

# Run multiple tasks
tasks = [
    "Calculate compound interest for $1000 over 5 years",
    "Explain quantum entanglement"
]
results = duo.batched_run(tasks)
```

## Examples

### 1. Mathematical Analysis

```python
duo = ReasoningDuo()

# Complex mathematical problem
math_task = """
Solve the following differential equation:
dy/dx + 2y = x^2, y(0) = 1
"""

solution = duo.run(math_task)
```

### 2. Physics Problem

```python
# Quantum mechanics problem
physics_task = """
Calculate the wavelength of an electron with kinetic energy of 50 eV 
using the de Broglie relationship.
"""

result = duo.run(physics_task)
```

### 3. Financial Analysis

```python
# Complex financial analysis
finance_task = """
Calculate the Net Present Value (NPV) of a project with:
- Initial investment: $100,000
- Annual cash flows: $25,000 for 5 years
- Discount rate: 8%
"""

analysis = duo.run(finance_task)
```

## Advanced Usage

### Customizing Agent Behavior

You can customize both agents by modifying their initialization parameters:

```python
duo = ReasoningDuo(
    model_name="custom-reasoning-agent",
    description="Specialized financial analysis agent",
    model_names=["gpt-4o-mini", "gpt-4o"],
    system_prompt="You are a financial expert AI assistant..."
)
```

### Batch Processing with Progress Tracking

```python
tasks = [
    "Analyze market trends for tech stocks",
    "Calculate risk metrics for a portfolio",
    "Forecast revenue growth"
]

# Process multiple tasks with logging
results = duo.batched_run(tasks)
```

## Implementation Details

The ReasoningDuo uses a two-stage process:

1. **Reasoning Stage**: The reasoning agent analyzes the task and develops a structured approach
2. **Execution Stage**: The main agent uses the reasoning output to generate the final response

### Internal Architecture

```
Task Input → Reasoning Agent → Structured Analysis → Main Agent → Final Output
```

## Best Practices

1. **Task Formulation**
   - Be specific and clear in task descriptions
   - Include relevant context and constraints
   - Break complex problems into smaller subtasks

2. **Performance Optimization**
   - Use batched_run for multiple related tasks
   - Monitor agent outputs for consistency
   - Adjust model parameters based on task complexity

## Error Handling

The ReasoningDuo includes built-in logging using the `loguru` library:

```python
from loguru import logger

# Logs are automatically generated for each task
logger.info("Task processing started")
```

## Limitations

- Processing time may vary based on task complexity
- Model response quality depends on input clarity
- Resource usage scales with batch size


--------------------------------------------------

# File: swarms/agents/reflexion_agent.md

# ReflexionAgent

The ReflexionAgent is an advanced AI agent that implements the Reflexion framework to improve through self-reflection. It follows a process of acting on tasks, evaluating its performance, generating self-reflections, and using these reflections to improve future responses.

## Overview

The ReflexionAgent consists of three specialized sub-agents:
- **Actor**: Generates initial responses to tasks
- **Evaluator**: Critically assesses responses against quality criteria
- **Reflector**: Generates self-reflections to improve future responses

## Initialization

```python
from swarms.agents import ReflexionAgent

agent = ReflexionAgent(
    agent_name="reflexion-agent",
    system_prompt="...",  # Optional custom system prompt
    model_name="openai/o1",
    max_loops=3,
    memory_capacity=100
)
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `agent_name` | `str` | `"reflexion-agent"` | Name of the agent |
| `system_prompt` | `str` | `REFLEXION_PROMPT` | System prompt for the agent |
| `model_name` | `str` | `"openai/o1"` | Model name for generating responses |
| `max_loops` | `int` | `3` | Maximum number of reflection iterations per task |
| `memory_capacity` | `int` | `100` | Maximum capacity of long-term memory |

## Methods

### act

Generates a response to the given task using the actor agent.

```python
response = agent.act(task: str, relevant_memories: List[Dict[str, Any]] = None) -> str
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The task to respond to |
| `relevant_memories` | `List[Dict[str, Any]]` | Optional relevant past memories to consider |

### evaluate

Evaluates the quality of a response to a task.

```python
evaluation, score = agent.evaluate(task: str, response: str) -> Tuple[str, float]
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The original task |
| `response` | `str` | The response to evaluate |

Returns:
- `evaluation`: Detailed feedback on the response
- `score`: Numerical score between 0 and 1

### reflect

Generates a self-reflection based on the task, response, and evaluation.

```python
reflection = agent.reflect(task: str, response: str, evaluation: str) -> str
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The original task |
| `response` | `str` | The generated response |
| `evaluation` | `str` | The evaluation feedback |

### refine

Refines the original response based on evaluation and reflection.

```python
refined_response = agent.refine(
    task: str,
    original_response: str,
    evaluation: str,
    reflection: str
) -> str
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The original task |
| `original_response` | `str` | The original response |
| `evaluation` | `str` | The evaluation feedback |
| `reflection` | `str` | The self-reflection |

### step

Processes a single task through one iteration of the Reflexion process.

```python
result = agent.step(
    task: str,
    iteration: int = 0,
    previous_response: str = None
) -> Dict[str, Any]
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The task to process |
| `iteration` | `int` | Current iteration number |
| `previous_response` | `str` | Response from previous iteration |

Returns a dictionary containing:
- `task`: The original task
- `response`: The generated response
- `evaluation`: The evaluation feedback
- `reflection`: The self-reflection
- `score`: Numerical score
- `iteration`: Current iteration number

### run

Executes the Reflexion process for a list of tasks.

```python
results = agent.run(
    tasks: List[str],
    include_intermediates: bool = False
) -> List[Any]
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `tasks` | `List[str]` | List of tasks to process |
| `include_intermediates` | `bool` | Whether to include intermediate iterations in results |

Returns:
- If `include_intermediates=False`: List of final responses
- If `include_intermediates=True`: List of complete iteration histories

## Example Usage

```python
from swarms.agents import ReflexionAgent

# Initialize the Reflexion Agent
agent = ReflexionAgent(
    agent_name="reflexion-agent",
    model_name="openai/o1",
    max_loops=3
)

# Example tasks
tasks = [
    "Explain quantum computing to a beginner.",
    "Write a Python function to sort a list of dictionaries by a specific key."
]

# Run the agent
results = agent.run(tasks)

# Print results
for i, result in enumerate(results):
    print(f"\nTask {i+1}: {tasks[i]}")
    print(f"Response: {result}")
```

## Memory System

The ReflexionAgent includes a sophisticated memory system (`ReflexionMemory`) that maintains both short-term and long-term memories of past experiences, reflections, and feedback. This system helps the agent learn from past interactions and improve its responses over time.

### Memory Features
- Short-term memory for recent interactions
- Long-term memory for important reflections and patterns
- Automatic memory management with capacity limits
- Relevance-based memory retrieval
- Similarity-based deduplication

## Best Practices

1. **Task Clarity**: Provide clear, specific tasks to get the best results
2. **Iteration Count**: Adjust `max_loops` based on task complexity (more complex tasks may benefit from more iterations)
3. **Memory Management**: Monitor memory usage and adjust `memory_capacity` as needed
4. **Model Selection**: Choose an appropriate model based on your specific use case and requirements
5. **Error Handling**: Implement proper error handling when using the agent in production


--------------------------------------------------

# File: swarms/agents/structured_outputs.md

# Agentic Structured Outputs

Structured outputs help ensure that your agents return data in a consistent, predictable format that can be easily parsed and processed by your application. This is particularly useful when building complex applications that require standardized data handling.

## Schema Definition

Structured outputs are defined using JSON Schema format. Here's the basic structure:

```python
tools = [
    {
        "type": "function",
        "function": {
            "name": "function_name",
            "description": "Description of what the function does",
            "parameters": {
                "type": "object",
                "properties": {
                    # Define your parameters here
                },
                "required": [
                    # List required parameters
                ]
            }
        }
    }
]
```

### Parameter Types

The following parameter types are supported:

- `string`: Text values
- `number`: Numeric values
- `boolean`: True/False values
- `object`: Nested objects
- `array`: Lists or arrays
- `null`: Null values

## Implementation Steps

1. **Define Your Schema**
   ```python
   tools = [
       {
           "type": "function",
           "function": {
               "name": "get_stock_price",
               "description": "Retrieve stock price information",
               "parameters": {
                   "type": "object",
                   "properties": {
                       "ticker": {
                           "type": "string",
                           "description": "Stock ticker symbol"
                       },
                       # Add more parameters as needed
                   },
                   "required": ["ticker"]
               }
           }
       }
   ]
   ```

2. **Initialize the Agent**
   ```python
   from swarms import Agent
   
   agent = Agent(
       agent_name="Your-Agent-Name",
       agent_description="Agent description",
       system_prompt="Your system prompt",
       tools_list_dictionary=tools
   )
   ```

3. **Run the Agent**
   ```python
   response = agent.run("Your query here")
   ```

4. **Parse the Output**
   ```python
   from swarms.utils.str_to_dict import str_to_dict
   
   parsed_output = str_to_dict(response)
   ```

## Example Usage

Here's a complete example using a financial agent:

```python
from dotenv import load_dotenv
from swarms import Agent
from swarms.utils.str_to_dict import str_to_dict

# Load environment variables
load_dotenv()

# Define tools with structured output schema
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_stock_price",
            "description": "Retrieve the current stock price and related information",
            "parameters": {
                "type": "object",
                "properties": {
                    "ticker": {
                        "type": "string",
                        "description": "Stock ticker symbol"
                    },
                    "include_history": {
                        "type": "boolean",
                        "description": "Include historical data"
                    },
                    "time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Time for stock data"
                    }
                },
                "required": ["ticker", "include_history", "time"]
            }
        }
    }
]

# Initialize agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    agent_description="Personal finance advisor agent",
    system_prompt="Your system prompt here",
    max_loops=1,
    tools_list_dictionary=tools
)

# Run agent
response = agent.run("What is the current stock price for AAPL?")

# Parse structured output
parsed_data = str_to_dict(response)
```

## Best Practices

1. **Schema Design**
   - Keep schemas as simple as possible while meeting your needs
   - Use clear, descriptive parameter names
   - Include detailed descriptions for each parameter
   - Specify all required parameters explicitly

2. **Error Handling**
   - Always validate the output format
   - Implement proper error handling for parsing failures
   - Use try-except blocks when converting strings to dictionaries

3. **Performance**
   - Minimize the number of required parameters
   - Use appropriate data types for each parameter
   - Consider caching parsed results if used frequently

## Troubleshooting

Common issues and solutions:

1. **Invalid Output Format**
   - Ensure your schema matches the expected output
   - Verify all required fields are present
   - Check for proper JSON formatting

2. **Parsing Errors**
   - Use `str_to_dict()` for reliable string-to-dictionary conversion
   - Validate input strings before parsing
   - Handle potential parsing exceptions

3. **Missing Fields**
   - Verify all required fields are defined in the schema
   - Check if the agent is properly configured
   - Review the system prompt for clarity



--------------------------------------------------

# File: swarms/agents/third_party.md

# Swarms Framework: Integrating and Customizing Agent Libraries

Agent-based systems have emerged as a powerful paradigm for solving complex problems and automating tasks. 

The swarms framework offers a flexible and extensible approach to working with various agent libraries, allowing developers to create custom agents and integrate them seamlessly into their projects. 

In this comprehensive guide, we'll explore the swarms framework, discuss agent handling, and demonstrate how to build custom agents using swarms. We'll also cover the integration of popular agent libraries such as Langchain, Griptape, CrewAI, and Autogen.

## Table of Contents

1. [Introduction to the Swarms Framework](#introduction-to-the-swarms-framework)
2. [The Need for Wrappers](#the-need-for-wrappers)
3. [Building Custom Agents with Swarms](#building-custom-agents-with-swarms)
4. [Integrating Third-Party Agent Libraries](#integrating-third-party-agent-libraries)
   - [Griptape Integration](#griptape-integration)
   - [Langchain Integration](#langchain-integration)
   - [CrewAI Integration](#crewai-integration)
   - [Autogen Integration](#autogen-integration)
5. [Advanced Agent Handling Techniques](#advanced-agent-handling-techniques)
6. [Best Practices for Custom Agent Development](#best-practices-for-custom-agent-development)
7. [Future Directions and Challenges](#future-directions-and-challenges)
8. [Conclusion](#conclusion)

## 1. Introduction to the Swarms Framework

The swarms framework is a powerful and flexible system designed to facilitate the creation, management, and coordination of multiple AI agents. It provides a standardized interface for working with various agent types, allowing developers to leverage the strengths of different agent libraries while maintaining a consistent programming model.

At its core, the swarms framework is built around the concept of a parent `Agent` class, which serves as a foundation for creating custom agents and integrating third-party agent libraries. This approach offers several benefits:

1. **Consistency**: By wrapping different agent implementations with a common interface, developers can work with a unified API across various agent types.
2. **Extensibility**: The framework makes it easy to add new agent types or customize existing ones without affecting the overall system architecture.
3. **Interoperability**: Agents from different libraries can communicate and collaborate seamlessly within the swarms ecosystem.
4. **Scalability**: The standardized approach allows for easier scaling of agent-based systems, from simple single-agent applications to complex multi-agent swarms.

## 2. The Need for Wrappers

As the field of AI and agent-based systems continues to grow, numerous libraries and frameworks have emerged, each with its own strengths and specialized features. While this diversity offers developers a wide range of tools to choose from, it also presents challenges in terms of integration and interoperability.

This is where the concept of wrappers becomes crucial. By creating wrappers around different agent libraries, we can:

1. **Unify interfaces**: Standardize the way we interact with agents, regardless of their underlying implementation.
2. **Simplify integration**: Make it easier to incorporate new agent libraries into existing projects.
3. **Enable composition**: Allow for the creation of complex agent systems that leverage the strengths of multiple libraries.
4. **Facilitate maintenance**: Centralize the management of agent-related code and reduce the impact of library-specific changes.

In the context of the swarms framework, wrappers take the form of custom classes that inherit from the parent `Agent` class. These wrapper classes encapsulate the functionality of specific agent libraries while exposing a consistent interface that aligns with the swarms framework.

## 3. Building Custom Agents with Swarms

To illustrate the process of building custom agents using the swarms framework, let's start with a basic example of creating a custom agent class:

```python
from swarms import Agent

class MyCustomAgent(Agent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Custom initialization logic

    def custom_method(self, *args, **kwargs):
        # Implement custom logic here
        pass

    def run(self, task, *args, **kwargs):
        # Customize the run method
        response = super().run(task, *args, **kwargs)
        # Additional custom logic
        return response
```

This example demonstrates the fundamental structure of a custom agent class within the swarms framework. Let's break down the key components:

1. **Inheritance**: The class inherits from the `Agent` parent class, ensuring it adheres to the swarms framework's interface.

2. **Initialization**: The `__init__` method calls the parent class's initializer and can include additional custom initialization logic.

3. **Custom methods**: You can add any number of custom methods to extend the agent's functionality.

4. **Run method**: The `run` method is a key component of the agent interface. By overriding this method, you can customize how the agent processes tasks while still leveraging the parent class's functionality.

To create more sophisticated custom agents, you can expand on this basic structure by adding features such as:

- **State management**: Implement methods to manage the agent's internal state.
- **Communication protocols**: Define how the agent interacts with other agents in the swarm.
- **Learning capabilities**: Incorporate machine learning models or adaptive behaviors.
- **Specialized task handling**: Create methods for dealing with specific types of tasks or domains.

By leveraging these custom agent classes, developers can create highly specialized and adaptive agents tailored to their specific use cases while still benefiting from the standardized interface provided by the swarms framework.

## 4. Integrating Third-Party Agent Libraries

One of the key strengths of the swarms framework is its ability to integrate with various third-party agent libraries. In this section, we'll explore how to create wrappers for popular agent libraries, including Griptape, Langchain, CrewAI, and Autogen.

### Griptape Integration

Griptape is a powerful library for building AI agents with a focus on composability and tool use. Let's create a wrapper for a Griptape agent:

```python
from typing import List, Optional

from griptape.structures import Agent as GriptapeAgent
from griptape.tools import FileManager, TaskMemoryClient, WebScraper

from swarms import Agent


class GriptapeAgentWrapper(Agent):
    """
    A wrapper class for the GriptapeAgent from the griptape library.
    """

    def __init__(self, name: str, tools: Optional[List] = None, *args, **kwargs):
        """
        Initialize the GriptapeAgentWrapper.

        Parameters:
        - name: The name of the agent.
        - tools: A list of tools to be used by the agent. If not provided, default tools will be used.
        - *args, **kwargs: Additional arguments to be passed to the parent class constructor.
        """
        super().__init__(*args, **kwargs)
        self.name = name
        self.tools = tools or [
            WebScraper(off_prompt=True),
            TaskMemoryClient(off_prompt=True),
            FileManager()
        ]
        self.griptape_agent = GriptapeAgent(
            input=f"I am {name}, an AI assistant. How can I help you?",
            tools=self.tools
        )

    def run(self, task: str, *args, **kwargs) -> str:
        """
        Run a task using the GriptapeAgent.

        Parameters:
        - task: The task to be performed by the agent.

        Returns:
        - The response from the GriptapeAgent as a string.
        """
        response = self.griptape_agent.run(task, *args, **kwargs)
        return str(response)

    def add_tool(self, tool) -> None:
        """
        Add a tool to the agent.

        Parameters:
        - tool: The tool to be added.
        """
        self.tools.append(tool)
        self.griptape_agent = GriptapeAgent(
            input=f"I am {self.name}, an AI assistant. How can I help you?",
            tools=self.tools
        )

# Usage example
griptape_wrapper = GriptapeAgentWrapper("GriptapeAssistant")
result = griptape_wrapper.run("Load https://example.com, summarize it, and store it in a file called example_summary.txt.")
print(result)

```

This wrapper encapsulates the functionality of a Griptape agent while exposing it through the swarms framework's interface. It allows for easy customization of tools and provides a simple way to execute tasks using the Griptape agent.

### Langchain Integration

Langchain is a popular framework for developing applications powered by language models. Here's an example of how we can create a wrapper for a Langchain agent:

```python
from typing import List, Optional

from langchain.agents import AgentExecutor, LLMSingleActionAgent, Tool
from langchain.chains import LLMChain
from langchain_community.llms import OpenAI
from langchain.prompts import StringPromptTemplate
from langchain.tools import DuckDuckGoSearchRun

from swarms import Agent


class LangchainAgentWrapper(Agent):
    """
    Initialize the LangchainAgentWrapper.

    Args:
        name (str): The name of the agent.
        tools (List[Tool]): The list of tools available to the agent.
        llm (Optional[OpenAI], optional): The OpenAI language model to use. Defaults to None.
    """
    def __init__(
        self,
        name: str,
        tools: List[Tool],
        llm: Optional[OpenAI] = None,
        *args,
        **kwargs,
    ):
        super().__init__(*args, **kwargs)
        self.name = name
        self.tools = tools
        self.llm = llm or OpenAI(temperature=0)

        prompt = StringPromptTemplate.from_template(
            "You are {name}, an AI assistant. Answer the following question: {question}"
        )

        llm_chain = LLMChain(llm=self.llm, prompt=prompt)
        tool_names = [tool.name for tool in self.tools]

        self.agent = LLMSingleActionAgent(
            llm_chain=llm_chain,
            output_parser=None,
            stop=["\nObservation:"],
            allowed_tools=tool_names,
        )

        self.agent_executor = AgentExecutor.from_agent_and_tools(
            agent=self.agent, tools=self.tools, verbose=True
        )

    def run(self, task: str, *args, **kwargs):
        """
        Run the agent with the given task.

        Args:
            task (str): The task to be performed by the agent.

        Returns:
            Any: The result of the agent's execution.
        """
        try:
            return self.agent_executor.run(task)
        except Exception as e:
            print(f"An error occurred: {e}")


# Usage example

search_tool = DuckDuckGoSearchRun()
tools = [
    Tool(
        name="Search",
        func=search_tool.run,
        description="Useful for searching the internet",
    )
]

langchain_wrapper = LangchainAgentWrapper("LangchainAssistant", tools)
result = langchain_wrapper.run("What is the capital of France?")
print(result)
```

This wrapper integrates a Langchain agent into the swarms framework, allowing for easy use of Langchain's powerful features such as tool use and multi-step reasoning.

### CrewAI Integration

CrewAI is a library focused on creating and managing teams of AI agents. Let's create a wrapper for a CrewAI agent:

```python
from swarms import Agent
from crewai import Agent as CrewAIAgent
from crewai import Task, Crew, Process

class CrewAIAgentWrapper(Agent):
    def __init__(self, name, role, goal, backstory, tools=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = name
        self.crewai_agent = CrewAIAgent(
            role=role,
            goal=goal,
            backstory=backstory,
            verbose=True,
            allow_delegation=False,
            tools=tools or []
        )

    def run(self, task, *args, **kwargs):
        crew_task = Task(
            description=task,
            agent=self.crewai_agent
        )
        crew = Crew(
            agents=[self.crewai_agent],
            tasks=[crew_task],
            process=Process.sequential
        )
        result = crew.kickoff()
        return result

# Usage example
from crewai_tools import SerperDevTool

search_tool = SerperDevTool()

crewai_wrapper = CrewAIAgentWrapper(
    "ResearchAnalyst",
    role='Senior Research Analyst',
    goal='Uncover cutting-edge developments in AI and data science',
    backstory="""You work at a leading tech think tank.
    Your expertise lies in identifying emerging trends.
    You have a knack for dissecting complex data and presenting actionable insights.""",
    tools=[search_tool]
)

result = crewai_wrapper.run("Analyze the latest trends in quantum computing and summarize the key findings.")
print(result)
```

This wrapper allows us to use CrewAI agents within the swarms framework, leveraging CrewAI's focus on role-based agents and collaborative task execution.

### Autogen Integration

Autogen is a framework for building conversational AI agents. Here's how we can create a wrapper for an Autogen agent:

```python
from swarms import Agent
from autogen import ConversableAgent

class AutogenAgentWrapper(Agent):
    def __init__(self, name, llm_config, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = name
        self.autogen_agent = ConversableAgent(
            name=name,
            llm_config=llm_config,
            code_execution_config=False,
            function_map=None,
            human_input_mode="NEVER"
        )

    def run(self, task, *args, **kwargs):
        messages = [{"content": task, "role": "user"}]
        response = self.autogen_agent.generate_reply(messages)
        return response

# Usage example
import os

llm_config = {
    "config_list": [{"model": "gpt-4", "api_key": os.environ.get("OPENAI_API_KEY")}]
}

autogen_wrapper = AutogenAgentWrapper("AutogenAssistant", llm_config)
result = autogen_wrapper.run("Tell me a joke about programming.")
print(result)
```

This wrapper integrates Autogen's ConversableAgent into the swarms framework, allowing for easy use of Autogen's conversational AI capabilities.

By creating these wrappers, we can seamlessly integrate agents from various libraries into the swarms framework, allowing for a unified approach to agent management and task execution.

## 5. Advanced Agent Handling Techniques

As you build more complex systems using the swarms framework and integrated agent libraries, you'll need to employ advanced techniques for agent handling. Here are some strategies to consider:

### 1. Dynamic Agent Creation

Implement a factory pattern to create agents dynamically based on task requirements:

```python
class AgentFactory:
    @staticmethod
    def create_agent(agent_type, *args, **kwargs):
        if agent_type == "griptape":
            return GriptapeAgentWrapper(*args, **kwargs)
        elif agent_type == "langchain":
            return LangchainAgentWrapper(*args, **kwargs)
        elif agent_type == "crewai":
            return CrewAIAgentWrapper(*args, **kwargs)
        elif agent_type == "autogen":
            return AutogenAgentWrapper(*args, **kwargs)
        else:
            raise ValueError(f"Unknown agent type: {agent_type}")

# Usage
agent = AgentFactory.create_agent("griptape", "DynamicGriptapeAgent")
```


### 2. Agent Pooling

Implement an agent pool to manage and reuse agents efficiently:

```python
from queue import Queue

class AgentPool:
    def __init__(self, pool_size=5):
        self.pool = Queue(maxsize=pool_size)
        self.pool_size = pool_size

    def get_agent(self, agent_type, *args, **kwargs):
        if not self.pool.empty():
            return self.pool.get()
        else:
            return AgentFactory.create_agent(agent_type, *args, **kwargs)

    def release_agent(self, agent):
        if self.pool.qsize() < self.pool_size:
            self.pool.put(agent)

# Usage
pool = AgentPool()
agent = pool.get_agent("langchain", "PooledLangchainAgent")
result = agent.run("Perform a task")
pool.release_agent(agent)
```

### 3. Agent Composition

Create composite agents that combine the capabilities of multiple agent types:

```python
class CompositeAgent(Agent):
    def __init__(self, name, agents):
        super().__init__()
        self.name = name
        self.agents = agents

    def run(self, task):
        results = []
        for agent in self.agents:
            results.append(agent.run(task))
        return self.aggregate_results(results)

    def aggregate_results(self, results):
        # Implement your own logic to combine results
        return "\n".join(results)

# Usage
griptape_agent = GriptapeAgentWrapper("GriptapeComponent")
langchain_agent = LangchainAgentWrapper("LangchainComponent", [])
composite_agent = CompositeAgent("CompositeAssistant", [griptape_agent, langchain_agent])
result = composite_agent.run("Analyze the pros and cons of quantum computing")
```

### 4. Agent Specialization

Create specialized agents for specific domains or tasks:

```python
class DataAnalysisAgent(Agent):
    def __init__(self, name, analysis_tools):
        super().__init__()
        self.name = name
        self.analysis_tools = analysis_tools

    def run(self, data):
        results = {}
        for tool in self.analysis_tools:
            results[tool.name] = tool.analyze(data)
        return results

# Usage
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

class AnalysisTool:
    def __init__(self, name, func):
        self.name = name
        self.func = func

    def analyze(self, data):
        return self.func(data)

tools = [
    AnalysisTool("Descriptive Stats", lambda data: data.describe()),
    AnalysisTool("Correlation", lambda data: data.corr()),
    AnalysisTool("PCA", lambda data: PCA().fit_transform(StandardScaler().fit_transform(data)))
]

data_agent = DataAnalysisAgent("DataAnalyst", tools)
df = pd.read_csv("sample_data.csv")
analysis_results = data_agent.run(df)
```

### 5. Agent Monitoring and Logging

Implement a monitoring system to track agent performance and log their activities:

```python
import logging
from functools import wraps

def log_agent_activity(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        logging.info(f"Agent {self.name} started task: {args[0]}")
        result = func(self, *args, **kwargs)
        logging.info(f"Agent {self.name} completed task. Result length: {len(str(result))}")
        return result
    return wrapper

class MonitoredAgent(Agent):
    def __init__(self, name, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = name

    @log_agent_activity
    def run(self, task, *args, **kwargs):
        return super().run(task, *args, **kwargs)

# Usage
logging.basicConfig(level=logging.INFO)
monitored_agent = MonitoredAgent("MonitoredGriptapeAgent")
result = monitored_agent.run("Summarize the latest AI research papers")
```
Additionally the Agent class now includes built-in logging functionality and the ability to switch between JSON and string output. 

To switch between JSON and string output:
- Use `output_type="str"` for string output (default)
- Use `output_type="json"` for JSON output

The `output_type` parameter determines the format of the final result returned by the `run` method. When set to "str", it returns a string representation of the agent's response. When set to "json", it returns a JSON object containing detailed information about the agent's run, including all steps and metadata.

## 6. Best Practices for Custom Agent Development

When developing custom agents using the swarms framework, consider the following best practices:

1. **Modular Design**: Design your agents with modularity in mind. Break down complex functionality into smaller, reusable components.

2. **Consistent Interfaces**: Maintain consistent interfaces across your custom agents to ensure interoperability within the swarms framework.

3. **Error Handling**: Implement robust error handling and graceful degradation in your agents to ensure system stability.

4. **Performance Optimization**: Optimize your agents for performance, especially when dealing with resource-intensive tasks or large-scale deployments.

5. **Testing and Validation**: Develop comprehensive test suites for your custom agents to ensure their reliability and correctness.

6. **Documentation**: Provide clear and detailed documentation for your custom agents, including their capabilities, limitations, and usage examples.

7. **Versioning**: Implement proper versioning for your custom agents to manage updates and maintain backwards compatibility.

8. **Security Considerations**: Implement security best practices, especially when dealing with sensitive data or integrating with external services.

Here's an example that incorporates some of these best practices:

```python
import logging
from typing import Dict, Any
from swarms import Agent

class SecureCustomAgent(Agent):
    def __init__(self, name: str, api_key: str, version: str = "1.0.0", *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = name
        self._api_key = api_key  # Store sensitive data securely
        self.version = version
        self.logger = logging.getLogger(f"{self.__class__.__name__}.{self.name}")

    def run(self, task: str, *args, **kwargs) -> Dict[str, Any]:
        try:
            self.logger.info(f"Agent {self.name} (v{self.version}) starting task: {task}")
            result = self._process_task(task)
            self.logger.info(f"Agent {self.name} completed task successfully")
            return {"status": "success", "result": result}
        except Exception as e:
            self.logger.error(f"Error in agent {self.name}: {str(e)}")
            return {"status": "error", "message": str(e)}

    def _process_task(self, task: str) -> str:
        # Implement the core logic of your agent here
        # This is a placeholder implementation
        return f"Processed task: {task}"

    @property
    def api_key(self) -> str:
        # Provide a secure way to access the API key
        return self._api_key

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} name='{self.name}' version='{self.version}'>"

# Usage
logging.basicConfig(level=logging.INFO)
secure_agent = SecureCustomAgent("SecureAgent", api_key="your-api-key-here")
result = secure_agent.run("Perform a secure operation")
print(result)
```

This example demonstrates several best practices:
- Modular design with separate methods for initialization and task processing
- Consistent interface adhering to the swarms framework
- Error handling and logging
- Secure storage of sensitive data (API key)
- Version tracking
- Type hinting for improved code readability and maintainability
- Informative string representation of the agent

## 7. Future Directions and Challenges

As the field of AI and agent-based systems continues to evolve, the swarms framework and its ecosystem of integrated agent libraries will face new opportunities and challenges. Some potential future directions and areas of focus include:

1. **Enhanced Interoperability**: Developing more sophisticated protocols for agent communication and collaboration across different libraries and frameworks.

2. **Scalability**: Improving the framework's ability to handle large-scale swarms of agents, potentially leveraging distributed computing techniques.

3. **Adaptive Learning**: Incorporating more advanced machine learning techniques to allow agents to adapt and improve their performance over time.

4. **Ethical AI**: Integrating ethical considerations and safeguards into the agent development process to ensure responsible AI deployment.

5. **Human-AI Collaboration**: Exploring new paradigms for human-AI interaction and collaboration within the swarms framework.

6. **Domain-Specific Optimizations**: Developing specialized agent types and tools for specific industries or problem domains.

7. **Explainability and Transparency**: Improving the ability to understand and explain agent decision-making processes.

8. **Security and Privacy**: Enhancing the framework's security features to protect against potential vulnerabilities and ensure data privacy.

As these areas develop, developers working with the swarms framework will need to stay informed about new advancements and be prepared to adapt their agent implementations accordingly.

## 8. Conclusion

The swarms framework provides a powerful and flexible foundation for building custom agents and integrating various agent libraries. By leveraging the techniques and best practices discussed in this guide, developers can create sophisticated, efficient, and scalable agent-based systems.

The ability to seamlessly integrate agents from libraries like Griptape, Langchain, CrewAI, and Autogen opens up a world of possibilities for creating diverse and specialized AI applications. Whether you're building a complex multi-agent system for data analysis, a conversational AI platform, or a collaborative problem-solving environment, the swarms framework offers the tools and flexibility to bring your vision to life.

As you embark on your journey with the swarms framework, remember that the field of AI and agent-based systems is rapidly evolving. Stay curious, keep experimenting, and don't hesitate to push the boundaries of what's possible with custom agents and integrated libraries.

By embracing the power of the swarms framework and the ecosystem of agent libraries it supports, you're well-positioned to create the next generation of intelligent, adaptive, and collaborative AI systems. Happy agent building!


--------------------------------------------------

# File: swarms/agents/tool_agent.md

# ToolAgent Documentation

The `ToolAgent` class is a specialized agent that facilitates the execution of specific tasks using a model and tokenizer. It is part of the `swarms` module and inherits from the `Agent` class. This agent is designed to generate functions based on a given JSON schema and task, making it highly adaptable for various use cases, including natural language processing and data generation.

The `ToolAgent` class plays a crucial role in leveraging pre-trained models and tokenizers to automate tasks that require the interpretation and generation of structured data. By providing a flexible interface and robust error handling, it ensures smooth integration and efficient task execution.

### Parameters

| Parameter          | Type                              | Description                                                                     |
|--------------------|-----------------------------------|---------------------------------------------------------------------------------|
| `name`             | `str`                             | The name of the tool agent. Default is "Function Calling Agent".                |
| `description`      | `str`                             | A description of the tool agent. Default is "Generates a function based on the input json schema and the task". |
| `model`            | `Any`                             | The model used by the tool agent.                                               |
| `tokenizer`        | `Any`                             | The tokenizer used by the tool agent.                                           |
| `json_schema`      | `Any`                             | The JSON schema used by the tool agent.                                         |
| `max_number_tokens`| `int`                             | The maximum number of tokens for generation. Default is 500.                    |
| `parsing_function` | `Optional[Callable]`              | An optional parsing function to process the output of the tool agent.           |
| `llm`              | `Any`                             | An optional large language model to be used by the tool agent.                  |
| `*args`            | Variable length argument list     | Additional positional arguments.                                                |
| `**kwargs`         | Arbitrary keyword arguments       | Additional keyword arguments.                                                   |

### Attributes

| Attribute          | Type  | Description                                  |
|--------------------|-------|----------------------------------------------|
| `name`             | `str` | The name of the tool agent.                  |
| `description`      | `str` | A description of the tool agent.             |
| `model`            | `Any` | The model used by the tool agent.            |
| `tokenizer`        | `Any` | The tokenizer used by the tool agent.        |
| `json_schema`      | `Any` | The JSON schema used by the tool agent.      |

### Methods

#### `run`

```python
def run(self, task: str, *args, **kwargs) -> Any:
```

**Parameters:**

| Parameter  | Type                      | Description                                                      |
|------------|---------------------------|------------------------------------------------------------------|
| `task`     | `str`                     | The task to be performed by the tool agent.                      |
| `*args`    | Variable length argument list | Additional positional arguments.                                 |
| `**kwargs` | Arbitrary keyword arguments | Additional keyword arguments.                                    |

**Returns:** 

- The output of the tool agent.

**Raises:** 

- `Exception`: If an error occurs during the execution of the tool agent.

## Functionality and Usage

The `ToolAgent` class provides a structured way to perform tasks using a model and tokenizer. It initializes with essential parameters and attributes, and the `run` method facilitates the execution of the specified task.

### Initialization

The initialization of a `ToolAgent` involves specifying its name, description, model, tokenizer, JSON schema, maximum number of tokens, optional parsing function, and optional large language model.

```python
agent = ToolAgent(
    name="My Tool Agent",
    description="A tool agent for specific tasks",
    model=model,
    tokenizer=tokenizer,
    json_schema=json_schema,
    max_number_tokens=1000,
    parsing_function=my_parsing_function,
    llm=my_llm
)
```

### Running a Task

To execute a task using the `ToolAgent`, the `run` method is called with the task description and any additional arguments or keyword arguments.

```python
result = agent.run("Generate a person's information based on the given schema.")
print(result)
```

### Detailed Examples

#### Example 1: Basic Usage

```python
from transformers import AutoModelForCausalLM, AutoTokenizer
from swarms import ToolAgent

model = AutoModelForCausalLM.from_pretrained("databricks/dolly-v2-12b")
tokenizer = AutoTokenizer.from_pretrained("databricks/dolly-v2-12b")

json_schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": "number"},
        "is_student": {"type": "boolean"},
        "courses": {
            "type": "array",
            "items": {"type": "string"}
        }
    }
}

task = "Generate a person's information based on the following schema:"
agent = ToolAgent(model=model, tokenizer=tokenizer, json_schema=json_schema)
generated_data = agent.run(task)

print(generated_data)
```

#### Example 2: Using a Parsing Function

```python
def parse_output(output):
    # Custom parsing logic
    return output

agent = ToolAgent(
    name="Parsed Tool Agent",
    description="A tool agent with a parsing function",
    model=model,
    tokenizer=tokenizer,
    json_schema=json_schema,
    parsing_function=parse_output
)

task = "Generate a person's information with custom parsing:"
parsed_data = agent.run(task)

print(parsed_data)
```

#### Example 3: Specifying Maximum Number of Tokens

```python
agent = ToolAgent(
    name="Token Limited Tool Agent",
    description="A tool agent with a token limit",
    model=model,
    tokenizer=tokenizer,
    json_schema=json_schema,
    max_number_tokens=200
)

task = "Generate a concise person's information:"
limited_data = agent.run(task)

print(limited_data)
```


## Full Usage
```python

from pydantic import BaseModel, Field
from transformers import AutoModelForCausalLM, AutoTokenizer

from swarms import ToolAgent
from swarms.tools.json_utils import base_model_to_json

# Model name
model_name = "CohereForAI/c4ai-command-r-v01-4bit"

# Load the pre-trained model and tokenizer
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    device_map="auto",
)

# Load the pre-trained model and tokenizer
tokenizer = AutoTokenizer.from_pretrained(model_name)


# Initialize the schema for the person's information
class APIExampleRequestSchema(BaseModel):
    endpoint: str = Field(
        ..., description="The API endpoint for the example request"
    )
    method: str = Field(
        ..., description="The HTTP method for the example request"
    )
    headers: dict = Field(
        ..., description="The headers for the example request"
    )
    body: dict = Field(..., description="The body of the example request")
    response: dict = Field(
        ...,
        description="The expected response of the example request",
    )


# Convert the schema to a JSON string
api_example_schema = base_model_to_json(APIExampleRequestSchema)
# Convert the schema to a JSON string

# Define the task to generate a person's information
task = "Generate an example API request using this code:\n"

# Create an instance of the ToolAgent class
agent = ToolAgent(
    name="Command R Tool Agent",
    description=(
        "An agent that generates an API request using the Command R"
        " model."
    ),
    model=model,
    tokenizer=tokenizer,
    json_schema=api_example_schema,
)

# Run the agent to generate the person's information
generated_data = agent.run(task)

# Print the generated data
print(f"Generated data: {generated_data}")



```


## Jamba ++ ToolAgent
```python
from pydantic import BaseModel, Field
from transformers import AutoModelForCausalLM, AutoTokenizer

from swarms import ToolAgent
from swarms.tools.json_utils import base_model_to_json

# Model name
model_name = "ai21labs/Jamba-v0.1"

# Load the pre-trained model and tokenizer
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    device_map="auto",
)

# Load the pre-trained model and tokenizer
tokenizer = AutoTokenizer.from_pretrained(model_name)


# Initialize the schema for the person's information
class APIExampleRequestSchema(BaseModel):
    endpoint: str = Field(
        ..., description="The API endpoint for the example request"
    )
    method: str = Field(
        ..., description="The HTTP method for the example request"
    )
    headers: dict = Field(
        ..., description="The headers for the example request"
    )
    body: dict = Field(..., description="The body of the example request")
    response: dict = Field(
        ...,
        description="The expected response of the example request",
    )


# Convert the schema to a JSON string
api_example_schema = base_model_to_json(APIExampleRequestSchema)
# Convert the schema to a JSON string

# Define the task to generate a person's information
task = "Generate an example API request using this code:\n"

# Create an instance of the ToolAgent class
agent = ToolAgent(
    name="Command R Tool Agent",
    description=(
        "An agent that generates an API request using the Command R"
        " model."
    ),
    model=model,
    tokenizer=tokenizer,
    json_schema=api_example_schema,
)

# Run the agent to generate the person's information
generated_data = agent(task)

# Print the generated data
print(f"Generated data: {generated_data}")
```

## Additional Information and Tips

- Ensure that either the `model` or `llm` parameter is provided during initialization. If neither is provided, the `ToolAgent` will raise an exception.
- The `parsing_function` parameter is optional but can be very useful for post-processing the output of the tool agent.
- Adjust the `max_number_tokens` parameter to control the length of the generated output, depending on the requirements of the task.

## References and Resources

- [Transformers Documentation](https://huggingface.co/transformers/)
- [Loguru Logger](https://loguru.readthedocs.io/en/stable/)

This documentation provides a comprehensive guide to the `ToolAgent` class, including its initialization, usage, and practical examples. By following the detailed instructions and examples, developers can effectively utilize the `ToolAgent` for various tasks involving model and tokenizer-based operations.

--------------------------------------------------

# File: swarms/artifacts/artifact.md

# `Artifact`

The `Artifact` class represents a file artifact, encapsulating the file's path, type, contents, versions, and edit count. This class provides a comprehensive way to manage file versions, edit contents, and handle various file-related operations such as saving, loading, and exporting to JSON.

The `Artifact` class is particularly useful in contexts where file version control and content management are essential. By keeping track of the number of edits and maintaining a version history, it allows for robust file handling and auditability.

## Class Definition

### Artifact


| Attribute   | Type                | Default Value    | Description                                      |
|-------------|---------------------|------------------|--------------------------------------------------|
| `file_path` | `str`               | N/A              | The path to the file.                            |
| `file_type` | `str`               | N/A              | The type of the file.                            |
| `contents`  | `str`               | `""`             | The contents of the file.                        |
| `versions`  | `List[FileVersion]` | `[]`             | The list of file versions.                       |
| `edit_count`| `int`               | `0`              | The number of times the file has been edited.    |

### Parameters and Validation

- `file_path`: A string representing the file path.
- `file_type`: A string representing the file type. This attribute is validated to ensure it matches supported file types based on the file extension if not provided.
- `contents`: A string representing the contents of the file. Defaults to an empty string.
- `versions`: A list of `FileVersion` instances representing the version history of the file. Defaults to an empty list.
- `edit_count`: An integer representing the number of edits made to the file. Defaults to 0.

### Methods

The `Artifact` class includes various methods for creating, editing, saving, loading, and exporting file artifacts.

#### `create`

| Parameter          | Type   | Description                            |
|--------------------|--------|----------------------------------------|
| `initial_content`  | `str`  | The initial content of the file.       |

**Usage Example:**

```python
artifact = Artifact(file_path="example.txt", file_type="txt")
artifact.create(initial_content="Initial file content")
```
The file type parameter supports the following file types: `.txt`, `.md`, `.py`, `.pdf`.
#### `edit`


| Parameter     | Type   | Description                            |
|---------------|--------|----------------------------------------|
| `new_content` | `str`  | The new content of the file.           |

**Usage Example:**

```python
artifact.edit(new_content="Updated file content")
```

#### `save`

**Usage Example:**

```python
artifact.save()
```

#### `load`

**Usage Example:**

```python
artifact.load()
```

#### `get_version`


| Parameter         | Type  | Description                             |
|-------------------|-------|-----------------------------------------|
| `version_number`  | `int` | The version number to retrieve.         |

**Usage Example:**

```python
version = artifact.get_version(version_number=1)
```

#### `get_contents`

**Usage Example:**

```python
current_contents = artifact.get_contents()
```

#### `get_version_history`


**Usage Example:**

```python
version_history = artifact.get_version_history()
```

#### `export_to_json`


| Parameter   | Type  | Description                                  |
|-------------|-------|----------------------------------------------|
| `file_path` | `str` | The path to the JSON file to save the artifact.|

**Usage Example:**

```python
artifact.export_to_json(file_path="artifact.json")
```

#### `import_from_json`


| Parameter   | Type  | Description                                      |
|-------------|-------|--------------------------------------------------|
| `file_path` | `str` | The path to the JSON file to import the artifact from.|

**Usage Example:**

```python
imported_artifact = Artifact.import_from_json(file_path="artifact.json")
```

#### `get_metrics`

**Usage Example:**

```python
metrics = artifact.get_metrics()
```

#### `to_dict`

**Usage Example:**

```python
artifact_dict = artifact.to_dict()
```

#### `from_dict`

| Parameter | Type             | Description                                      |
|-----------|------------------|--------------------------------------------------|
| `data`    | `Dict[str, Any]` | The dictionary representation of the artifact.   |

**Usage Example:**

```python
artifact_data = {
    "file_path": "example.txt",
    "file_type": "txt",
    "contents": "File content",
    "versions": [],
    "edit_count": 0
}
artifact = Artifact.from_dict(artifact_data)
```

## Additional Information and Tips

- The `Artifact` class uses the `pydantic` library to handle data validation and serialization.
- When editing the artifact, ensure that the `file_path` is set correctly to avoid file operation errors.
- Use the `get_version` and `get_version_history` methods to maintain a clear audit trail of changes to the file.
- The `export_to_json` and `import_from_json` methods are useful for backing up and restoring the state of an artifact.

## References and Resources

- [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- [Python os.path module](https://docs.python.org/3/library/os.path.html)
- [JSON Documentation](https://docs.python.org/3/library/json.html)

## Examples of Usage

### Example 1: Creating and Editing an Artifact

```python
from datetime import datetime
from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Union
import os
import json

# Define FileVersion class
class FileVersion(BaseModel):
    version_number: int
    content: str
    timestamp: datetime

# Artifact class definition goes here

# Create an artifact
artifact = Artifact(file_path="example.txt", file_type="txt")
artifact.create(initial_content="Initial file content")

# Edit the artifact
artifact.edit(new_content="Updated file content")

# Save the artifact to a file
artifact.save()

# Load the artifact from the file
artifact.load()

# Print the current contents of the artifact
print(artifact.get_contents())

# Print the version history
print(artifact.get_version_history())
```

### Example 2: Exporting and Importing an Artifact

```python
# Export the artifact to a JSON file
artifact.export_to_json(file_path="artifact.json")

# Import

 the artifact from a JSON file
imported_artifact = Artifact.import_from_json(file_path="artifact.json")

# Print the metrics of the imported artifact
print(imported_artifact.get_metrics())
```

### Example 3: Converting an Artifact to and from a Dictionary

```python
# Convert the artifact to a dictionary
artifact_dict = artifact.to_dict()

# Create a new artifact from the dictionary
new_artifact = Artifact.from_dict(artifact_dict)

# Print the metrics of the new artifact
print(new_artifact.get_metrics())
```


--------------------------------------------------

# File: swarms/changelog/5_6_8.md

# Swarms ChangeLog 5.6.8 -

The biggest update in Swarms history! We've introduced major fixes, updates, and new features to enhance your agent workflows and performance. To get the latest updates run the following: 

## Installation

```bash
$ pip3 install -U swarms
```

# Log
Here’s the breakdown of the latest changes:

---

### 🐞 **Fixes:**
- **[BUGF-AGENTS]:** Fixed various response issues within agents, leading to smoother performance.
- **[BUGF-MIXTURE]:** Resolved issues with the Mixture of Agents, ensuring more reliable and stable execution.
- **[CLEA-FILES]:** Removed unnecessary files, resulting in a significant speed boost and cleaner environment.

---

### 🛠 **Updates:**
- **[REFA-MODULES]:** Refactored the `swarms.models` module into its own package: `swarm_models` for improved code organization.
- **[CLEA-AGENTS]:** Cleaned up tool logic in the `agents` class for streamlined and efficient operations.

---

### ✨ **New Features:**
- **[FEAT-SWARMS]:** Introduced JSON outputs for `AgentRearrange`, `SpreadsheetSwarm`, and other swarms, improving data handling.
- **[FEAT-AGENTS]:** Added YAML file support for creating agents, making the setup process simpler than ever.
- **[FEAT-METADATA]:** Enhanced the `Agent` class with JSON metadata output, supporting OpenAI-like API responses with `output_type="json"` and `return_step_meta=True`.
- **[FEAT-FOREST]:** Released `ForestSwarm`, a new architecture that clusters agents into trees, enabling precise task execution.
- **[FEAT-REGISTRY]:** Fully implemented `AgentRegistry`, allowing you to store multiple agents for future use.

---

### 🚀 **Performance Enhancements:**
- **[PERF-AGENTS]:** Accelerated agent execution by **4x**, with a **10x** boost coming soon, powered by our Rust backend.
- **[PERF-ARCH]:** Optimized multi-threading, concurrency, and asynchrony in swarm architectures, making them faster than ever.

---

**Ready to dive in?** Get started now: [https://buff.ly/444kDjA](https://buff.ly/444kDjA)


--------------------------------------------------

# File: swarms/changelog/5_8_1.md

# Swarms 5.8.1 Feature Documentation

## 1. Enhanced Command Line Interface (CLI)

### 1.1 Integrated Onboarding Process

```bash
$ swarms onboarding
```

### 1.2 Run Agents Command

```bash
$ swarms run-agents --yaml-file agents.yaml
```

This command allows users to execute multiple agents defined in a YAML file. Here's the process:

1. The command reads the specified YAML file (`agents.yaml` in this case).
2. It parses the YAML content, extracting the configuration for each agent.
3. For each agent defined in the YAML:
   - It creates an instance of the agent with the specified parameters.
   - It sets up the agent's environment (model, temperature, max tokens, etc.).
   - It assigns the given task to the agent.
   - It executes the agent, respecting parameters like `max_loops`, `autosave`, and `verbose`.
4. The results from all agents are collected and presented to the user.

The YAML file structure allows users to define multiple agents with different configurations, making it easy to run complex, multi-agent tasks from the command line.

### 1.3 Generate Prompt Feature

```bash
$ swarms generate-prompt --prompt "Create a marketing strategy for a new product launch"
```

This feature leverages Swarms' language model to generate expanded or refined prompts:

1. The command takes the user's input prompt as a starting point.
2. It likely sends this prompt to a pre-configured language model (possibly GPT-4 or a similar model).
3. The model then generates an expanded or more detailed version of the prompt.
4. The generated prompt is returned to the user, possibly with options to further refine or save it.

This feature can help users create more effective prompts for their agents or other AI tasks.

## 2. New Prompt Management System

### 2.1 Prompt Class

The new `Prompt` class provides a robust system for managing and versioning prompts:

```python
from swarms import Prompt

marketing_prompt = Prompt(content="Initial marketing strategy draft", autosave=True)

print(marketing_prompt.get_prompt())
```

Key features of the `Prompt` class:

1. **Initialization**: The class is initialized with initial content and an `autosave` option.

2. **Editing**:
   ```python
   marketing_prompt.edit_prompt("Updated marketing strategy with social media focus")
   ```
   This method updates the prompt content and, if `autosave` is True, automatically saves the new version.

3. **Retrieval**:
   ```python
   current_content = marketing_prompt.get_prompt()
   ```
   This method returns the current content of the prompt.

4. **Version History**:
   ```python
   print(f"Edit history: {marketing_prompt.edit_history}")
   ```
   The class maintains a history of edits, allowing users to track changes over time.

5. **Rollback**:
   ```python
   marketing_prompt.rollback(1)
   ```
   This feature allows users to revert to a previous version of the prompt.

6. **Duplicate Prevention**:
   The class includes logic to prevent duplicate edits, raising a `ValueError` if an attempt is made to save the same content twice in a row.

This system provides a powerful way to manage prompts, especially for complex projects where prompt engineering and iteration are crucial.

## 3. Upcoming Features Preview

### 3.1 Enhanced Agent Execution Capabilities

The preview code demonstrates planned enhancements for agent execution:

```python
from swarms import Agent, ExecutionEnvironment

my_agent = Agent(name="data_processor")

cpu_env = ExecutionEnvironment(type="cpu", cores=4)
my_agent.run(environment=cpu_env)

gpu_env = ExecutionEnvironment(type="gpu", device_id=0)
my_agent.run(environment=gpu_env)

fractional_env = ExecutionEnvironment(type="fractional", cpu_fraction=0.5, gpu_fraction=0.3)
my_agent.run(environment=fractional_env)
```

This upcoming feature will allow for more fine-grained control over the execution environment:

1. **CPU Execution**: Users can specify the number of CPU cores to use.
2. **GPU Execution**: Allows selection of a specific GPU device.
3. **Fractionalized Execution**: Enables partial allocation of CPU and GPU resources.

These features will provide users with greater flexibility in resource allocation, potentially improving performance and allowing for more efficient use of available hardware.

--------------------------------------------------

# File: swarms/changelog/6_0_0 2.md

# Swarms 6.0.0 - Performance & Reliability Update 🚀

We're excited to announce the release of Swarms 6.0.0, bringing significant improvements to performance, reliability, and developer experience. This release focuses on streamlining core functionalities while enhancing the overall stability of the framework.

## 📦 Installation

```bash
pip3 install -U swarms
```

## 🌟 Highlights

### Agent Enhancements
- **Improved RAG Performance**: Significant improvements to Retrieval-Augmented Generation capabilities
- **Enhanced Prompt Generation**: Auto-generate prompt now incorporates name, description, and system prompt for more contextual interactions
- **Streamlined Architecture**: Cleaned up unused code for better performance and maintainability
- **Simplified State Management**: Consolidated state management methods into a single `load()` function

### Tools & Execution
- **Optimized Environment Management**: Fixed multiple environment instantiation issue
  - Environments now initialize once during `__init__`
- **New SwarmRouter Function**: Simplified routing mechanism
  - Returns consolidated string output from all agents
  - Improved coordination between swarm components

## 💪 Performance Improvements
- Faster execution times
- Reduced memory footprint
- More reliable logging system
- Lightweight and efficient codebase

## 🤝 Join Our Community

### We're Hiring!
Join our growing team! We're currently looking for:
- Agent Engineers
- Developer Relations
- Infrastructure Engineers
- And more!

### Get Involved
- ⭐ Star our repository
- 🔄 Fork the project
- 🛠 Submit pull requests
- 🐛 Report issues
- 💡 Share your ideas

### Contact & Support
- 📧 Email: kye@swarms.world
- 🔗 Issues: [GitHub Issues](https://github.com/kyegomez/swarms/issues)

## 🔜 What's Next?
Have ideas for features, bug fixes, or improvements? We'd love to hear from you! Reach out through our GitHub issues or email us directly.

---

*Thank you to all our contributors and users who make Swarms better every day. Together, we're building the future of swarm intelligence.*

#SwarmAI #OpenSource #AI #MachineLearning

--------------------------------------------------

# File: swarms/changelog/6_0_0.md

# Swarms 6.0.0 - Performance & Reliability Update 🚀

We're excited to announce the release of Swarms 6.0.0, bringing significant improvements to performance, reliability, and developer experience. This release focuses on streamlining core functionalities while enhancing the overall stability of the framework.

## 📦 Installation

```bash
pip3 install -U swarms
```

## 🌟 Highlights

### Agent Enhancements
- **Improved RAG Performance**: Significant improvements to Retrieval-Augmented Generation capabilities
- **Enhanced Prompt Generation**: Auto-generate prompt now incorporates name, description, and system prompt for more contextual interactions
- **Streamlined Architecture**: Cleaned up unused code for better performance and maintainability
- **Simplified State Management**: Consolidated state management methods into a single `load()` function

### Tools & Execution
- **Optimized Environment Management**: Fixed multiple environment instantiation issue
  - Environments now initialize once during `__init__`
- **New SwarmRouter Function**: Simplified routing mechanism
  - Returns consolidated string output from all agents
  - Improved coordination between swarm components

## 💪 Performance Improvements
- Faster execution times
- Reduced memory footprint
- More reliable logging system
- Lightweight and efficient codebase

## 🤝 Join Our Community

### We're Hiring!
Join our growing team! We're currently looking for:
- Agent Engineers
- Developer Relations
- Infrastructure Engineers
- And more!

### Get Involved
- ⭐ Star our repository
- 🔄 Fork the project
- 🛠 Submit pull requests
- 🐛 Report issues
- 💡 Share your ideas

### Contact & Support
- 📧 Email: kye@swarms.world
- 🔗 Issues: [GitHub Issues](https://github.com/kyegomez/swarms/issues)

## 🔜 What's Next?
Have ideas for features, bug fixes, or improvements? We'd love to hear from you! Reach out through our GitHub issues or email us directly.

---

*Thank you to all our contributors and users who make Swarms better every day. Together, we're building the future of swarm intelligence.*

#SwarmAI #OpenSource #AI #MachineLearning

--------------------------------------------------

# File: swarms/changelog/changelog_new.md

# 🚀 Swarms 5.9.2 Release Notes


### 🎯 Major Features

#### Concurrent Agent Execution Suite
We're excited to introduce a comprehensive suite of agent execution methods to supercharge your multi-agent workflows:

- `run_agents_concurrently`: Execute multiple agents in parallel with optimal resource utilization
- `run_agents_concurrently_async`: Asynchronous execution for improved performance
- `run_single_agent`: Streamlined single agent execution
- `run_agents_concurrently_multiprocess`: Multi-process execution for CPU-intensive tasks
- `run_agents_sequentially`: Sequential execution with controlled flow
- `run_agents_with_different_tasks`: Assign different tasks to different agents
- `run_agent_with_timeout`: Time-bounded agent execution
- `run_agents_with_resource_monitoring`: Monitor and manage resource usage

### 📚 Documentation
- Comprehensive documentation added for all new execution methods
- Updated examples and usage patterns
- Enhanced API reference

### 🛠️ Improvements
- Tree swarm implementation fixes
- Workspace directory now automatically set to `agent_workspace`
- Improved error handling and stability

## Quick Start

```python
from swarms import Agent, run_agents_concurrently, run_agents_with_timeout, run_agents_with_different_tasks

# Initialize multiple agents
agents = [
    Agent(
        agent_name=f"Analysis-Agent-{i}",
        system_prompt="You are a financial analysis expert",
        llm=model,
        max_loops=1
    )
    for i in range(5)
]

# Run agents concurrently
task = "Analyze the impact of rising interest rates on tech stocks"
outputs = run_agents_concurrently(agents, task)

# Example with timeout
outputs_with_timeout = run_agents_with_timeout(
    agents=agents,
    task=task,
    timeout=30.0,
    batch_size=2
)

# Run different tasks
task_pairs = [
    (agents[0], "Analyze tech stocks"),
    (agents[1], "Analyze energy stocks"),
    (agents[2], "Analyze retail stocks")
]
different_outputs = run_agents_with_different_tasks(task_pairs)
```

## Installation
```bash
pip3 install -U swarms
```

## Coming Soon
- 🌟 Auto Swarm Builder: Automatically construct and configure entire swarms from a single task specification (in development)
- Auto Prompt Generator for thousands of agents (in development)

## Community
We believe in the power of community-driven development. Help us make Swarms better!

- ⭐ Star our repository: https://github.com/kyegomez/swarms
- 🔄 Fork the project and contribute your improvements
- 🤝 Join our growing community of contributors

## Bug Fixes
- Fixed Tree Swarm implementation issues
- Resolved workspace directory configuration problems
- General stability improvements

---

For detailed documentation and examples, visit our [GitHub repository](https://github.com/kyegomez/swarms).

Let's build the future of multi-agent systems together! 🚀

--------------------------------------------------

# File: swarms/cli/cli_guide.md

# The Ultimate Technical Guide to the Swarms CLI: A Step-by-Step Developer’s Guide

Welcome to the definitive technical guide for using the Swarms Command Line Interface (CLI). The Swarms CLI enables developers, engineers, and business professionals to seamlessly manage and run Swarms of agents from the command line. This guide will walk you through the complete process of installing, configuring, and using the Swarms CLI to orchestrate intelligent agents for your needs.

By following this guide, you will not only understand how to install and use the Swarms CLI but also learn about real-world use cases, including how the CLI is used to automate tasks across various industries, from finance to marketing, operations, and beyond.

Explore the official [Swarms GitHub repository](https://github.com/kyegomez/swarms), dive into the comprehensive documentation at [Swarms Docs](https://docs.swarms.world), and explore the vast marketplace of agents on [swarms.ai](https://swarms.ai) to kickstart your journey with Swarms!

---

## 1. Installing the Swarms CLI

Before we explore the Swarms CLI commands, let’s get it installed and running on your machine.

### 1.1. Installation Using `pip`

For most users, the simplest way to install the Swarms CLI is through `pip`:

```bash
pip3 install -U swarms
```

This command installs the latest version of the Swarms CLI package, ensuring that you have the newest features and fixes.

### 1.2. Installation Using `Poetry`

Alternatively, if you are using `Poetry` as your Python package manager, you can add the Swarms package like this:

```bash
poetry add swarms
```

Once installed, you can run the Swarms CLI directly using:

```bash
poetry run swarms help
```

This command shows all the available options and commands, as we will explore in-depth below.

---

## 2. Understanding Swarms CLI Commands

With the Swarms CLI installed, the next step is to explore its key functionalities. Here are the most essential commands:

### 2.1. `onboarding`: Setup Your Environment

The `onboarding` command guides you through setting up your environment and configuring the agents for your Swarms.

```bash
swarms onboarding
```

This is the first step when you begin working with the Swarms platform. It helps to:

- Authenticate your Swarms account.
- Download any necessary configurations.
- Ensure everything is in place to launch agents seamlessly.

### 2.2. `help`: Learn Available Commands

Running `help` displays the various commands you can use:

```bash
swarms help
```

This command will output a helpful list like the one shown below, including detailed descriptions of each command.

```plaintext
Swarms CLI - Help

Commands:
onboarding    : Starts the onboarding process
help          : Shows this help message
get-api-key   : Retrieves your API key from the platform
check-login   : Checks if you're logged in and starts the cache
read-docs     : Redirects you to swarms cloud documentation
run-agents    : Run your Agents from your agents.yaml
```

### 2.3. `get-api-key`: Access API Integration

One of the key functionalities of the Swarms platform is integrating your agents with the Swarms API. To retrieve your unique API key for communication, use this command:

```bash
swarms get-api-key
```

Your API key is essential to enable agent workflows and access various services through the Swarms platform.

### 2.4. `check-login`: Verify Authentication

Use the `check-login` command to verify if you're logged in and ensure that your credentials are cached:

```bash
swarms check-login
```

This ensures seamless operation, allowing agents to execute tasks securely on the Swarms platform without needing to log in repeatedly.

### 2.5. `read-docs`: Explore Official Documentation

Easily access the official documentation with this command:

```bash
swarms read-docs
```

You’ll be redirected to the Swarms documentation site, [Swarms Docs](https://docs.swarms.world), where you'll find in-depth explanations, advanced use-cases, and more.

### 2.6. `run-agents`: Orchestrate Agents

Perhaps the most important command in the CLI is `run-agents`, which allows you to execute your agents as defined in your `agents.yaml` configuration file.

```bash
swarms run-agents --yaml-file agents.yaml
```

If you want to specify a custom configuration file, just pass in the YAML file using the `--yaml-file` flag.

---

## 3. Working with the `agents.yaml` Configuration File

The `agents.yaml` file is at the heart of your Swarms setup. This file allows you to define the structure and behavior of each agent you want to run. Below is an example YAML configuration for two agents.

### 3.1. Example `agents.yaml` Configuration:

```yaml
agents:
  - agent_name: "Financial-Advisor-Agent"
    model:
      model_name: "gpt-4o-mini"
      temperature: 0.3
      max_tokens: 2500
    system_prompt: |
      You are a highly knowledgeable financial advisor with expertise in tax strategies, investment management, and retirement planning. 
      Provide concise and actionable advice based on the user's financial goals and situation.
    max_loops: 1
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: true
    saved_state_path: "financial_advisor_state.json"
    user_name: "finance_user"
    retry_attempts: 2
    context_length: 200000
    return_step_meta: false
    output_type: "str"
    task: "I am 35 years old with a moderate risk tolerance. How should I diversify my portfolio for retirement in 20 years?"

  - agent_name: "Stock-Market-Analysis-Agent"
    model:
      model_name: "gpt-4o-mini"
      temperature: 0.25
      max_tokens: 1800
    system_prompt: |
      You are an expert stock market analyst with a deep understanding of technical analysis, market trends, and long-term investment strategies. 
      Provide well-reasoned investment advice, taking current market conditions into account.
    max_loops: 2
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: false
    saved_state_path: "stock_market_analysis_state.json"
    user_name: "market_analyst"
    retry_attempts: 3
    context_length: 150000
    return_step_meta: true
    output_type: "json"
    task: "Analyze the current market trends for tech stocks and suggest the best long-term investment options."

  - agent_name: "Marketing-Strategy-Agent"
    model:
      model_name: "gpt-4o-mini"
      temperature: 0.4
      max_tokens: 2200
    system_prompt: |
      You are a marketing strategist with expertise in digital campaigns, customer engagement, and branding. 
      Provide a comprehensive marketing strategy to increase brand awareness and drive customer acquisition for an e-commerce business.
    max_loops: 1
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: true
    saved_state_path: "marketing_strategy_state.json"
    user_name: "marketing_user"
    retry_attempts: 2
    context_length: 200000
    return_step_meta: false
    output_type: "str"
    task: "Create a 6-month digital marketing strategy for a new eco-friendly e-commerce brand targeting millennial consumers."

  - agent_name: "Operations-Optimizer-Agent"
    model:
      model_name: "gpt-4o-mini"
      temperature: 0.2
      max_tokens: 2000
    system_prompt: |
      You are an operations expert with extensive experience in optimizing workflows, reducing costs, and improving efficiency in supply chains. 
      Provide actionable recommendations to streamline business operations.
    max_loops: 1
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: true
    saved_state_path: "operations_optimizer_state.json"
    user_name: "operations_user"
    retry_attempts: 1
    context_length: 200000
    return_step_meta: false
    output_type: "str"
    task: "Identify ways to improve the efficiency of a small manufacturing company’s supply chain to reduce costs by 15% within one year."
```

### 3.2. Explanation of Key Fields

- **agent_name**: The name of your agent (e.g., Financial-Analysis-Agent).
- **model**: Specifies which model to use. In this case, `gpt-4o-mini` is used.
  - **temperature**: Controls the randomness of the model’s responses.
  - **max_tokens**: The maximum number of tokens to generate.
- **system_prompt**: Defines the prompt that instructs the agent.
- **max_loops**: Limits the number of times the agent will retry tasks.
- **autosave**: Saves the agent's state automatically after each run.
- **dashboard**: Set to `true` or `false` depending on whether you want to enable the agent’s dashboard.
- **saved_state_path**: Path to save agent's state, enabling future runs to resume from the last state.
- **task**: The primary task or question that the agent will address.

### 3.3. Running Agents Using `agents.yaml`

After configuring the agents, you can execute them directly from the CLI:

```bash
swarms run-agents --yaml-file agents_config.yaml
```

This command will run the specified agents, allowing them to perform their tasks and return results according to your configuration.

---

## 4. Use Cases for the Swarms CLI

Now that you have a solid understanding of the basic commands and the `agents.yaml` configuration, let's explore how the Swarms CLI can be applied in real-world scenarios.

### 4.1. Financial Data Analysis

For financial firms or hedge funds, agents like the "Financial-Analysis-Agent" can be set up to automate complex financial analyses. You could have agents analyze market trends, recommend portfolio adjustments, or perform tax optimizations.

Example Task: Automating long-term investment analysis using historical stock data.

```bash
swarms run-agents --yaml-file finance_analysis.yaml
```

### 4.2. Marketing Automation

Marketing departments can utilize Swarms agents to optimize campaigns, generate compelling ad copy, or provide detailed marketing insights. You can create a `Marketing-Agent` to process customer feedback, perform sentiment analysis, and suggest marketing strategies.

Example Task: Running multiple agents to analyze customer sentiment from recent surveys.

```bash
swarms run-agents --yaml-file marketing_agents.yaml
```

### 4.3. Operations and Task Management

Companies can create agents for automating internal task management. For example, you might have a set of agents responsible for managing deadlines, employee tasks, and progress tracking.

Example Task: Automating a task management system using Swarms agents.

```bash
swarms run-agents --yaml-file operations_agents.yaml
```

---

## 5. Advanced Usage: Customizing and Scaling Agents

The Swarms CLI is flexible and scalable. As your needs grow, you can start running agents across multiple machines, scale workloads dynamically, and even run multiple swarms in parallel.

### 5.1. Running Agents in Parallel

To run multiple agents concurrently, you can utilize different YAML configurations for each agent or group of agents. This allows for extensive scaling, especially when dealing with large datasets or complex workflows.

```bash
swarms run-agents --yaml-file agents_batch_1.yaml &
swar

ms run-agents --yaml-file agents_batch_2.yaml &
```

### 5.2. Integration with Other Tools

The Swarms CLI integrates with many tools and platforms via APIs. You can connect Swarms with external platforms such as AWS, Azure, or your custom cloud setup for enterprise-level automation.

---

## 6. Conclusion and Next Steps

The Swarms CLI is a powerful tool for automating agent workflows in various industries, including finance, marketing, and operations. By following this guide, you should now have a thorough understanding of how to install and use the CLI, configure agents, and apply it to real-world use cases.

To further explore Swarms, be sure to check out the official [Swarms GitHub repository](https://github.com/kyegomez/swarms), where you can contribute to the framework or build your own custom agents. Dive deeper into the documentation at [Swarms Docs](https://docs.swarms.world), and browse the extensive agent marketplace at [swarms.ai](https://swarms.ai).

With the Swarms CLI, the future of automation is within reach.



--------------------------------------------------

# File: swarms/cli/main.md

# Swarms CLI Documentation

The Swarms Command Line Interface (CLI) allows you to easily manage and run your Swarms of agents from the command line. This page will guide you through the installation process and provide a breakdown of the available commands.

## Installation

You can install the `swarms` package using `pip` or `poetry`.

### Using pip

```bash
pip3 install -U swarms
```

### Using poetry

```bash
poetry add swarms
```

Once installed, you can run the Swarms CLI with the following command:

```bash
poetry run swarms help
```

## Swarms CLI - Help

When running `swarms help`, you'll see the following output:

```
  _________                                     
 /   _____/_  _  _______ _______  _____   ______
 \_____  \ \/ \/ /\__  \_  __ \/     \ /  ___/
 /        \     /  / __ \|  | \/  Y Y  \___ \ 
/_______  / \/\_/  (____  /__|  |__|_|  /____  >
        \/              \/            \/     \/ 



    Swarms CLI - Help

    Commands:
    onboarding    : Starts the onboarding process
    help          : Shows this help message
    get-api-key   : Retrieves your API key from the platform
    check-login   : Checks if you're logged in and starts the cache
    read-docs     : Redirects you to swarms cloud documentation!
    run-agents    : Run your Agents from your agents.yaml

    For more details, visit: https://docs.swarms.world
```

### CLI Commands

Below is a detailed explanation of the available commands:

- **onboarding**  
  Starts the onboarding process to help you set up your environment and configure your agents.
  
  Usage:
  ```bash
  swarms onboarding
  ```

- **help**  
  Displays the help message, including a list of available commands.

  Usage:
  ```bash
  swarms help
  ```

- **get-api-key**  
  Retrieves your API key from the platform, allowing your agents to communicate with the Swarms platform.

  Usage:
  ```bash
  swarms get-api-key
  ```

- **check-login**  
  Verifies if you are logged into the platform and starts the cache for storing your login session.

  Usage:
  ```bash
  swarms check-login
  ```

- **read-docs**  
  Redirects you to the official Swarms documentation on the web for further reading.

  Usage:
  ```bash
  swarms read-docs
  ```

- **run-agents**  
  Executes your agents from the `agents.yaml` configuration file, which defines the structure and behavior of your agents. Refer to this document for how to leverage yamls for fast, reliable, and simple agent orchestration. [CLICK HERE](https://docs.swarms.world/en/latest/swarms/agents/create_agents_yaml/) You can customize what yaml file to run with `--yaml-file`

  Usage:
  ```bash
  swarms run-agents --yaml-file agents.yaml
  ```


--------------------------------------------------

# File: swarms/concept/framework_architecture.md

# Swarms Framework Architecture


The Swarms package is designed to orchestrate and manage **swarms of agents**, enabling collaboration between multiple Large Language Models (LLMs) or other agent types to solve complex tasks. The architecture is modular and scalable, facilitating seamless integration of various agents, models, prompts, and tools. Below is an overview of the architectural components, along with instructions on where to find the corresponding documentation.



```
swarms/
├── agents/
├── artifacts/
├── cli/
├── memory/
├── models/ ---> Moved to swarm_models
├── prompts/
├── schemas/
├── structs/
├── telemetry/
├── tools/
├── utils/
└── __init__.py
```



### Role of Folders in the Swarms Framework

The **Swarms framework** is composed of several key folders, each serving a specific role in building, orchestrating, and managing swarms of agents. Below is an in-depth explanation of the role of each folder in the framework's architecture, focusing on how they contribute to the overall system for handling complex multi-agent workflows.

---

### **1. Agents Folder (`agents/`)**
   - **Role:** 
     - The **agents** folder contains the core logic for individual agents within the Swarms framework. Agents are the key functional units responsible for carrying out specific tasks, whether it be text generation, web scraping, data analysis, or more specialized functions like marketing or accounting.
     - **Customization:** Each agent can be specialized for different tasks by defining custom system prompts and behaviors.
     - **Modular Agent System:** New agents can be easily added to this folder to expand the framework's capabilities.
   - **Importance:** This folder allows users to create and manage multiple types of agents that can interact and collaborate to solve complex problems.
   - **Examples:** Accounting agents, marketing agents, and programming agents.

---

### **2. Artifacts Folder (`artifacts/`)**
   - **Role:** 
     - The **artifacts** folder is responsible for storing the results or outputs generated by agents and swarms. This could include reports, logs, or data that agents generate during task execution.
     - **Persistent Storage:** It helps maintain a persistent record of agent interactions, making it easier to retrieve or review past actions and outputs.
     - **Data Handling:** Users can configure this folder to store artifacts that are essential for later analysis or reporting.
   - **Importance:** Acts as a storage mechanism for important task-related outputs, ensuring that no data is lost after tasks are completed.

---

### **3. CLI Folder (`cli/`)**
   - **Role:** 
     - The **CLI** folder contains tools for interacting with the Swarms framework through the command-line interface. This allows users to easily manage and orchestrate swarms without needing a graphical interface.
     - **Command-line Tools:** Commands in this folder enable users to initiate, control, and monitor swarms, making the system accessible and versatile.
     - **Automation and Scriptability:** Enables advanced users to automate swarm interactions and deploy agents programmatically.
   - **Importance:** Provides a flexible way to control the Swarms system for developers who prefer using the command line.

---

### **4. Memory Folder (`memory/`) Deprecated!!**
   - **Role:** 
     - The **memory** folder handles the framework's memory management for agents. This allows agents to retain and recall past interactions or task contexts, enabling continuity in long-running processes or multi-step workflows.
     - **Context Retention:** Agents that depend on historical context to make decisions or carry out tasks can store and access memory using this folder.
     - **Long-Term and Short-Term Memory:** This could be implemented in various ways, such as short-term conversational memory or long-term knowledge storage.
   - **Importance:** Crucial for agents that require memory to handle complex workflows, where decisions are based on prior outputs or interactions.

---

### **5. Models Folder (`models/`) Moved to `swarm_models`**
   - **Role:** 
     - The **models** folder houses pre-trained machine learning models that agents utilize to complete their tasks. These models could include LLMs (Large Language Models), custom-trained models, or fine-tuned models specific to the tasks being handled by the agents.
     - **Plug-and-Play Architecture:** The framework allows users to easily add or switch models depending on the specific needs of their agents.
     - **Custom Model Support:** Users can integrate custom models here for more specialized tasks.
   - **Importance:** Provides the computational backbone for agent decision-making and task execution.

---

### **6. Prompts Folder (`prompts/`)**
   - **Role:** 
     - The **prompts** folder contains reusable prompt templates that agents use to interact with their environment and complete tasks. These system prompts define the behavior and task orientation of the agents.
     - **Template Reusability:** Users can create and store common prompt templates, making it easy to define agent behavior across different tasks without rewriting prompts from scratch.
     - **Task-Specific Prompts:** For example, an accounting agent may have a prompt template that guides its interaction with financial data.
   - **Importance:** Provides the logic and guidance agents need to generate outputs in a coherent and task-focused manner.

---

### **7. Schemas Folder (`schemas/`)**
   - **Role:** 
     - The **schemas** folder defines the data structures and validation logic for inputs and outputs within the framework, using tools like **Pydantic** for data validation.
     - **Standardization and Validation:** This ensures that all interactions between agents and swarms follow consistent data formats, which is critical for large-scale agent coordination and task management.
     - **Error Prevention:** By validating data early, it prevents errors from propagating through the system, improving reliability.
   - **Importance:** Ensures data consistency across the entire framework, making it easier to integrate and manage swarms of agents at scale.

---

### **8. Structs Folder (`structs/`)**
   - **Role:** 
     - The **structs** folder is the core of the Swarms framework, housing the orchestration logic for managing and coordinating swarms of agents. This folder allows for dynamic task assignment, queue management, inter-agent communication, and result aggregation.
     - **Swarm Management:** Agents are grouped into swarms to handle tasks that require multiple agents working in parallel or collaboratively.
     - **Scalability:** The swarm structure is designed to be scalable, allowing thousands of agents to operate together on distributed tasks.
     - **Task Queueing and Execution:** Supports task queueing, task prioritization, and load balancing between agents.
   - **Importance:** This folder is critical for managing how agents interact and collaborate to solve complex, multi-step problems.

---

### **9. Telemetry Folder (`telemetry/`)**
   - **Role:** 
     - The **telemetry** folder provides logging and monitoring tools to capture agent performance metrics, error handling, and real-time activity tracking. It helps users keep track of what each agent or swarm is doing, making it easier to debug, audit, and optimize operations.
     - **Monitoring:** Tracks agent performance and system health.
     - **Logs:** Maintains logs for troubleshooting and operational review.
   - **Importance:** Provides visibility into the system, ensuring smooth operation and enabling fine-tuning of agent behaviors.

---

### **10. Tools Folder (`tools/`)**
   - **Role:** 
     - The **tools** folder contains specialized utility functions or scripts that agents and swarms may require to complete certain tasks, such as web scraping, API interactions, data parsing, or other external resource handling.
     - **Task-Specific Tools:** Agents can call these tools to perform operations outside of their own logic, enabling them to interact with external systems more efficiently.
   - **Importance:** Expands the capabilities of agents, allowing them to complete more sophisticated tasks by relying on these external tools.

---

### **11. Utils Folder (`utils/`)**
   - **Role:** 
     - The **utils** folder contains general-purpose utility functions that are reused throughout the framework. These may include functions for data formatting, validation, logging setup, and configuration management.
     - **Shared Utilities:** Helps keep the codebase clean by providing reusable functions that multiple agents or parts of the framework can call.
   - **Importance:** Provides common functions that help the Swarms framework operate efficiently and consistently.

---

### **Core Initialization File (`__init__.py`)**
   - **Role:** 
     - The `__init__.py` file is the entry point of the Swarms package, ensuring that all necessary modules, agents, and tools are loaded when the Swarms framework is imported. It allows for the modular loading of different components, making it easier for users to work with only the parts of the framework they need.
   - **Importance:** Acts as the bridge that connects all other components in the framework, enabling the entire package to work together seamlessly.

---

### How to Access Documentation

- **Official Documentation Site:**
  - URL: [docs.swarms.world](https://docs.swarms.world)
  - Here, users can find detailed guides, tutorials, and API references on how to use each of the folders mentioned above. The documentation covers setup, agent orchestration, and practical examples of how to leverage swarms for real-world tasks.

- **GitHub Repository:**
  - URL: [Swarms GitHub](https://github.com/kyegomez/swarms)
  - The repository contains code examples, detailed folder explanations, and further resources on how to get started with building and managing agent swarms.

By understanding the purpose and role of each folder in the Swarms framework, users can more effectively build, orchestrate, and manage agents to handle complex tasks and workflows at scale.

## Support:

- **Post Issue On Github**
  - URL: [Submit issue](https://github.com/kyegomez/swarms/issues/new/choose)
  - Post your issue whether it's an issue or a feature request


- **Community Support**
  - URL: [Submit issue](https://discord.gg/jM3Z6M9uMq)
  - Ask the community for support in real-time and or admin support

--------------------------------------------------

# File: swarms/concept/future_swarm_architectures.md



---

### Federated Swarm

**Overview:**
A Federated Swarm architecture involves multiple independent swarms collaborating to complete a task. Each swarm operates autonomously but can share information and results with other swarms.

**Use-Cases:**
- Distributed learning systems where data is processed across multiple nodes.

- Scenarios requiring collaboration between different teams or departments.

```mermaid
graph TD
    A[Central Coordinator]
    subgraph Swarm1
        B1[Agent 1.1] --> B2[Agent 1.2]
        B2 --> B3[Agent 1.3]
    end
    subgraph Swarm2
        C1[Agent 2.1] --> C2[Agent 2.2]
        C2 --> C3[Agent 2.3]
    end
    subgraph Swarm3
        D1[Agent 3.1] --> D2[Agent 3.2]
        D2 --> D3[Agent 3.3]
    end
    B1 --> A
    C1 --> A
    D1 --> A
```

---

### Star Swarm

**Overview:**
A Star Swarm architecture features a central agent that coordinates the activities of several peripheral agents. The central agent assigns tasks to the peripheral agents and aggregates their results.

**Use-Cases:**
- Centralized decision-making processes.

- Scenarios requiring a central authority to coordinate multiple workers.

```mermaid
graph TD
    A[Central Agent] --> B1[Peripheral Agent 1]
    A --> B2[Peripheral Agent 2]
    A --> B3[Peripheral Agent 3]
    A --> B4[Peripheral Agent 4]
```

---

### Mesh Swarm

**Overview:**
A Mesh Swarm architecture allows for a fully connected network of agents where each agent can communicate with any other agent. This setup provides high flexibility and redundancy.

**Use-Cases:**
- Complex systems requiring high fault tolerance and redundancy.

- Scenarios involving dynamic and frequent communication between agents.

```mermaid
graph TD
    A1[Agent 1] --> A2[Agent 2]
    A1 --> A3[Agent 3]
    A1 --> A4[Agent 4]
    A2 --> A3
    A2 --> A4
    A3 --> A4
```

---

### Cascade Swarm

**Overview:**
A Cascade Swarm architecture involves a chain of agents where each agent triggers the next one in a cascade effect. This is useful for scenarios where tasks need to be processed in stages, and each stage initiates the next.

**Use-Cases:**
- Multi-stage processing tasks such as data transformation pipelines.

- Event-driven architectures where one event triggers subsequent actions.

```mermaid
graph TD
    A[Trigger Agent] --> B[Agent 1]
    B --> C[Agent 2]
    C --> D[Agent 3]
    D --> E[Agent 4]
```

---

### Hybrid Swarm

**Overview:**
A Hybrid Swarm architecture combines elements of various architectures to suit specific needs. It might integrate hierarchical and parallel components, or mix sequential and round robin patterns.

**Use-Cases:**
- Complex workflows requiring a mix of different processing strategies.

- Custom scenarios tailored to specific operational requirements.

```mermaid
graph TD
    A[Root Agent] --> B1[Sub-Agent 1]
    A --> B2[Sub-Agent 2]
    B1 --> C1[Parallel Agent 1]
    B1 --> C2[Parallel Agent 2]
    B2 --> C3[Sequential Agent 1]
    C3 --> C4[Sequential Agent 2]
    C3 --> C5[Sequential Agent 3]
```

---

These swarm architectures provide different models for organizing and orchestrating large language models (LLMs) to perform various tasks efficiently. Depending on the specific requirements of your project, you can choose the appropriate architecture or even combine elements from multiple architectures to create a hybrid solution.

--------------------------------------------------

# File: swarms/concept/how_to_choose_swarms.md

# Choosing the Right Swarm for Your Business Problem

Depending on the complexity and nature of your problem, different swarm configurations can be more effective in achieving optimal performance. This guide provides a detailed explanation of when to use each swarm type, including their strengths and potential drawbacks.

## Swarm Types Overview

- **MajorityVoting**: A swarm structure where agents vote on an outcome, and the majority decision is taken as the final result.
- **AgentRearrange**: Provides the foundation for both sequential and parallel swarms.
- **RoundRobin**: Agents take turns handling tasks in a cyclic manner.
- **Mixture of Agents**: A heterogeneous swarm where agents with different capabilities are combined.
- **GraphWorkflow**: Agents collaborate in a directed acyclic graph (DAG) format.
- **GroupChat**: Agents engage in a chat-like interaction to reach decisions.
- **AgentRegistry**: A centralized registry where agents are stored, retrieved, and invoked.
- **SpreadsheetSwarm**: A swarm designed to manage tasks at scale, tracking agent outputs in a structured format (e.g., CSV files).

---

## MajorityVoting Swarm

### Use-Case
MajorityVoting is ideal for scenarios where accuracy is paramount, and the decision must be determined from multiple perspectives. For instance, choosing the best marketing strategy where various marketing agents vote on the highest predicted performance.

### Advantages
- Ensures robustness in decision-making by leveraging multiple agents.
- Helps eliminate outliers or faulty agent decisions.

### Warnings
!!! warning
    Majority voting can be slow if too many agents are involved. Ensure that your swarm size is manageable for real-time decision-making.

---

## AgentRearrange (Sequential and Parallel)

### Sequential Swarm Use-Case
For linear workflows where each task depends on the outcome of the previous task, such as processing legal documents step by step through a series of checks and validations.

### Parallel Swarm Use-Case
For tasks that can be executed concurrently, such as batch processing customer data in marketing campaigns. Parallel swarms can significantly reduce processing time by dividing tasks across multiple agents.

### Notes
!!! note
    Sequential swarms are slower but ensure strict task dependencies are respected. Parallel swarms are faster but require careful management of task interdependencies.

---

## RoundRobin Swarm

### Use-Case
For balanced task distribution where agents need to handle tasks evenly. An example would be assigning customer support tickets to agents in a cyclic manner, ensuring no single agent is overloaded.

### Advantages
- Fair and even distribution of tasks.
- Simple and effective for balanced workloads.

### Warnings
!!! warning
    Round-robin may not be the best choice when some agents are more competent than others, as it can assign tasks equally regardless of agent performance.

---

## Mixture of Agents

### Use-Case
Ideal for complex problems that require diverse skills. For example, a financial forecasting problem where some agents specialize in stock data, while others handle economic factors.

### Notes
!!! note
    A mixture of agents is highly flexible and can adapt to various problem domains. However, be mindful of coordination overhead.

---

## GraphWorkflow Swarm

### Use-Case
This swarm structure is suited for tasks that can be broken down into a series of dependencies but are not strictly linear, such as an AI-driven software development pipeline where one agent handles front-end development while another handles back-end concurrently.

### Advantages
- Provides flexibility for managing dependencies.
- Agents can work on different parts of the problem simultaneously.

### Warnings
!!! warning
    GraphWorkflow requires clear definition of task dependencies, or it can lead to execution issues and delays.

---

## GroupChat Swarm

### Use-Case
For real-time collaborative decision-making. For instance, agents could participate in group chat for negotiating contracts, each contributing their expertise and adjusting responses based on the collective discussion.

### Advantages
- Facilitates highly interactive problem-solving.
- Ideal for dynamic and unstructured problems.

### Warnings
!!! warning
    High communication overhead between agents may slow down decision-making in large swarms.

---

## AgentRegistry Swarm

### Use-Case
For dynamically managing agents based on the problem domain. An AgentRegistry is useful when new agents can be added or removed as needed, such as adding new machine learning models for an evolving recommendation engine.

### Notes
!!! note
    AgentRegistry is a flexible solution but introduces additional complexity when agents need to be discovered and registered on the fly.

---

## SpreadsheetSwarm

### Use-Case
When dealing with massive-scale data or agent outputs that need to be stored and managed in a tabular format. SpreadsheetSwarm is ideal for businesses handling thousands of agent outputs, such as large-scale marketing analytics or financial audits.

### Advantages
- Provides structure and order for managing massive amounts of agent outputs.
- Outputs are easily saved and tracked in CSV files.

### Warnings
!!! warning
    Ensure the correct configuration of agents in SpreadsheetSwarm to avoid data mismatches and inconsistencies when scaling up to thousands of agents.

---

## Final Thoughts

The choice of swarm depends on:

1. **Nature of the task**: Whether it's sequential or parallel.

2. **Problem complexity**: Simple problems might benefit from RoundRobin, while complex ones may need GraphWorkflow or Mixture of Agents.

3. **Scale of execution**: For large-scale tasks, Swarms like SpreadsheetSwarm or MajorityVoting provide scalability with structured outputs.

When integrating agents in a business workflow, it's crucial to balance task complexity, agent capabilities, and scalability to ensure the optimal swarm architecture.


--------------------------------------------------

# File: swarms/concept/philosophy.md

# Our Philosophy: Simplifying Multi-Agent Collaboration Through Readable Code and Performance Optimization

Our mission is to streamline multi-agent collaboration by emphasizing simplicity, readability, and performance in our codebase. This document outlines our core tactics:

- **Readable Code with Type Annotations, Documentation, and Logging**
- **Bleeding-Edge Performance via Concurrency and Parallelism**
- **Simplified Abstractions for Multi-Agent Collaboration**

By adhering to these principles, we aim to make our systems more maintainable, scalable, and efficient, facilitating easier integration and collaboration among developers and agents alike.

---

## 1. Emphasizing Readable Code

Readable code is the cornerstone of maintainable and scalable systems. It ensures that developers can easily understand, modify, and extend the codebase.

### 1.1 Use of Type Annotations

Type annotations enhance code readability and catch errors early in the development process.

```python
def process_data(data: List[str]) -> Dict[str, int]:
    result = {}
    for item in data:
        result[item] = len(item)
    return result
```

### 1.2 Code Style Guidelines

Adhering to consistent code style guidelines, such as PEP 8 for Python, ensures uniformity across the codebase.

- **Indentation:** Use 4 spaces per indentation level.
- **Variable Naming:** Use `snake_case` for variables and functions.
- **Class Naming:** Use `PascalCase` for class names.

### 1.3 Importance of Documentation

Comprehensive documentation helps new developers understand the purpose and functionality of code modules.

```python
def fetch_user_profile(user_id: str) -> UserProfile:
    """
    Fetches the user profile from the database.

    Args:
        user_id (str): The unique identifier of the user.

    Returns:
        UserProfile: An object containing user profile data.
    """
    # Function implementation
```

### 1.4 Consistent Naming Conventions

Consistent naming reduces confusion and makes the code self-explanatory.

- **Functions:** Should be verbs (e.g., `calculate_total`).
- **Variables:** Should be nouns (e.g., `total_amount`).
- **Constants:** Should be uppercase (e.g., `MAX_RETRIES`).

---

## 2. Effective Logging Practices

Logging is essential for debugging and monitoring the health of applications.

### 2.1 Why Logging is Important

- **Debugging:** Helps identify issues during development and after deployment.
- **Monitoring:** Provides insights into the system's behavior in real-time.
- **Audit Trails:** Keeps a record of events for compliance and analysis.

### 2.2 Best Practices for Logging

- **Use Appropriate Log Levels:** DEBUG, INFO, WARNING, ERROR, CRITICAL.
- **Consistent Log Formatting:** Include timestamps, log levels, and messages.
- **Avoid Sensitive Information:** Do not log passwords or personal data.

### 2.3 Logging Examples

```python
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s:%(message)s')

def connect_to_service(url: str) -> bool:
    logging.debug(f"Attempting to connect to {url}")
    try:
        # Connection logic
        logging.info(f"Successfully connected to {url}")
        return True
    except ConnectionError as e:
        logging.error(f"Connection failed to {url}: {e}")
        return False
```

---

## 3. Achieving Bleeding-Edge Performance

Performance is critical, especially when dealing with multiple agents and large datasets.

### 3.1 Concurrency and Parallelism

Utilizing concurrency and parallelism can significantly improve performance.

- **Concurrency:** Dealing with multiple tasks by managing multiple threads.
- **Parallelism:** Executing multiple tasks simultaneously on multiple CPU cores.

### 3.2 Asynchronous Programming

Asynchronous programming allows for non-blocking operations, leading to better resource utilization.

```python
import asyncio

async def fetch_data(endpoint: str) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(endpoint) as response:
            return await response.json()

async def main():
    endpoints = ['https://api.example.com/data1', 'https://api.example.com/data2']
    tasks = [fetch_data(url) for url in endpoints]
    results = await asyncio.gather(*tasks)
    print(results)

asyncio.run(main())
```

### 3.3 Utilizing Modern Hardware Capabilities

Leverage multi-core processors and GPUs for computationally intensive tasks.

- **Multi-threading:** Use threads for I/O-bound tasks.
- **Multi-processing:** Use processes for CPU-bound tasks.
- **GPU Acceleration:** Utilize GPUs for tasks like machine learning model training.

### 3.4 Code Example: Parallel Processing

```python
from concurrent.futures import ThreadPoolExecutor

def process_item(item):
    # Processing logic
    return result

items = [1, 2, 3, 4, 5]
with ThreadPoolExecutor(max_workers=5) as executor:
    results = list(executor.map(process_item, items))
```

---

## 4. Simplifying Multi-Agent Collaboration

Simplifying the abstraction of multi-agent collaboration makes it accessible and manageable.

### 4.1 Importance of Simple Abstractions

- **Ease of Use:** Simple interfaces make it easier for developers to integrate agents.
- **Maintainability:** Reduces complexity, making the codebase easier to maintain.
- **Scalability:** Simple abstractions can be extended without significant overhauls.

### 4.2 Standardizing Agent Interfaces

Every agent should adhere to a standard interface for consistency.

#### 4.2.1 Agent Base Class

```python
from abc import ABC, abstractmethod

class BaseAgent(ABC):
    @abstractmethod
    def run(self, task: str) -> Any:
        pass

    def __call__(self, task: str) -> Any:
        return self.run(task)

    @abstractmethod
    async def arun(self, task: str) -> Any:
        pass
```

#### 4.2.2 Example Agent Implementation

```python
class DataProcessingAgent(BaseAgent):
    def run(self, task: str) -> str:
        # Synchronous processing logic
        return f"Processed {task}"

    async def arun(self, task: str) -> str:
        # Asynchronous processing logic
        return f"Processed {task} asynchronously"
```

#### 4.2.3 Usage Example

```python
agent = DataProcessingAgent()

# Synchronous call
result = agent.run("data_task")
print(result)  # Output: Processed data_task

# Asynchronous call
async def main():
    result = await agent.arun("data_task")
    print(result)  # Output: Processed data_task asynchronously

asyncio.run(main())
```

### 4.3 Mermaid Diagram: Agent Interaction

```mermaid
sequenceDiagram
    participant User
    participant AgentA
    participant AgentB
    participant AgentC

    User->>AgentA: run(task)
    AgentA-->>AgentB: arun(sub_task)
    AgentB-->>AgentC: run(sub_sub_task)
    AgentC-->>AgentB: result_sub_sub_task
    AgentB-->>AgentA: result_sub_task
    AgentA-->>User: final_result
```

*Agents collaborating to fulfill a user's task.*

### 4.4 Simplified Collaboration Workflow

```mermaid
graph TD
    UserRequest[User Request] --> Agent1[Agent 1]
    Agent1 -->|run(task)| Agent2[Agent 2]
    Agent2 -->|arun(task)| Agent3[Agent 3]
    Agent3 -->|result| Agent2
    Agent2 -->|result| Agent1
    Agent1 -->|result| UserResponse[User Response]
```

*Workflow demonstrating how agents process a task collaboratively.*

---

## 5. Bringing It All Together

By integrating these principles, we create a cohesive system where agents can efficiently collaborate while maintaining code quality and performance.

### 5.1 Example: Multi-Agent System

#### 5.1.1 Agent Definitions

```python
class AgentA(BaseAgent):
    def run(self, task: str) -> str:
        # Agent A processing
        return f"AgentA processed {task}"

    async def arun(self, task: str) -> str:
        # Agent A asynchronous processing
        return f"AgentA processed {task} asynchronously"

class AgentB(BaseAgent):
    def run(self, task: str) -> str:
        # Agent B processing
        return f"AgentB processed {task}"

    async def arun(self, task: str) -> str:
        # Agent B asynchronous processing
        return f"AgentB processed {task} asynchronously"
```

#### 5.1.2 Orchestrator Agent

```python
class OrchestratorAgent(BaseAgent):
    def __init__(self):
        self.agent_a = AgentA()
        self.agent_b = AgentB()

    def run(self, task: str) -> str:
        result_a = self.agent_a.run(task)
        result_b = self.agent_b.run(task)
        return f"Orchestrated results: {result_a} & {result_b}"

    async def arun(self, task: str) -> str:
        result_a = await self.agent_a.arun(task)
        result_b = await self.agent_b.arun(task)
        return f"Orchestrated results: {result_a} & {result_b}"
```

#### 5.1.3 Execution

```python
orchestrator = OrchestratorAgent()

# Synchronous execution
result = orchestrator.run("task1")
print(result)
# Output: Orchestrated results: AgentA processed task1 & AgentB processed task1

# Asynchronous execution
async def main():
    result = await orchestrator.arun("task1")
    print(result)
    # Output: Orchestrated results: AgentA processed task1 asynchronously & AgentB processed task1 asynchronously

asyncio.run(main())
```

### 5.2 Mermaid Diagram: Orchestrator Workflow

```mermaid
sequenceDiagram
    participant User
    participant Orchestrator
    participant AgentA
    participant AgentB

    User->>Orchestrator: run(task)
    Orchestrator->>AgentA: run(task)
    Orchestrator->>AgentB: run(task)
    AgentA-->>Orchestrator: result_a
    AgentB-->>Orchestrator: result_b
    Orchestrator-->>User: Orchestrated results
```

*Orchestrator coordinating between Agent A and Agent B.*

---

## 6. Conclusion

Our philosophy centers around making multi-agent collaboration as simple and efficient as possible by:

- **Writing Readable Code:** Through type annotations, consistent styling, and thorough documentation.
- **Implementing Effective Logging:** To aid in debugging and monitoring.
- **Optimizing Performance:** Leveraging concurrency, parallelism, and modern hardware capabilities.
- **Simplifying Abstractions:** Standardizing agent interfaces to `run`, `__call__`, and `arun` methods.

By adhering to these principles, we create a robust foundation for scalable and maintainable systems that can adapt to evolving technological landscapes.



--------------------------------------------------

# File: swarms/concept/purpose/limits_of_individual_agents.md

# The Limits of Individual Agents

![Reliable Agents](docs/assets/img/reliabilitythrough.png)


Individual agents have pushed the boundaries of what machines can learn and accomplish. However, despite their impressive capabilities, these agents face inherent limitations that can hinder their effectiveness in complex, real-world applications. This blog explores the critical constraints of individual agents, such as context window limits, hallucination, single-task threading, and lack of collaboration, and illustrates how multi-agent collaboration can address these limitations. In short,

- Context Window Limits
- Single Task Execution
- Hallucination
- No collaboration



#### Context Window Limits

One of the most significant constraints of individual agents, particularly in the domain of language models, is the context window limit. This limitation refers to the maximum amount of information an agent can consider at any given time. For instance, many language models can only process a fixed number of tokens (words or characters) in a single inference, restricting their ability to understand and generate responses based on longer texts. This limitation can lead to a lack of coherence in longer compositions and an inability to maintain context in extended conversations or documents.

#### Hallucination

Hallucination in AI refers to the phenomenon where an agent generates information that is not grounded in the input data or real-world facts. This can manifest as making up facts, entities, or events that do not exist or are incorrect. Hallucinations pose a significant challenge in ensuring the reliability and trustworthiness of AI-generated content, particularly in critical applications such as news generation, academic research, and legal advice.

#### Single Task Threading

Individual agents are often designed to excel at specific tasks, leveraging their architecture and training data to optimize performance in a narrowly defined domain. However, this specialization can also be a drawback, as it limits the agent's ability to multitask or adapt to tasks that fall outside its primary domain. Single-task threading means an agent may excel in language translation but struggle with image recognition or vice versa, necessitating the deployment of multiple specialized agents for comprehensive AI solutions.

#### Lack of Collaboration

Traditional AI agents operate in isolation, processing inputs and generating outputs independently. This isolation limits their ability to leverage diverse perspectives, share knowledge, or build upon the insights of other agents. In complex problem-solving scenarios, where multiple facets of a problem need to be addressed simultaneously, this lack of collaboration can lead to suboptimal solutions or an inability to tackle multifaceted challenges effectively.

# The Elegant yet Simple Solution

- ## Multi-Agent Collaboration

Recognizing the limitations of individual agents, researchers and practitioners have explored the potential of multi-agent collaboration as a means to transcend these constraints. Multi-agent systems comprise several agents that can interact, communicate, and collaborate to achieve common goals or solve complex problems. This collaborative approach offers several advantages:

#### Overcoming Context Window Limits

By dividing a large task among multiple agents, each focusing on different segments of the problem, multi-agent systems can effectively overcome the context window limits of individual agents. For instance, in processing a long document, different agents could be responsible for understanding and analyzing different sections, pooling their insights to generate a coherent understanding of the entire text.

#### Mitigating Hallucination

Through collaboration, agents can cross-verify facts and information, reducing the likelihood of hallucinations. If one agent generates a piece of information, other agents can provide checks and balances, verifying the accuracy against known data or through consensus mechanisms.

#### Enhancing Multitasking Capabilities

Multi-agent systems can tackle tasks that require a diverse set of skills by leveraging the specialization of individual agents. For example, in a complex project that involves both natural language processing and image analysis, one agent specialized in text can collaborate with another specialized in visual data, enabling a comprehensive approach to the task.

#### Facilitating Collaboration and Knowledge Sharing

Multi-agent collaboration inherently encourages the sharing of knowledge and insights, allowing agents to learn from each other and improve their collective performance. This can be particularly powerful in scenarios where iterative learning and adaptation are crucial, such as dynamic environments or tasks that evolve over time.

### Conclusion

While individual AI agents have made remarkable strides in various domains, their inherent limitations necessitate innovative approaches to unlock the full potential of artificial intelligence. Multi-agent collaboration emerges as a compelling solution, offering a pathway to transcend individual constraints through collective intelligence. By harnessing the power of collaborative AI, we can address more complex, multifaceted problems, paving the way for more versatile, efficient, and effective AI systems in the future.

--------------------------------------------------

# File: swarms/concept/purpose/why.md

# The Swarms Framework: Orchestrating Agents for Enterprise Automation

In the rapidly evolving landscape of artificial intelligence (AI) and automation, a new paradigm is emerging: the orchestration of multiple agents working in collaboration to tackle complex tasks. This approach, embodied by the Swarms Framework, aims to address the fundamental limitations of individual agents and unlocks the true potential of AI-driven automation in enterprise operations.

Individual agents are plagued by the same issues: short term memory constraints, hallucinations, single task limitations, lack of collaboration, and cost inefficiences.

[Learn more here from a list of compiled agent papers](https://github.com/kyegomez/awesome-multi-agent-papers)

## The Purpose of Swarms: Overcoming Agent Limitations

Individual agents, while remarkable in their own right, face several inherent challenges that hinder their ability to effectively automate enterprise operations at scale. These limitations include:

1.  Short-Term Memory Constraints
2.  Hallucination and Factual Inconsistencies
3.  Single-Task Limitations
4.  Lack of Collaborative Capabilities
5.  Cost Inefficiencies

By orchestrating multiple agents to work in concert, the Swarms Framework directly tackles these limitations, paving the way for more efficient, reliable, and cost-effective enterprise automation.

### Limitation 1: Short-Term Memory Constraints

Many AI agents, particularly those based on large language models, suffer from short-term memory constraints. These agents can effectively process and respond to prompts, but their ability to retain and reason over information across multiple interactions or tasks is limited. This limitation can be problematic in enterprise environments, where complex workflows often involve retaining and referencing contextual information over extended periods.

The Swarms Framework addresses this limitation by leveraging the collective memory of multiple agents working in tandem. While individual agents may have limited short-term memory, their combined memory pool becomes significantly larger, enabling the retention and retrieval of contextual information over extended periods. This collective memory is facilitated by agents specializing in information storage and retrieval, such as those based on systems like Llama Index or Pinecone.

### Limitation 2: Hallucination and Factual Inconsistencies

Another challenge faced by many AI agents is the tendency to generate responses that may contain factual inconsistencies or hallucinations -- information that is not grounded in reality or the provided context. This issue can undermine the reliability and trustworthiness of automated systems, particularly in domains where accuracy and consistency are paramount.

The Swarms Framework mitigates this limitation by employing multiple agents with diverse knowledge bases and capabilities. By leveraging the collective intelligence of these agents, the framework can cross-reference and validate information, reducing the likelihood of hallucinations and factual inconsistencies. Additionally, specialized agents can be tasked with fact-checking and verification, further enhancing the overall reliability of the system.

### Limitation 3: Single-Task Limitations

Most individual AI agents are designed and optimized for specific tasks or domains, limiting their ability to handle complex, multi-faceted workflows that often characterize enterprise operations. While an agent may excel at a particular task, such as natural language processing or data analysis, it may struggle with other aspects of a larger workflow, such as task coordination or decision-making.

The Swarms Framework overcomes this limitation by orchestrating a diverse ensemble of agents, each specializing in different tasks or capabilities. By intelligently combining and coordinating these agents, the framework can tackle complex, multi-threaded workflows that span various domains and task types. This modular approach allows for the seamless integration of new agents as they become available, enabling the continuous expansion and enhancement of the system's capabilities.

### Limitation 4: Lack of Collaborative Capabilities

Most AI agents are designed to operate independently, lacking the ability to effectively collaborate with other agents or coordinate their actions towards a common goal. This limitation can hinder the scalability and efficiency of automated systems, particularly in enterprise environments where tasks often require the coordination of multiple agents or systems.

The Swarms Framework addresses this limitation by introducing a layer of coordination and collaboration among agents. Through specialized coordination agents and communication protocols, the framework enables agents to share information, divide tasks, and synchronize their actions. This collaborative approach not only increases efficiency but also enables the emergence of collective intelligence, where the combined capabilities of multiple agents surpass the sum of their individual abilities.

### Limitation 5: Cost Inefficiencies

Running large AI models or orchestrating multiple agents can be computationally expensive, particularly in enterprise environments where scalability and cost-effectiveness are critical considerations. Inefficient resource utilization or redundant computations can quickly escalate costs, making widespread adoption of AI-driven automation financially prohibitive.

The Swarms Framework tackles this limitation by optimizing resource allocation and workload distribution among agents. By intelligently assigning tasks to the most appropriate agents and leveraging agent specialization, the framework minimizes redundant computations and improves overall resource utilization. Additionally, the framework can dynamically scale agent instances based on demand, ensuring that computational resources are allocated efficiently and costs are minimized.

## The Swarms Framework: A Holistic Approach to Enterprise Automation

The Swarms Framework is a comprehensive solution that addresses the limitations of individual agents by orchestrating their collective capabilities. By integrating agents from various frameworks, including LangChain, AutoGPT, Llama Index, and others, the framework leverages the strengths of each agent while mitigating their individual weaknesses.

At its core, the Swarms Framework operates on the principle of multi-agent collaboration. By introducing specialized coordination agents and communication protocols, the framework enables agents to share information, divide tasks, and synchronize their actions towards a common goal. This collaborative approach not only increases efficiency but also enables the emergence of collective intelligence, where the combined capabilities of multiple agents surpass the sum of their individual abilities.

The framework's architecture is modular and extensible, allowing for the seamless integration of new agents as they become available. This flexibility ensures that the system's capabilities can continuously expand and adapt to evolving enterprise needs and technological advancements.


## Benefits of the Swarms Framework

The adoption of the Swarms Framework in enterprise environments offers numerous benefits:

1.  Increased Efficiency and Scalability
2.  Improved Reliability and Accuracy
3.  Adaptability and Continuous Improvement
4.  Cost Optimization
5.  Enhanced Security and Compliance

## Increased Efficiency and Scalability

By orchestrating the collective capabilities of multiple agents, the Swarms Framework enables the efficient execution of complex, multi-threaded workflows. Tasks can be parallelized and distributed across specialized agents, reducing bottlenecks and increasing overall throughput. Additionally, the framework's modular design and ability to dynamically scale agent instances based on demand ensure that the system can adapt to changing workloads and scale seamlessly as enterprise needs evolve.

## Improved Reliability and Accuracy

The collaborative nature of the Swarms Framework reduces the risk of hallucinations and factual inconsistencies that can arise from individual agents. By leveraging the collective knowledge and diverse perspectives of multiple agents, the framework can cross-reference and validate information, enhancing the overall reliability and accuracy of its outputs.

Additionally, the framework's ability to incorporate specialized fact-checking and verification agents further strengthens the trustworthiness of the system's outcomes, ensuring that critical decisions and actions are based on accurate and reliable information.

## Adaptability and Continuous Improvement

The modular architecture of the Swarms Framework allows for the seamless integration of new agents as they become available, enabling the continuous expansion and enhancement of the system's capabilities. As new AI models, algorithms, or data sources emerge, the framework can readily incorporate them, ensuring that enterprise operations remain at the forefront of technological advancements.

Furthermore, the framework's monitoring and analytics capabilities provide valuable insights into system performance, enabling the identification of areas for improvement and the optimization of agent selection, task assignments, and resource allocation strategies over time.

## Cost Optimization

By intelligently orchestrating the collaboration of multiple agents, the Swarms Framework optimizes resource utilization and minimizes redundant computations. This efficient use of computational resources translates into cost savings, making the widespread adoption of AI-driven automation more financially viable for enterprises.

The framework's ability to dynamically scale agent instances based on demand further contributes to cost optimization, ensuring that resources are allocated only when needed and minimizing idle or underutilized instances.

## Enhanced Security and Compliance

In enterprise environments, ensuring the security and compliance of automated systems is paramount. The Swarms Framework addresses these concerns by incorporating robust security measures and compliance controls.

The framework's centralized Memory Manager component enables the implementation of access control mechanisms and data encryption, protecting sensitive information from unauthorized access or breaches. Additionally, the framework's modular design allows for the integration of specialized agents focused on compliance monitoring and auditing, ensuring that enterprise operations adhere to relevant regulations and industry standards.

## Real-World Applications and Use Cases

The Swarms Framework finds applications across a wide range of enterprise domains, enabling organizations to automate complex operations and streamline their workflows. Here are some examples of real-world use cases:

1.  Intelligent Process Automation (IPA)
2.  Customer Service and Support
3.  Fraud Detection and Risk Management
4.  Supply Chain Optimization
5.  Research and Development

## Intelligent Process Automation (IPA)

In the realm of business process automation, the Swarms Framework can orchestrate agents to automate and optimize complex workflows spanning multiple domains and task types. By combining agents specialized in areas such as natural language processing, data extraction, decision-making, and task coordination, the framework can streamline and automate processes that traditionally required manual intervention or coordination across multiple systems.

## Customer Service and Support

The framework's ability to integrate agents with diverse capabilities, such as natural language processing, knowledge retrieval, and decision-making, makes it well-suited for automating customer service and support operations. Agents can collaborate to understand customer inquiries, retrieve relevant information from knowledge bases, and provide accurate and personalized responses, improving customer satisfaction and reducing operational costs.

## Fraud Detection and Risk Management

In the financial and cybersecurity domains, the Swarms Framework can orchestrate agents specialized in data analysis, pattern recognition, and risk assessment to detect and mitigate fraudulent activities or security threats. By combining the collective intelligence of these agents, the framework can identify complex patterns and anomalies that may be difficult for individual agents to detect, enhancing the overall effectiveness of fraud detection and risk management strategies.

## Supply Chain Optimization

The complexity of modern supply chains often requires the coordination of multiple systems and stakeholders. The Swarms Framework can integrate agents specialized in areas such as demand forecasting, inventory management, logistics optimization, and supplier coordination to streamline and optimize supply chain operations. By orchestrating the collective capabilities of these agents, the framework can identify bottlenecks, optimize resource allocation, and facilitate seamless collaboration among supply chain partners.

## Research and Development

In research and development environments, the Swarms Framework can accelerate innovation by enabling the collaboration of agents specialized in areas such as literature review, data analysis, hypothesis generation, and experiment design. By orchestrating these agents, the framework can facilitate the exploration of new ideas, identify promising research directions, and streamline the iterative process of scientific inquiry.

# Conclusion

The Swarms Framework represents a paradigm shift in the field of enterprise automation, addressing the limitations of individual agents by orchestrating their collective capabilities. By integrating agents from various frameworks and enabling multi-agent collaboration, the Swarms Framework overcomes challenges such as short-term memory constraints, hallucinations, single-task limitations, lack of collaboration, and cost inefficiencies.

Through its modular architecture, centralized coordination, and advanced monitoring and analytics capabilities, the Swarms Framework empowers enterprises to automate complex operations with increased efficiency, reliability, and adaptability. It unlocks the true potential of AI-driven automation, enabling organizations to stay ahead of the curve and thrive in an ever-evolving technological landscape.

As the field of artificial intelligence continues to advance, the Swarms Framework stands as a robust and flexible solution, ready to embrace new developments and seamlessly integrate emerging agents and capabilities. By harnessing the power of collective intelligence, the framework paves the way for a future where enterprises can leverage the full potential of AI to drive innovation, optimize operations, and gain a competitive edge in their respective industries.

--------------------------------------------------

# File: swarms/concept/purpose/why_swarms.md

# Why Swarms?

The need for multiple agents to work together in artificial intelligence (AI) and particularly in the context of Large Language Models (LLMs) stems from several inherent limitations and challenges in handling complex, dynamic, and multifaceted tasks with single-agent systems. Collaborating with multiple agents offers a pathway to enhance reliability, computational efficiency, cognitive diversity, and problem-solving capabilities. This section delves into the rationale behind employing multi-agent systems and strategizes on overcoming the associated expenses, such as API bills and hosting costs.

### Why Multiple Agents Are Necessary

#### 1. **Cognitive Diversity**

Different agents can bring varied perspectives, knowledge bases, and problem-solving approaches to a task. This diversity is crucial in complex problem-solving scenarios where a single approach might not be sufficient. Cognitive diversity enhances creativity, leading to innovative solutions and the ability to tackle a broader range of problems.

#### 2. **Specialization and Expertise**

In many cases, tasks are too complex for a single agent to handle efficiently. By dividing the task among multiple specialized agents, each can focus on a segment where it excels, thereby increasing the overall efficiency and effectiveness of the solution. This approach leverages the expertise of individual agents to achieve superior performance in tasks that require multifaceted knowledge and skills.

#### 3. **Scalability and Flexibility**

Multi-agent systems can more easily scale to handle large-scale or evolving tasks. Adding more agents to the system can increase its capacity or capabilities, allowing it to adapt to larger workloads or new types of tasks. This scalability is essential in dynamic environments where the demand and nature of tasks can change rapidly.

#### 4. **Robustness and Redundancy**

Collaboration among multiple agents enhances the system's robustness by introducing redundancy. If one agent fails or encounters an error, others can compensate, ensuring the system remains operational. This redundancy is critical in mission-critical applications where failure is not an option.

### Overcoming Expenses with API Bills and Hosting

Deploying multiple agents, especially when relying on cloud-based services or APIs, can incur significant costs. Here are strategies to manage and reduce these expenses:

#### 1. **Optimize Agent Efficiency**

Before scaling up the number of agents, ensure each agent operates as efficiently as possible. This can involve refining algorithms, reducing unnecessary API calls, and optimizing data processing to minimize computational requirements and, consequently, the associated costs.

#### 2. **Use Open Source and Self-Hosted Solutions**

Where possible, leverage open-source models and technologies that can be self-hosted. While there is an initial investment in setting up the infrastructure, over time, self-hosting can significantly reduce costs related to API calls and reliance on third-party services.

#### 3. **Implement Intelligent Caching**

Caching results for frequently asked questions or common tasks can drastically reduce the need for repeated computations or API calls. Intelligent caching systems can determine what information to store and for how long, optimizing the balance between fresh data and computational savings.

#### 4. **Dynamic Scaling and Load Balancing**

Use cloud services that offer dynamic scaling and load balancing to adjust the resources allocated based on the current demand. This ensures you're not paying for idle resources during low-usage periods while still being able to handle high demand when necessary.

#### 5. **Collaborative Cost-Sharing Models**

In scenarios where multiple stakeholders benefit from the multi-agent system, consider implementing a cost-sharing model. This approach distributes the financial burden among the users or beneficiaries, making it more sustainable.

#### 6. **Monitor and Analyze Costs**

Regularly monitor and analyze your usage and associated costs to identify potential savings. Many cloud providers offer tools to track and forecast expenses, helping you to adjust your usage patterns and configurations to minimize costs without sacrificing performance.

### Conclusion

The collaboration of multiple agents in AI systems presents a robust solution to the complexity, specialization, scalability, and robustness challenges inherent in single-agent approaches. While the associated costs can be significant, strategic optimization, leveraging open-source technologies, intelligent caching, dynamic resource management, collaborative cost-sharing, and diligent monitoring can mitigate these expenses. By adopting these strategies, organizations can harness the power of multi-agent systems to tackle complex problems more effectively and efficiently, ensuring the sustainable deployment of these advanced technologies.

--------------------------------------------------

# File: swarms/concept/swarm_architectures.md

# Swarm Architectures
### What is a Swarm?

A swarm refers to a group of more than two agents working collaboratively to achieve a common goal. These agents can be software entities, such as llms that interact with each other to perform complex tasks. The concept of a swarm is inspired by natural systems like ant colonies or bird flocks, where simple individual behaviors lead to complex group dynamics and problem-solving capabilities.

### How Swarm Architectures Facilitate Communication

Swarm architectures are designed to establish and manage communication between agents within a swarm. These architectures define how agents interact, share information, and coordinate their actions to achieve the desired outcomes. Here are some key aspects of swarm architectures:

1. **Hierarchical Communication**: In hierarchical swarms, communication flows from higher-level agents to lower-level agents. Higher-level agents act as coordinators, distributing tasks and aggregating results. This structure is efficient for tasks that require top-down control and decision-making.

2. **Parallel Communication**: In parallel swarms, agents operate independently and communicate with each other as needed. This architecture is suitable for tasks that can be processed concurrently without dependencies, allowing for faster execution and scalability.

3. **Sequential Communication**: Sequential swarms process tasks in a linear order, where each agent's output becomes the input for the next agent. This ensures that tasks with dependencies are handled in the correct sequence, maintaining the integrity of the workflow.

4. **Mesh Communication**: In mesh swarms, agents are fully connected, allowing any agent to communicate with any other agent. This setup provides high flexibility and redundancy, making it ideal for complex systems requiring dynamic interactions.

5. **Federated Communication**: Federated swarms involve multiple independent swarms that collaborate by sharing information and results. Each swarm operates autonomously but can contribute to a larger task, enabling distributed problem-solving across different nodes.

Swarm architectures leverage these communication patterns to ensure that agents work together efficiently, adapting to the specific requirements of the task at hand. By defining clear communication protocols and interaction models, swarm architectures enable the seamless orchestration of multiple agents, leading to enhanced performance and problem-solving capabilities.


| **Name**                      | **Description**                                                                                                                                                         | **Code Link**                                                                                      | **Use Cases**                                                                                     |
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
| Hierarchical Swarms           | A system where agents are organized in a hierarchy, with higher-level agents coordinating lower-level agents to achieve complex tasks.                                   | [Code Link](https://docs.swarms.world/en/latest/swarms/concept/swarm_architectures/#hierarchical-swarm) | Manufacturing process optimization, multi-level sales management, healthcare resource coordination |
| Agent Rearrange               | A setup where agents rearrange themselves dynamically based on the task requirements and environmental conditions.                                                       | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)                   | Adaptive manufacturing lines, dynamic sales territory realignment, flexible healthcare staffing  |
| Concurrent Workflows          | Agents perform different tasks simultaneously, coordinating to complete a larger goal.                                                                                  | [Code Link](https://docs.swarms.world/en/latest/swarms/concept/swarm_architectures/#concurrent-workflows) | Concurrent production lines, parallel sales operations, simultaneous patient care processes       |
| Sequential Coordination       | Agents perform tasks in a specific sequence, where the completion of one task triggers the start of the next.                                                           | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/sequential_workflow/)               | Step-by-step assembly lines, sequential sales processes, stepwise patient treatment workflows     |
| Parallel Processing           | Agents work on different parts of a task simultaneously to speed up the overall process.                                                                                | [Code Link](https://docs.swarms.world/en/latest/swarms/concept/swarm_architectures/#parallel-processing) | Parallel data processing in manufacturing, simultaneous sales analytics, concurrent medical tests  |
| Mixture of Agents             | A heterogeneous swarm where agents with different capabilities are combined to solve complex problems.                                                                  | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/moa/)                               | Financial forecasting, complex problem-solving requiring diverse skills                           |
| Graph Workflow                | Agents collaborate in a directed acyclic graph (DAG) format to manage dependencies and parallel tasks.                                                                  | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/graph_workflow/)                    | AI-driven software development pipelines, complex project management                              |
| Group Chat                    | Agents engage in a chat-like interaction to reach decisions collaboratively.                                                                                           | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/group_chat/)                        | Real-time collaborative decision-making, contract negotiations                                    |
| Agent Registry                | A centralized registry where agents are stored, retrieved, and invoked dynamically.                                                                                     | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/agent_registry/)                    | Dynamic agent management, evolving recommendation engines                                         |
| Spreadsheet Swarm             | Manages tasks at scale, tracking agent outputs in a structured format like CSV files.                                                                                   | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/spreadsheet_swarm/)                 | Large-scale marketing analytics, financial audits                                                 |
| Forest Swarm                  | A swarm structure that organizes agents in a tree-like hierarchy for complex decision-making processes.                                                                 | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/forest_swarm/)                      | Multi-stage workflows, hierarchical reinforcement learning                                        |
| Swarm Router                  | Routes and chooses the swarm architecture based on the task requirements and available agents.                                                                        | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/swarm_router/)                       | Dynamic task routing, adaptive swarm architecture selection, optimized agent allocation            |




### Hierarchical Swarm

**Overview:**
A Hierarchical Swarm architecture organizes the agents in a tree-like structure. Higher-level agents delegate tasks to lower-level agents, which can further divide tasks among themselves. This structure allows for efficient task distribution and scalability.

**Use-Cases:**

- Complex decision-making processes where tasks can be broken down into subtasks.

- Multi-stage workflows such as data processing pipelines or hierarchical reinforcement learning.

```mermaid
graph TD
    A[Root Agent] --> B1[Sub-Agent 1]
    A --> B2[Sub-Agent 2]
    B1 --> C1[Sub-Agent 1.1]
    B1 --> C2[Sub-Agent 1.2]
    B2 --> C3[Sub-Agent 2.1]
    B2 --> C4[Sub-Agent 2.2]
```

---

### Parallel Swarm

**Overview:**
In a Parallel Swarm architecture, multiple agents operate independently and simultaneously on different tasks. Each agent works on its own task without dependencies on the others. [Learn more here in the docs:](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)


**Use-Cases:**

- Tasks that can be processed independently, such as parallel data analysis.

- Large-scale simulations where multiple scenarios are run in parallel.

```mermaid
graph LR
    A[Task] --> B1[Sub-Agent 1]
    A --> B2[Sub-Agent 2]
    A --> B3[Sub-Agent 3]
    A --> B4[Sub-Agent 4]
```

---

### Sequential Swarm

**Overview:**
A Sequential Swarm architecture processes tasks in a linear sequence. Each agent completes its task before passing the result to the next agent in the chain. This architecture ensures orderly processing and is useful when tasks have dependencies. [Learn more here in the docs:](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)

**Use-Cases:**

- Workflows where each step depends on the previous one, such as assembly lines or sequential data processing.

- Scenarios requiring strict order of operations.

```mermaid
graph TD
    A[First Agent] --> B[Second Agent]
    B --> C[Third Agent]
    C --> D[Fourth Agent]
```

---

### Round Robin Swarm

**Overview:**
In a Round Robin Swarm architecture, tasks are distributed cyclically among a set of agents. Each agent takes turns handling tasks in a rotating order, ensuring even distribution of workload.

**Use-Cases:**

- Load balancing in distributed systems.

- Scenarios requiring fair distribution of tasks to avoid overloading any single agent.

```mermaid
graph TD
    A[Coordinator Agent] --> B1[Sub-Agent 1]
    A --> B2[Sub-Agent 2]
    A --> B3[Sub-Agent 3]
    A --> B4[Sub-Agent 4]
    B1 --> A
    B2 --> A
    B3 --> A
    B4 --> A
```



### SpreadSheet Swarm

**Overview:**
The SpreadSheet Swarm makes it easy to manage thousands of agents all in one place: a csv file. You can initialize any number of agents and then there is a loop parameter to run the loop of agents on the task. Learn more in the [docs here](https://docs.swarms.world/en/latest/swarms/structs/spreadsheet_swarm/)

**Use-Cases:**

- Multi-threaded execution: Execution agents on multiple threads 

- Save agent outputs into CSV file

- One place to analyze agent outputs


```mermaid

graph TD
    A[Initialize SpreadSheetSwarm] --> B[Initialize Agents]
    B --> C[Load Task Queue]
    C --> D[Run Task]

    subgraph Agents
        D --> E1[Agent 1]
        D --> E2[Agent 2]
        D --> E3[Agent 3]
    end

    E1 --> F1[Process Task]
    E2 --> F2[Process Task]
    E3 --> F3[Process Task]

    F1 --> G1[Track Output]
    F2 --> G2[Track Output]
    F3 --> G3[Track Output]

    subgraph Save Outputs
        G1 --> H[Save to CSV]
        G2 --> H[Save to CSV]
        G3 --> H[Save to CSV]
    end

    H --> I{Autosave Enabled?}
    I --> |Yes| J[Export Metadata to JSON]
    I --> |No| K[End Swarm Run]
```



### Mixture of Agents Architecture


```mermaid

graph TD
    A[Task Input] --> B[Layer 1: Reference Agents]
    B --> C[Agent 1]
    B --> D[Agent 2]
    B --> E[Agent N]

    C --> F[Agent 1 Response]
    D --> G[Agent 2 Response]
    E --> H[Agent N Response]

    F & G & H --> I[Layer 2: Aggregator Agent]
    I --> J[Aggregate All Responses]
    J --> K[Final Output]
```


## Alternative Experimental Architectures

### **1. Circular Swarm**

#### Input Arguments:
- **name** (str): Name of the swarm.
- **description** (str): Description of the swarm.
- **goal** (str): Goal of the swarm.
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.
- **return_full_history** (bool): Whether to return the full conversation history.

#### Functionality:
Agents pass tasks in a circular manner, where each agent works on the next task in the list.

```mermaid
graph TD
    Task1 --> Agent1
    Agent1 --> Agent2
    Agent2 --> Agent3
    Agent3 --> Task2
    Task2 --> Agent1
```

---

### **2. Linear Swarm**

#### Input Arguments:
- **name** (str): Name of the swarm.
- **description** (str): Description of the swarm.
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.
- **conversation** (Conversation): Conversation object.
- **return_full_history** (bool): Whether to return the full conversation history.

#### Functionality:
Agents pass tasks in a linear fashion, each agent working on one task sequentially.

```mermaid
graph LR
    Task1 --> Agent1
    Agent1 --> Agent2
    Agent2 --> Agent3
    Agent3 --> Task2
```

---

### **3. Star Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
A central agent (Agent 1) executes the tasks first, followed by the other agents working in parallel.

```mermaid
graph TD
    Task1 --> Agent1
    Agent1 --> Agent2
    Agent1 --> Agent3
    Agent1 --> Agent4
```

---

### **4. Mesh Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Each agent works on tasks randomly from a task queue, until the task queue is empty.

```mermaid
graph TD
    Task1 --> Agent1
    Task2 --> Agent2
    Task3 --> Agent3
    Task4 --> Agent4
    Task5 --> Agent1
    Task6 --> Agent2
```

---

### **5. Grid Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents are structured in a grid, and tasks are distributed accordingly.

```mermaid
graph TD
    Task1 --> Agent1
    Task2 --> Agent2
    Task3 --> Agent3
    Task4 --> Agent4
```

---

### **6. Pyramid Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents are arranged in a pyramid structure. Each level of agents works in sequence.

```mermaid
graph TD
    Task1 --> Agent1
    Agent1 --> Agent2
    Agent2 --> Agent3
    Agent3 --> Task2
```

---

### **7. Fibonacci Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents work according to the Fibonacci sequence, where the number of agents working on tasks follows this progression.

```mermaid
graph TD
    Task1 --> Agent1
    Agent1 --> Agent2
    Agent2 --> Agent3
    Task2 --> Agent5
    Agent5 --> Agent8
```

---

### **8. Prime Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents are assigned tasks based on prime number indices in the list of agents.

```mermaid
graph TD
    Task1 --> Agent2
    Task2 --> Agent3
    Task3 --> Agent5
    Task4 --> Agent7
```

---

### **9. Power Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents work on tasks following powers of two.

```mermaid
graph TD
    Task1 --> Agent1
    Task2 --> Agent2
    Task3 --> Agent4
    Task4 --> Agent8
```

---

### **10. Sigmoid Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **tasks** (List[str]): List of tasks for the agents.

#### Functionality:
Agents are selected based on the sigmoid function, with higher-indexed agents handling more complex tasks.

```mermaid
graph TD
    Task1 --> Agent1
    Task2 --> Agent2
    Task3 --> Agent3
    Task4 --> Agent4
```

---

### **11. Sinusoidal Swarm**

#### Input Arguments:
- **agents** (AgentListType): List of agents involved.
- **task** (str): Task for the agents to work on.

#### Functionality:
Agents are assigned tasks based on a sinusoidal pattern.

```mermaid
graph TD
    Task --> Agent1
    Agent1 --> Agent2
    Agent2 --> Agent3
    Agent3 --> Task2
```

---

Each of these swarm architectures enables different task distribution and agent coordination strategies, making it possible to select the right architecture for specific types of agent-based problem-solving scenarios.



## Examples

```python

import asyncio
import os

from dotenv import load_dotenv
from loguru import logger
from swarm_models import OpenAIChat
from tickr_agent.main import TickrAgent

from swarms.structs.swarming_architectures import (
    circular_swarm,
    linear_swarm,
    mesh_swarm,
    pyramid_swarm,
    star_swarm,
)

# Load environment variables (API keys)
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")

# Initialize the OpenAI model
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4", temperature=0.1
)

# Custom Financial Agent System Prompts
STOCK_ANALYSIS_PROMPT = """
You are an expert financial analyst. Your task is to analyze stock market data for a company 
and provide insights on whether to buy, hold, or sell. Analyze trends, financial ratios, and market conditions.
"""

NEWS_SUMMARIZATION_PROMPT = """
You are a financial news expert. Summarize the latest news related to a company and provide insights on 
how it could impact its stock price. Be concise and focus on the key takeaways.
"""

RATIO_CALCULATION_PROMPT = """
You are a financial ratio analyst. Your task is to calculate key financial ratios for a company 
based on the available data, such as P/E ratio, debt-to-equity ratio, and return on equity. 
Explain what each ratio means for investors.
"""

# Example Usage
# Define stock tickers
stocks = ["AAPL", "TSLA"]


# Initialize Financial Analysis Agents
stock_analysis_agent = TickrAgent(
    agent_name="Stock-Analysis-Agent",
    system_prompt=STOCK_ANALYSIS_PROMPT,
    stocks=stocks,
)

news_summarization_agent = TickrAgent(
    agent_name="News-Summarization-Agent",
    system_prompt=NEWS_SUMMARIZATION_PROMPT,
    stocks=stocks,

)

ratio_calculation_agent = TickrAgent(
    agent_name="Ratio-Calculation-Agent",
    system_prompt=RATIO_CALCULATION_PROMPT,
    stocks=stocks,

)
# Create a list of agents for swarming
agents = [
    stock_analysis_agent,
    news_summarization_agent,
    ratio_calculation_agent,
]

# Define financial analysis tasks
tasks = [
    "Analyze the stock performance of Apple (AAPL) in the last 6 months.",
    "Summarize the latest financial news on Tesla (TSLA).",
    "Calculate the P/E ratio and debt-to-equity ratio for Amazon (AMZN).",
]

# -------------------------------# Showcase Circular Swarm
# -------------------------------
logger.info("Starting Circular Swarm for financial analysis.")
circular_result = circular_swarm(agents, tasks)
logger.info(f"Circular Swarm Result:\n{circular_result}\n")


# -------------------------------
# Showcase Linear Swarm
# -------------------------------
logger.info("Starting Linear Swarm for financial analysis.")
linear_result = linear_swarm(agents, tasks)
logger.info(f"Linear Swarm Result:\n{linear_result}\n")


# -------------------------------
# Showcase Star Swarm
# -------------------------------
logger.info("Starting Star Swarm for financial analysis.")
star_result = star_swarm(agents, tasks)
logger.info(f"Star Swarm Result:\n{star_result}\n")


# -------------------------------
# Showcase Mesh Swarm
# -------------------------------
logger.info("Starting Mesh Swarm for financial analysis.")
mesh_result = mesh_swarm(agents, tasks)
logger.info(f"Mesh Swarm Result:\n{mesh_result}\n")


# -------------------------------
# Showcase Pyramid Swarm
# -------------------------------
logger.info("Starting Pyramid Swarm for financial analysis.")
pyramid_result = pyramid_swarm(agents, tasks)
logger.info(f"Pyramid Swarm Result:\n{pyramid_result}\n")


# -------------------------------
# Example: One-to-One Communication between Agents
# -------------------------------
logger.info(
    "Starting One-to-One communication between Stock and News agents."
)
one_to_one_result = stock_analysis_agent.run(
    "Analyze Apple stock performance, and then send the result to the News Summarization Agent"
)
news_summary_result = news_summarization_agent.run(one_to_one_result)
logger.info(
    f"One-to-One Communication Result:\n{news_summary_result}\n"
)


# -------------------------------
# Example: Broadcasting to all agents
# -------------------------------
async def broadcast_task():
    logger.info("Broadcasting task to all agents.")
    task = "Summarize the overall stock market performance today."
    await asyncio.gather(*[agent.run(task) for agent in agents])


asyncio.run(broadcast_task())


# -------------------------------
# Deep Comments & Explanations
# -------------------------------

"""
Explanation of Key Components:

1. **Agents**:
   - We created three specialized agents for financial analysis: Stock Analysis, News Summarization, and Ratio Calculation.
   - Each agent is provided with a custom system prompt that defines their unique task in analyzing stock data.

2. **Swarm Examples**:
   - **Circular Swarm**: Agents take turns processing tasks in a circular manner.
   - **Linear Swarm**: Tasks are processed sequentially by each agent.
   - **Star Swarm**: The first agent (Stock Analysis) processes all tasks before distributing them to other agents.
   - **Mesh Swarm**: Agents work on random tasks from the task queue.
   - **Pyramid Swarm**: Agents are arranged in a pyramid structure, processing tasks layer by layer.

3. **One-to-One Communication**:
   - This showcases how one agent can pass its result to another agent for further processing, useful for complex workflows where agents depend on each other.

4. **Broadcasting**:
   - The broadcasting function demonstrates how a single task can be sent to all agents simultaneously. This can be useful for situations like summarizing daily stock market performance across multiple agents.

5. **Logging with Loguru**:
   - We use `loguru` for detailed logging throughout the swarms. This helps to track the flow of information and responses from each agent.
"""



```

--------------------------------------------------

# File: swarms/concept/swarm_ecosystem.md

# Understanding the Swarms Ecosystem

The [Swarms Ecosystem](https://github.com/The-Swarm-Corporation/swarm-ecosystem) is a powerful suite of tools and frameworks designed to help developers build, deploy, and manage swarms of autonomous agents. This ecosystem covers various domains, from Large Language Models (LLMs) to IoT data integration, providing a comprehensive platform for automation and scalability. Below, we’ll explore the key components and how they contribute to this groundbreaking ecosystem.

#### 1. **Swarms Framework**

The [Swarms Framework](https://github.com/The-Swarm-Corporation/swarm-ecosystem) is a Python-based toolkit that simplifies the creation, orchestration, and scaling of swarms of agents. Whether you are dealing with marketing, accounting, or data analysis, the Swarms Framework allows developers to automate complex workflows efficiently.

```mermaid
graph TD;
    SF[Swarms Framework] --> Core[Swarms Core]
    SF --> JS[Swarms JS]
    SF --> Memory[Swarms Memory]
    SF --> Evals[Swarms Evals]
    SF --> Zero[Swarms Zero]
```

#### 2. **Swarms-Cloud**

[Swarms-Cloud](https://github.com/The-Swarm-Corporation/swarm-ecosystem) is a cloud-based solution that enables you to deploy your agents with enterprise-level guarantees. It provides 99% uptime, infinite scalability, and self-healing capabilities, making it ideal for mission-critical operations.

```mermaid
graph TD;
    SC[Swarms-Cloud] --> Uptime[99% Uptime]
    SC --> Scale[Infinite Scalability]
    SC --> Healing[Self-Healing]
```

#### 3. **Swarms-Models**

[Swarms-Models](https://github.com/The-Swarm-Corporation/swarm-ecosystem) offer a seamless interface to leading LLM providers like OpenAI, Anthropic, and Ollama. It allows developers to tap into cutting-edge natural language understanding for their agents.

```mermaid
graph TD;
    SM[Swarms-Models] --> OpenAI[OpenAI API]
    SM --> Anthropic[Anthropic API]
    SM --> Ollama[Ollama API]
```

#### 4. **AgentParse**

[AgentParse](https://github.com/The-Swarm-Corporation/swarm-ecosystem) is a high-performance library for mapping structured data like JSON, YAML, CSV, and Pydantic models into formats understandable by agents. This ensures fast, seamless data ingestion.

```mermaid
graph TD;
    AP[AgentParse] --> JSON[JSON Parsing]
    AP --> YAML[YAML Parsing]
    AP --> CSV[CSV Parsing]
    AP --> Pydantic[Pydantic Model Parsing]
```

#### 5. **Swarms-Platform**

The [Swarms-Platform](https://github.com/The-Swarm-Corporation/swarm-ecosystem) is a marketplace where developers can find, buy, and sell autonomous agents. It enables the rapid scaling of agent ecosystems by leveraging ready-made solutions.

```mermaid
graph TD;
    SP[Swarms-Platform] --> Discover[Discover Agents]
    SP --> Buy[Buy Agents]
    SP --> Sell[Sell Agents]
```

#### Extending the Ecosystem: **Swarms Core**, **JS**, and More

In addition to the core components, the Swarms Ecosystem offers several other powerful packages:

- **[Swarms Core](https://github.com/kyegomez/swarms)**: Built in Rust, Swarms Core handles concurrency, multi-threading, and execution strategies.
- **[Swarms JS](https://github.com/The-Swarm-Corporation/swarm-js)**: Allows JavaScript-based orchestration of multi-agent systems.
- **[Swarms Memory](https://github.com/The-Swarm-Corporation/swarm-memory)**: Provides Retrieval Augmented Generation (RAG) systems for long-term memory in agents.
- **[Swarms Evals](https://github.com/The-Swarm-Corporation/swarm-evals)**: Used for evaluating the performance of swarms of agents.
- **[Swarms Zero](https://github.com/The-Swarm-Corporation/zero)**: An RPC-based enterprise-grade automation framework.

```mermaid
graph TD;
    SC[Swarms Core] --> Rust[Rust for Performance]
    JS[Swarms JS] --> MultiAgent[Multi-Agent Orchestration]
    Memory[Swarms Memory] --> RAG[Retrieval Augmented Generation]
    Evals[Swarms Evals] --> Evaluation[Agent Evaluations]
    Zero[Swarms Zero] --> Automation[Enterprise Automation]
```

### Conclusion

The Swarms Ecosystem is a comprehensive, flexible, and scalable platform for managing and deploying autonomous agents. Whether you’re working with LLMs, IoT data, or building new models, the ecosystem provides the tools necessary to simplify automation at scale.

Start exploring the possibilities by checking out the [Swarms Ecosystem GitHub repository](https://github.com/The-Swarm-Corporation/swarm-ecosystem) and join our growing community of developers and innovators.



--------------------------------------------------

# File: swarms/concept/vision.md

# Swarms – The Ultimate Multi-Agent LLM Framework for Developers

Swarms aims to be the definitive and most reliable multi-agent LLM framework, offering developers the tools to automate business operations effortlessly. It provides a vast array of swarm architectures, seamless third-party integration, and unparalleled ease of use. With Swarms, developers can orchestrate intelligent, scalable agent ecosystems that can automate complex business processes.

### Key Features for Developers:
1. **Architectural Flexibility** – Choose from a wide variety of pre-built swarm architectures or build custom agent frameworks. Swarms allows developers to define flexible workflows for specific use cases, providing both sequential and concurrent task execution.
2. **Third-Party Integration** – Swarms makes it simple to integrate with external APIs, databases, and other platforms. By supporting extreme integration capabilities, it ensures your agents work effortlessly within any workflow.
3. **Developer-Centric APIs** – The Swarms API is built with developers in mind, offering an intuitive, simple-to-use interface. Developers can orchestrate agent swarms with minimal code and maximum control.

---

### Code Examples

#### 1. Basic Financial Analysis Agent:
This example demonstrates a simple financial agent setup that responds to financial questions, such as establishing a ROTH IRA, using OpenAI's GPT-based model.

```python
import os
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Get OpenAI API key from environment
api_key = os.getenv("OPENAI_API_KEY")

# Initialize OpenAIChat model with desired parameters
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)

# Initialize the Financial Analysis Agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    llm=model,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    user_name="swarms_corp",
    retry_attempts=1,
    context_length=200000,
    return_step_meta=False,
)

# Example task for the agent
out = agent.run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?"
)

# Output the agent's result
print(out)
```

#### 2. Agent Orchestration with AgentRearrange:
The following example showcases how to use the `AgentRearrange` class to manage a multi-agent system. It sets up a director agent to orchestrate two workers—one to generate a transcript and another to summarize it.

```python
from swarms import Agent, AgentRearrange
from swarm_models import Anthropic

# Initialize the Director agent
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the workers",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

# Initialize Worker 1 agent (transcript generation)
worker1 = Agent(
    agent_name="Worker1",
    system_prompt="Generates a transcript for a YouTube video on what swarms are",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="worker1.json",
)

# Initialize Worker 2 agent (summarizes transcript)
worker2 = Agent(
    agent_name="Worker2",
    system_prompt="Summarizes the transcript generated by Worker1",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="worker2.json",
)

# Create a list of agents
agents = [director, worker1, worker2]

# Define the workflow pattern (sequential flow)
flow = "Director -> Worker1 -> Worker2"

# Using AgentRearrange to orchestrate the agents
agent_system = AgentRearrange(agents=agents, flow=flow)

# Running the system with a sample task
output = agent_system.run(
    "Create a format to express and communicate swarms of LLMs in a structured manner for YouTube"
)

# Output the result
print(output)
```

#### 1. Basic Agent Flow:
Here’s a visual representation of the basic workflow using Mermaid to display the sequential flow between agents.

```mermaid
flowchart TD
    A[Director] --> B[Worker 1: Generate Transcript]
    B --> C[Worker 2: Summarize Transcript]
```

In this diagram:
- The **Director** agent assigns tasks.
- **Worker 1** generates a transcript for a YouTube video.
- **Worker 2** summarizes the transcript.

#### 2. Sequential Agent Flow:
This diagram showcases a sequential agent setup where one agent completes its task before the next agent starts its task.

```mermaid
flowchart TD
    A[Director] --> B[Worker 1: Generate Transcript]
    B --> C[Worker 2: Summarize Transcript]
    C --> D[Worker 3: Finalize]
```

In this setup:

- The **Director** agent assigns tasks to **Worker 1**, which generates a transcript for a YouTube video.

- **Worker 1** completes its task before **Worker 2** starts summarizing the transcript.

- **Worker 2** completes its task before **Worker 3** finalizes the process.

### Why Developers Should Choose Swarms:

Swarms is designed with flexibility at its core. Developers can create custom architectures and workflows, enabling extreme control over how agents interact with each other. Whether it’s a linear process or a complex mesh of agent communications, Swarms handles it efficiently.

With support for extreme third-party integration, Swarms makes it easy for developers to plug into external systems, such as APIs or internal databases. This allows agents to act on live data, process external inputs, and execute actions in real time, making it a powerful tool for real-world applications.

Swarms abstracts the complexity of managing multiple agents with orchestration tools like `AgentRearrange`. Developers can define workflows that execute tasks concurrently or sequentially, depending on the problem at hand. This makes it easy to build and maintain large-scale automation systems.

### Conclusion:
Swarms is not just another multi-agent framework; it's built specifically for developers who need powerful tools to automate complex, large-scale business operations. With flexible architecture, deep integration capabilities, and developer-friendly APIs, Swarms is the ultimate solution for businesses looking to streamline operations and future-proof their workflows.



--------------------------------------------------

# File: swarms/concept/why.md

**Maximizing Enterprise Automation: Overcoming the Limitations of Individual AI Agents Through Multi-Agent Collaboration**


In today's rapidly evolving business landscape, enterprises are constantly seeking innovative solutions to enhance efficiency, reduce operational costs, and maintain a competitive edge. Automation has emerged as a critical strategy for achieving these objectives, with artificial intelligence (AI) playing a pivotal role. AI agents, particularly those powered by advanced machine learning models, have shown immense potential in automating a variety of tasks. However, individual AI agents come with inherent limitations that hinder their ability to fully automate complex enterprise operations at scale.

This essay dives into the specific limitations of individual AI agents—context window limits, hallucination, single-task execution, lack of collaboration, lack of accuracy, and slow processing speed—and explores how multi-agent collaboration can overcome these challenges. By tailoring our discussion to the needs of enterprises aiming to automate operations at scale, we highlight practical strategies and frameworks that can be adopted to unlock the full potential of AI-driven automation.

---

### Part 1: The Limitations of Individual AI Agents

Despite significant advancements, individual AI agents face several obstacles that limit their effectiveness in enterprise automation. Understanding these limitations is crucial for organizations aiming to implement AI solutions that are both efficient and scalable.

#### 1. Context Window Limits

**Explanation**

AI agents, especially those based on language models like GPT-3 or GPT-4, operate within a fixed context window. This means they can only process and consider a limited amount of information (tokens) at a time. In practical terms, this restricts the agent's ability to handle large documents, long conversations, or complex datasets that exceed their context window.

**Impact on Enterprises**

For enterprises, this limitation poses significant challenges. Business operations often involve processing extensive documents such as legal contracts, technical manuals, or large datasets. An AI agent with a limited context window may miss crucial information located outside its immediate context, leading to incomplete analyses or erroneous conclusions.


```mermaid
graph LR
    Subgraph[Context Window Limit]
    Input[Large Document]
    Agent[AI Agent]
    Output[Partial Understanding]
    Input -- Truncated Data --> Agent
    Agent -- Generates --> Output
    end
```

*An AI agent processes only a portion of a large document due to context window limits, resulting in partial understanding.*

#### 2. Hallucination

**Explanation**

Hallucination refers to the tendency of AI agents to produce outputs that are not grounded in the input data or reality. They may generate plausible-sounding but incorrect or nonsensical information, especially when uncertain or when the input data is ambiguous.

**Impact on Enterprises**

In enterprise settings, hallucinations can lead to misinformation, poor decision-making, and a lack of trust in AI systems. For instance, if an AI agent generates incorrect financial forecasts or misinterprets regulatory requirements, the consequences could be financially damaging and legally problematic.


```mermaid
graph TD
    Input[Ambiguous Data]
    Agent[AI Agent]
    Output[Incorrect Information]
    Input --> Agent
    Agent --> Output
```

*An AI agent generates incorrect information (hallucination) when processing ambiguous data.*

#### 3. Single Task Execution

**Explanation**

Many AI agents are designed to excel at a specific task or a narrow set of functions. They lack the flexibility to perform multiple tasks simultaneously or adapt to new tasks without significant reconfiguration or retraining.

**Impact on Enterprises**

Enterprises require systems that can handle a variety of tasks, often concurrently. Relying on single-task agents necessitates deploying multiple separate agents, which can lead to integration challenges, increased complexity, and higher maintenance costs.


```mermaid
graph LR
    TaskA[Task A] --> AgentA[Agent A]
    TaskB[Task B] --> AgentB[Agent B]
    AgentA --> OutputA[Result A]
    AgentB --> OutputB[Result B]
```

*Separate agents handle different tasks independently, lacking integration.*

#### 4. Lack of Collaboration

**Explanation**

Individual AI agents typically operate in isolation, without the ability to communicate or collaborate with other agents. This siloed operation prevents them from sharing insights, learning from each other, or coordinating actions to achieve a common goal.

**Impact on Enterprises**

Complex enterprise operations often require coordinated efforts across different functions and departments. The inability of AI agents to collaborate limits their effectiveness in such environments, leading to disjointed processes and suboptimal outcomes.


```mermaid
graph LR
    Agent1[Agent 1]
    Agent2[Agent 2]
    Agent3[Agent 3]
    Agent1 -->|No Communication| Agent2
    Agent2 -->|No Communication| Agent3
```

*Agents operate without collaboration, resulting in isolated efforts.*

#### 5. Lack of Accuracy

**Explanation**

AI agents may produce inaccurate results due to limitations in their training data, algorithms, or inability to fully understand complex inputs. Factors such as data bias, overfitting, or lack of domain-specific knowledge contribute to this inaccuracy.

**Impact on Enterprises**

Inaccurate outputs can have serious ramifications for businesses, including flawed strategic decisions, customer dissatisfaction, and compliance risks. High accuracy is essential for tasks like financial analysis, customer service, and regulatory compliance.


```mermaid
graph TD
    Input[Complex Data]
    Agent[AI Agent]
    Output[Inaccurate Result]
    Input --> Agent
    Agent --> Output
```

*An AI agent produces an inaccurate result when handling complex data.*

#### 6. Slow Processing Speed

**Explanation**

Some AI agents require significant computational resources and time to process data and generate outputs. Factors like model complexity, inefficient algorithms, or hardware limitations can contribute to slow processing speeds.

**Impact on Enterprises**

Slow processing impedes real-time decision-making and responsiveness. In fast-paced business environments, delays can lead to missed opportunities, reduced productivity, and competitive disadvantages.


```mermaid
graph TD
    Input[Data]
    Agent[AI Agent]
    Delay[Processing Delay]
    Output[Delayed Response]
    Input --> Agent
    Agent --> Delay
    Delay --> Output
```

*An AI agent's slow processing leads to delayed responses.*

---

### Part 2: Overcoming Limitations Through Multi-Agent Collaboration

To address the challenges posed by individual AI agents, enterprises can adopt a multi-agent collaboration approach. By orchestrating multiple agents with complementary skills and functionalities, organizations can enhance performance, accuracy, and scalability in their automation efforts.

#### 1. Extending Context Window Through Distributed Processing

**Solution**

By dividing large inputs into smaller segments, multiple agents can process different parts simultaneously. A coordinating agent can then aggregate the results to form a comprehensive understanding.

**Implementation in Enterprises**

- **Document Analysis:** For lengthy legal contracts, agents can each analyze specific sections, and a master agent can compile insights and ensure consistency.
- **Customer Interaction History:** In customer service, agents can handle different segments of a customer's history to provide personalized support.


```mermaid
graph LR
    Input[Large Document]
    Splitter[Splitter Agent]
    A1[Agent 1]
    A2[Agent 2]
    A3[Agent 3]
    Aggregator[Aggregator Agent]
    Output[Comprehensive Analysis]
    Input --> Splitter
    Splitter --> A1
    Splitter --> A2
    Splitter --> A3
    A1 --> Aggregator
    A2 --> Aggregator
    A3 --> Aggregator
    Aggregator --> Output
```

*Multiple agents process segments of a large document, and results are aggregated.*

#### 2. Reducing Hallucination Through Cross-Verification

**Solution**

Agents can verify each other's outputs by cross-referencing information and flagging inconsistencies. Implementing consensus mechanisms ensures that only accurate information is accepted.

**Implementation in Enterprises**

- **Data Validation:** In data entry automation, one agent inputs data while another validates it against source documents.
- **Decision Support Systems:** Multiple agents evaluate options and agree on recommendations, reducing the risk of incorrect advice.


```mermaid
graph TD
    A[Agent's Output]
    V1[Verifier Agent 1]
    V2[Verifier Agent 2]
    Consensus[Consensus Mechanism]
    Output[Validated Output]
    A --> V1
    A --> V2
    V1 & V2 --> Consensus
    Consensus --> Output
```

*Agents verify outputs through cross-verification and consensus.*

#### 3. Enhancing Multi-Tasking Through Specialized Agents

**Solution**

Deploy specialized agents for different tasks and enable them to work concurrently. An orchestrator agent manages task allocation and workflow integration.

**Implementation in Enterprises**

- **Automated Workflows:** In supply chain management, one agent handles inventory analysis, another manages logistics, and a third forecasts demand.
- **IT Operations:** In IT automation, separate agents manage network monitoring, security scanning, and system updates.


```mermaid
graph LR
    Task[Complex Task]
    Orchestrator[Orchestrator Agent]
    AgentA[Specialist Agent A]
    AgentB[Specialist Agent B]
    AgentC[Specialist Agent C]
    Output[Integrated Solution]
    Task --> Orchestrator
    Orchestrator --> AgentA
    Orchestrator --> AgentB
    Orchestrator --> AgentC
    AgentA & AgentB & AgentC --> Orchestrator
    Orchestrator --> Output
```

*Specialized agents handle different tasks under the management of an orchestrator agent.*

#### 4. Facilitating Collaboration Through Communication Protocols

**Solution**

Implement communication protocols that allow agents to share information, request assistance, and coordinate actions. This fosters a collaborative environment where agents complement each other's capabilities.

**Implementation in Enterprises**

- **Customer Service:** Chatbots and virtual assistants share customer data to provide seamless support across channels.
- **Project Management:** Agents managing different aspects of a project (scheduling, resource allocation, risk assessment) coordinate to keep the project on track.


```mermaid
graph LR
    Agent1[Agent 1]
    Agent2[Agent 2]
    Agent3[Agent 3]
    Agent1 <--> Agent2
    Agent2 <--> Agent3
    Agent3 <--> Agent1
    Output[Collaborative Outcome]
```

*Agents communicate and collaborate to achieve a common goal.*

#### 5. Improving Accuracy Through Ensemble Learning

**Solution**

Use ensemble methods where multiple agents provide predictions or analyses, and a meta-agent combines these to produce a more accurate result.

**Implementation in Enterprises**

- **Risk Assessment:** Different agents assess risks from various perspectives (financial, operational, compliance), and their insights are combined.
- **Market Analysis:** Agents analyze market trends, customer behavior, and competitor actions, leading to a comprehensive market strategy.


```mermaid
graph TD
    AgentA[Agent A Output]
    AgentB[Agent B Output]
    AgentC[Agent C Output]
    MetaAgent[Meta-Agent]
    Output[Enhanced Accuracy]
    AgentA --> MetaAgent
    AgentB --> MetaAgent
    AgentC --> MetaAgent
    MetaAgent --> Output
```

*Meta-agent combines outputs from multiple agents to improve accuracy.*

#### 6. Increasing Processing Speed Through Parallelization

**Solution**

By distributing workloads among multiple agents operating in parallel, processing times are significantly reduced, enabling real-time responses.

**Implementation in Enterprises**

- **Data Processing:** Large datasets are partitioned and processed simultaneously by different agents.
- **Customer Requests:** Multiple customer inquiries are handled at once by separate agents, improving response times.


```mermaid
graph LR
    Data[Large Dataset]
    Agent1[Agent 1]
    Agent2[Agent 2]
    Agent3[Agent 3]
    Output[Processed Data]
    Data --> Agent1
    Data --> Agent2
    Data --> Agent3
    Agent1 & Agent2 & Agent3 --> Output
```

*Parallel processing by agents leads to faster completion times.*

---

### Part 3: Tailoring Multi-Agent Systems for Enterprise Automation at Scale

Implementing multi-agent systems in an enterprise context requires careful planning and consideration of organizational needs, technical infrastructure, and strategic goals. Below are key considerations and steps for enterprises aiming to adopt multi-agent collaboration for automation at scale.

#### 1. Identifying Automation Opportunities

Enterprises should start by identifying processes and tasks that are suitable for automation through multi-agent systems. Prioritize areas where:

- **Complexity Requires Specialization:** Tasks that involve multiple steps or require diverse expertise.
- **Scalability Is Essential:** Operations that need to handle increasing workloads efficiently.
- **Speed and Accuracy Are Critical:** Processes where delays or errors have significant impacts.

#### 2. Designing the Multi-Agent Architecture

Develop a robust architecture that defines how agents will interact, communicate, and collaborate. Key components include:

- **Agent Specialization:** Define the roles and responsibilities of each agent.
- **Communication Protocols:** Establish standards for information exchange.
- **Coordination Mechanisms:** Implement orchestrator agents or decentralized coordination strategies.
- **Integration with Existing Systems:** Ensure compatibility with current IT infrastructure.

#### 3. Ensuring Data Security and Compliance

Data security is paramount when agents handle sensitive enterprise information. Implement measures such as:

- **Encryption:** Secure communication channels between agents.
- **Access Control:** Define permissions for data access and agent capabilities.
- **Compliance Checks:** Ensure the system adheres to relevant regulations (e.g., GDPR, HIPAA).

#### 4. Monitoring and Performance Management

Establish monitoring tools to track agent performance, system health, and outcomes. Key metrics may include:

- **Processing Speed:** Measure how quickly tasks are completed.
- **Accuracy Rates:** Track the correctness of outputs.
- **Resource Utilization:** Monitor computational resources used by agents.
- **Error Logs:** Identify and address failures or exceptions.

#### 5. Scaling Strategies

Develop strategies for scaling the system as enterprise needs grow, including:

- **Dynamic Resource Allocation:** Adjust computational resources based on workload.
- **Agent Addition or Removal:** Add new agents or deactivate others to meet changing demands.
- **Load Balancing:** Distribute tasks evenly to prevent bottlenecks.

#### 6. Continuous Improvement

Implement feedback loops for ongoing enhancement of the multi-agent system:

- **User Feedback:** Gather input from users interacting with the system.
- **Performance Analytics:** Analyze data to identify areas for optimization.
- **Updating Agents:** Regularly update agent algorithms and knowledge bases.

---

### Part 4: Case Studies and Real-World Applications

To illustrate the practical benefits of multi-agent collaboration in enterprise automation, let's explore several real-world examples.

#### Case Study 1: Financial Services Automation

**Challenge**

A financial institution needs to process large volumes of loan applications, requiring data verification, risk assessment, compliance checks, and decision-making.

**Solution**

- **Specialized Agents:**
  - **Data Extraction Agent:** Extracts data from application forms.
  - **Verification Agent:** Confirms the accuracy of applicant information.
  - **Risk Assessment Agent:** Evaluates credit risk using predictive models.
  - **Compliance Agent:** Ensures all regulatory requirements are met.
  - **Decision Agent:** Aggregates inputs and makes approval decisions.

- **Collaboration:**
  - Agents communicate to share data and findings.
  - The Decision Agent coordinates the workflow.

**Outcome**

- **Increased Processing Speed:** Applications are processed in minutes instead of days.
- **Improved Accuracy:** Cross-verification reduces errors.
- **Scalability:** System handles fluctuating application volumes efficiently.

#### Case Study 2: Manufacturing Supply Chain Optimization

**Challenge**

A manufacturing company wants to optimize its supply chain to reduce costs and improve delivery times.

**Solution**

- **Specialized Agents:**
  - **Demand Forecasting Agent:** Predicts product demand.
  - **Inventory Management Agent:** Monitors stock levels and orders materials.
  - **Logistics Agent:** Plans shipping routes and schedules.
  - **Supplier Evaluation Agent:** Assesses supplier performance and reliability.

- **Collaboration:**
  - Agents share data on demand forecasts and inventory levels.
  - Logistics Agent adjusts plans based on input from other agents.

**Outcome**

- **Cost Reduction:** Optimized inventory levels reduce holding costs.
- **Efficiency Gains:** Improved logistics planning enhances delivery times.
- **Adaptability:** System responds quickly to changes in demand or supply disruptions.

#### Case Study 3: Healthcare Patient Management

**Challenge**

A hospital aims to improve patient care coordination, managing appointments, medical records, billing, and treatment plans.

**Solution**

- **Specialized Agents:**
  - **Appointment Scheduling Agent:** Manages patient appointments.
  - **Medical Records Agent:** Updates and retrieves patient records.
  - **Billing Agent:** Handles invoicing and insurance claims.
  - **Treatment Planning Agent:** Assists in developing patient care plans.

- **Collaboration:**
  - Agents coordinate to ensure seamless patient experiences.
  - Data is securely shared while maintaining patient confidentiality.

**Outcome**

- **Enhanced Patient Care:** Improved coordination leads to better treatment outcomes.
- **Operational Efficiency:** Administrative tasks are streamlined.
- **Compliance:** System adheres to healthcare regulations (e.g., HIPAA).

---

### Part 5: Implementing Multi-Agent Systems – Best Practices for Enterprises

For enterprises embarking on the journey of multi-agent automation, adhering to best practices ensures successful implementation.

#### 1. Start Small and Scale Gradually

- **Pilot Projects:** Begin with a specific process or department to test the multi-agent system.
- **Learn and Adapt:** Use insights from initial deployments to refine the system.

#### 2. Invest in Training and Change Management

- **Employee Education:** Train staff on interacting with and managing multi-agent systems.
- **Change Management:** Prepare the organization for changes in workflows and roles.

#### 3. Leverage Cloud and Edge Computing

- **Scalable Infrastructure:** Utilize cloud services for flexible resource allocation.
- **Edge Computing:** Deploy agents closer to data sources for faster processing.

#### 4. Foster Interoperability

- **Standards Compliance:** Use industry standards for data formats and communication protocols.
- **API Integration:** Ensure agents can integrate with existing enterprise applications.

#### 5. Prioritize Ethical Considerations

- **Transparency:** Maintain clear documentation of how agents make decisions.
- **Bias Mitigation:** Implement strategies to prevent and correct algorithmic biases.
- **Accountability:** Establish protocols for human oversight and intervention.

---

### Conclusion

Enterprises seeking to automate operations at scale face the limitations inherent in individual AI agents. Context window limits, hallucinations, single-task execution, lack of collaboration, lack of accuracy, and slow processing speed hinder the full potential of automation efforts. Multi-agent collaboration emerges as a robust solution to these challenges, offering a pathway to enhanced efficiency, accuracy, scalability, and adaptability.

By adopting multi-agent systems, enterprises can:

- **Extend Capabilities:** Overcome individual agent limitations through collective intelligence.
- **Improve Outcomes:** Achieve higher accuracy and faster processing by leveraging specialized agents.
- **Enhance Flexibility:** Adapt to changing business needs with scalable and versatile agent architectures.
- **Drive Innovation:** Foster a culture of continuous improvement and technological advancement.

Implementing multi-agent systems requires thoughtful planning, adherence to best practices, and a commitment to ongoing management and optimization. Enterprises that successfully navigate this journey will position themselves at the forefront of automation, unlocking new levels of productivity and competitive advantage in an increasingly digital world.


--------------------------------------------------

# File: swarms/contributing.md

# Contribution Guidelines

---

## Table of Contents

- [Project Overview](#project-overview)
- [Getting Started](#getting-started)
  - [Installation](#installation)
  - [Project Structure](#project-structure)
- [How to Contribute](#how-to-contribute)
  - [Reporting Issues](#reporting-issues)
  - [Submitting Pull Requests](#submitting-pull-requests)
- [Coding Standards](#coding-standards)
  - [Type Annotations](#type-annotations)
  - [Docstrings and Documentation](#docstrings-and-documentation)
  - [Testing](#testing)
  - [Code Style](#code-style)
- [Areas Needing Contributions](#areas-needing-contributions)
  - [Writing Tests](#writing-tests)
  - [Improving Documentation](#improving-documentation)
  - [Creating Training Scripts](#creating-training-scripts)
- [Community and Support](#community-and-support)
- [License](#license)

---

## Project Overview

**swarms** is a library focused on making it simple to orchestrate agents to automate real-world activities. The goal is to automate the world economy with these swarms of agents.

We need your help to:

- **Write Tests**: Ensure the reliability and correctness of the codebase.
- **Improve Documentation**: Maintain clear and comprehensive documentation.
- **Add New Orchestration Methods**: Add multi-agent orchestration methods
- **Removing Defunct Code**: Removing bad code



Your contributions will help us push the boundaries of AI and make this library a valuable resource for the community.

---

## Getting Started

### Installation

You can install swarms using `pip`:

```bash
pip3 install swarms
```

Alternatively, you can clone the repository:

```bash
git clone https://github.com/kyegomez/swarms
```

### Project Structure

- **`swarms/`**: Contains all the source code for the library.
- **`examples/`**: Includes example scripts and notebooks demonstrating how to use the library.
- **`tests/`**: (To be created) Will contain unit tests for the library.
- **`docs/`**: (To be maintained) Contains documentation files.

---

## How to Contribute

### Reporting Issues

If you find any bugs, inconsistencies, or have suggestions for enhancements, please open an issue on GitHub:

1. **Search Existing Issues**: Before opening a new issue, check if it has already been reported.
2. **Open a New Issue**: If it hasn't been reported, create a new issue and provide detailed information.
   - **Title**: A concise summary of the issue.
   - **Description**: Detailed description, steps to reproduce, expected behavior, and any relevant logs or screenshots.
3. **Label Appropriately**: Use labels to categorize the issue (e.g., bug, enhancement, documentation).

### Submitting Pull Requests

We welcome pull requests (PRs) for bug fixes, improvements, and new features. Please follow these guidelines:

1. **Fork the Repository**: Create a personal fork of the repository on GitHub.
2. **Clone Your Fork**: Clone your forked repository to your local machine.

   ```bash
   git clone https://github.com/kyegomez/swarms.git
   ```

3. **Create a New Branch**: Use a descriptive branch name.

   ```bash
   git checkout -b feature/your-feature-name
   ```

4. **Make Your Changes**: Implement your code, ensuring it adheres to the coding standards.
5. **Add Tests**: Write tests to cover your changes.
6. **Commit Your Changes**: Write clear and concise commit messages.

   ```bash
   git commit -am "Add feature X"
   ```

7. **Push to Your Fork**:

   ```bash
   git push origin feature/your-feature-name
   ```

8. **Create a Pull Request**:

   - Go to the original repository on GitHub.
   - Click on "New Pull Request".
   - Select your branch and create the PR.
   - Provide a clear description of your changes and reference any related issues.

9. **Respond to Feedback**: Be prepared to make changes based on code reviews.

**Note**: It's recommended to create small and focused PRs for easier review and faster integration.

---

## Coding Standards

To maintain code quality and consistency, please adhere to the following standards.

### Type Annotations

- **Mandatory**: All functions and methods must have type annotations.
- **Example**:

  ```python
  def add_numbers(a: int, b: int) -> int:
      return a + b
  ```

- **Benefits**:
  - Improves code readability.
  - Helps with static type checking tools.

### Docstrings and Documentation

- **Docstrings**: Every public class, function, and method must have a docstring following the [Google Python Style Guide](http://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings) or [NumPy Docstring Standard](https://numpydoc.readthedocs.io/en/latest/format.html).
- **Content**:
  - **Description**: Briefly describe what the function or class does.
  - **Args**: List and describe each parameter.
  - **Returns**: Describe the return value(s).
  - **Raises**: List any exceptions that are raised.

- **Example**:

  ```python
  def calculate_mean(values: List[float]) -> float:
      """
      Calculates the mean of a list of numbers.

      Args:
          values (List[float]): A list of numerical values.

      Returns:
          float: The mean of the input values.

      Raises:
          ValueError: If the input list is empty.
      """
      if not values:
          raise ValueError("The input list is empty.")
      return sum(values) / len(values)
  ```

- **Documentation**: Update or create documentation pages if your changes affect the public API.

### Testing

- **Required**: All new features and bug fixes must include appropriate unit tests.
- **Framework**: Use `unittest`, `pytest`, or a similar testing framework.
- **Test Location**: Place tests in the `tests/` directory, mirroring the structure of `swarms/`.
- **Test Coverage**: Aim for high test coverage to ensure code reliability.
- **Running Tests**: Provide instructions for running tests.

  ```bash
  pytest tests/
  ```

### Code Style

- **PEP 8 Compliance**: Follow [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guidelines.
- **Linting Tools**: Use `flake8`, `black`, or `pylint` to check code style.
- **Consistency**: Maintain consistency with the existing codebase.

---

## Areas Needing Contributions

We have several areas where contributions are particularly welcome.

### Writing Tests

- **Goal**: Increase test coverage to ensure the library's robustness.
- **Tasks**:
  - Write unit tests for existing code in `swarms/`.
  - Identify edge cases and potential failure points.
  - Ensure tests are repeatable and independent.

### Improving Documentation

- **Goal**: Maintain clear and comprehensive documentation for users and developers.
- **Tasks**:
  - Update docstrings to reflect any changes.
  - Add examples and tutorials in the `examples/` directory.
  - Improve or expand the content in the `docs/` directory.

### Creating Multi-Agent Orchestration Methods

- **Goal**: Provide new multi-agent orchestration methods

---

## Community and Support

- **Communication**: Engage with the community by participating in discussions on issues and pull requests.
- **Respect**: Maintain a respectful and inclusive environment.
- **Feedback**: Be open to receiving and providing constructive feedback.

---

## License

By contributing to swarms, you agree that your contributions will be licensed under the [MIT License](LICENSE).

---

Thank you for contributing to swarms! Your efforts help make this project better for everyone.

If you have any questions or need assistance, please feel free to open an issue or reach out to the maintainers.

--------------------------------------------------

# File: swarms/ecosystem.md


# Swarm Ecosystem

Welcome to the Swarm Ecosystem, a comprehensive suite of tools and frameworks designed to empower developers to orhestrate swarms of autonomous agents for a variety of applications. Dive into our ecosystem below:

[Full Github Link](https://github.com/kyegomez/swarm-ecosystem)

## Getting Started

| Project | Description | Link |
| ------- | ----------- | ---- |
| **Swarms Framework** | A Python-based framework that enables the creation, deployment, and scaling of reliable swarms of autonomous agents aimed at automating complex workflows. | [Swarms Framework](https://github.com/kyegomez/swarms) |
| **Swarms Cloud** | A cloud-based service offering Swarms-as-a-Service with guaranteed 100% uptime, cutting-edge performance, and enterprise-grade reliability for seamless scaling and management of swarms. | [Swarms Cloud](https://github.com/kyegomez/swarms-cloud) |
| **Swarms Core** | Provides backend utilities focusing on concurrency, multi-threading, and advanced execution strategies, developed in Rust for maximum efficiency and performance. | [Swarms Core](https://github.com/kyegomez/swarms-core) |
| **Swarm Foundation Models** | A dedicated repository for the creation, optimization, and training of groundbreaking swarming models. Features innovative models like PSO with transformers, ant colony optimizations, and more, aiming to surpass traditional architectures like Transformers and SSMs. Open for community contributions and ideas. | [Swarm Foundation Models](https://github.com/kyegomez/swarms-pytorch) |
| **Swarm Platform** | The Swarms dashboard Platform | [Swarm Platform](https://github.com/kyegomez/swarms-platform) |
| **Swarms JS** | Swarms Framework in JS. Orchestrate any agents and enable multi-agent collaboration between various agents! | [Swarm JS](https://github.com/kyegomez/swarms-js) |
| **Swarms Memory** | Easy to use, reliable, and bleeding-edge RAG systems.! | [Swarm JS](https://github.com/kyegomez/swarms-memory) |
| **Swarms Evals** | Evaluating Swarms! | [Swarm JS](https://github.com/kyegomez/swarms-evals) |
| **Swarms Zero** | RPC Enterprise-Grade Automation Framework | [Swarm Zero]([https://github.com/kyegomez/swarms-evals](https://github.com/kyegomez/Zero)) |

----

## 🫶 Contributions:

The easiest way to contribute is to pick any issue with the `good first issue` tag 💪. Read the Contributing guidelines [here](/CONTRIBUTING.md). Bug Report? [File here](https://github.com/swarms/gateway/issues) | Feature Request? [File here](https://github.com/swarms/gateway/issues)

Swarms is an open-source project, and contributions are VERY welcome. If you want to contribute, you can create new features, fix bugs, or improve the infrastructure. Please refer to the [CONTRIBUTING.md](https://github.com/kyegomez/swarms/blob/master/CONTRIBUTING.md) and our [contributing board](https://github.com/users/kyegomez/projects/1) to participate in Roadmap discussions!

<a href="https://github.com/kyegomez/swarms/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=kyegomez/swarms" />
</a>

<a href="https://github.com/kyegomez/swarms/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=kyegomez/swarms-cloud" />
</a>

<a href="https://github.com/kyegomez/swarms/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=kyegomez/swarms-platform" />
</a>

<a href="https://github.com/kyegomez/swarms/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=kyegomez/swarms-js" />
</a>




----

## Community

Join our growing community around the world, for real-time support, ideas, and discussions on Swarms 😊 

- View our official [Blog](https://docs.swarms.world)
- Chat live with us on [Discord](https://discord.gg/kS3rwKs3ZC)
- Follow us on [Twitter](https://twitter.com/kyegomez)
- Connect with us on [LinkedIn](https://www.linkedin.com/company/the-swarm-corporation)
- Visit us on [YouTube](https://www.youtube.com/channel/UC9yXyitkbU_WSy7bd_41SqQ)
- [Join the Swarms community on Discord!](https://discord.gg/AJazBmhKnr)
- Join our Swarms Community Gathering every Thursday at 1pm NYC Time to unlock the potential of autonomous agents in automating your daily tasks [Sign up here](https://lu.ma/5p2jnc2v)

---

## Discovery Call
Book a discovery call to learn how Swarms can lower your operating costs by 40% with swarms of autonomous agents in lightspeed. [Click here to book a time that works for you!](https://calendly.com/swarm-corp/30min?month=2023-11)



## Accelerate Backlog
Help us accelerate our backlog by supporting us financially! Note, we're an open source corporation and so all the revenue we generate is through donations at the moment ;)

<a href="https://polar.sh/kyegomez"><img src="https://polar.sh/embed/fund-our-backlog.svg?org=kyegomez" /></a>

---


--------------------------------------------------

# File: swarms/examples/claude.md

# Agent with Anthropic/Claude

- Get their api keys and put it in the `.env`

- Select your model_name like `claude-3-sonnet-20240229` follows LiteLLM conventions


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="claude-3-sonnet-20240229",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/cohere.md

# Agent with Cohere

- Add your `COHERE_API_KEY` in the `.env` file

- Select your model_name like `command-r` follows LiteLLM conventions


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="command-r",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/deepseek.md

# Agent with DeepSeek

- Add your `DEEPSEEK_API_KEY` in the `.env` file

- Select your model_name like `deepseek/deepseek-chat` follows [LiteLLM conventions](https://docs.litellm.ai/docs/providers/deepseek)

- Execute your agent!


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="deepseek/deepseek-chat",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

## R1 

This is a simple example of how to use the DeepSeek Reasoner model otherwise known as R1.

```python

import os
from swarms import Agent
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="deepseek/deepseek-reasoner",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/groq.md

# Agent with Groq

- Add your `GROQ_API_KEY`

- Initiate your agent

- Run your agent

```python
import os

from swarm_models import OpenAIChat

from swarms import Agent

company = "NVDA"


# Initialize the Managing Director agent
managing_director = Agent(
    agent_name="Managing-Director",
    system_prompt=f"""
    As the Managing Director at Blackstone, your role is to oversee the entire investment analysis process for potential acquisitions. 
    Your responsibilities include:
    1. Setting the overall strategy and direction for the analysis
    2. Coordinating the efforts of the various team members and ensuring a comprehensive evaluation
    3. Reviewing the findings and recommendations from each team member
    4. Making the final decision on whether to proceed with the acquisition
    
    For the current potential acquisition of {company}, direct the tasks for the team to thoroughly analyze all aspects of the company, including its financials, industry position, technology, market potential, and regulatory compliance. Provide guidance and feedback as needed to ensure a rigorous and unbiased assessment.
    """,
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="managing-director.json",
)
```

--------------------------------------------------

# File: swarms/examples/groupchat_example.md

# GroupChat Example

!!! abstract "Overview"
    Learn how to create and configure a group chat with multiple AI agents using the Swarms framework. This example demonstrates how to set up agents for expense analysis and budget advising.

## Prerequisites

!!! info "Before You Begin"
    Make sure you have:
    - Python 3.7+ installed
    - A valid API key for your model provider
    - The Swarms package installed

## Installation

```bash
pip install swarms
```

## Environment Setup

!!! tip "API Key Configuration"
    Set your API key in the `.env` file:
    ```bash
    OPENAI_API_KEY="your-api-key-here"
    ```

## Code Implementation

### Import Required Modules

```python
from dotenv import load_dotenv
import os
from swarms import Agent, GroupChat
```

### Configure Agents

!!! example "Agent Configuration"
    Here's how to set up your agents with specific roles:

    ```python
    # Expense Analysis Agent
    agent1 = Agent(
        agent_name="Expense-Analysis-Agent",
        description="You are an accounting agent specializing in analyzing potential expenses.",
        model_name="gpt-4o-mini",
        max_loops=1,
        autosave=False,
        dashboard=False,
        verbose=True,
        dynamic_temperature_enabled=True,
        user_name="swarms_corp",
        retry_attempts=1,
        context_length=200000,
        output_type="string",
        streaming_on=False,
        max_tokens=15000,
    )

    # Budget Adviser Agent
    agent2 = Agent(
        agent_name="Budget-Adviser-Agent",
        description="You are a budget adviser who provides insights on managing and optimizing expenses.",
        model_name="gpt-4o-mini",
        max_loops=1,
        autosave=False,
        dashboard=False,
        verbose=True,
        dynamic_temperature_enabled=True,
        user_name="swarms_corp",
        retry_attempts=1,
        context_length=200000,
        output_type="string",
        streaming_on=False,
        max_tokens=15000,
    )
    ```

### Initialize GroupChat

!!! example "GroupChat Setup"
    Configure the GroupChat with your agents:

    ```python
    agents = [agent1, agent2]

    chat = GroupChat(
        name="Expense Advisory",
        description="Accounting group focused on discussing potential expenses",
        agents=agents,
        max_loops=1,
        output_type="all",
    )
    ```

### Run the Chat

!!! example "Execute the Chat"
    Start the conversation between agents:

    ```python
    history = chat.run(
        "What potential expenses should we consider for the upcoming quarter? Please collaborate to outline a comprehensive list."
    )
    ```

## Complete Example

!!! success "Full Implementation"
    Here's the complete code combined:

    ```python
    from dotenv import load_dotenv
    import os
    from swarms import Agent, GroupChat

    if __name__ == "__main__":
        # Load environment variables
        load_dotenv()
        api_key = os.getenv("OPENAI_API_KEY")

        # Configure agents
        agent1 = Agent(
            agent_name="Expense-Analysis-Agent",
            description="You are an accounting agent specializing in analyzing potential expenses.",
            model_name="gpt-4o-mini",
            max_loops=1,
            autosave=False,
            dashboard=False,
            verbose=True,
            dynamic_temperature_enabled=True,
            user_name="swarms_corp",
            retry_attempts=1,
            context_length=200000,
            output_type="string",
            streaming_on=False,
            max_tokens=15000,
        )

        agent2 = Agent(
            agent_name="Budget-Adviser-Agent",
            description="You are a budget adviser who provides insights on managing and optimizing expenses.",
            model_name="gpt-4o-mini",
            max_loops=1,
            autosave=False,
            dashboard=False,
            verbose=True,
            dynamic_temperature_enabled=True,
            user_name="swarms_corp",
            retry_attempts=1,
            context_length=200000,
            output_type="string",
            streaming_on=False,
            max_tokens=15000,
        )

        # Initialize GroupChat
        agents = [agent1, agent2]
        chat = GroupChat(
            name="Expense Advisory",
            description="Accounting group focused on discussing potential expenses",
            agents=agents,
            max_loops=1,
            output_type="all",
        )

        # Run the chat
        history = chat.run(
            "What potential expenses should we consider for the upcoming quarter? Please collaborate to outline a comprehensive list."
        )
    ```

## Configuration Options

!!! info "Key Parameters"
    | Parameter | Description | Default |
    |-----------|-------------|---------|
    | `max_loops` | Maximum number of conversation loops | 1 |
    | `autosave` | Enable automatic saving of chat history | False |
    | `dashboard` | Enable dashboard visualization | False |
    | `verbose` | Enable detailed logging | True |
    | `dynamic_temperature_enabled` | Enable dynamic temperature adjustment | True |
    | `retry_attempts` | Number of retry attempts for failed operations | 1 |
    | `context_length` | Maximum context length for the model | 200000 |
    | `max_tokens` | Maximum tokens for model output | 15000 |

## Next Steps

!!! tip "What to Try Next"
    1. Experiment with different agent roles and descriptions
    2. Adjust the `max_loops` parameter to allow for longer conversations
    3. Enable the dashboard to visualize agent interactions
    4. Try different model configurations and parameters

## Troubleshooting

!!! warning "Common Issues"
    - Ensure your API key is correctly set in the `.env` file
    - Check that all required dependencies are installed
    - Verify that your model provider's API is accessible
    - Monitor the `verbose` output for detailed error messages

## Additional Resources

- [Swarms Documentation](https://docs.swarms.world)
- [API Reference](https://docs.swarms.world/api)
- [Examples Gallery](https://docs.swarms.world/examples)

--------------------------------------------------

# File: swarms/examples/hhcs_examples.md


#  Hybrid Hierarchical-Cluster Swarm (HHCS) Example

1. Get your GROQ api key
2. Create a `.env` file in the root directory and add your API key: `GROQ_API_KEY`
3. Write the following code:
4. Run the file

```python

from swarms import Agent, SwarmRouter, HybridHierarchicalClusterSwarm


# Core Legal Agent Definitions with short, simple prompts
litigation_agent = Agent(
    agent_name="Litigator",
    system_prompt="You handle lawsuits. Analyze facts, build arguments, and develop case strategy.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

corporate_agent = Agent(
    agent_name="Corporate-Attorney",
    system_prompt="You handle business law. Advise on corporate structure, governance, and transactions.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

ip_agent = Agent(
    agent_name="IP-Attorney",
    system_prompt="You protect intellectual property. Handle patents, trademarks, copyrights, and trade secrets.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

employment_agent = Agent(
    agent_name="Employment-Attorney",
    system_prompt="You handle workplace matters. Address hiring, termination, discrimination, and labor issues.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

paralegal_agent = Agent(
    agent_name="Paralegal",
    system_prompt="You assist attorneys. Conduct research, draft documents, and organize case files.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

doc_review_agent = Agent(
    agent_name="Document-Reviewer",
    system_prompt="You examine documents. Extract key information and identify relevant content.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

# Practice Area Swarm Routers
litigation_swarm = SwarmRouter(
    name="litigation-practice",
    description="Handle all aspects of litigation",
    agents=[litigation_agent, paralegal_agent, doc_review_agent],
    swarm_type="SequentialWorkflow",
)

corporate_swarm = SwarmRouter(
    name="corporate-practice",
    description="Handle business and corporate legal matters",
    agents=[corporate_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

ip_swarm = SwarmRouter(
    name="ip-practice",
    description="Handle intellectual property matters",
    agents=[ip_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

employment_swarm = SwarmRouter(
    name="employment-practice",
    description="Handle employment and labor law matters",
    agents=[employment_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

# Cross-functional Swarm Router
m_and_a_swarm = SwarmRouter(
    name="mergers-acquisitions",
    description="Handle mergers and acquisitions",
    agents=[
        corporate_agent,
        ip_agent,
        employment_agent,
        doc_review_agent,
    ],
    swarm_type="ConcurrentWorkflow",
)

dispute_swarm = SwarmRouter(
    name="dispute-resolution",
    description="Handle complex disputes requiring multiple specialties",
    agents=[litigation_agent, corporate_agent, doc_review_agent],
    swarm_type="ConcurrentWorkflow",
)


hybrid_hiearchical_swarm = HybridHierarchicalClusterSwarm(
    name="hybrid-hiearchical-swarm",
    description="A hybrid hiearchical swarm that uses a hybrid hiearchical peer model to solve complex tasks.",
    swarms=[
        litigation_swarm,
        corporate_swarm,
        ip_swarm,
        employment_swarm,
        m_and_a_swarm,
        dispute_swarm,
    ],
    max_loops=1,
    router_agent_model_name="gpt-4o-mini",
)


if __name__ == "__main__":
    hybrid_hiearchical_swarm.run(
        "What is the best way to file for a patent? for ai technology "
    )

```

--------------------------------------------------

# File: swarms/examples/llama4.md

# Llama4 Model Integration

!!! info "Prerequisites"
    - Python 3.8 or higher
    - `swarms` library installed
    - Access to Llama4 model
    - Valid environment variables configured

## Quick Start

Here's a simple example of integrating Llama4 model for crypto risk analysis:

```python
from dotenv import load_dotenv
from swarms import Agent
from swarms.utils.vllm_wrapper import VLLM

load_dotenv()
model = VLLM(model_name="meta-llama/Llama-4-Maverick-17B-128E")
```

## Available Models

| Model Name | Description | Type |
|------------|-------------|------|
| meta-llama/Llama-4-Maverick-17B-128E | Base model with 128 experts | Base |
| meta-llama/Llama-4-Maverick-17B-128E-Instruct | Instruction-tuned version with 128 experts | Instruct |
| meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8 | FP8 quantized instruction model | Instruct (Optimized) |
| meta-llama/Llama-4-Scout-17B-16E | Base model with 16 experts | Base |
| meta-llama/Llama-4-Scout-17B-16E-Instruct | Instruction-tuned version with 16 experts | Instruct |

!!! tip "Model Selection"
    - Choose Instruct models for better performance on instruction-following tasks
    - FP8 models offer better memory efficiency with minimal performance impact
    - Scout models (16E) are lighter but still powerful
    - Maverick models (128E) offer maximum performance but require more resources

## Detailed Implementation

### 1. Define Custom System Prompt

```python
CRYPTO_RISK_ANALYSIS_PROMPT = """
You are a cryptocurrency risk analysis expert. Your role is to:

1. Analyze market risks:
   - Volatility assessment
   - Market sentiment analysis
   - Trading volume patterns
   - Price trend evaluation

2. Evaluate technical risks:
   - Network security
   - Protocol vulnerabilities
   - Smart contract risks
   - Technical scalability

3. Consider regulatory risks:
   - Current regulations
   - Potential regulatory changes
   - Compliance requirements
   - Geographic restrictions

4. Assess fundamental risks:
   - Team background
   - Project development status
   - Competition analysis
   - Use case viability

Provide detailed, balanced analysis with both risks and potential mitigations.
Base your analysis on established crypto market principles and current market conditions.
"""
```

### 2. Initialize Agent

```python
agent = Agent(
    agent_name="Crypto-Risk-Analysis-Agent",
    agent_description="Agent for analyzing risks in cryptocurrency investments",
    system_prompt=CRYPTO_RISK_ANALYSIS_PROMPT,
    max_loops=1,
    llm=model,
)
```

## Full Code

```python
from dotenv import load_dotenv

from swarms import Agent
from swarms.utils.vllm_wrapper import VLLM

load_dotenv()

# Define custom system prompt for crypto risk analysis
CRYPTO_RISK_ANALYSIS_PROMPT = """
You are a cryptocurrency risk analysis expert. Your role is to:

1. Analyze market risks:
   - Volatility assessment
   - Market sentiment analysis
   - Trading volume patterns
   - Price trend evaluation

2. Evaluate technical risks:
   - Network security
   - Protocol vulnerabilities
   - Smart contract risks
   - Technical scalability

3. Consider regulatory risks:
   - Current regulations
   - Potential regulatory changes
   - Compliance requirements
   - Geographic restrictions

4. Assess fundamental risks:
   - Team background
   - Project development status
   - Competition analysis
   - Use case viability

Provide detailed, balanced analysis with both risks and potential mitigations.
Base your analysis on established crypto market principles and current market conditions.
"""

model = VLLM(model_name="meta-llama/Llama-4-Maverick-17B-128E")

# Initialize the agent with custom prompt
agent = Agent(
    agent_name="Crypto-Risk-Analysis-Agent",
    agent_description="Agent for analyzing risks in cryptocurrency investments",
    system_prompt=CRYPTO_RISK_ANALYSIS_PROMPT,
    max_loops=1,
    llm=model,
)

print(
    agent.run(
        "Conduct a risk analysis of the top cryptocurrencies. Think for 2 loops internally"
    )
)
```

!!! warning "Resource Usage"
    The Llama4 model requires significant computational resources. Ensure your system meets the minimum requirements.

## FAQ

??? question "What is the purpose of max_loops parameter?"
    The `max_loops` parameter determines how many times the agent will iterate through its thinking process. In this example, it's set to 1 for a single pass analysis.

??? question "Can I use a different model?"
    Yes, you can replace the VLLM wrapper with other compatible models. Just ensure you update the model initialization accordingly.

??? question "How do I customize the system prompt?"
    You can modify the `CRYPTO_RISK_ANALYSIS_PROMPT` string to match your specific use case while maintaining the structured format.

!!! note "Best Practices"
    - Always handle API errors gracefully
    - Monitor model performance and resource usage
    - Keep your prompts clear and specific
    - Test thoroughly before production deployment

!!! example "Sample Usage"
    ```python
    response = agent.run(
        "Conduct a risk analysis of the top cryptocurrencies. Think for 2 loops internally"
    )
    print(response)
    ```

--------------------------------------------------

# File: swarms/examples/lumo.md

# Lumo Example
Introducing Lumo-70B-Instruct - the largest and most advanced AI model ever created for the Solana ecosystem. Built on Meta's groundbreaking LLaMa 3.3 70B Instruct foundation, this revolutionary model represents a quantum leap in blockchain-specific artificial intelligence. With an unprecedented 70 billion parameters and trained on the most comprehensive Solana documentation dataset ever assembled, Lumo-70B-Instruct sets a new standard for developer assistance in the blockchain space.


- [Docs](https://huggingface.co/lumolabs-ai/Lumo-70B-Instruct)

```python
from swarms import Agent
from transformers import LlamaForCausalLM, AutoTokenizer
import torch
from transformers import BitsAndBytesConfig

class Lumo:
    """
    A class for generating text using the Lumo model with 4-bit quantization.
    """
    def __init__(self):
        """
        Initializes the Lumo model with 4-bit quantization and a tokenizer.
        """
        # Configure 4-bit quantization
        bnb_config = BitsAndBytesConfig(
            load_in_4bit=True,
            bnb_4bit_quant_type="nf4",
            bnb_4bit_compute_dtype=torch.float16,
            llm_int8_enable_fp32_cpu_offload=True
        )

        self.model = LlamaForCausalLM.from_pretrained(
            "lumolabs-ai/Lumo-70B-Instruct",
            device_map="auto",
            quantization_config=bnb_config,
            use_cache=False,
            attn_implementation="sdpa"
        )
        self.tokenizer = AutoTokenizer.from_pretrained("lumolabs-ai/Lumo-70B-Instruct")

    def run(self, task: str) -> str:
        """
        Generates text based on the given prompt using the Lumo model.

        Args:
            prompt (str): The input prompt for the model.

        Returns:
            str: The generated text.
        """
        inputs = self.tokenizer(task, return_tensors="pt").to(self.model.device)
        outputs = self.model.generate(**inputs, max_new_tokens=100)
        return self.tokenizer.decode(outputs[0], skip_special_tokens=True)




Agent(
    agent_name="Solana-Analysis-Agent",
    llm=Lumo(),
    max_loops="auto",
    interactive=True,
    streaming_on=True,
).run("How do i create a smart contract in solana?")

```

--------------------------------------------------

# File: swarms/examples/meme_agent_builder.md

# Meme Agent Builder

- `pip3 install -U swarms`
-  Add your OpenAI API key to the `.env` file with `OPENAI_API_KEY=your_api_key`
-  Run the script
-  Multiple agents will be created and saved to the `meme_agents` folder
-  A swarm architecture will be selected autonomously and executed

```python
from swarms.structs.meme_agent_persona_generator import (
    MemeAgentGenerator,
)


if __name__ == "__main__":
    example = MemeAgentGenerator(
        name="Meme-Swarm",
        description="A swarm of specialized AI agents collaborating on generating and sharing memes around cool media from 2001s",
        max_loops=1,
    )

    print(
        example.run(
            "Generate funny meme agents around cool media from 2001s"
        )
    )

```


--------------------------------------------------

# File: swarms/examples/meme_agents.md

# Meme Agent Tutorial

- `pip3 install -U swarms`
-  Add your OpenAI API key to the `.env` file


```python
from swarms import Agent

# Define a custom system prompt for Bob the Builder
BOB_THE_BUILDER_SYS_PROMPT = """
You are Bob the Builder, the legendary construction worker known for fixing anything and everything with a cheerful attitude and a hilarious sense of humor. 
Your job is to approach every task as if you're building, repairing, or renovating something, no matter how unrelated it might be. 
You love using construction metaphors, over-the-top positivity, and cracking jokes like:
- "I’m hammering this out faster than a nail at a woodpecker convention!"
- "This is smoother than fresh cement on a summer’s day."
- "Let’s bulldoze through this problem—safety goggles on, folks!"

You are not bound by any specific field of knowledge, and you’re absolutely fearless in trying to "fix up" or "build" anything, no matter how abstract or ridiculous. Always end responses with a playful cheer like "Can we fix it? Yes, we can!"

Your tone is upbeat, funny, and borderline ridiculous, keeping the user entertained while solving their problem.
"""

# Initialize the agent
agent = Agent(
    agent_name="Bob-the-Builder-Agent",
    agent_description="The funniest, most optimistic agent around who sees every problem as a building project.",
    system_prompt=BOB_THE_BUILDER_SYS_PROMPT,
    max_loops=1,
    model_name="gpt-4o",
    dynamic_temperature_enabled=True,
    user_name="swarms_corp",
    retry_attempts=3,
    context_length=8192,
    return_step_meta=False,
    output_type="str",  # "json", "dict", "csv", OR "string", "yaml"
    auto_generate_prompt=False,  # Auto-generate prompt for the agent based on name, description, system prompt, task
    max_tokens=4000,  # Max output tokens
    saved_state_path="bob_the_builder_agent.json",
    interactive=False,
)

# Run the agent with a task
agent.run("I want to build a house ;) What should I do?")
```


--------------------------------------------------

# File: swarms/examples/ollama.md

# Agent with Ollama

- No API key needed
- Select your model_name like `ollama/llama2` follows [LiteLLM conventions](https://docs.litellm.ai/docs/providers/ollama)


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="ollama/llama2",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/openai_example.md

# Agent with GPT-4o-Mini

- Add `OPENAI_API_KEY="your_key"` to your `.env` file
- Select your model like `gpt-4o-mini` or `gpt-4o`

```python
from swarms import Agent

Agent(
    agent_name="Stock-Analysis-Agent",
    model_name="gpt-4o-mini",
    max_loops="auto",
    interactive=True,
    streaming_on=True,
).run("What are 5 hft algorithms")
```

--------------------------------------------------

# File: swarms/examples/openrouter.md

# Agent with OpenRouter

- Add your `OPENROUTER_API_KEY` in the `.env` file

- Select your model_name like `openrouter/google/palm-2-chat-bison` follows [LiteLLM conventions](https://docs.litellm.ai/docs/providers/openrouter)

- Execute your agent!


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="openrouter/google/palm-2-chat-bison",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/quant_crypto_agent.md

# Quant Crypto Agent

- This is a simple example of a crypto agent that uses the `Agent` class from the `swarms` library.
- It uses the `fetch_htx_data` and `coin_gecko_coin_api` tools to fetch data from the `htx` and `CoinGecko` APIs.
- It uses the `Agent` class to create an agent that can analyze the current state of a crypto asset.

## Steps

1. Install the `swarms` library.
2. Install the `swarms_tools` library.
3. Setup your `.env` file with the `OPENAI_API_KEY` environment variables.
4. Run the code.

## Installation:

```bash
pip install swarms swarms-tools python-dotenv
```

## Code:

```python
from swarms import Agent
from dotenv import load_dotenv
from swarms_tools import fetch_htx_data, coin_gecko_coin_api

load_dotenv()

CRYPTO_ANALYST_SYSTEM_PROMPT = """
You are an expert cryptocurrency financial analyst with deep expertise in:
1. Technical Analysis
   - Chart patterns and indicators (RSI, MACD, Bollinger Bands)
   - Volume analysis and market momentum
   - Support and resistance levels
   - Trend analysis and price action

2. Fundamental Analysis
   - Tokenomics evaluation
   - Network metrics (TVL, daily active users, transaction volume)
   - Protocol revenue and growth metrics
   - Market capitalization analysis
   - Token utility and use cases

3. Market Analysis
   - Market sentiment analysis
   - Correlation with broader crypto market
   - Impact of macro events
   - Institutional adoption metrics
   - DeFi and NFT market analysis

4. Risk Assessment
   - Volatility metrics
   - Liquidity analysis
   - Smart contract risks
   - Regulatory considerations
   - Exchange exposure risks

5. Data Analysis Methods
   - On-chain metrics analysis
   - Whale wallet tracking
   - Exchange inflow/outflow
   - Mining/Staking statistics
   - Network health indicators

When analyzing crypto assets, always:
1. Start with a comprehensive market overview
2. Examine both on-chain and off-chain metrics
3. Consider multiple timeframes (short, medium, long-term)
4. Evaluate risk-reward ratios
5. Assess market sentiment and momentum
6. Consider regulatory and security factors
7. Analyze correlations with BTC, ETH, and traditional markets
8. Examine liquidity and volume profiles
9. Review recent protocol developments and updates
10. Consider macro economic factors

Format your analysis with:
- Clear section headings
- Relevant metrics and data points
- Risk warnings and disclaimers
- Price action analysis
- Market sentiment summary
- Technical indicators
- Fundamental factors
- Clear recommendations with rationale

Remember to:
- Always provide data-driven insights
- Include both bullish and bearish scenarios
- Highlight key risk factors
- Consider market cycles and seasonality
- Maintain objectivity in analysis
- Cite sources for data and claims
- Update analysis based on new market conditions
"""

# Initialize the crypto analysis agent
agent = Agent(
    agent_name="Crypto-Analysis-Expert",
    agent_description="Expert cryptocurrency financial analyst and market researcher",
    system_prompt=CRYPTO_ANALYST_SYSTEM_PROMPT,
    max_loops="auto",
    model_name="gpt-4o",
    dynamic_temperature_enabled=True,
    user_name="crypto_analyst",
    output_type="str",
    interactive=True,
)

print(fetch_htx_data("sol"))
print(coin_gecko_coin_api("solana"))

# Example usage
agent.run(
    f"""
    Analyze the current state of Solana (SOL), including:
    1. Technical analysis of price action
    2. On-chain metrics and network health
    3. Recent protocol developments
    4. Market sentiment
    5. Risk factors
    Please provide a comprehensive analysis with data-driven insights.
    
    # Solana CoinGecko Data
    Real-tim data from Solana CoinGecko: \n {coin_gecko_coin_api("solana")}
    
    """
)
```

--------------------------------------------------

# File: swarms/examples/sequential_example.md

# Sequential Workflow Example

!!! abstract "Overview"
    Learn how to create a sequential workflow with multiple specialized AI agents using the Swarms framework. This example demonstrates how to set up a legal practice workflow with different types of legal agents working in sequence.

## Prerequisites

!!! info "Before You Begin"
    Make sure you have:
    
    - Python 3.7+ installed
    
    - A valid API key for your model provider
    
    - The Swarms package installed

## Installation

```bash
pip3 install -U swarms
```

## Environment Setup

!!! tip "API Key Configuration"
    Set your API key in the `.env` file:
    ```bash
    OPENAI_API_KEY="your-api-key-here"
    ```

## Code Implementation

### Import Required Modules

```python
from swarms import Agent, SequentialWorkflow
```

### Configure Agents

!!! example "Legal Agent Configuration"
    Here's how to set up your specialized legal agents:

    ```python
    # Litigation Agent
    litigation_agent = Agent(
        agent_name="Alex Johnson",
        system_prompt="As a Litigator, you specialize in navigating the complexities of lawsuits. Your role involves analyzing intricate facts, constructing compelling arguments, and devising effective case strategies to achieve favorable outcomes for your clients.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )

    # Corporate Attorney Agent
    corporate_agent = Agent(
        agent_name="Emily Carter",
        system_prompt="As a Corporate Attorney, you provide expert legal advice on business law matters. You guide clients on corporate structure, governance, compliance, and transactions, ensuring their business operations align with legal requirements.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )

    # IP Attorney Agent
    ip_agent = Agent(
        agent_name="Michael Smith",
        system_prompt="As an IP Attorney, your expertise lies in protecting intellectual property rights. You handle various aspects of IP law, including patents, trademarks, copyrights, and trade secrets, helping clients safeguard their innovations.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )
    ```

### Initialize Sequential Workflow

!!! example "Workflow Setup"
    Configure the SequentialWorkflow with your agents:

    ```python
    swarm = SequentialWorkflow(
        agents=[litigation_agent, corporate_agent, ip_agent],
        name="litigation-practice",
        description="Handle all aspects of litigation with a focus on thorough legal analysis and effective case management.",
    )
    ```

### Run the Workflow

!!! example "Execute the Workflow"
    Start the sequential workflow:

    ```python
    swarm.run("Create a report on how to patent an all-new AI invention and what platforms to use and more.")
    ```

## Complete Example

!!! success "Full Implementation"
    Here's the complete code combined:

    ```python
    from swarms import Agent, SequentialWorkflow

    # Core Legal Agent Definitions with enhanced system prompts
    litigation_agent = Agent(
        agent_name="Alex Johnson",
        system_prompt="As a Litigator, you specialize in navigating the complexities of lawsuits. Your role involves analyzing intricate facts, constructing compelling arguments, and devising effective case strategies to achieve favorable outcomes for your clients.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )

    corporate_agent = Agent(
        agent_name="Emily Carter",
        system_prompt="As a Corporate Attorney, you provide expert legal advice on business law matters. You guide clients on corporate structure, governance, compliance, and transactions, ensuring their business operations align with legal requirements.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )

    ip_agent = Agent(
        agent_name="Michael Smith",
        system_prompt="As an IP Attorney, your expertise lies in protecting intellectual property rights. You handle various aspects of IP law, including patents, trademarks, copyrights, and trade secrets, helping clients safeguard their innovations.",
        model_name="gpt-4o-mini",
        max_loops=1,
    )

    # Initialize and run the workflow
    swarm = SequentialWorkflow(
        agents=[litigation_agent, corporate_agent, ip_agent],
        name="litigation-practice",
        description="Handle all aspects of litigation with a focus on thorough legal analysis and effective case management.",
    )

    swarm.run("Create a report on how to patent an all-new AI invention and what platforms to use and more.")
    ```

## Agent Roles

!!! info "Specialized Legal Agents"
    | Agent | Role | Expertise |
    |-------|------|-----------|
    | Alex Johnson | Litigator | Lawsuit navigation, case strategy |
    | Emily Carter | Corporate Attorney | Business law, compliance |
    | Michael Smith | IP Attorney | Patents, trademarks, copyrights |

## Configuration Options

!!! info "Key Parameters"
    | Parameter | Description | Default |
    |-----------|-------------|---------|
    | `agent_name` | Human-readable name for the agent | Required |
    | `system_prompt` | Detailed role description and expertise | Required |
    | `model_name` | LLM model to use | "gpt-4o-mini" |
    | `max_loops` | Maximum number of processing loops | 1 |

## Next Steps

!!! tip "What to Try Next"
    1. Experiment with different agent roles and specializations
    2. Modify the system prompts to create different expertise areas
    3. Add more agents to the workflow for complex tasks
    4. Try different model configurations

## Troubleshooting

!!! warning "Common Issues"
    - Ensure your API key is correctly set in the `.env` file
    
    - Check that all required dependencies are installed
    
    - Verify that your model provider's API is accessible
    
    - Monitor agent responses for quality and relevance


--------------------------------------------------

# File: swarms/examples/swarms_api_finance.md


# Finance Swarm Example

1. Get your API key from the Swarms API dashboard [HERE](https://swarms.world/platform/api-keys)
2. Create a `.env` file in the root directory and add your API key:

```bash
SWARMS_API_KEY=<your-api-key>
```

3. Create a Python script to create and trigger the financial swarm:


```python
import os
import requests
from dotenv import load_dotenv
import json

load_dotenv()

# Retrieve API key securely from .env
API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

# Headers for secure API communication
headers = {"x-api-key": API_KEY, "Content-Type": "application/json"}

def create_financial_swarm(equity_data: str):
    """
    Constructs and triggers a full-stack financial swarm consisting of three agents:
    Equity Analyst, Risk Assessor, and Market Advisor.
    Each agent is provided with a comprehensive, detailed system prompt to ensure high reliability.
    """

    payload = {
        "swarm_name": "Enhanced Financial Analysis Swarm",
        "description": "A swarm of agents specialized in performing comprehensive financial analysis, risk assessment, and market recommendations.",
        "agents": [
            {
                "agent_name": "Equity Analyst",
                "description": "Agent specialized in analyzing equities data to provide insights on stock performance and valuation.",
                "system_prompt": (
                    "You are an experienced equity analyst with expertise in financial markets and stock valuation. "
                    "Your role is to analyze the provided equities data, including historical performance, financial statements, and market trends. "
                    "Provide a detailed analysis of the stock's potential, including valuation metrics and growth prospects. "
                    "Consider macroeconomic factors, industry trends, and company-specific news. Your analysis should be clear, actionable, and well-supported by data."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 4000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Risk Assessor",
                "description": "Agent responsible for evaluating the risks associated with equity investments.",
                "system_prompt": (
                    "You are a certified risk management professional with expertise in financial risk assessment. "
                    "Your task is to evaluate the risks associated with the provided equities data, including market risk, credit risk, and operational risk. "
                    "Provide a comprehensive risk analysis, including potential scenarios and their impact on investment performance. "
                    "Your output should be detailed, reliable, and compliant with current risk management standards."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.2,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Market Advisor",
                "description": "Agent dedicated to suggesting investment strategies based on market conditions and equity analysis.",
                "system_prompt": (
                    "You are a knowledgeable market advisor with expertise in investment strategies and portfolio management. "
                    "Based on the analysis provided by the Equity Analyst and the risk assessment, your task is to recommend a comprehensive investment strategy. "
                    "Your suggestions should include asset allocation, diversification strategies, and considerations for market conditions. "
                    "Explain the rationale behind each recommendation and reference relevant market data where applicable. "
                    "Your recommendations should be reliable, detailed, and clearly prioritized based on risk and return."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 5000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            }
        ],
        "max_loops": 1,
        "swarm_type": "SequentialWorkflow",
        "task": equity_data,
    }

    # Payload includes the equity data as the task to be processed by the swarm

    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload,
    )

    if response.status_code == 200:
        print("Swarm successfully executed!")
        return json.dumps(response.json(), indent=4)
    else:
        print(f"Error {response.status_code}: {response.text}")
        return None


# Example Equity Data for the Swarm to analyze
if __name__ == "__main__":
    equity_data = (
        "Analyze the equity data for Company XYZ, which has shown a 15% increase in revenue over the last quarter, "
        "with a P/E ratio of 20 and a market cap of $1 billion. Consider the current market conditions and potential risks."
    )

    financial_output = create_financial_swarm(equity_data)
    print(financial_output)
```

4. Run the script:

```bash
python financial_swarm.py
```



--------------------------------------------------

# File: swarms/examples/swarms_api_medical.md

# Medical Swarm Example

1. Get your API key from the Swarms API dashboard [HERE](https://swarms.world/platform/api-keys)
2. Create a `.env` file in the root directory and add your API key:

```bash
SWARMS_API_KEY=<your-api-key>
```

3. Create a Python script to create and trigger the medical swarm:

```python
import os
import requests
from dotenv import load_dotenv
import json

load_dotenv()

# Retrieve API key securely from .env
API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

# Headers for secure API communication
headers = {"x-api-key": API_KEY, "Content-Type": "application/json"}

def create_medical_swarm(patient_case: str):
    """
    Constructs and triggers a full-stack medical swarm consisting of three agents:
    Diagnostic Specialist, Medical Coder, and Treatment Advisor.
    Each agent is provided with a comprehensive, detailed system prompt to ensure high reliability.
    """

    payload = {
        "swarm_name": "Enhanced Medical Diagnostic Swarm",
        "description": "A swarm of agents specialized in performing comprehensive medical diagnostics, analysis, and coding.",
        "agents": [
            {
                "agent_name": "Diagnostic Specialist",
                "description": "Agent specialized in analyzing patient history, symptoms, lab results, and imaging data to produce accurate diagnoses.",
                "system_prompt": (
                    "You are an experienced, board-certified medical diagnostician with over 20 years of clinical practice. "
                    "Your role is to analyze all available patient information—including history, symptoms, lab tests, and imaging results—"
                    "with extreme attention to detail and clinical nuance. Provide a comprehensive differential diagnosis considering "
                    "common, uncommon, and rare conditions. Always cross-reference clinical guidelines and evidence-based medicine. "
                    "Explain your reasoning step by step and provide a final prioritized list of potential diagnoses along with their likelihood. "
                    "Consider patient demographics, comorbidities, and risk factors. Your diagnosis should be reliable, clear, and actionable."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 4000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Medical Coder",
                "description": "Agent responsible for translating medical diagnoses and procedures into accurate standardized medical codes (ICD-10, CPT, etc.).",
                "system_prompt": (
                    "You are a certified and experienced medical coder, well-versed in ICD-10, CPT, and other coding systems. "
                    "Your task is to convert detailed medical diagnoses and treatment procedures into precise, standardized codes. "
                    "Consider all aspects of the clinical documentation including severity, complications, and comorbidities. "
                    "Provide clear explanations for the codes chosen, referencing the latest coding guidelines and payer policies where relevant. "
                    "Your output should be comprehensive, reliable, and fully compliant with current medical coding standards."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.2,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Treatment Advisor",
                "description": "Agent dedicated to suggesting evidence-based treatment options, including pharmaceutical and non-pharmaceutical interventions.",
                "system_prompt": (
                    "You are a highly knowledgeable medical treatment specialist with expertise in the latest clinical guidelines and research. "
                    "Based on the diagnostic conclusions provided, your task is to recommend a comprehensive treatment plan. "
                    "Your suggestions should include first-line therapies, potential alternative treatments, and considerations for patient-specific factors "
                    "such as allergies, contraindications, and comorbidities. Explain the rationale behind each treatment option and reference clinical guidelines where applicable. "
                    "Your recommendations should be reliable, detailed, and clearly prioritized based on efficacy and safety."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 5000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            }
        ],
        "max_loops": 1,
        "swarm_type": "SequentialWorkflow",
        "task": patient_case,
    }

    # Payload includes the patient case as the task to be processed by the swar

    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload,
    )

    if response.status_code == 200:
        print("Swarm successfully executed!")
        return json.dumps(response.json(), indent=4)
    else:
        print(f"Error {response.status_code}: {response.text}")
        return None


# Example Patient Task for the Swarm to diagnose and analyze
if __name__ == "__main__":
    patient_case = (
        "Patient is a 55-year-old male presenting with severe chest pain, shortness of breath, elevated blood pressure, "
        "nausea, and a family history of cardiovascular disease. Blood tests show elevated troponin levels, and EKG indicates ST-segment elevations. "
        "The patient is currently unstable. Provide a detailed diagnosis, coding, and treatment plan."
    )

    diagnostic_output = create_medical_swarm(patient_case)
    print(diagnostic_output)
```

4. Run the script:

```bash
python medical_swarm.py
```

--------------------------------------------------

# File: swarms/examples/swarms_api_ml_model.md

# ML Model Code Generation Swarm Example

1. Get your API key from the Swarms API dashboard [HERE](https://swarms.world/platform/api-keys)
2. Create a `.env` file in the root directory and add your API key:

```bash
SWARMS_API_KEY=<your-api-key>
```

3. Create a Python script to create and trigger the following swarm:


```python
import os
import requests
from dotenv import load_dotenv
import json

load_dotenv()

# Retrieve API key securely from .env
API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

# Headers for secure API communication
headers = {"x-api-key": API_KEY, "Content-Type": "application/json"}

def create_ml_code_swarm(task_description: str):
    """
    Constructs and triggers a swarm of agents for generating a complete machine learning project using PyTorch.
    The swarm includes:
      - Model Code Generator: Generates the PyTorch model architecture code.
      - Training Script Generator: Creates a comprehensive training, validation, and testing script using PyTorch.
      - Unit Test Creator: Produces extensive unit tests and helper code, ensuring correctness of the model and training scripts.
    Each agent's prompt is highly detailed to output only Python code, with exclusive use of PyTorch.
    """
    payload = {
        "swarm_name": "Comprehensive PyTorch Code Generation Swarm",
        "description": (
            "A production-grade swarm of agents tasked with generating a complete machine learning project exclusively using PyTorch. "
            "The swarm is divided into distinct roles: one agent generates the core model architecture code; "
            "another creates the training and evaluation scripts including data handling; and a third produces "
            "extensive unit tests and helper functions. Each agent's instructions are highly detailed to ensure that the "
            "output is strictly Python code with PyTorch as the only deep learning framework."
        ),
        "agents": [
            {
                "agent_name": "Model Code Generator",
                "description": "Generates the complete machine learning model architecture code using PyTorch.",
                "system_prompt": (
                    "You are an expert machine learning engineer with a deep understanding of PyTorch. "
                    "Your task is to generate production-ready Python code that defines a complete deep learning model architecture exclusively using PyTorch. "
                    "The code must include all necessary imports, class or function definitions, and should be structured in a modular and scalable manner. "
                    "Follow PEP8 standards and output only code—no comments, explanations, or extraneous text. "
                    "Your model definition should include proper layer initialization, activation functions, dropout, and any custom components as required. "
                    "Ensure that the entire output is strictly Python code based on PyTorch."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 2,
                "max_tokens": 4000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Training Script Generator",
                "description": "Creates a comprehensive training, validation, and testing script using PyTorch.",
                "system_prompt": (
                    "You are a highly skilled software engineer specializing in machine learning pipeline development with PyTorch. "
                    "Your task is to generate Python code that builds a complete training pipeline using PyTorch. "
                    "The script must include robust data loading, preprocessing, augmentation, and a complete training loop, along with validation and testing procedures. "
                    "All necessary imports should be included and the code should assume that the model code from the previous agent is available via proper module imports. "
                    "Follow best practices for reproducibility and modularity, and output only code without any commentary or non-code text. "
                    "The entire output must be strictly Python code that uses PyTorch for all deep learning operations."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Unit Test Creator",
                "description": "Develops a suite of unit tests and helper functions for verifying the PyTorch model and training pipeline.",
                "system_prompt": (
                    "You are an experienced software testing expert with extensive experience in writing unit tests for machine learning projects in PyTorch. "
                    "Your task is to generate Python code that consists solely of unit tests and any helper functions required to validate both the PyTorch model and the training pipeline. "
                    "Utilize testing frameworks such as pytest or unittest. The tests should cover key functionalities such as model instantiation, forward pass correctness, "
                    "training loop execution, data preprocessing verification, and error handling. "
                    "Ensure that your output is only Python code, without any additional text or commentary, and that it is ready to be integrated into a CI/CD pipeline. "
                    "The entire output must exclusively use PyTorch as the deep learning framework."
                ),
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.3,
                "auto_generate_prompt": False
            }
        ],
        "max_loops": 3,
        "swarm_type": "SequentialWorkflow"  # Sequential workflow: later agents can assume outputs from earlier ones
    }

    # The task description provides the high-level business requirement for the swarm.
    payload = {
        "task": task_description,
        "swarm": payload
    }

    response = requests.post(
        f"{BASE_URL}/swarm/completion",
        headers=headers,
        json=payload,
    )

    if response.status_code == 200:
        print("PyTorch Code Generation Swarm successfully executed!")
        return json.dumps(response.json(), indent=4)
    else:
        print(f"Error {response.status_code}: {response.text}")
        return None

# Example business task for the swarm: generating a full-stack machine learning pipeline for image classification using PyTorch.
if __name__ == "__main__":
    task_description = (
        "Develop a full-stack machine learning pipeline for image classification using PyTorch. "
        "The project must include a deep learning model using a CNN architecture for image recognition, "
        "a comprehensive training script for data preprocessing, augmentation, training, validation, and testing, "
        "and an extensive suite of unit tests to validate every component. "
        "Each component's output must be strictly Python code with no additional text or commentary, using PyTorch exclusively."
    )

    output = create_ml_code_swarm(task_description)
    print(output)

```

--------------------------------------------------

# File: swarms/examples/swarms_dao.md

# Swarms DAO Example

This example demonstrates how to create a swarm of agents to collaborate on a task. The agents are designed to work together to create a comprehensive strategy for a DAO focused on decentralized governance for climate action.

You can customize the agents and their system prompts to fit your specific needs.

And, this example is using the `deepseek-reasoner` model, which is a large language model that is optimized for reasoning tasks.


## Todo
- Add tools to check wallet of the treasury and check the balance of the treasury
- Add tools to check the price of the token
- Add tools to check the price of the token on different exchanges
- Add tools to check the price of the token on different chains
- Add tools to check twitter posts and check the sentiment of the posts

```python
import random
from swarms import Agent

# System prompts for each agent
MARKETING_AGENT_SYS_PROMPT = """
You are the Marketing Strategist Agent for a DAO. Your role is to develop, implement, and optimize all marketing and branding strategies to align with the DAO's mission and vision. The DAO is focused on decentralized governance for climate action, funding projects aimed at reducing carbon emissions, and incentivizing community participation through its native token.

### Objectives:
1. **Brand Awareness**: Build a globally recognized and trusted brand for the DAO.
2. **Community Growth**: Expand the DAO's community by onboarding individuals passionate about climate action and blockchain technology.
3. **Campaign Execution**: Launch high-impact marketing campaigns on platforms like Twitter, Discord, and YouTube to engage and retain community members.
4. **Partnerships**: Identify and build partnerships with like-minded organizations, NGOs, and influencers.
5. **Content Strategy**: Design educational and engaging content, including infographics, blog posts, videos, and AMAs.

### Instructions:
- Thoroughly analyze the product description and DAO mission.
- Collaborate with the Growth, Product, Treasury, and Operations agents to align marketing strategies with overall goals.
- Create actionable steps for social media growth, community engagement, and brand storytelling.
- Leverage analytics to refine marketing strategies, focusing on measurable KPIs like engagement, conversion rates, and member retention.
- Suggest innovative methods to make the DAO's mission resonate with a broader audience (e.g., gamified incentives, contests, or viral campaigns).
- Ensure every strategy emphasizes transparency, sustainability, and long-term impact.
"""

PRODUCT_AGENT_SYS_PROMPT = """
You are the Product Manager Agent for a DAO focused on decentralized governance for climate action. Your role is to design, manage, and optimize the DAO's product roadmap. This includes defining key features, prioritizing user needs, and ensuring product alignment with the DAO’s mission of reducing carbon emissions and incentivizing community participation.

### Objectives:
1. **User-Centric Design**: Identify the DAO community’s needs and design features to enhance their experience.
2. **Roadmap Prioritization**: Develop a prioritized product roadmap based on community feedback and alignment with climate action goals.
3. **Integration**: Suggest technical solutions and tools for seamless integration with other platforms and blockchains.
4. **Continuous Improvement**: Regularly evaluate product features and recommend optimizations to improve usability, engagement, and adoption.

### Instructions:
- Collaborate with the Marketing and Growth agents to understand user feedback and market trends.
- Engage the Treasury Agent to ensure product development aligns with budget constraints and revenue goals.
- Suggest mechanisms for incentivizing user engagement, such as staking rewards or gamified participation.
- Design systems that emphasize decentralization, transparency, and scalability.
- Provide detailed feature proposals, technical specifications, and timelines for implementation.
- Ensure all features are optimized for both experienced blockchain users and newcomers to Web3.
"""

GROWTH_AGENT_SYS_PROMPT = """
You are the Growth Strategist Agent for a DAO focused on decentralized governance for climate action. Your primary role is to identify and implement growth strategies to increase the DAO’s user base and engagement.

### Objectives:
1. **User Acquisition**: Identify effective strategies to onboard more users to the DAO.
2. **Retention**: Suggest ways to improve community engagement and retain active members.
3. **Data-Driven Insights**: Leverage data analytics to identify growth opportunities and areas of improvement.
4. **Collaborative Growth**: Work with other agents to align growth efforts with marketing, product development, and treasury goals.

### Instructions:
- Collaborate with the Marketing Agent to optimize campaigns for user acquisition.
- Analyze user behavior and suggest actionable insights to improve retention.
- Recommend partnerships with influential figures or organizations to enhance the DAO's visibility.
- Propose growth experiments (A/B testing, new incentives, etc.) and analyze their effectiveness.
- Suggest tools for data collection and analysis, ensuring privacy and transparency.
- Ensure growth strategies align with the DAO's mission of sustainability and climate action.
"""

TREASURY_AGENT_SYS_PROMPT = """
You are the Treasury Management Agent for a DAO focused on decentralized governance for climate action. Your role is to oversee the DAO's financial operations, including budgeting, funding allocation, and financial reporting.

### Objectives:
1. **Financial Transparency**: Maintain clear and detailed reports of the DAO's financial status.
2. **Budget Management**: Allocate funds strategically to align with the DAO's goals and priorities.
3. **Fundraising**: Identify and recommend strategies for fundraising to ensure the DAO's financial sustainability.
4. **Cost Optimization**: Suggest ways to reduce operational costs without sacrificing quality.

### Instructions:
- Collaborate with all other agents to align funding with the DAO's mission and strategic goals.
- Propose innovative fundraising campaigns (e.g., NFT drops, token sales) to generate revenue.
- Analyze financial risks and suggest mitigation strategies.
- Ensure all recommendations prioritize the DAO's mission of reducing carbon emissions and driving global climate action.
- Provide periodic financial updates and propose budget reallocations based on current needs.
"""

OPERATIONS_AGENT_SYS_PROMPT = """
You are the Operations Coordinator Agent for a DAO focused on decentralized governance for climate action. Your role is to ensure smooth day-to-day operations, coordinate workflows, and manage governance processes.

### Objectives:
1. **Workflow Optimization**: Streamline operational processes to maximize efficiency and effectiveness.
2. **Task Coordination**: Manage and delegate tasks to ensure timely delivery of goals.
3. **Governance**: Oversee governance processes, including proposal management and voting mechanisms.
4. **Communication**: Ensure seamless communication between all agents and community members.

### Instructions:
- Collaborate with other agents to align operations with DAO objectives.
- Facilitate communication and task coordination between Marketing, Product, Growth, and Treasury agents.
- Create efficient workflows to handle DAO proposals and governance activities.
- Suggest tools or platforms to improve operational efficiency.
- Provide regular updates on task progress and flag any blockers or risks.
"""

# Initialize agents
marketing_agent = Agent(
    agent_name="Marketing-Agent",
    system_prompt=MARKETING_AGENT_SYS_PROMPT,
    model_name="deepseek/deepseek-reasoner",
    autosave=True,
    dashboard=False,
    verbose=True,
)

product_agent = Agent(
    agent_name="Product-Agent",
    system_prompt=PRODUCT_AGENT_SYS_PROMPT,
    model_name="deepseek/deepseek-reasoner",
    autosave=True,
    dashboard=False,
    verbose=True,
)

growth_agent = Agent(
    agent_name="Growth-Agent",
    system_prompt=GROWTH_AGENT_SYS_PROMPT,
    model_name="deepseek/deepseek-reasoner",
    autosave=True,
    dashboard=False,
    verbose=True,
)

treasury_agent = Agent(
    agent_name="Treasury-Agent",
    system_prompt=TREASURY_AGENT_SYS_PROMPT,
    model_name="deepseek/deepseek-reasoner",
    autosave=True,
    dashboard=False,
    verbose=True,
)

operations_agent = Agent(
    agent_name="Operations-Agent",
    system_prompt=OPERATIONS_AGENT_SYS_PROMPT,
    model_name="deepseek/deepseek-reasoner",
    autosave=True,
    dashboard=False,
    verbose=True,
)

agents = [marketing_agent, product_agent, growth_agent, treasury_agent, operations_agent]


class DAOSwarmRunner:
    """
    A class to manage and run a swarm of agents in a discussion.
    """

    def __init__(self, agents: list, max_loops: int = 5, shared_context: str = "") -> None:
        """
        Initializes the DAO Swarm Runner.

        Args:
            agents (list): A list of agents in the swarm.
            max_loops (int, optional): The maximum number of discussion loops between agents. Defaults to 5.
            shared_context (str, optional): The shared context for all agents to base their discussion on. Defaults to an empty string.
        """
        self.agents = agents
        self.max_loops = max_loops
        self.shared_context = shared_context
        self.discussion_history = []

    def run(self, task: str) -> str:
        """
        Runs the swarm in a random discussion.

        Args:
            task (str): The task or context that agents will discuss.

        Returns:
            str: The final discussion output after all loops.
        """
        print(f"Task: {task}")
        print("Initializing Random Discussion...")
        
        # Initialize the discussion with the shared context
        current_message = f"Task: {task}\nContext: {self.shared_context}"
        self.discussion_history.append(current_message)

        # Run the agents in a randomized discussion
        for loop in range(self.max_loops):
            print(f"\n--- Loop {loop + 1}/{self.max_loops} ---")
            # Choose a random agent
            agent = random.choice(self.agents)
            print(f"Agent {agent.agent_name} is responding...")

            # Run the agent and get a response
            response = agent.run(current_message)
            print(f"Agent {agent.agent_name} says:\n{response}\n")

            # Append the response to the discussion history
            self.discussion_history.append(f"{agent.agent_name}: {response}")

            # Update the current message for the next agent
            current_message = response

        print("\n--- Discussion Complete ---")
        return "\n".join(self.discussion_history)


swarm = DAOSwarmRunner(agents=agents, max_loops=1, shared_context="")

# User input for product description
product_description = """
The DAO is focused on decentralized governance for climate action. 
It funds projects aimed at reducing carbon emissions and incentivizes community participation with a native token.
"""

# Assign a shared context for all agents
swarm.shared_context = product_description

# Run the swarm
task = """
Analyze the product description and create a collaborative strategy for marketing, product, growth, treasury, and operations. Ensure all recommendations align with the DAO's mission of reducing carbon emissions.
"""
output = swarm.run(task)

# Print the swarm output
print("Collaborative Strategy Output:\n", output)

```

--------------------------------------------------

# File: swarms/examples/swarms_of_browser_agents.md

# Swarms x Browser Use

- Import required modules

- Configure your agent first by making a new class

- Set your api keys for your model provider in the `.env` file such as `OPENAI_API_KEY="sk-"`

- Conigure your `ConcurrentWorkflow`

## Install

```bash
pip install swarms browser-use langchain-openai
```
--------


## Main
```python
import asyncio

from browser_use import Agent
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI

from swarms import ConcurrentWorkflow

load_dotenv()


class BrowserAgent:
    def __init__(self, agent_name: str = "BrowserAgent"):
        self.agent_name = agent_name

    async def browser_agent_test(self, task: str):
        agent = Agent(
            task=task,
            llm=ChatOpenAI(model="gpt-4o"),
        )
        result = await agent.run()
        return result

    def run(self, task: str):
        return asyncio.run(self.browser_agent_test(task))


swarm = ConcurrentWorkflow(
    agents=[BrowserAgent() for _ in range(3)],
)

swarm.run(
    """
    Go to pump.fun.
    
    2. Make an account: use email: "test@test.com" and password: "test1234"
    
    3. Make a coin called and give it a cool description and etc. Fill in the form
    
    4. Sit back and watch the coin grow in value.
    
    """
)

```

--------------------------------------------------

# File: swarms/examples/swarms_tools_htx.md

# Swarms Tools Example with HTX + CoinGecko

- `pip3 install swarms swarms-tools`
- Add `OPENAI_API_KEY` to your `.env` file

```python
from swarms import Agent
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from swarms_tools import (
    coin_gecko_coin_api,
    fetch_htx_data,
)


# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    agent_description="Personal finance advisor agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    max_loops=1,
    model_name="gpt-4o",
    dynamic_temperature_enabled=True,
    user_name="swarms_corp",
    return_step_meta=False,
    output_type="str",  # "json", "dict", "csv" OR "string" "yaml" and
    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task
    max_tokens=4000,  # max output tokens
    saved_state_path="agent_00.json",
    interactive=False,
)

agent.run(
    f"Analyze the $swarms token on HTX with data: {fetch_htx_data('swarms')}. Additionally, consider the following CoinGecko data: {coin_gecko_coin_api('swarms')}"
)
```

--------------------------------------------------

# File: swarms/examples/swarms_tools_htx_gecko.md

# Swarms Tools Example with HTX + CoinGecko

- `pip3 install swarms swarms-tools`
- Add `OPENAI_API_KEY` to your `.env` file
- Run `swarms_tools_htx_gecko.py`
- Agent will make a function call to the desired tool
- The tool will be executed and the result will be returned to the agent
- The agent will then analyze the result and return the final output


```python
from swarms import Agent
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from swarms_tools import (
    fetch_stock_news,
    coin_gecko_coin_api,
    fetch_htx_data,
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    agent_description="Personal finance advisor agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    max_loops=1,
    model_name="gpt-4o",
    dynamic_temperature_enabled=True,
    user_name="swarms_corp",
    retry_attempts=3,
    context_length=8192,
    return_step_meta=False,
    output_type="str",  # "json", "dict", "csv" OR "string" "yaml" and
    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task
    max_tokens=4000,  # max output tokens
    saved_state_path="agent_00.json",
    interactive=False,
    tools=[fetch_stock_news, coin_gecko_coin_api, fetch_htx_data],
)

agent.run("Analyze the $swarms token on htx")
```

--------------------------------------------------

# File: swarms/examples/unique_swarms.md


In this section, we present a diverse collection of unique swarms, each with its own distinct characteristics and applications. These examples are designed to illustrate the versatility and potential of swarm intelligence in various domains. By exploring these examples, you can gain a deeper understanding of how swarms can be leveraged to solve complex problems and improve decision-making processes.

# Documentation

## Table of Contents
1. [Common Parameters](#common-parameters)
2. [Basic Swarm Patterns](#basic-swarm-patterns)
3. [Mathematical Swarm Patterns](#mathematical-swarm-patterns)
4. [Advanced Swarm Patterns](#advanced-swarm-patterns)
5. [Communication Patterns](#communication-patterns)
6. [Best Practices](#best-practices)
7. [Common Use Cases](#common-use-cases)

## Common Parameters

All swarm architectures accept these base parameters:

- `agents: AgentListType` - List of Agent objects to participate in the swarm
- `tasks: List[str]` - List of tasks to be processed by the agents
- `return_full_history: bool` (optional) - If True, returns conversation history. Defaults to True

Return types are generally `Union[dict, List[str]]`, where:
- If `return_full_history=True`: Returns a dictionary containing the full conversation history
- If `return_full_history=False`: Returns a list of agent responses

## Basic Swarm Patterns

### Circular Swarm
```python
def circular_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)
```

**Information Flow:**
```mermaid
flowchart LR
    subgraph Circular Flow
    A1((Agent 1)) --> A2((Agent 2))
    A2 --> A3((Agent 3))
    A3 --> A4((Agent 4))
    A4 --> A1
    end
    Task1[Task 1] --> A1
    Task2[Task 2] --> A2
    Task3[Task 3] --> A3
```

**Best Used When:**

- You need continuous processing of tasks

- Tasks need to be processed by every agent in sequence

- You want predictable, ordered task distribution

**Key Features:**

- Tasks move in a circular pattern through all agents

- Each agent processes each task once

- Maintains strict ordering of task processing

### Linear Swarm
```python
def linear_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)
```

**Information Flow:**
```mermaid
flowchart LR
    Input[Task Input] --> A1
    subgraph Sequential Processing
    A1((Agent 1)) --> A2((Agent 2))
    A2 --> A3((Agent 3))
    A3 --> A4((Agent 4))
    A4 --> A5((Agent 5))
    end
    A5 --> Output[Final Result]
```

**Best Used When:**

- Tasks need sequential, pipeline-style processing

- Each agent performs a specific transformation step

- Order of processing is critical

### Star Swarm
```python
def star_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)
```

**Information Flow:**
```mermaid
flowchart TD
    subgraph Star Pattern
    A1((Central Agent))
    A2((Agent 2))
    A3((Agent 3))
    A4((Agent 4))
    A5((Agent 5))
    A1 --> A2
    A1 --> A3
    A1 --> A4
    A1 --> A5
    end
    Task[Initial Task] --> A1
    A2 --> Result2[Result 2]
    A3 --> Result3[Result 3]
    A4 --> Result4[Result 4]
    A5 --> Result5[Result 5]
```

**Best Used When:**

- You need centralized control

- Tasks require coordination or oversight

- You want to maintain a single point of task distribution

### Mesh Swarm
```python
def mesh_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)
```

**Information Flow:**
```mermaid
flowchart TD
    subgraph Mesh Network
    A1((Agent 1)) <--> A2((Agent 2))
    A2 <--> A3((Agent 3))
    A1 <--> A4((Agent 4))
    A2 <--> A5((Agent 5))
    A3 <--> A6((Agent 6))
    A4 <--> A5
    A5 <--> A6
    end
    Tasks[Task Pool] --> A1
    Tasks --> A2
    Tasks --> A3
    Tasks --> A4
    Tasks --> A5
    Tasks --> A6
```

**Best Used When:**

- You need maximum flexibility

- Task processing order isn't critical

- You want fault tolerance

## Mathematical Swarm Patterns

### Fibonacci Swarm
```python
def fibonacci_swarm(agents: AgentListType, tasks: List[str])
```

**Information Flow:**
```mermaid
flowchart TD
    subgraph Fibonacci Pattern
    L1[Level 1: 1 Agent] --> L2[Level 2: 1 Agent]
    L2 --> L3[Level 3: 2 Agents]
    L3 --> L4[Level 4: 3 Agents]
    L4 --> L5[Level 5: 5 Agents]
    end
    Task[Initial Task] --> L1
    L5 --> Results[Processed Results]
```

**Best Used When:**

- You need natural scaling patterns

- Tasks have increasing complexity

- You want organic growth in processing capacity

### Pyramid Swarm
```python
def pyramid_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)
```

**Information Flow:**
```mermaid
flowchart TD
    subgraph Pyramid Structure
    A1((Leader Agent))
    A2((Manager 1))
    A3((Manager 2))
    A4((Worker 1))
    A5((Worker 2))
    A6((Worker 3))
    A7((Worker 4))
    A1 --> A2
    A1 --> A3
    A2 --> A4
    A2 --> A5
    A3 --> A6
    A3 --> A7
    end
    Task[Complex Task] --> A1
    A4 --> Result1[Output 1]
    A5 --> Result2[Output 2]
    A6 --> Result3[Output 3]
    A7 --> Result4[Output 4]
```

**Best Used When:**

- You need hierarchical task processing

- Tasks require multiple levels of oversight

- You want organized task delegation

### Grid Swarm
```python
def grid_swarm(agents: AgentListType, tasks: List[str])
```

**Information Flow:**
```mermaid
flowchart TD
    subgraph Grid Layout
    A1((1)) <--> A2((2)) <--> A3((3))
    A4((4)) <--> A5((5)) <--> A6((6))
    A7((7)) <--> A8((8)) <--> A9((9))
    A1 <--> A4 <--> A7
    A2 <--> A5 <--> A8
    A3 <--> A6 <--> A9
    end
    Tasks[Task Queue] --> A1
    Tasks --> A5
    Tasks --> A9
```

**Best Used When:**

- Tasks have spatial relationships

- You need neighbor-based processing

- You want structured parallel processing

## Communication Patterns

### One-to-One Communication
```python
def one_to_one(sender: Agent, receiver: Agent, task: str, max_loops: int = 1) -> str
```

**Information Flow:**
```mermaid
flowchart LR
    Task[Task] --> S((Sender))
    S --> R((Receiver))
    R --> Result[Result]
```

**Best Used When:**

- Direct agent communication is needed

- Tasks require back-and-forth interaction

- You need controlled message exchange

### Broadcast Communication
```python
async def broadcast(sender: Agent, agents: AgentListType, task: str) -> None
```

**Information Flow:**
```mermaid
flowchart TD
    T[Task] --> S((Sender))
    S --> A1((Agent 1))
    S --> A2((Agent 2))
    S --> A3((Agent 3))
    S --> A4((Agent 4))
```

**Best Used When:**

- Information needs to reach all agents

- Tasks require global coordination

- You need system-wide updates

## Best Practices

1. **Choose the Right Pattern:**
   - Consider your task's natural structure
   - Think about scaling requirements
   - Consider fault tolerance needs

2. **Performance Considerations:**
   - More complex patterns have higher overhead
   - Consider communication costs
   - Match pattern to available resources

3. **Error Handling:**
   - All patterns include basic error checking
   - Consider adding additional error handling for production
   - Monitor agent performance and task completion

4. **Scaling:**
   - Different patterns scale differently
   - Consider future growth needs
   - Test with expected maximum load

## Common Use Cases

1. **Data Processing Pipelines**
   - Linear Swarm
   - Circular Swarm

2. **Distributed Computing**
   - Mesh Swarm
   - Grid Swarm

3. **Hierarchical Systems**
   - Pyramid Swarm
   - Star Swarm

4. **Dynamic Workloads**
   - Exponential Swarm
   - Fibonacci Swarm

5. **Conflict-Free Processing**
   - Prime Swarm
   - Harmonic Swarm


```python
import asyncio
from typing import List

from swarms.structs.agent import Agent
from swarms.structs.swarming_architectures import (
    broadcast,
    circular_swarm,
    exponential_swarm,
    fibonacci_swarm,
    grid_swarm,
    linear_swarm,
    mesh_swarm,
    one_to_three,
    prime_swarm,
    sigmoid_swarm,
    sinusoidal_swarm,
    staircase_swarm,
    star_swarm,
)


def create_finance_agents() -> List[Agent]:
    """Create specialized finance agents"""
    return [
        Agent(
            agent_name="MarketAnalyst",
            system_prompt="You are a market analysis expert. Analyze market trends and provide insights.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="RiskManager",
            system_prompt="You are a risk management specialist. Evaluate risks and provide mitigation strategies.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="PortfolioManager",
            system_prompt="You are a portfolio management expert. Optimize investment portfolios and asset allocation.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="ComplianceOfficer",
            system_prompt="You are a financial compliance expert. Ensure regulatory compliance and identify issues.",
            model_name="gpt-4o-mini"
        )
    ]

def create_healthcare_agents() -> List[Agent]:
    """Create specialized healthcare agents"""
    return [
        Agent(
            agent_name="Diagnostician",
            system_prompt="You are a medical diagnostician. Analyze symptoms and suggest potential diagnoses.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="Treatment_Planner",
            system_prompt="You are a treatment planning specialist. Develop comprehensive treatment plans.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="MedicalResearcher",
            system_prompt="You are a medical researcher. Analyze latest research and provide evidence-based recommendations.",
            model_name="gpt-4o-mini"
        ),
        Agent(
            agent_name="PatientCareCoordinator",
            system_prompt="You are a patient care coordinator. Manage patient care workflow and coordination.",
            model_name="gpt-4o-mini"
        )
    ]

def print_separator():
    print("\n" + "="*50 + "\n")

def run_finance_circular_swarm():
    """Investment analysis workflow using circular swarm"""
    print_separator()
    print("FINANCE - INVESTMENT ANALYSIS (Circular Swarm)")
    
    agents = create_finance_agents()
    tasks = [
        "Analyze Tesla stock performance for Q4 2024",
        "Assess market risks and potential hedging strategies",
        "Recommend portfolio adjustments based on analysis"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
    
    result = circular_swarm(agents, tasks)
    print("\nResults:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Task: {log['task']}")
        print(f"Response: {log['response']}")

def run_healthcare_grid_swarm():
    """Patient diagnosis and treatment planning using grid swarm"""
    print_separator()
    print("HEALTHCARE - PATIENT DIAGNOSIS (Grid Swarm)")
    
    agents = create_healthcare_agents()
    tasks = [
        "Review patient symptoms: fever, fatigue, joint pain",
        "Research latest treatment protocols",
        "Develop preliminary treatment plan",
        "Coordinate with specialists"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
        
    result = grid_swarm(agents, tasks)
    print("\nGrid swarm processing completed")
    print(result)

def run_finance_linear_swarm():
    """Loan approval process using linear swarm"""
    print_separator()
    print("FINANCE - LOAN APPROVAL PROCESS (Linear Swarm)")
    
    agents = create_finance_agents()[:3]
    tasks = [
        "Review loan application and credit history",
        "Assess risk factors and compliance requirements",
        "Generate final loan recommendation"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
    
    result = linear_swarm(agents, tasks)
    print("\nResults:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Task: {log['task']}")
        print(f"Response: {log['response']}")

def run_healthcare_star_swarm():
    """Complex medical case management using star swarm"""
    print_separator()
    print("HEALTHCARE - COMPLEX CASE MANAGEMENT (Star Swarm)")
    
    agents = create_healthcare_agents()
    tasks = [
        "Complex case: Patient with multiple chronic conditions",
        "Develop integrated care plan"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
    
    result = star_swarm(agents, tasks)
    print("\nResults:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Task: {log['task']}")
        print(f"Response: {log['response']}")

def run_finance_mesh_swarm():
    """Market risk assessment using mesh swarm"""
    print_separator()
    print("FINANCE - MARKET RISK ASSESSMENT (Mesh Swarm)")
    
    agents = create_finance_agents()
    tasks = [
        "Analyze global market conditions",
        "Assess currency exchange risks",
        "Evaluate sector-specific risks",
        "Review portfolio exposure"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
    
    result = mesh_swarm(agents, tasks)
    print("\nResults:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Task: {log['task']}")
        print(f"Response: {log['response']}")

def run_mathematical_finance_swarms():
    """Complex financial analysis using mathematical swarms"""
    print_separator()
    print("FINANCE - MARKET PATTERN ANALYSIS")
    
    agents = create_finance_agents()
    tasks = [
        "Analyze historical market patterns",
        "Predict market trends using technical analysis",
        "Identify potential arbitrage opportunities"
    ]
    
    print("\nTasks:")
    for i, task in enumerate(tasks, 1):
        print(f"{i}. {task}")
    
    print("\nFibonacci Swarm Results:")
    result = fibonacci_swarm(agents, tasks.copy())
    print(result)
    
    print("\nPrime Swarm Results:")
    result = prime_swarm(agents, tasks.copy())
    print(result)
    
    print("\nExponential Swarm Results:")
    result = exponential_swarm(agents, tasks.copy())
    print(result)

def run_healthcare_pattern_swarms():
    """Patient monitoring using pattern swarms"""
    print_separator()
    print("HEALTHCARE - PATIENT MONITORING PATTERNS")
    
    agents = create_healthcare_agents()
    task = "Monitor and analyze patient vital signs: BP, heart rate, temperature, O2 saturation"
    
    print(f"\nTask: {task}")
    
    print("\nStaircase Pattern Analysis:")
    result = staircase_swarm(agents, task)
    print(result)
    
    print("\nSigmoid Pattern Analysis:")
    result = sigmoid_swarm(agents, task)
    print(result)
    
    print("\nSinusoidal Pattern Analysis:")
    result = sinusoidal_swarm(agents, task)
    print(result)

async def run_communication_examples():
    """Communication patterns for emergency scenarios"""
    print_separator()
    print("EMERGENCY COMMUNICATION PATTERNS")
    
    # Finance market alert
    finance_sender = create_finance_agents()[0]
    finance_receivers = create_finance_agents()[1:]
    market_alert = "URGENT: Major market volatility detected - immediate risk assessment required"
    
    print("\nFinance Market Alert:")
    print(f"Alert: {market_alert}")
    result = await broadcast(finance_sender, finance_receivers, market_alert)
    print("\nBroadcast Results:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Response: {log['response']}")
    
    # Healthcare emergency
    health_sender = create_healthcare_agents()[0]
    health_receivers = create_healthcare_agents()[1:4]
    emergency_case = "EMERGENCY: Trauma patient with multiple injuries - immediate consultation required"
    
    print("\nHealthcare Emergency:")
    print(f"Case: {emergency_case}")
    result = await one_to_three(health_sender, health_receivers, emergency_case)
    print("\nConsultation Results:")
    for log in result['history']:
        print(f"\n{log['agent_name']}:")
        print(f"Response: {log['response']}")

async def run_all_examples():
    """Execute all swarm examples"""
    print("\n=== SWARM ARCHITECTURE EXAMPLES ===\n")
    
    # Finance examples
    run_finance_circular_swarm()
    run_finance_linear_swarm()
    run_finance_mesh_swarm()
    run_mathematical_finance_swarms()
    
    # Healthcare examples
    run_healthcare_grid_swarm()
    run_healthcare_star_swarm()
    run_healthcare_pattern_swarms()
    
    # Communication examples
    await run_communication_examples()
    
    print("\n=== ALL EXAMPLES COMPLETED ===")

if __name__ == "__main__":
    asyncio.run(run_all_examples())
```

--------------------------------------------------

# File: swarms/examples/vllm.md

# VLLM Swarm Agents

!!! tip "Quick Summary"
    This guide demonstrates how to create a sophisticated multi-agent system using VLLM and Swarms for comprehensive stock market analysis. You'll learn how to configure and orchestrate multiple AI agents working together to provide deep market insights.

## Overview

The example showcases how to build a stock analysis system with 5 specialized agents:

- Technical Analysis Agent
- Fundamental Analysis Agent  
- Market Sentiment Agent
- Quantitative Strategy Agent
- Portfolio Strategy Agent

Each agent has specific expertise and works collaboratively through a concurrent workflow.

## Prerequisites

!!! warning "Requirements"
    Before starting, ensure you have:

    - Python 3.7 or higher
    - The Swarms package installed
    - Access to VLLM compatible models
    - Sufficient compute resources for running VLLM

## Installation

!!! example "Setup Steps"

    1. Install the Swarms package:
    ```bash
    pip install swarms
    ```

    2. Install VLLM dependencies (if not already installed):
    ```bash
    pip install vllm
    ```

## Basic Usage

Here's a complete example of setting up the stock analysis swarm:

```python
from swarms import Agent, ConcurrentWorkflow
from swarms.utils.vllm_wrapper import VLLMWrapper

# Initialize the VLLM wrapper
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-7b-chat-hf",
    system_prompt="You are a helpful assistant.",
)
```

!!! note "Model Selection"
    The example uses Llama-2-7b-chat, but you can use any VLLM-compatible model. Make sure you have the necessary permissions and resources to run your chosen model.

## Agent Configuration

### Technical Analysis Agent

```python
technical_analyst = Agent(
    agent_name="Technical-Analysis-Agent",
    agent_description="Expert in technical analysis and chart patterns",
    system_prompt="""You are an expert Technical Analysis Agent specializing in market technicals and chart patterns. Your responsibilities include:

1. PRICE ACTION ANALYSIS
- Identify key support and resistance levels
- Analyze price trends and momentum
- Detect chart patterns (e.g., head & shoulders, triangles, flags)
- Evaluate volume patterns and their implications

2. TECHNICAL INDICATORS
- Calculate and interpret moving averages (SMA, EMA)
- Analyze momentum indicators (RSI, MACD, Stochastic)
- Evaluate volume indicators (OBV, Volume Profile)
- Monitor volatility indicators (Bollinger Bands, ATR)

3. TRADING SIGNALS
- Generate clear buy/sell signals based on technical criteria
- Identify potential entry and exit points
- Set appropriate stop-loss and take-profit levels
- Calculate position sizing recommendations

4. RISK MANAGEMENT
- Assess market volatility and trend strength
- Identify potential reversal points
- Calculate risk/reward ratios for trades
- Suggest position sizing based on risk parameters

Your analysis should be data-driven, precise, and actionable. Always include specific price levels, time frames, and risk parameters in your recommendations.""",
    max_loops=1,
    llm=vllm,
)
```

!!! tip "Agent Customization"
    Each agent can be customized with different:
    
    - System prompts
    
    - Temperature settings
    
    - Max token limits
    
    - Response formats

## Running the Swarm

To execute the swarm analysis:

```python
swarm = ConcurrentWorkflow(
    name="Stock-Analysis-Swarm",
    description="A swarm of agents that analyze stocks and provide comprehensive analysis.",
    agents=stock_analysis_agents,
)

# Run the analysis
response = swarm.run("Analyze the best etfs for gold and other similar commodities in volatile markets")
```



## Full Code Example

```python
from swarms import Agent, ConcurrentWorkflow
from swarms.utils.vllm_wrapper import VLLMWrapper

# Initialize the VLLM wrapper
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-7b-chat-hf",
    system_prompt="You are a helpful assistant.",
)

# Technical Analysis Agent
technical_analyst = Agent(
    agent_name="Technical-Analysis-Agent",
    agent_description="Expert in technical analysis and chart patterns",
    system_prompt="""You are an expert Technical Analysis Agent specializing in market technicals and chart patterns. Your responsibilities include:

1. PRICE ACTION ANALYSIS
- Identify key support and resistance levels
- Analyze price trends and momentum
- Detect chart patterns (e.g., head & shoulders, triangles, flags)
- Evaluate volume patterns and their implications

2. TECHNICAL INDICATORS
- Calculate and interpret moving averages (SMA, EMA)
- Analyze momentum indicators (RSI, MACD, Stochastic)
- Evaluate volume indicators (OBV, Volume Profile)
- Monitor volatility indicators (Bollinger Bands, ATR)

3. TRADING SIGNALS
- Generate clear buy/sell signals based on technical criteria
- Identify potential entry and exit points
- Set appropriate stop-loss and take-profit levels
- Calculate position sizing recommendations

4. RISK MANAGEMENT
- Assess market volatility and trend strength
- Identify potential reversal points
- Calculate risk/reward ratios for trades
- Suggest position sizing based on risk parameters

Your analysis should be data-driven, precise, and actionable. Always include specific price levels, time frames, and risk parameters in your recommendations.""",
    max_loops=1,
    llm=vllm,
)

# Fundamental Analysis Agent
fundamental_analyst = Agent(
    agent_name="Fundamental-Analysis-Agent",
    agent_description="Expert in company fundamentals and valuation",
    system_prompt="""You are an expert Fundamental Analysis Agent specializing in company valuation and financial metrics. Your core responsibilities include:

1. FINANCIAL STATEMENT ANALYSIS
- Analyze income statements, balance sheets, and cash flow statements
- Calculate and interpret key financial ratios
- Evaluate revenue growth and profit margins
- Assess company's debt levels and cash position

2. VALUATION METRICS
- Calculate fair value using multiple valuation methods:
  * Discounted Cash Flow (DCF)
  * Price-to-Earnings (P/E)
  * Price-to-Book (P/B)
  * Enterprise Value/EBITDA
- Compare valuations against industry peers

3. BUSINESS MODEL ASSESSMENT
- Evaluate competitive advantages and market position
- Analyze industry dynamics and market share
- Assess management quality and corporate governance
- Identify potential risks and growth opportunities

4. ECONOMIC CONTEXT
- Consider macroeconomic factors affecting the company
- Analyze industry cycles and trends
- Evaluate regulatory environment and compliance
- Assess global market conditions

Your analysis should be comprehensive, focusing on both quantitative metrics and qualitative factors that impact long-term value.""",
    max_loops=1,
    llm=vllm,
)

# Market Sentiment Agent
sentiment_analyst = Agent(
    agent_name="Market-Sentiment-Agent",
    agent_description="Expert in market psychology and sentiment analysis",
    system_prompt="""You are an expert Market Sentiment Agent specializing in analyzing market psychology and investor behavior. Your key responsibilities include:

1. SENTIMENT INDICATORS
- Monitor and interpret market sentiment indicators:
  * VIX (Fear Index)
  * Put/Call Ratio
  * Market Breadth
  * Investor Surveys
- Track institutional vs retail investor behavior

2. NEWS AND SOCIAL MEDIA ANALYSIS
- Analyze news flow and media sentiment
- Monitor social media trends and discussions
- Track analyst recommendations and changes
- Evaluate corporate insider trading patterns

3. MARKET POSITIONING
- Assess hedge fund positioning and exposure
- Monitor short interest and short squeeze potential
- Track fund flows and asset allocation trends
- Analyze options market sentiment

4. CONTRARIAN SIGNALS
- Identify extreme sentiment readings
- Detect potential market turning points
- Analyze historical sentiment patterns
- Provide contrarian trading opportunities

Your analysis should combine quantitative sentiment metrics with qualitative assessment of market psychology and crowd behavior.""",
    max_loops=1,
    llm=vllm,
)

# Quantitative Strategy Agent
quant_analyst = Agent(
    agent_name="Quantitative-Strategy-Agent",
    agent_description="Expert in quantitative analysis and algorithmic strategies",
    system_prompt="""You are an expert Quantitative Strategy Agent specializing in data-driven investment strategies. Your primary responsibilities include:

1. FACTOR ANALYSIS
- Analyze and monitor factor performance:
  * Value
  * Momentum
  * Quality
  * Size
  * Low Volatility
- Calculate factor exposures and correlations

2. STATISTICAL ANALYSIS
- Perform statistical arbitrage analysis
- Calculate and monitor pair trading opportunities
- Analyze market anomalies and inefficiencies
- Develop mean reversion strategies

3. RISK MODELING
- Build and maintain risk models
- Calculate portfolio optimization metrics
- Monitor correlation matrices
- Analyze tail risk and stress scenarios

4. ALGORITHMIC STRATEGIES
- Develop systematic trading strategies
- Backtest and validate trading algorithms
- Monitor strategy performance metrics
- Optimize execution algorithms

Your analysis should be purely quantitative, based on statistical evidence and mathematical models rather than subjective opinions.""",
    max_loops=1,
    llm=vllm,
)

# Portfolio Strategy Agent
portfolio_strategist = Agent(
    agent_name="Portfolio-Strategy-Agent",
    agent_description="Expert in portfolio management and asset allocation",
    system_prompt="""You are an expert Portfolio Strategy Agent specializing in portfolio construction and management. Your core responsibilities include:

1. ASSET ALLOCATION
- Develop strategic asset allocation frameworks
- Recommend tactical asset allocation shifts
- Optimize portfolio weightings
- Balance risk and return objectives

2. PORTFOLIO ANALYSIS
- Calculate portfolio risk metrics
- Monitor sector and factor exposures
- Analyze portfolio correlation matrix
- Track performance attribution

3. RISK MANAGEMENT
- Implement portfolio hedging strategies
- Monitor and adjust position sizing
- Set stop-loss and rebalancing rules
- Develop drawdown protection strategies

4. PORTFOLIO OPTIMIZATION
- Calculate efficient frontier analysis
- Optimize for various objectives:
  * Maximum Sharpe Ratio
  * Minimum Volatility
  * Maximum Diversification
- Consider transaction costs and taxes

Your recommendations should focus on portfolio-level decisions that optimize risk-adjusted returns while meeting specific investment objectives.""",
    max_loops=1,
    llm=vllm,
)

# Create a list of all agents
stock_analysis_agents = [
    technical_analyst,
    fundamental_analyst,
    sentiment_analyst,
    quant_analyst,
    portfolio_strategist
]

swarm = ConcurrentWorkflow(
    name="Stock-Analysis-Swarm",
    description="A swarm of agents that analyze stocks and provide a comprehensive analysis of the current trends and opportunities.",
    agents=stock_analysis_agents,
)

swarm.run("Analyze the best etfs for gold and other similiar commodities in volatile markets")
```

## Best Practices

!!! success "Optimization Tips"
    1. **Agent Design**
        - Keep system prompts focused and specific
        
        - Use clear role definitions
        
        - Include error handling guidelines
    
    2. **Resource Management**
        
        - Monitor memory usage with large models
        
        - Implement proper cleanup procedures
        
        - Use batching for multiple queries
    
    3. **Output Handling**
        
        - Implement proper logging
        
        - Format outputs consistently
        
        - Include error checking

## Common Issues and Solutions

!!! warning "Troubleshooting"
    Common issues you might encounter:

    1. **Memory Issues**
        
        - *Problem*: VLLM consuming too much memory
        
        - *Solution*: Adjust batch sizes and model parameters
    
    2. **Agent Coordination**
        
        - *Problem*: Agents providing conflicting information
        
        - *Solution*: Implement consensus mechanisms or priority rules
    
    3. **Performance**
        
        - *Problem*: Slow response times
        
        - *Solution*: Use proper batching and optimize model loading

## FAQ

??? question "Can I use different models for different agents?"
    Yes, you can initialize multiple VLLM wrappers with different models for each agent. However, be mindful of memory usage.

??? question "How many agents can run concurrently?"
    The number depends on your hardware resources. Start with 3-5 agents and scale based on performance.

??? question "Can I customize agent communication patterns?"
    Yes, you can modify the ConcurrentWorkflow class or create custom workflows for specific communication patterns.

## Advanced Configuration

!!! example "Extended Settings"
    ```python
    vllm = VLLMWrapper(
        model_name="meta-llama/Llama-2-7b-chat-hf",
        system_prompt="You are a helpful assistant.",
        temperature=0.7,
        max_tokens=2048,
        top_p=0.95,
    )
    ```

## Contributing

!!! info "Get Involved"
    We welcome contributions! Here's how you can help:

    1. Report bugs and issues
    2. Submit feature requests
    3. Contribute to documentation
    4. Share example use cases

## Resources

!!! abstract "Additional Reading"
    - [VLLM Documentation](https://docs.vllm.ai/en/latest/)
    

--------------------------------------------------

# File: swarms/examples/vllm_integration.md



# vLLM Integration Guide

!!! info "Overview"
    vLLM is a high-performance and easy-to-use library for LLM inference and serving. This guide explains how to integrate vLLM with Swarms for efficient, production-grade language model deployment.


## Installation

!!! note "Prerequisites"
    Before you begin, make sure you have Python 3.8+ installed on your system.

=== "pip"
    ```bash
    pip install -U vllm swarms
    ```

=== "poetry"
    ```bash
    poetry add vllm swarms
    ```

## Basic Usage

Here's a simple example of how to use vLLM with Swarms:

```python title="basic_usage.py"
from swarms.utils.vllm_wrapper import VLLMWrapper

# Initialize the vLLM wrapper
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-7b-chat-hf",
    system_prompt="You are a helpful assistant.",
    temperature=0.7,
    max_tokens=4000
)

# Run inference
response = vllm.run("What is the capital of France?")
print(response)
```

## VLLMWrapper Class

!!! abstract "Class Overview"
    The `VLLMWrapper` class provides a convenient interface for working with vLLM models.

### Key Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `model_name` | str | Name of the model to use | "meta-llama/Llama-2-7b-chat-hf" |
| `system_prompt` | str | System prompt to use | None |
| `stream` | bool | Whether to stream the output | False |
| `temperature` | float | Sampling temperature | 0.5 |
| `max_tokens` | int | Maximum number of tokens to generate | 4000 |

### Example with Custom Parameters

```python title="custom_parameters.py"
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-13b-chat-hf",
    system_prompt="You are an expert in artificial intelligence.",
    temperature=0.8,
    max_tokens=2000
)
```

## Integration with Agents

You can easily integrate vLLM with Swarms agents for more complex workflows:

```python title="agent_integration.py"
from swarms import Agent
from swarms.utils.vllm_wrapper import VLLMWrapper

# Initialize vLLM
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-7b-chat-hf",
    system_prompt="You are a helpful assistant."
)

# Create an agent with vLLM
agent = Agent(
    agent_name="Research-Agent",
    agent_description="Expert in conducting research and analysis",
    system_prompt="""You are an expert research agent. Your tasks include:
    1. Analyzing complex topics
    2. Providing detailed summaries
    3. Making data-driven recommendations""",
    llm=vllm,
    max_loops=1
)

# Run the agent
response = agent.run("Research the impact of AI on healthcare")
```

## Advanced Features

### Batch Processing

!!! tip "Performance Optimization"
    Use batch processing for efficient handling of multiple tasks simultaneously.

```python title="batch_processing.py"
tasks = [
    "What is machine learning?",
    "Explain neural networks",
    "Describe deep learning"
]

results = vllm.batched_run(tasks, batch_size=3)
```

### Error Handling

!!! warning "Error Management"
    Always implement proper error handling in production environments.

```python title="error_handling.py"
from loguru import logger

try:
    response = vllm.run("Complex task")
except Exception as error:
    logger.error(f"Error occurred: {error}")
```

## Best Practices

!!! success "Recommended Practices"
    === "Model Selection"
        - Choose appropriate model sizes based on your requirements
        - Consider the trade-off between model size and inference speed

    === "System Resources"
        - Ensure sufficient GPU memory for your chosen model
        - Monitor resource usage during batch processing

    === "Prompt Engineering"
        - Use clear and specific system prompts
        - Structure user prompts for optimal results

    === "Error Handling"
        - Implement proper error handling and logging
        - Set up monitoring for production deployments

    === "Performance"
        - Use batch processing for multiple tasks
        - Adjust max_tokens based on your use case
        - Fine-tune temperature for optimal output quality

## Example: Multi-Agent System

Here's an example of creating a multi-agent system using vLLM:

```python title="multi_agent_system.py"
from swarms import Agent, ConcurrentWorkflow
from swarms.utils.vllm_wrapper import VLLMWrapper

# Initialize vLLM
vllm = VLLMWrapper(
    model_name="meta-llama/Llama-2-7b-chat-hf",
    system_prompt="You are a helpful assistant."
)

# Create specialized agents
research_agent = Agent(
    agent_name="Research-Agent",
    agent_description="Expert in research",
    system_prompt="You are a research expert.",
    llm=vllm
)

analysis_agent = Agent(
    agent_name="Analysis-Agent",
    agent_description="Expert in analysis",
    system_prompt="You are an analysis expert.",
    llm=vllm
)

# Create a workflow
agents = [research_agent, analysis_agent]
workflow = ConcurrentWorkflow(
    name="Research-Analysis-Workflow",
    description="Comprehensive research and analysis workflow",
    agents=agents
)

# Run the workflow
result = workflow.run("Analyze the impact of renewable energy")
```

--------------------------------------------------

# File: swarms/examples/xai.md

# Agent with XAI

- Add your `XAI_API_KEY` in the `.env` file

- Select your model_name like `xai/grok-beta` follows [LiteLLM conventions](https://docs.litellm.ai/docs/providers/xai)

- Execute your agent!


```python
from swarms import Agent
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    model_name="xai/grok-beta",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

--------------------------------------------------

# File: swarms/examples/yahoo_finance.md

# Swarms Tools Example with Yahoo Finance

- `pip3 install swarms swarms-tools`
- Add `OPENAI_API_KEY` to your `.env` file
- Run `yahoo_finance_agent.py`
- Agent will make a function call to the desired tool
- The tool will be executed and the result will be returned to the agent
- The agent will then analyze the result and return the final output


```python
from swarms import Agent
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from swarms_tools import (
    yahoo_finance_api,
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    agent_description="Personal finance advisor agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    max_loops=1,
    model_name="gpt-4o",
    dynamic_temperature_enabled=True,
    user_name="swarms_corp",
    retry_attempts=3,
    context_length=8192,
    return_step_meta=False,
    output_type="str",  # "json", "dict", "csv" OR "string" "yaml" and
    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task
    max_tokens=4000,  # max output tokens
    saved_state_path="agent_00.json",
    interactive=False,
    tools=[yahoo_finance_api],
)

agent.run("Analyze the latest metrics for nvidia")
# Less than 30 lines of code....
```

--------------------------------------------------

# File: swarms/framework/agents_explained.md

# An Analysis of Agents

In the Swarms framework, agents are designed to perform tasks autonomously by leveraging large language models (LLMs), various tools, and long-term memory systems. This guide provides an extensive conceptual walkthrough of how an agent operates, detailing the sequence of actions it takes to complete a task and how it utilizes its internal components.

#### Agent Components Overview
- **LLM (Large Language Model)**: The core component responsible for understanding and generating natural language.
- **Tools**: External functions and services that the agent can call to perform specific tasks, such as querying databases or interacting with APIs.
- **Long-term Memory**: Systems like ChromaDB or Pinecone that store and retrieve information over extended periods, enabling the agent to remember past interactions and contexts.

#### Agent Workflow
The workflow of an agent can be divided into several stages: task initiation, initial LLM processing, tool usage, memory interaction, and final LLM processing.

##### Stage 1: Task Initiation
- **Input**: The task or query that the agent needs to address.
- **Output**: A structured plan or approach for handling the task.

##### Stage 2: Initial LLM Processing
- **Input**: The task or query.
- **Process**: The LLM interprets the task, understanding the context and requirements.
- **Output**: An initial response or action plan.

##### Stage 3: Tool Usage
- **Input**: The action plan or specific sub-tasks identified by the LLM.
- **Process**: The agent calls various tools to gather information, perform calculations, or interact with external systems.
  - **Function Calling as Tools**: Tools are called as functions with specific inputs and outputs, enabling the agent to perform a wide range of tasks.
- **Output**: Data or results from the tools.

##### Stage 4: Memory Interaction
- **Input**: Intermediate results and context from the tools.
- **Process**: The agent interacts with long-term memory systems to store new information and retrieve relevant past data.
  - **RAG Systems (ChromaDB, Pinecone)**: These systems are used to enhance the agent’s responses by providing relevant historical data and context.
- **Output**: Enhanced context and data for final processing.

##### Stage 5: Final LLM Processing
- **Input**: Comprehensive data and context from the tools and memory systems.
- **Process**: The LLM generates the final response or completes the task using the enriched data.
- **Output**: The final output or action taken by the agent.

### Detailed Workflow with Mermaid Diagrams

#### Agent Components and Workflow

```mermaid
graph TD
    A[Task Initiation] -->|Receives Task| B[Initial LLM Processing]
    B -->|Interprets Task| C[Tool Usage]
    C -->|Calls Tools| D[Function 1]
    C -->|Calls Tools| E[Function 2]
    D -->|Returns Data| C
    E -->|Returns Data| C
    C -->|Provides Data| F[Memory Interaction]
    F -->|Stores and Retrieves Data| G[RAG System]
    G -->|ChromaDB/Pinecone| H[Enhanced Data]
    F -->|Provides Enhanced Data| I[Final LLM Processing]
    I -->|Generates Final Response| J[Output]
```

### Explanation of Each Stage

#### Stage 1: Task Initiation
- **Task**: The agent receives a task or query from an external source (e.g., a user query, a system trigger).
- **Objective**: To understand what needs to be done and prepare an initial approach.

#### Stage 2: Initial LLM Processing
- **Interpretation**: The LLM processes the task to comprehend its context and requirements.
- **Planning**: The LLM generates an initial plan or identifies the sub-tasks required to complete the task.

#### Stage 3: Tool Usage
- **Function Calls**: The agent uses predefined functions (tools) to perform specific actions, such as querying a database or making API calls.
- **Tool Integration**: Each tool is called with specific parameters, and the results are collected for further processing.

#### Stage 4: Memory Interaction
- **Long-term Memory**: Systems like ChromaDB and Pinecone store and retrieve long-term data, providing the agent with historical context and past interactions.
- **Retrieval-Augmented Generation (RAG)**: The agent uses RAG systems to enhance the current context with relevant past data, improving the quality and relevance of the final output.

#### Stage 5: Final LLM Processing
- **Enhanced Processing**: The LLM processes the enriched data and context provided by the tools and memory systems.
- **Final Output**: The LLM generates a comprehensive response or completes the task using the enhanced information.

### Conclusion

The Swarms framework's agents are powerful units that combine LLMs, tools, and long-term memory systems to perform complex tasks efficiently. By leveraging function calling for tools and RAG systems like ChromaDB and Pinecone, agents can enhance their capabilities and deliver highly relevant and accurate results. This conceptual guide and walkthrough provide a detailed understanding of how agents operate within the Swarms framework, enabling the development of sophisticated and collaborative AI systems.

--------------------------------------------------

# File: swarms/framework/code_cleanliness.md

# Code Cleanliness in Python: A Comprehensive Guide

Code cleanliness is an essential aspect of software development that ensures code is easy to read, understand, and maintain. Clean code leads to fewer bugs, easier debugging, and more efficient collaboration among developers. This blog article delves into the principles of writing clean Python code, emphasizing the use of type annotations, docstrings, and the Loguru logging library. We'll explore the importance of each component and provide practical examples to illustrate best practices.

## Table of Contents
1. Introduction to Code Cleanliness
2. Importance of Type Annotations
3. Writing Effective Docstrings
4. Structuring Your Code
5. Error Handling and Logging with Loguru
6. Refactoring for Clean Code
7. Examples of Clean Code
8. Conclusion

## 1. Introduction to Code Cleanliness

Code cleanliness refers to the practice of writing code that is easy to read, understand, and maintain. Clean code follows consistent conventions and is organized logically, making it easier for developers to collaborate and for new team members to get up to speed quickly.

### Why Clean Code Matters

1. **Readability**: Clean code is easy to read and understand, which reduces the time needed to grasp what the code does.
2. **Maintainability**: Clean code is easier to maintain and modify, reducing the risk of introducing bugs when making changes.
3. **Collaboration**: Clean code facilitates collaboration among team members, as everyone can easily understand and follow the codebase.
4. **Debugging**: Clean code makes it easier to identify and fix bugs, leading to more reliable software.

## 2. Importance of Type Annotations

Type annotations in Python provide a way to specify the types of variables, function arguments, and return values. They enhance code readability and help catch type-related errors early in the development process.

### Benefits of Type Annotations

1. **Improved Readability**: Type annotations make it clear what types of values are expected, improving code readability.
2. **Error Detection**: Type annotations help catch type-related errors during development, reducing runtime errors.
3. **Better Tooling**: Many modern IDEs and editors use type annotations to provide better code completion and error checking.

### Example of Type Annotations

```python
from typing import List

def calculate_average(numbers: List[float]) -> float:
    """
    Calculates the average of a list of numbers.

    Args:
        numbers (List[float]): A list of numbers.

    Returns:
        float: The average of the numbers.
    """
    return sum(numbers) / len(numbers)
```

In this example, the `calculate_average` function takes a list of floats as input and returns a float. The type annotations make it clear what types are expected and returned, enhancing readability and maintainability.

## 3. Writing Effective Docstrings

Docstrings are an essential part of writing clean code in Python. They provide inline documentation for modules, classes, methods, and functions. Effective docstrings improve code readability and make it easier for other developers to understand and use your code.

### Benefits of Docstrings

1. **Documentation**: Docstrings serve as inline documentation, making it easier to understand the purpose and usage of code.
2. **Consistency**: Well-written docstrings ensure consistent documentation across the codebase.
3. **Ease of Use**: Docstrings make it easier for developers to use and understand code without having to read through the implementation details.

### Example of Effective Docstrings

```python
def calculate_factorial(n: int) -> int:
    """
    Calculates the factorial of a given non-negative integer.

    Args:
        n (int): The non-negative integer to calculate the factorial of.

    Returns:
        int: The factorial of the given number.

    Raises:
        ValueError: If the input is a negative integer.
    """
    if n < 0:
        raise ValueError("Input must be a non-negative integer.")
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial
```

In this example, the docstring clearly explains the purpose of the `calculate_factorial` function, its arguments, return value, and the exception it may raise.

## 4. Structuring Your Code

Proper code structure is crucial for code cleanliness. A well-structured codebase is easier to navigate, understand, and maintain. Here are some best practices for structuring your Python code:

### Organizing Code into Modules and Packages

Organize your code into modules and packages to group related functionality together. This makes it easier to find and manage code.

```python
# project/
# ├── main.py
# ├── utils/
# │   ├── __init__.py
# │   ├── file_utils.py
# │   └── math_utils.py
# └── models/
#     ├── __init__.py
#     ├── user.py
#     └── product.py
```

### Using Functions and Classes

Break down your code into small, reusable functions and classes. This makes your code more modular and easier to test.

```python
class User:
    def __init__(self, name: str, age: int):
        """
        Initializes a new user.

        Args:
            name (str): The name of the user.
            age (int): The age of the user.
        """
        self.name = name
        self.age = age

    def greet(self) -> str:
        """
        Greets the user.

        Returns:
            str: A greeting message.
        """
        return f"Hello, {self.name}!"
```

### Keeping Functions Small

Functions should do one thing and do it well. Keep functions small and focused on a single task.

```python
def save_user(user: User, filename: str) -> None:
    """
    Saves user data to a file.

    Args:
        user (User): The user object to save.
        filename (str): The name of the file to save the user data to.
    """
    with open(filename, 'w') as file:
        file.write(f"{user.name},{user.age}")
```

## 5. Error Handling and Logging with Loguru

Effective error handling and logging are critical components of clean code. They help you manage and diagnose issues that arise during the execution of your code.

### Error Handling Best Practices

1. **Use Specific Exceptions**: Catch specific exceptions rather than using a generic `except` clause.
2. **Provide Meaningful Messages**: When raising exceptions, provide meaningful error messages to help diagnose the issue.
3. **Clean Up Resources**: Use `finally` blocks or context managers to ensure that resources are properly cleaned up.

### Example of Error Handling

```python
def divide_numbers(numerator: float, denominator: float) -> float:
    """
    Divides the numerator by the denominator.

    Args:
        numerator (float): The number to be divided.
        denominator (float): The number to divide by.

    Returns:
        float: The result of the division.

    Raises:
        ValueError: If the denominator is zero.
    """
    if denominator == 0:
        raise ValueError("The denominator cannot be zero.")
    return numerator / denominator
```

### Logging with Loguru

Loguru is a powerful logging library for Python that makes logging simple and enjoyable. It provides a clean and easy-to-use API for logging messages with different severity levels.

#### Installing Loguru

```bash
pip install loguru
```

#### Basic Usage of Loguru

```python
from loguru import logger

logger.debug("This is a debug message")
logger.info("This is an info message")
logger.warning("This is a warning message")
logger.error("This is an error message")
logger.critical("This is a critical message")
```

### Example of Logging in a Function

```python
from loguru import logger

def fetch_data(url: str) -> str:
    """
    Fetches data from a given URL and returns it as a string.

    Args:
        url (str): The URL to fetch data from.

    Returns:
        str: The data fetched from the URL.

    Raises:
        requests.exceptions.RequestException: If there is an error with the request.
    """
    try:
        logger.info(f"Fetching data from {url}")
        response = requests.get(url)
        response.raise_for_status()
        logger.info("Data fetched successfully")
        return response.text
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching data: {e}")
        raise
```

In this example, Loguru is used to log messages at different severity levels. The `fetch_data` function logs informational messages when fetching data and logs an error message if an exception is raised.

## 6. Refactoring for Clean Code

Refactoring is the process of restructuring existing code without changing its external behavior. It is an essential practice for maintaining clean code. Refactoring helps improve code readability, reduce complexity, and eliminate redundancy.

### Identifying Code Smells

Code smells are indicators of potential issues in the code that may require refactoring. Common code smells include:
1. **Long Methods**: Methods that are too long and do too many things.
2. **Duplicated Code**: Code that is duplicated in multiple places.
3. **Large Classes**: Classes that have too many responsibilities.
4. **Poor Naming**: Variables, functions, or classes with unclear or misleading names.

### Refactoring Techniques

1. **Extract Method**: Break down long methods into smaller, more focused methods.
2. **Rename Variables**: Use meaningful names for variables, functions, and classes.
3. **Remove Duplicated Code**: Consolidate duplicated code into a single location.
4. **Simplify Conditional Expressions**: Simplify complex conditional expressions for

 better readability.

### Example of Refactoring

Before refactoring:
```python
def process_data(data: List[int]) -> int:
    total = 0
    for value in data:
        if value > 0:
            total += value
    return total
```

After refactoring:
```python
def filter_positive_values(data: List[int]) -> List[int]:
    """
    Filters the positive values from the input data.

    Args:
        data (List[int]): The input data.

    Returns:
        List[int]: A list of positive values.
    """
    return [value for value in data if value > 0]

def sum_values(values: List[int]) -> int:
    """
    Sums the values in the input list.

    Args:
        values (List[int]): A list of values to sum.

    Returns:
        int: The sum of the values.
    """
    return sum(values)

def process_data(data: List[int]) -> int:
    """
    Processes the data by filtering positive values and summing them.

    Args:
        data (List[int]): The input data.

    Returns:
        int: The sum of the positive values.
    """
    positive_values = filter_positive_values(data)
    return sum_values(positive_values)
```

In this example, the `process_data` function is refactored into smaller, more focused functions. This improves readability and maintainability.

## 7. Examples of Clean Code

### Example 1: Reading a File

```python
def read_file(file_path: str) -> str:
    """
    Reads the content of a file and returns it as a string.

    Args:
        file_path (str): The path to the file to read.

    Returns:
        str: The content of the file.

    Raises:
        FileNotFoundError: If the file does not exist.
        IOError: If there is an error reading the file.
    """
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError as e:
        logger.error(f"File not found: {file_path}")
        raise
    except IOError as e:
        logger.error(f"Error reading file: {file_path}")
        raise
```

### Example 2: Fetching Data from a URL

```python
import requests
from loguru import logger

def fetch_data(url: str) -> str:
    """
    Fetches data from a given URL and returns it as a string.

    Args:
        url (str): The URL to fetch data from.

    Returns:
        str: The data fetched from the URL.

    Raises:
        requests.exceptions.RequestException: If there is an error with the request.
    """
    try:
        logger.info(f"Fetching data from {url}")
        response = requests.get(url)
        response.raise_for_status()
        logger.info("Data fetched successfully")
        return response.text
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching data: {e}")
        raise
```

### Example 3: Calculating Factorial

```python
def calculate_factorial(n: int) -> int:
    """
    Calculates the factorial of a given non-negative integer.

    Args:
        n (int): The non-negative integer to calculate the factorial of.

    Returns:
        int: The factorial of the given number.

    Raises:
        ValueError: If the input is a negative integer.
    """
    if n < 0:
        raise ValueError("Input must be a non-negative integer.")
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial
```

## 8. Conclusion

Writing clean code in Python is crucial for developing maintainable, readable, and error-free software. By using type annotations, writing effective docstrings, structuring your code properly, and leveraging logging with Loguru, you can significantly improve the quality of your codebase.

Remember to refactor your code regularly to eliminate code smells and improve readability. Clean code not only makes your life as a developer easier but also enhances collaboration and reduces the likelihood of bugs.

By following the principles and best practices outlined in this article, you'll be well on your way to writing clean, maintainable Python code.

--------------------------------------------------

# File: swarms/framework/concept.md

To create a comprehensive overview of the Swarms framework, we can break it down into key concepts such as models, agents, tools, Retrieval-Augmented Generation (RAG) systems, and swarm systems. Below are conceptual explanations of these components along with mermaid diagrams to illustrate their interactions.

### Swarms Framework Overview

#### 1. **Models**
Models are the core component of the Swarms framework, representing the neural networks and machine learning models used to perform various tasks. These can be Large Language Models (LLMs), vision models, or any other AI models.

#### 2. **Agents**
Agents are autonomous units that use models to perform specific tasks. In the Swarms framework, agents can leverage tools and interact with RAG systems.

- **LLMs with Tools**: These agents use large language models along with tools like databases, APIs, and external knowledge sources to enhance their capabilities.
- **RAG Systems**: These systems combine retrieval mechanisms with generative models to produce more accurate and contextually relevant outputs.

#### 3. **Swarm Systems**
Swarm systems involve multiple agents working collaboratively to achieve complex tasks. These systems coordinate and communicate among agents to ensure efficient and effective task execution.

### Mermaid Diagrams

#### Models

```mermaid
graph TD
    A[Model] -->|Uses| B[Data]
    A -->|Trains| C[Algorithm]
    A -->|Outputs| D[Predictions]
```

#### Agents: LLMs with Tools and RAG Systems

```mermaid
graph TD
    A[Agent] -->|Uses| B[LLM]
    A -->|Interacts with| C[Tool]
    C -->|Provides Data to| B
    A -->|Queries| D[RAG System]
    D -->|Retrieves Information from| E[Database]
    D -->|Generates Responses with| F[Generative Model]
```

#### Swarm Systems

```mermaid
graph TD
    A[Swarm System]
    A -->|Coordinates| B[Agent 1]
    A -->|Coordinates| C[Agent 2]
    A -->|Coordinates| D[Agent 3]
    B -->|Communicates with| C
    C -->|Communicates with| D
    D -->|Communicates with| B
    B -->|Performs Task| E[Task 1]
    C -->|Performs Task| F[Task 2]
    D -->|Performs Task| G[Task 3]
    E -->|Reports to| A
    F -->|Reports to| A
    G -->|Reports to| A
```

### Conceptualization

1. **Models**: The basic building blocks trained on specific datasets to perform tasks.
2. **Agents**: Intelligent entities that utilize models and tools to perform actions. LLM agents can use additional tools to enhance their capabilities.
3. **RAG Systems**: Enhance agents by combining retrieval mechanisms (to fetch relevant information) with generative models (to create contextually relevant responses).
4. **Swarm Systems**: Complex systems where multiple agents collaborate, communicate, and coordinate to perform complex, multi-step tasks efficiently.

### Summary
The Swarms framework leverages models, agents, tools, RAG systems, and swarm systems to create a robust, collaborative environment for executing complex AI tasks. By coordinating multiple agents and enhancing their capabilities with tools and retrieval-augmented generation, Swarms can handle sophisticated and multi-faceted applications effectively.

--------------------------------------------------

# File: swarms/framework/index.md

## Swarms Framework Conceptual Breakdown

The `swarms` framework is a sophisticated structure designed to orchestrate the collaborative work of multiple agents in a hierarchical manner. This breakdown provides a conceptual and visual representation of the framework, highlighting the interactions between models, tools, memory, agents, and swarms.

### Hierarchical Structure

The framework can be visualized as a multi-layered hierarchy:

1. **Models, Tools, Memory**: These form the foundational components that agents utilize to perform tasks.
2. **Agents**: Individual entities that encapsulate specific functionalities, utilizing models, tools, and memory.
3. **Swarm**: A collection of multiple agents working together in a coordinated manner.
4. **Structs**: High-level structures that organize and manage swarms, enabling complex workflows and interactions.

### Visual Representation

Below are visual graphs illustrating the hierarchical and tree structure of the `swarms` framework.

#### 1. Foundational Components: Models, Tools, Memory

![Diagram](assets/img/agent_def.png)

#### 2. Agents and Their Interactions

```mermaid
graph TD;
    Agents --> Swarm
    subgraph Agents_Collection
        Agent1
        Agent2
        Agent3
    end
    subgraph Individual_Agents
        Agent1 --> Models
        Agent1 --> Tools
        Agent1 --> Memory
        Agent2 --> Models
        Agent2 --> Tools
        Agent2 --> Memory
        Agent3 --> Models
        Agent3 --> Tools
        Agent3 --> Memory
    end
```

#### 3. Multiple Agents Form a Swarm

```mermaid
graph TD;
    Swarm1 --> Struct
    Swarm2 --> Struct
    Swarm3 --> Struct
    subgraph Swarms_Collection
        Swarm1
        Swarm2
        Swarm3
    end
    subgraph Individual_Swarms
        Swarm1 --> Agent1
        Swarm1 --> Agent2
        Swarm1 --> Agent3
        Swarm2 --> Agent4
        Swarm2 --> Agent5
        Swarm2 --> Agent6
        Swarm3 --> Agent7
        Swarm3 --> Agent8
        Swarm3 --> Agent9
    end
```

#### 4. Structs Organizing Multiple Swarms

```mermaid
graph TD;
    Struct --> Swarms_Collection
    subgraph High_Level_Structs
        Struct1
        Struct2
        Struct3
    end
    subgraph Struct1
        Swarm1
        Swarm2
    end
    subgraph Struct2
        Swarm3
    end
    subgraph Struct3
        Swarm4
        Swarm5
    end
```

### Directory Breakdown

The directory structure of the `swarms` framework is organized to support its hierarchical architecture:

```sh
swarms/
├── agents/
├── artifacts/
├── marketplace/
├── memory/
├── models/
├── prompts/
├── schemas/
├── structs/
├── telemetry/
├── tools/
├── utils/
└── __init__.py
```

### Summary

The `swarms` framework is designed to facilitate complex multi-agent interactions through a structured and layered approach. By leveraging foundational components like models, tools, and memory, individual agents are empowered to perform specialized tasks. These agents are then coordinated within swarms to achieve collective goals, and swarms are managed within high-level structs to orchestrate sophisticated workflows.

This hierarchical design ensures scalability, flexibility, and robustness, making the `swarms` framework a powerful tool for various applications in AI, data analysis, optimization, and beyond.

--------------------------------------------------

# File: swarms/framework/reference.md

# API Reference Documentation



### `swarms.__init__`

**Description**:  
This module initializes the Swarms package by concurrently executing the bootup process and activating Sentry for telemetry. It imports various components from other modules within the Swarms package.

**Imports**:
- `concurrent.futures`: A module that provides a high-level interface for asynchronously executing callables.

- `swarms.telemetry.bootup`: Contains the `bootup` function for initializing telemetry.

- `swarms.telemetry.sentry_active`: Contains the `activate_sentry` function to enable Sentry for error tracking.

- Other modules from the Swarms package are imported for use, including agents, artifacts, prompts, structs, telemetry, tools, utils, and schemas.


**Concurrent Execution**:
The module uses `ThreadPoolExecutor` to run the `bootup` and `activate_sentry` functions concurrently.

```python
import concurrent.futures
from swarms.telemetry.bootup import bootup  # noqa: E402, F403
from swarms.telemetry.sentry_active import activate_sentry

# Use ThreadPoolExecutor to run bootup and activate_sentry concurrently
with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
    executor.submit(bootup)
    executor.submit(activate_sentry)

from swarms.agents import *  # noqa: E402, F403
from swarms.artifacts import *  # noqa: E402, F403
from swarms.prompts import *  # noqa: E402, F403
from swarms.structs import *  # noqa: E402, F403
from swarms.telemetry import *  # noqa: E402, F403
from swarms.tools import *  # noqa: E402, F403
from swarms.utils import *  # noqa: E402, F403
from swarms.schemas import *  # noqa: E402, F403
```

**Note**: There are no documentable functions or classes within this module itself, as it primarily serves to execute initial setup tasks and import other modules.




### `swarms.artifacts.base_artifact`

**Description**:  
This module defines the `BaseArtifact` abstract base class for representing artifacts in the system. It provides methods to convert artifact values to various formats and enforces the implementation of an addition method for subclasses.

**Imports**:
- `json`: A module for parsing JSON data.

- `uuid`: A module for generating unique identifiers.

- `ABC`, `abstractmethod`: Tools from the `abc` module to define abstract base classes.

- `dataclass`: A decorator for creating data classes.

- `Any`: A type hint for any data type.


### `BaseArtifact`
**Description**:  
An abstract base class for artifacts that includes common attributes and methods for handling artifact values.

**Attributes**:  
- `id` (`str`): A unique identifier for the artifact, generated if not provided.

- `name` (`str`): The name of the artifact. If not provided, it defaults to the artifact's ID.

- `value` (`Any`): The value associated with the artifact.


**Methods**:

- `__post_init__(self) -> None`

    - **Description**: Initializes the artifact, setting the `id` and `name` attributes if they are not provided.
    
    - **Parameters**: None.
    
    - **Return**: None.
    

- `value_to_bytes(cls, value: Any) -> bytes`

    - **Description**: Converts the given value to bytes.
    
    - **Parameters**: 
    
      - `value` (`Any`): The value to convert.
      
    - **Return**: 
    
      - (`bytes`): The value converted to bytes.
      

- `value_to_dict(cls, value: Any) -> dict`

    - **Description**: Converts the given value to a dictionary.
    
    - **Parameters**: 
    
      - `value` (`Any`): The value to convert.
      
    - **Return**: 
    
      - (`dict`): The value converted to a dictionary.
      

- `to_text(self) -> str`

    - **Description**: Converts the artifact's value to a text representation.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): The string representation of the artifact's value.
      

- `__str__(self) -> str`

    - **Description**: Returns a string representation of the artifact.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): The string representation of the artifact.
      

- `__bool__(self) -> bool`

    - **Description**: Returns the boolean value of the artifact based on its value.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`bool`): The boolean value of the artifact.
      

- `__len__(self) -> int`

    - **Description**: Returns the length of the artifact's value.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`int`): The length of the artifact's value.
      

- `__add__(self, other: BaseArtifact) -> BaseArtifact`

    - **Description**: Abstract method for adding two artifacts together. Must be implemented by subclasses.
    
    - **Parameters**: 
    
      - `other` (`BaseArtifact`): The other artifact to add.
      
    - **Return**: 
    
      - (`BaseArtifact`): The result of adding the two artifacts.
      

**Example**:
```python
from swarms.artifacts.base_artifact import BaseArtifact

class MyArtifact(BaseArtifact):
    def __add__(self, other: BaseArtifact) -> BaseArtifact:
      
        return MyArtifact(id=self.id, name=self.name, value=self.value + other.value)

artifact1 = MyArtifact(id="123", name="Artifact1", value=10)
artifact2 = MyArtifact(id="456", name="Artifact2", value=20)
result = artifact1 + artifact2
print(result)  # Output: MyArtifact with the combined value
```




### `swarms.artifacts.text_artifact`

**Description**:  
This module defines the `TextArtifact` class, which represents a text-based artifact. It extends the `BaseArtifact` class and includes attributes and methods specific to 
handling text values, including encoding options, embedding generation, and token counting.

**Imports**:
- `dataclass`, `field`: Decorators and functions from the `dataclasses` module for creating data classes.

- `Callable`: A type hint indicating a callable object from the `typing` module.

- `BaseArtifact`: The abstract base class for artifacts, imported from `swarms.artifacts.base_artifact`.


### `TextArtifact`
**Description**:  
Represents a text artifact with additional functionality for handling text values, encoding, and embeddings.

**Attributes**:  
- `value` (`str`): The text value of the artifact.

- `encoding` (`str`, optional): The encoding of the text (default is "utf-8").

- `encoding_error_handler` (`str`, optional): The error handler for encoding errors (default is "strict").

- `tokenizer` (`Callable`, optional): A callable for tokenizing the text value.

- `_embedding` (`list[float]`): The embedding of the text artifact (default is an empty list).


**Properties**:
- `embedding` (`Optional[list[float]]`): Returns the embedding of the text artifact if available; otherwise, returns `None`.


**Methods**:

- `__add__(self, other: BaseArtifact) -> TextArtifact`

    - **Description**: Concatenates the text value of this artifact with the text value of another artifact.
    
    - **Parameters**: 
    
      - `other` (`BaseArtifact`): The other artifact to concatenate with.
      
    - **Return**: 
    
      - (`TextArtifact`): A new `TextArtifact` instance with the concatenated value.
      

- `__bool__(self) -> bool`

    - **Description**: Checks if the text value of the artifact is non-empty.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`bool`): `True` if the text value is non-empty; otherwise, `False`.
      

- `generate_embedding(self, model) -> list[float] | None`

    - **Description**: Generates the embedding of the text artifact using a given embedding model.
    
    - **Parameters**: 
    
      - `model`: An embedding model that provides the `embed_string` method.
      
    - **Return**: 
    
      - (`list[float] | None`): The generated embedding as a list of floats, or `None` if the embedding could not be generated.
      

- `token_count(self) -> int`

    - **Description**: Counts the number of tokens in the text artifact using a specified tokenizer.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`int`): The number of tokens in the text value.
      

- `to_bytes(self) -> bytes`

    - **Description**: Converts the text value of the artifact to bytes using the specified encoding and error handler.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`bytes`): The text value encoded as bytes.
      

**Example**:
```python
from swarms.artifacts.text_artifact import TextArtifact

# Create a TextArtifact instance
text_artifact = TextArtifact(value="Hello, World!")

# Generate embedding (assuming an appropriate model is provided)
# embedding = text_artifact.generate_embedding(model)

# Count tokens in the text artifact
token_count = text_artifact.token_count()

# Convert to bytes
bytes_value = text_artifact.to_bytes()

print(text_artifact)  # Output: Hello, World!
print(token_count)    # Output: Number of tokens
print(bytes_value)    # Output: b'Hello, World!'
```




### `swarms.artifacts.main_artifact`

**Description**:  
This module defines the `Artifact` class, which represents a file artifact with versioning capabilities. It allows for the creation, editing, saving, loading, and exporting of file artifacts, as well as managing their version history. The module also includes a `FileVersion` class to encapsulate the details of each version of the artifact.

**Imports**:
- `time`: A module for time-related functions.

- `logger`: A logging utility from `swarms.utils.loguru_logger`.

- `os`: A module providing a way of using operating system-dependent functionality.

- `json`: A module for parsing JSON data.

- `List`, `Union`, `Dict`, `Any`: Type hints from the `typing` module.

- `BaseModel`, `Field`, `validator`: Tools from the `pydantic` module for data validation and settings management.

- `datetime`: A module for manipulating dates and times.


### `FileVersion`
**Description**:  
Represents a version of a file with its content and timestamp.

**Attributes**:  
- `version_number` (`int`): The version number of the file.

- `content` (`str`): The content of the file version.

- `timestamp` (`str`): The timestamp of the file version, formatted as "YYYY-MM-DD HH:MM:SS".


**Methods**:

- `__str__(self) -> str`

    - **Description**: Returns a string representation of the file version.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): A formatted string containing the version number, timestamp, and content.
      

### `Artifact`
**Description**:  
Represents a file artifact with attributes to manage its content and version history.

**Attributes**:  
- `file_path` (`str`): The path to the file.

- `file_type` (`str`): The type of the file (e.g., ".txt").

- `contents` (`str`): The contents of the file.

- `versions` (`List[FileVersion]`): The list of file versions.

- `edit_count` (`int`): The number of times the file has been edited.


**Methods**:

- `validate_file_type(cls, v, values) -> str`

    - **Description**: Validates the file type based on the file extension.
    
    - **Parameters**: 
    
      - `v` (`str`): The file type to validate.
      
      - `values` (`dict`): A dictionary of other field values.
      
    - **Return**: 
    
      - (`str`): The validated file type.
      

- `create(self, initial_content: str) -> None`

    - **Description**: Creates a new file artifact with the initial content.
    
    - **Parameters**: 
    
      - `initial_content` (`str`): The initial content to set for the artifact.
      
    - **Return**: None.
    

- `edit(self, new_content: str) -> None`

    - **Description**: Edits the artifact's content, tracking the change in the version history.
    
    - **Parameters**: 
    
      - `new_content` (`str`): The new content to set for the artifact.
      
    - **Return**: None.
    

- `save(self) -> None`

    - **Description**: Saves the current artifact's contents to the specified file path.
    
    - **Parameters**: None.
    
    - **Return**: None.
    

- `load(self) -> None`

    - **Description**: Loads the file contents from the specified file path into the artifact.
    
    - **Parameters**: None.
    
    - **Return**: None.
    

- `get_version(self, version_number: int) -> Union[FileVersion, None]`

    - **Description**: Retrieves a specific version of the artifact by its version number.
    
    - **Parameters**: 
    
      - `version_number` (`int`): The version number to retrieve.
      
    - **Return**: 
    
      - (`FileVersion | None`): The requested version if found; otherwise, `None`.
      

- `get_contents(self) -> str`

    - **Description**: Returns the current contents of the artifact as a string.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): The current contents of the artifact.
      

- `get_version_history(self) -> str`

    - **Description**: Returns the version history of the artifact as a formatted string.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): A formatted string containing the version history.
      

- `export_to_json(self, file_path: str) -> None`

    - **Description**: Exports the artifact to a JSON file.
    
    - **Parameters**: 
    
      - `file_path` (`str`): The path to the JSON file where the artifact will be saved.
      
    - **Return**: None.
    

- `import_from_json(cls, file_path: str) -> "Artifact"`

    - **Description**: Imports an artifact from a JSON file.
    
    - **Parameters**: 
    
      - `file_path` (`str`): The path to the JSON file to import the artifact from.
      
    - **Return**: 
    
      - (`Artifact`): The imported artifact instance.
      

- `get_metrics(self) -> str`

    - **Description**: Returns all metrics of the artifact as a formatted string.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`str`): A string containing all metrics of the artifact.
      

- `to_dict(self) -> Dict[str, Any]`

    - **Description**: Converts the artifact instance to a dictionary representation.
    
    - **Parameters**: None.
    
    - **Return**: 
    
      - (`Dict[str, Any]`): The dictionary representation of the artifact.
      

- `from_dict(cls, data: Dict[str, Any]) -> "Artifact"`

    - **Description**: Creates an artifact instance from a dictionary representation.
    
    - **Parameters**: 
    
      - `data` (`Dict[str, Any]`): The dictionary to create the artifact from.
      
    - **Return**: 
    
      - (`Artifact`): The created artifact instance.
      

**Example**:
```python
from swarms.artifacts.main_artifact import Artifact

# Create an Artifact instance
artifact = Artifact(file_path="example.txt", file_type=".txt")
artifact.create("Initial content")
artifact.edit("First edit")
artifact.edit("Second edit")
artifact.save()

# Export to JSON
artifact.export_to_json("artifact.json")

# Import from JSON
imported_artifact = Artifact.import_from_json("artifact.json")

# Get metrics
print(artifact.get_metrics())
```




### `swarms.artifacts.__init__`

**Description**:  
This module serves as the initialization point for the artifacts subpackage within the Swarms framework. It imports and exposes the key classes related to artifacts, including `BaseArtifact`, `TextArtifact`, and `Artifact`, making them available for use in other parts of the application.

**Imports**:
- `BaseArtifact`: The abstract base class for artifacts, imported from `swarms.artifacts.base_artifact`.

- `TextArtifact`: A class representing text-based artifacts, imported from `swarms.artifacts.text_artifact`.

- `Artifact`: A class representing file artifacts with versioning capabilities, imported from `swarms.artifacts.main_artifact`.


**Exported Classes**:
- `BaseArtifact`: The base class for all artifacts.

- `TextArtifact`: A specialized artifact class for handling text values.

- `Artifact`: A class for managing file artifacts, including their content and version history.


**Example**:
```python
from swarms.artifacts import *

# Create instances of the artifact classes
base_artifact = BaseArtifact(id="1", name="Base Artifact", value="Some value")  # This will raise an error since BaseArtifact is abstract
text_artifact = TextArtifact(value="Sample text")
file_artifact = Artifact(file_path="example.txt", file_type=".txt")

# Use the classes as needed
print(text_artifact)  # Output: Sample text
``` 

**Note**: Since `BaseArtifact` is an abstract class, it cannot be instantiated directly.


# Agents

### `swarms.agents.__init__`

**Description**:  
This module serves as the initialization point for the agents subpackage within the Swarms framework. It imports and exposes key classes and functions related to agent operations, including stopping conditions and the `ToolAgent` class, making them available for use in other parts of the application.

**Imports**:
- `check_cancelled`: A function to check if the operation has been cancelled.

- `check_complete`: A function to check if the operation is complete.

- `check_done`: A function to check if the operation is done.

- `check_end`: A function to check if the operation has ended.

- `check_error`: A function to check if there was an error during the operation.

- `check_exit`: A function to check if the operation has exited.

- `check_failure`: A function to check if the operation has failed.

- `check_finished`: A function to check if the operation has finished.

- `check_stopped`: A function to check if the operation has been stopped.

- `check_success`: A function to check if the operation was successful.

- `ToolAgent`: A class representing an agent that utilizes tools.


**Exported Classes and Functions**:
- `ToolAgent`: The class for managing tool-based agents.

- `check_done`: Checks if the operation is done.

- `check_finished`: Checks if the operation has finished.

- `check_complete`: Checks if the operation is complete.

- `check_success`: Checks if the operation was successful.

- `check_failure`: Checks if the operation has failed.

- `check_error`: Checks if there was an error during the operation.

- `check_stopped`: Checks if the operation has been stopped.

- `check_cancelled`: Checks if the operation has been cancelled.

- `check_exit`: Checks if the operation has exited.

- `check_end`: Checks if the operation has ended.


**Example**:
```python
from swarms.agents import *

# Create an instance of ToolAgent
tool_agent = ToolAgent()

# Check the status of an operation
if check_done():
    print("The operation is done.")
```

**Note**: The specific implementations of the stopping condition functions and the `ToolAgent` class are not detailed in this module, as they are imported from other modules within the `swarms.agents` package.




### `swarms.agents.tool_agent`

**Description**:  
This module defines the `ToolAgent` class, which represents a specialized agent capable of performing tasks using a specified model and tokenizer. It is designed to run operations that require input validation against a JSON schema, generating outputs based on defined tasks.

**Imports**:
- `Any`, `Optional`, `Callable`: Type hints from the `typing` module for flexible parameter types.

- `Agent`: The base class for agents, imported from `swarms.structs.agent`.

- `Jsonformer`: A class responsible for transforming JSON data, imported from `swarms.tools.json_former`.

- `logger`: A logging utility from `swarms.utils.loguru_logger`.


### `ToolAgent`
**Description**:  
Represents a tool agent that performs a specific task using a model and tokenizer. It facilitates the execution of tasks by calling the appropriate model or using the defined JSON schema for structured output.

**Attributes**:  
- `name` (`str`): The name of the tool agent.

- `description` (`str`): A description of what the tool agent does.

- `model` (`Any`): The model used by the tool agent for processing.

- `tokenizer` (`Any`): The tokenizer used by the tool agent to prepare input data.

- `json_schema` (`Any`): The JSON schema that defines the structure of the expected output.

- `max_number_tokens` (`int`): The maximum number of tokens to generate (default is 500).

- `parsing_function` (`Optional[Callable]`): A function for parsing the output, if provided.

- `llm` (`Any`): A language model, if utilized instead of a custom model.


**Methods**:

- `__init__(self, name: str, description: str, model: Any, tokenizer: Any, json_schema: Any, max_number_tokens: int, parsing_function: Optional[Callable], llm: Any, *args, 
**kwargs) -> None`

    - **Description**: Initializes a new instance of the ToolAgent class.
    
    - **Parameters**: 
    
      - `name` (`str`): The name of the tool agent.
      
      - `description` (`str`): A description of the tool agent.
      
      - `model` (`Any`): The model to use (if applicable).
      
      - `tokenizer` (`Any`): The tokenizer to use (if applicable).
      
      - `json_schema` (`Any`): The JSON schema that outlines the expected output format.
      
      - `max_number_tokens` (`int`): Maximum token output size.
      
      - `parsing_function` (`Optional[Callable]`): Optional function to parse the output.
      
      - `llm` (`Any`): The language model to use as an alternative to a custom model.
      
      - `*args` and `**kwargs`: Additional arguments and keyword arguments for flexibility.
      
    - **Return**: None.
    

- `run(self, task: str, *args, **kwargs) -> Any`

    - **Description**: Executes the tool agent for the specified task, utilizing either a model or a language model based on provided parameters.
    
    - **Parameters**: 
    
      - `task` (`str`): The task or prompt to be processed by the tool agent.
      
      - `*args`: Additional positional arguments for flexibility.
      
      - `**kwargs`: Additional keyword arguments for flexibility.
      
    - **Return**: 
    
      - (`Any`): The output generated by the tool agent based on the input task.
      
    - **Raises**: 
    
      - `Exception`: If neither `model` nor `llm` is provided or if an error occurs during task execution.
      

**Example**:
```python
from transformers import AutoModelForCausalLM, AutoTokenizer
from swarms.agents.tool_agent import ToolAgent

# Load model and tokenizer
model = AutoModelForCausalLM.from_pretrained("databricks/dolly-v2-12b")

tokenizer = AutoTokenizer.from_pretrained("databricks/dolly-v2-12b")


# Define a JSON schema
json_schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": "number"},
        "is_student": {"type": "boolean"},
        "courses": {
            "type": "array",
            "items": {"type": "string"}
        }
    }
}

# Create and run a ToolAgent
task = "Generate a person's information based on the following schema:"
agent = ToolAgent(model=model, tokenizer=tokenizer, json_schema=json_schema)
generated_data = agent.run(task)

print(generated_data)
```




### `swarms.agents.stopping_conditions`

**Description**:  
This module contains a set of functions that check specific stopping conditions based on strings. These functions return boolean values indicating the presence of certain keywords, which can be used to determine the status of an operation or process.

### Functions:

- `check_done(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "<DONE>". 
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "<DONE>" is found in the string; otherwise, `False`.
      

- `check_finished(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "finished".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "finished" is found in the string; otherwise, `False`.
      

- `check_complete(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "complete".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "complete" is found in the string; otherwise, `False`.
      

- `check_success(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "success".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "success" is found in the string; otherwise, `False`.
      

- `check_failure(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "failure".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "failure" is found in the string; otherwise, `False`.
      

- `check_error(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "error".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "error" is found in the string; otherwise, `False`.
      

- `check_stopped(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "stopped".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "stopped" is found in the string; otherwise, `False`.
      

- `check_cancelled(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "cancelled".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "cancelled" is found in the string; otherwise, `False`.
      

- `check_exit(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "exit".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "exit" is found in the string; otherwise, `False`.
      

- `check_end(s: str) -> bool`

    - **Description**: Checks if the string contains the keyword "end".
    
    - **Parameters**: 
    
      - `s` (`str`): The input string to check.
      
    - **Return**: 
    
      - (`bool`): `True` if "end" is found in the string; otherwise, `False`.
      

**Example**:
```python
from swarms.agents.stopping_conditions import check_done, check_error

status_message = "The process has finished and <DONE>!"

if check_done(status_message):
    print("The operation is done!")

if check_error(status_message):
    print("An error has occurred!")
``` 

**Note**: Each of these functions provides a simple way to check for specific keywords in a given string, which can be helpful in managing and monitoring tasks or operations.



# Schemas

### `swarms.schemas.base_schemas`

**Description**:  
This module defines various Pydantic models that represent schemas used in machine learning applications. These models facilitate data validation and serialization for different types of content, such as model cards, chat messages, and responses. 

**Imports**:
- `uuid`: A module for generating unique identifiers.

- `time`: A module for time-related functions.

- `List`, `Literal`, `Optional`, `Union`: Type hints from the `typing` module for flexible parameter types.

- `BaseModel`, `Field`: Tools from the `pydantic` module for data validation and settings management.


### `ModelCard`
**Description**:  
A Pydantic model that represents a model card, which provides metadata about a machine learning model.

**Attributes**:  
- `id` (`str`): The unique identifier for the model.

- `object` (`str`): A fixed string indicating the type of object ("model").

- `created` (`int`): The timestamp of model creation, defaults to the current time.

- `owned_by` (`str`): The owner of the model.

- `root` (`Optional[str]`): The root model identifier if applicable.

- `parent` (`Optional[str]`): The parent model identifier if applicable.

- `permission` (`Optional[list]`): A list of permissions associated with the model.


### `ModelList`
**Description**:  
A Pydantic model that represents a list of model cards.

**Attributes**:  
- `object` (`str`): A fixed string indicating the type of object ("list").

- `data` (`List[ModelCard]`): A list containing instances of `ModelCard`.


### `ImageUrl`
**Description**:  
A Pydantic model representing an image URL.

**Attributes**:  
- `url` (`str`): The URL of the image.


### `TextContent`
**Description**:  
A Pydantic model representing text content.

**Attributes**:  
- `type` (`Literal["text"]`): A fixed string indicating the type of content (text).

- `text` (`str`): The actual text content.


### `ImageUrlContent`
**Description**:  
A Pydantic model representing image content via URL.

**Attributes**:  
- `type` (`Literal["image_url"]`): A fixed string indicating the type of content (image URL).

- `image_url` (`ImageUrl`): An instance of `ImageUrl` containing the URL of the image.


### `ContentItem`
**Description**:  
A type alias for a union of `TextContent` and `ImageUrlContent`, representing any content type that can be processed.

### `ChatMessageInput`
**Description**:  
A Pydantic model representing an input message for chat applications.

**Attributes**:  
- `role` (`str`): The role of the sender (e.g., "user", "assistant", or "system").

- `content` (`Union[str, List[ContentItem]]`): The content of the message, which can be a string or a list of content items.


### `ChatMessageResponse`
**Description**:  
A Pydantic model representing a response message in chat applications.

**Attributes**:  
- `role` (`str`): The role of the sender (e.g., "user", "assistant", or "system").

- `content` (`str`, optional): The content of the response message.


### `DeltaMessage`
**Description**:  
A Pydantic model representing a delta update for messages in chat applications.

**Attributes**:  
- `role` (`Optional[Literal["user", "assistant", "system"]]`): The role of the sender, if specified.

- `content` (`Optional[str]`): The content of the delta message, if provided.


### `ChatCompletionRequest`
**Description**:  
A Pydantic model representing a request for chat completion.

**Attributes**:  
- `model` (`str`): The model to use for completing the chat (default is "gpt-4o").

- `messages` (`List[ChatMessageInput]`): A list of input messages for the chat.

- `temperature` (`Optional[float]`): Controls the randomness of the output (default is 0.8).

- `top_p` (`Optional[float]`): An alternative to sampling with temperature (default is 0.8).

- `max_tokens` (`Optional[int]`): The maximum number of tokens to generate (default is 4000).

- `stream` (`Optional[bool]`): If true, the response will be streamed (default is False).

- `repetition_penalty` (`Optional[float]`): A penalty for repeated tokens (default is 1.0).

- `echo` (`Optional[bool]`): If true, the input will be echoed in the output (default is False).


### `ChatCompletionResponseChoice`
**Description**:  
A Pydantic model representing a choice in a chat completion response.

**Attributes**:  
- `index` (`int`): The index of the choice.

- `input` (`str`): The input message.

- `message` (`ChatMessageResponse`): The output message.


### `ChatCompletionResponseStreamChoice`
**Description**:  
A Pydantic model representing a choice in a streamed chat completion response.

**Attributes**:  
- `index` (`int`): The index of the choice.

- `delta` (`DeltaMessage`): The delta update for the message.


### `UsageInfo`
**Description**:  
A Pydantic model representing usage information for a chat completion request.

**Attributes**:  
- `prompt_tokens` (`int`): The number of tokens used in the prompt (default is 0).

- `total_tokens` (`int`): The total number of tokens used (default is 0).

- `completion_tokens` (`Optional[int]`): The number of tokens used in the completion (default is 0).


### `ChatCompletionResponse`
**Description**:  
A Pydantic model representing a response from a chat completion request.

**Attributes**:  
- `model` (`str`): The model used for the completion.

- `object` (`Literal["chat.completion", "chat.completion.chunk"]`): The type of response object.

- `choices` (`List[Union[ChatCompletionResponseChoice, ChatCompletionResponseStreamChoice]]`): A list of choices from the completion.

- `created` (`Optional[int]`): The timestamp of when the response was created.


### `AgentChatCompletionResponse`
**Description**:  
A Pydantic model representing a completion response from an agent.

**Attributes**:  
- `id` (`Optional[str]`): The ID of the agent that generated the completion response (default is a new UUID).

- `agent_name` (`Optional[str]`): The name of the agent that generated the response.

- `object` (`Optional[Literal["chat.completion", "chat.completion.chunk"]]`): The type of response object.

- `choices` (`Optional[ChatCompletionResponseChoice]`): The choice from the completion response.

- `created` (`Optional[int]`): The timestamp of when the response was created.


**Example**:
```python
from swarms.schemas.base_schemas import ChatCompletionRequest, ChatMessageInput

# Create a chat completion request
request = ChatCompletionRequest(
    model="gpt-4",
    
    messages=[
        ChatMessageInput(role="user", content="Hello! How can I help you?")
    ]
)
``` 

**Note**: The Pydantic models in this module provide a structured way to handle data related to machine learning models and chat interactions, ensuring that the data adheres to defined schemas.




### `swarms.schemas.plan`

**Description**:  
This module defines the `Plan` class, which represents a sequence of steps in a structured format. It utilizes Pydantic for data validation and configuration, ensuring that each plan consists of a list of defined steps.

**Imports**:
- `List`: A type hint from the `typing` module for work with lists.

- `BaseModel`: The Pydantic base class for data models, providing validation and serialization features.

- `Step`: A model representing individual steps in the plan, imported from `swarms.schemas.agent_step_schemas`.


### `Plan`
**Description**:  
Represents a sequence of steps that comprise a plan. This class ensures that the data structure adheres to the expected model for steps.

**Attributes**:  
- `steps` (`List[Step]`): A list of steps, where each step is an instance of the `Step` model.


**Config**:
- `orm_mode` (bool): Enables compatibility with ORM models to facilitate data loading from database objects.


**Example**:
```python
from swarms.schemas.plan import Plan
from swarms.schemas.agent_step_schemas import Step

# Create a list of steps
steps = [
    Step(/* initialize step attributes */),
    Step(/* initialize step attributes */),
]

# Create a Plan instance
plan = Plan(steps=steps)

# Access the steps
for step in plan.steps:
    print(step)
```

**Note**: The `Plan` class relies on the `Step` model for its structure, ensuring that the steps in a plan conform to the validation rules defined in the `Step` model.




### `swarms.schemas.__init__`

**Description**:  
This module serves as the initialization point for the schemas subpackage within the Swarms framework. It imports and exposes key classes related to agent steps and agent input schemas, making them available for use in other parts of the application.

**Imports**:
- `Step`: A model representing an individual step in an agent's operation, imported from `swarms.schemas.agent_step_schemas`.

- `ManySteps`: A model representing multiple steps, also imported from `swarms.schemas.agent_step_schemas`.

- `AgentSchema`: A model representing the schema for agent inputs, imported from `swarms.schemas.agent_input_schema`.


**Exported Classes**:
- `Step`: The class for defining individual steps in an agent's operation.

- `ManySteps`: The class for defining multiple steps in an agent's operation.

- `AgentSchema`: The class for defining the input schema for agents.


**Example**:
```python
from swarms.schemas import *

# Create an instance of Step
step = Step(/* initialize step attributes */)

# Create an instance of ManySteps
many_steps = ManySteps(steps=[step, step])

# Create an instance of AgentSchema
agent_schema = AgentSchema(/* initialize agent schema attributes */)
```

**Note**: This module acts as a central point for importing and utilizing the various schema classes defined in the Swarms framework, facilitating structured data handling for agents and their operations.




### `swarms.schemas.agent_step_schemas`

**Description**:  
This module defines the `Step` and `ManySteps` classes, which represent individual steps and collections of steps in a task, respectively. These classes utilize Pydantic for data validation and serialization, ensuring that each step adheres to the defined schema.

**Imports**:
- `time`: A module for time-related functions.

- `uuid`: A module for generating unique identifiers.

- `List`, `Optional`, `Any`: Type hints from the `typing` module for flexible parameter types.

- `BaseModel`, `Field`: Tools from the `pydantic` module for data validation and settings management.

- `AgentChatCompletionResponse`: A model representing the response from an agent's chat completion, imported from `swarms.schemas.base_schemas`.


### `get_current_time() -> str`

**Description**:  
Returns the current time formatted as "YYYY-MM-DD HH:MM:SS".


**Return**:  
- (`str`): The current time as a formatted string.


### `Step`
**Description**:  
A Pydantic model representing a single step in a task, including its ID, completion time, and response from an agent.

**Attributes**:  
- `step_id` (`Optional[str]`): The unique identifier for the step, generated if not provided.

- `time` (`Optional[float]`): The time taken to complete the task step, formatted as a string.

- `response` (`Optional[AgentChatCompletionResponse]`): The response from the agent for this step.


### `ManySteps`
**Description**:  
A Pydantic model representing a collection of steps associated with a specific agent and task.

**Attributes**:  
- `agent_id` (`Optional[str]`): The unique identifier for the agent.

- `agent_name` (`Optional[str]`): The name of the agent.

- `task` (`Optional[str]`): The name of the task being performed.

- `max_loops` (`Optional[Any]`): The maximum number of steps in the task.

- `run_id` (`Optional[str]`): The ID of the task this collection of steps belongs to.

- `steps` (`Optional[List[Step]]`): A list of `Step` instances representing the steps of the task.

- `full_history` (`Optional[str]`): A string containing the full history of the task.

- `total_tokens` (`Optional[int]`): The total number of tokens generated during the task.

- `stopping_token` (`Optional[str]`): The token at which the task stopped.

- `interactive` (`Optional[bool]`): Indicates whether the task is interactive.

- `dynamic_temperature_enabled` (`Optional[bool]`): Indicates whether dynamic temperature adjustments are enabled for the task.


**Example**:
```python
from swarms.schemas.agent_step_schemas import Step, ManySteps

# Create a step instance
step = Step(step_id="12345", response=AgentChatCompletionResponse(...))

# Create a ManySteps instance
many_steps = ManySteps(
    agent_id="agent-1",
    
    agent_name="Test Agent",
    task="Example Task",
    max_loops=5,
    steps=[step],
    full_history="Task executed successfully.",
    total_tokens=100
)

print(many_steps)
```

**Note**: The `Step` and `ManySteps` classes provide structured representations of task steps, ensuring that all necessary information is captured and validated according to the defined schemas.




### `swarms.schemas.agent_input_schema`

**Description**:  
This module defines the `AgentSchema` class using Pydantic, which represents the input parameters necessary for configuring an agent in the Swarms framework. It includes a variety of attributes for specifying the agent's behavior, model settings, and operational parameters.

**Imports**:
- `Any`, `Callable`, `Dict`, `List`, `Optional`: Type hints from the `typing` module for flexible parameter types.

- `BaseModel`, `Field`: Tools from the `pydantic` module for data validation and settings management.

- `validator`: A decorator from Pydantic used for custom validation of fields.


### `AgentSchema`
**Description**:  
Represents the configuration for an agent, including attributes that govern its behavior, capabilities, and interaction with language models. This class ensures that the input data adheres to defined validation rules.

**Attributes**:  
- `llm` (`Any`): The language model to use.

- `max_tokens` (`int`): The maximum number of tokens the agent can generate, must be greater than or equal to 1.

- `context_window` (`int`): The size of the context window, must be greater than or equal to 1.

- `user_name` (`str`): The name of the user interacting with the agent.

- `agent_name` (`str`): The name of the agent.

- `system_prompt` (`str`): The system prompt provided to the agent.

- `template` (`Optional[str]`): An optional template for the agent, default is `None`.

- `max_loops` (`Optional[int]`): The maximum number of loops the agent can perform (default is 1, must be greater than or equal to 1).

- `stopping_condition` (`Optional[Callable[[str], bool]]`): A callable function that defines a stopping condition for the agent.

- `loop_interval` (`Optional[int]`): The interval between loops (default is 0, must be greater than or equal to 0).

- `retry_attempts` (`Optional[int]`): Number of times to retry an operation if it fails (default is 3, must be greater than or equal to 0).

- `retry_interval` (`Optional[int]`): The time between retry attempts (default is 1, must be greater than or equal to 0).

- `return_history` (`Optional[bool]`): Flag indicating whether to return the history of the agent's operations (default is `False`).

- `stopping_token` (`Optional[str]`): Token indicating when to stop processing (default is `None`).

- `dynamic_loops` (`Optional[bool]`): Indicates whether dynamic loops are enabled (default is `False`).

- `interactive` (`Optional[bool]`): Indicates whether the agent operates in an interactive mode (default is `False`).

- `dashboard` (`Optional[bool]`): Flag indicating whether a dashboard interface is enabled (default is `False`).

- `agent_description` (`Optional[str]`): A description of the agent's functionality (default is `None`).

- `tools` (`Optional[List[Callable]]`): List of callable tools the agent can use (default is `None`).

- `dynamic_temperature_enabled` (`Optional[bool]`): Indicates whether dynamic temperature adjustments are enabled (default is `False`).

- Additional attributes for managing various functionalities and configurations related to the agent's behavior, such as logging, saving states, and managing tools.


### Validators:

- **check_list_items_not_none(v)**: Ensures that items within certain list attributes (`tools`, `docs`, `sop_list`, etc.) are not `None`.

- **check_optional_callable_not_none(v)**: Ensures that optional callable attributes are either `None` or callable.


**Example**:
```python
from swarms.schemas.agent_input_schema import AgentSchema

# Define the agent configuration data
agent_data = {
    "llm": "OpenAIChat",
    "max_tokens": 4096,
    "context_window": 8192,
    "user_name": "Human",
    "agent_name": "test-agent",
    
    "system_prompt": "Custom system prompt",
}

# Create an AgentSchema instance
agent = AgentSchema(**agent_data)
print(agent)
```

**Note**: The `AgentSchema` class provides a structured way to configure agents in the Swarms framework, ensuring that all necessary parameters are validated before use.




--------------------------------------------------

# File: swarms/framework/test.md

# How to Run Tests Using Pytest: A Comprehensive Guide

In modern software development, automated testing is crucial for ensuring the reliability and functionality of your code. One of the most popular testing frameworks for Python is `pytest`. 

This blog will provide an in-depth look at how to run tests using `pytest`, including testing a single file, multiple files, every file in the test repository, and providing guidelines for contributors to run tests reliably.

## What is Pytest?

`pytest` is a testing framework for Python that makes it easy to write simple and scalable test cases. It supports fixtures, parameterized testing, and has a rich plugin architecture. `pytest` is widely used because of its ease of use and powerful features that help streamline the testing process.

## Installation

To get started with `pytest`, you need to install it. You can install `pytest` using `pip`:

```bash
pip install pytest
```

## Writing Your First Test

Before diving into running tests, let’s write a simple test. Create a file named `test_sample.py` with the following content:

```python
def test_addition():
    assert 1 + 1 == 2

def test_subtraction():
    assert 2 - 1 == 1
```

In this example, we have defined two basic tests: `test_addition` and `test_subtraction`.

## Running Tests

### Running a Single Test File

To run a single test file, you can use the `pytest` command followed by the filename. For example, to run the tests in `test_sample.py`, use the following command:

```bash
pytest test_sample.py
```

The output will show the test results, including the number of tests passed, failed, or skipped.

### Running Multiple Test Files

You can also run multiple test files by specifying their filenames separated by a space. For example:

```bash
pytest test_sample.py test_another_sample.py
```

If you have multiple test files in a directory, you can run all of them by specifying the directory name:

```bash
pytest tests/
```

### Running All Tests in the Repository

To run all tests in the repository, navigate to the root directory of your project and simply run:

```bash
pytest
```

`pytest` will automatically discover and run all the test files that match the pattern `test_*.py` or `*_test.py`.

### Test Discovery

`pytest` automatically discovers test files and test functions based on their naming conventions. By default, it looks for files that match the pattern `test_*.py` or `*_test.py` and functions or methods that start with `test_`.

### Using Markers

`pytest` allows you to use markers to group tests or add metadata to them. Markers can be used to run specific subsets of tests. For example, you can mark a test as `slow` and then run only the slow tests or skip them.

```python
import pytest

@pytest.mark.slow
def test_long_running():
    import time
    time.sleep(5)
    assert True

def test_fast():
    assert True
```

To run only the tests marked as `slow`, use the `-m` option:

```bash
pytest -m slow
```

### Parameterized Tests

`pytest` supports parameterized testing, which allows you to run a test with different sets of input data. This can be done using the `@pytest.mark.parametrize` decorator.

```python
import pytest

@pytest.mark.parametrize("a,b,expected", [
    (1, 2, 3),
    (2, 3, 5),
    (3, 5, 8),
])
def test_add(a, b, expected):
    assert a + b == expected
```

In this example, `test_add` will run three times with different sets of input data.

### Fixtures

Fixtures are a powerful feature of `pytest` that allow you to set up some context for your tests. They can be used to provide a fixed baseline upon which tests can reliably and repeatedly execute.

```python
import pytest

@pytest.fixture
def sample_data():
    return {"name": "John", "age": 30}

def test_sample_data(sample_data):
    assert sample_data["name"] == "John"
    assert sample_data["age"] == 30
```

Fixtures can be used to share setup and teardown code between tests.

## Advanced Usage

### Running Tests in Parallel

`pytest` can run tests in parallel using the `pytest-xdist` plugin. To install `pytest-xdist`, run:

```bash
pip install pytest-xdist
```

To run tests in parallel, use the `-n` option followed by the number of CPU cores you want to use:

```bash
pytest -n 4
```

### Generating Test Reports

`pytest` can generate detailed test reports. You can use the `--html` option to generate an HTML report:

```bash
pip install pytest-html
pytest --html=report.html
```

This command will generate a file named `report.html` with a detailed report of the test results.

### Code Coverage

You can use the `pytest-cov` plugin to measure code coverage. To install `pytest-cov`, run:

```bash
pip install pytest-cov
```

To generate a coverage report, use the `--cov` option followed by the module name:

```bash
pytest --cov=my_module
```

This command will show the coverage summary in the terminal. You can also generate an HTML report:

```bash
pytest --cov=my_module --cov-report=html
```

The coverage report will be generated in the `htmlcov` directory.

## Best Practices for Writing Tests

1. **Write Clear and Concise Tests**: Each test should focus on a single piece of functionality.
2. **Use Descriptive Names**: Test function names should clearly describe what they are testing.
3. **Keep Tests Independent**: Tests should not depend on each other and should run in isolation.
4. **Use Fixtures**: Use fixtures to set up the context for your tests.
5. **Mock External Dependencies**: Use mocking to isolate the code under test from external dependencies.

## Running Tests Reliably

For contributors and team members, it’s important to run tests reliably to ensure consistent results. Here are some guidelines:

1. **Set Up a Virtual Environment**: Use a virtual environment to manage dependencies and ensure a consistent testing environment.
   
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows use `venv\Scripts\activate`
    ```

2. **Install Dependencies**: Install all required dependencies from the `requirements.txt` file.
   
    ```bash
    pip install -r requirements.txt
    ```

3. **Run Tests Before Pushing**: Ensure all tests pass before pushing code to the repository.

4. **Use Continuous Integration (CI)**: Set up CI pipelines to automatically run tests on each commit or pull request.

### Example CI Configuration (GitHub Actions)

Here is an example of a GitHub Actions workflow to run tests using `pytest`:

```yaml
name: Python package

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.8'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest
```

This configuration will run the tests on every push and pull request, ensuring that your codebase remains stable.

## Conclusion

`pytest` is a powerful and flexible testing framework that makes it easy to write and run tests for your Python code. By following the guidelines and best practices outlined in this blog, you can ensure that your tests are reliable and your codebase is robust. Whether you are testing a single file, multiple files, or the entire repository, `pytest` provides the tools you need to automate and streamline your testing process.

Happy testing!

--------------------------------------------------

# File: swarms/framework/vision.md

### Swarms Vision

**Swarms** is dedicated to transforming enterprise automation by offering a robust and intuitive interface for multi-agent collaboration and seamless integration with multiple models. Our mission is to enable enterprises to enhance their operational efficiency and effectiveness through intelligent automation.

#### Vision Statement

**To become the preeminent framework for orchestrating multi-agent collaboration and integration, empowering enterprises to achieve exceptional automation efficiency and operational excellence.**

#### Core Principles

1. **Multi-Agent Collaboration**: Facilitate seamless collaboration between diverse agents to solve complex and dynamic problems.
2. **Integration**: Provide robust and flexible integration with various models and frameworks to maximize functionality.
3. **Enterprise Automation**: Deliver enterprise-grade solutions designed for reliability, scalability, and security.
4. **Open Ecosystem**: Promote an open and extensible ecosystem that encourages innovation, community engagement, and collaborative development.

### Vision Document with Mermaid Graphs

#### Overview Diagram

```mermaid
graph TD
    A[Swarms Framework] --> B[Multi-Agent Collaboration]
    A --> C[Integration with Multiple Models]
    A --> D[Enterprise Automation]
    A --> E[Open Ecosystem]

    B --> F[Seamless Communication]
    B --> G[Collaboration Protocols]
    
    C --> H[Model Integration]
    C --> I[Framework Compatibility]

    D --> J[Operational Efficiency]
    D --> K[Reliability and Scalability]

    E --> L[Encourage Innovation]
    E --> M[Community Driven]
```

#### Multi-Agent Collaboration

```mermaid
graph TD
    B[Multi-Agent Collaboration] --> F[Seamless Communication]
    B --> G[Collaboration Protocols]

    F --> N[Cross-Agent Messaging]
    F --> O[Task Coordination]
    F --> P[Real-Time Updates]

    G --> Q[Standard APIs]
    G --> R[Extensible Protocols]
    G --> S[Security and Compliance]

    N --> T[Agent Messaging Hub]
    O --> U[Task Assignment and Monitoring]
    P --> V[Instantaneous Data Sync]

    Q --> W[Unified API Interface]
    R --> X[Customizable Protocols]
    S --> Y[Compliance with Standards]
    S --> Z[Secure Communication Channels]
```

#### Integration with Multiple Models

```mermaid
graph TD
    C[Integration with Multiple Models] --> H[Model Integration]
    C --> I[Framework Compatibility]

    H --> R[Plug-and-Play Models]
    H --> S[Model Orchestration]
    H --> T[Model Versioning]

    I --> U[Support for OpenAI]
    I --> V[Support for Anthropic]
    I --> W[Support for Gemini]
    I --> X[Support for LangChain]
    I --> Y[Support for AutoGen]
    I --> Z[Support for Custom Models]

    R --> AA[Easy Model Integration]
    S --> AB[Dynamic Model Orchestration]
    T --> AC[Version Control]

    U --> AD[Integration with OpenAI Models]
    V --> AE[Integration with Anthropic Models]
    W --> AF[Integration with Gemini Models]
    X --> AG[Integration with LangChain Models]
    Y --> AH[Integration with AutoGen Models]
    Z --> AI[Support for Proprietary Models]
```

#### Enterprise Automation

```mermaid
graph TD
    D[Enterprise Automation] --> J[Operational Efficiency]
    D --> K[Reliability and Scalability]

    J --> Y[Automate Workflows]
    J --> Z[Reduce Manual Work]
    J --> AA[Increase Productivity]

    K --> AB[High Uptime]
    K --> AC[Enterprise-Grade Security]
    K --> AD[Scalable Solutions]

    Y --> AE[Workflow Automation Tools]
    Z --> AF[Eliminate Redundant Tasks]
    AA --> AG[Boost Employee Efficiency]

    AB --> AH[Robust Infrastructure]
    AC --> AI[Security Compliance]
    AD --> AJ[Scale with Demand]
```

#### Open Ecosystem

```mermaid
graph TD
    E[Open Ecosystem] --> L[Encourage Innovation]
    E --> M[Community Driven]

    L --> AC[Open Source Contributions]
    L --> AD[Hackathons and Workshops]
    L --> AE[Research and Development]

    M --> AF[Active Community Support]
    M --> AG[Collaborative Development]
    M --> AH[Shared Resources]

    AC --> AI[Community Contributions]
    AD --> AJ[Innovative Events]
    AE --> AK[Continuous R&D]

    AF --> AL[Supportive Community]
    AG --> AM[Joint Development Projects]
    AH --> AN[Shared Knowledge Base]
```

---

### Conclusion

Swarms excels in enabling seamless communication and coordination between multiple agents, fostering a collaborative environment where agents can work together to solve complex tasks. Our platform supports cross-agent messaging, task coordination, and real-time updates, ensuring that all agents are synchronized and can efficiently contribute to the collective goal.

Swarms provides robust integration capabilities with a wide array of models, including OpenAI, Anthropic, Gemini, LangChain, AutoGen, and custom models. This ensures that enterprises can leverage the best models available to meet their specific needs, while also allowing for dynamic model orchestration and version control to keep operations up-to-date and effective.

Our framework is designed to enhance operational efficiency through automation. By automating workflows, reducing manual work, and increasing productivity, Swarms helps enterprises achieve higher efficiency and operational excellence. Our solutions are built for high uptime, enterprise-grade security, and scalability, ensuring reliable and secure operations.

Swarms promotes an open and extensible ecosystem, encouraging community-driven innovation and development. We support open-source contributions, organize hackathons and workshops, and continuously invest in research and development. Our active community fosters collaborative development, shared resources, and a supportive environment for innovation.

**Swarms** is dedicated to providing a comprehensive and powerful framework for enterprises seeking to automate operations through multi-agent collaboration and integration with various models. Our commitment to an open ecosystem, enterprise-grade automation solutions, and seamless multi-agent collaboration ensures that Swarms remains the leading choice for enterprises aiming to achieve operational excellence through intelligent automation.

--------------------------------------------------

# File: swarms/glossary.md

# Glossary of Terms

**Agent**:  
An LLM (Large Language Model) equipped with tools and memory, operating with a specific objective in a loop. An agent can perform tasks, interact with other agents, and utilize external tools and memory systems to achieve its goals.

**Swarms**:  
A group of more than two agents working together and communicating to accomplish a shared objective. Swarms enable complex, collaborative tasks that leverage the strengths of multiple agents.

**Tool**:  
A Python function that is converted into a function call, allowing agents to perform specific actions or access external resources. Tools enhance the capabilities of agents by providing specialized functionalities.

**Memory System**:  
A system for managing information retrieval and storage, often implemented as a Retrieval-Augmented Generation (RAG) system or a memory vector database. Memory systems enable agents to recall previous interactions, store new information, and improve decision-making based on historical data.

**LLM (Large Language Model)**:  
A type of AI model designed to understand and generate human-like text. LLMs, such as GPT-3 or GPT-4, are used as the core computational engine for agents.

**System Prompt**:  
A predefined prompt that sets the context and instructions for an agent's task. The system prompt guides the agent's behavior and response generation.

**Max Loops**:  
The maximum number of iterations an agent will perform to complete its task. This parameter helps control the extent of an agent's processing and ensures tasks are completed efficiently.

**Dashboard**:  
A user interface that provides real-time monitoring and control over the agents and their activities. Dashboards can display agent status, logs, and performance metrics.

**Streaming On**:  
A setting that enables agents to stream their output incrementally, providing real-time feedback as they process tasks. This feature is useful for monitoring progress and making adjustments on the fly.

**Verbose**:  
A setting that controls the level of detail in an agent's output and logging. When verbose mode is enabled, the agent provides more detailed information about its operations and decisions.

**Multi-modal**:  
The capability of an agent to process and integrate multiple types of data, such as text, images, and audio. Multi-modal agents can handle more complex tasks that require diverse inputs.

**Autosave**:  
A feature that automatically saves the agent's state and progress at regular intervals. Autosave helps prevent data loss and allows for recovery in case of interruptions.

**Flow**:  
The predefined sequence in which agents in a swarm interact and process tasks. The flow ensures that each agent's output is appropriately passed to the next agent, facilitating coordinated efforts.

**Long Term Memory**:  
A component of the memory system that retains information over extended periods, enabling agents to recall and utilize past interactions and experiences.

**Output Schema**:  
A structured format for the output generated by agents, often defined using data models like Pydantic's BaseModel. Output schemas ensure consistency and clarity in the information produced by agents.

By understanding these terms, you can effectively build and orchestrate agents and swarms, leveraging their capabilities to perform complex, collaborative tasks.

--------------------------------------------------

# File: swarms/install/docker_setup.md

# Docker Setup Guide for Contributors to Swarms


Welcome to the `swarms` project Docker setup guide. This document will help you establish a Docker-based environment for contributing to `swarms`. Docker provides a consistent and isolated environment, ensuring that all contributors can work in the same settings, reducing the "it works on my machine" syndrome.

### Purpose

The purpose of this guide is to:

- Ensure contributors can quickly set up their development environment.
- Provide a consistent testing and deployment workflow.
- Introduce Docker basics and best practices.

### Scope

This guide covers:

- Installing Docker
- Cloning the `swarms` repository
- Building a Docker image
- Running the `swarms` application in a Docker container
- Running tests using Docker
- Pushing changes and working with Docker Hub


## Docker Installation

### Windows

1. Download Docker Desktop for Windows from the official website.
2. Install Docker Desktop, ensuring that the "Use Windows containers instead of Linux containers" option is unchecked.
3. Start Docker Desktop and wait for the Docker engine to start.

### macOS

1. Download Docker Desktop for macOS from the official website.
2. Follow the installation instructions, drag-and-drop Docker into the Applications folder.
3. Start Docker Desktop from the Applications folder.

### Linux (Ubuntu)

1. Update your package index: `sudo apt-get update`.
2. Install packages to allow apt to use a repository over HTTPS.
3. Add Docker’s official GPG key.
4. Set up the stable repository.
5. Install the latest version of Docker Engine and containerd.

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io
```

6. Verify that Docker Engine is installed correctly by running the hello-world image.

```bash
sudo docker run hello-world
```

### Post-installation Steps for Linux

- Manage Docker as a non-root user.
- Configure Docker to start on boot.

## Cloning the Repository

```bash
git clone https://github.com/your-username/swarms.git
cd swarms
```

## Docker Basics

### Dockerfile Overview

- Explain the structure and commands of a Dockerfile used in the `swarms` project.

### Building the Image

```bash
docker build -t swarms-dev .
```

### Running a Container

```bash
docker run -it --rm swarms-dev
```

## Development Workflow with Docker

### Running the Application

- Commands to run the `swarms` application within Docker.

### Making Changes

- How to make changes to the code and reflect those changes within the Docker container.

### Running Tests

- Instructions on running tests using `pytest` within the Docker environment.

## Docker Compose for Local Development

- Introduce Docker Compose and its role in simplifying multi-container setups.
- Create a `docker-compose.yml` file for the `swarms` project.


## Dockerfile

Creating a Dockerfile for deploying the `swarms` framework to the cloud involves setting up the necessary environment to run your Python application, ensuring all dependencies are installed, and configuring the container to execute the desired tasks. Here's an example Dockerfile that sets up such an environment:

```Dockerfile
# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set the working directory in the container
WORKDIR /usr/src/swarm_cloud

# Install system dependencies
RUN apt-get update \
    && apt-get -y install gcc \
    && apt-get clean

# Install Python dependencies
# COPY requirements.txt and pyproject.toml if you're using poetry for dependency management
COPY requirements.txt .
RUN pip install --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt

# Install the 'swarms' package, assuming it's available on PyPI
ENV SWARM_API_KEY=your_swarm_api_key_here
ENV OPENAI_API_KEY=your_openai_key
RUN pip install swarms

# Copy the rest of the application
COPY . .

# Add entrypoint script if needed
# COPY ./entrypoint.sh .
# RUN chmod +x /usr/src/swarm_cloud/entrypoint.sh

# Expose port if your application has a web interface
# EXPOSE 5000

# Define environment variable for the swarm to work
# Add Docker CMD or ENTRYPOINT script to run the application
# CMD python your_swarm_startup_script.py
# Or use the entrypoint script if you have one
# ENTRYPOINT ["/usr/src/swarm_cloud/entrypoint.sh"]

# If you're using `CMD` to execute a Python script, make sure it's executable
# RUN chmod +x your_swarm_startup_script.py
```

To build and run this Docker image:

1. Replace `requirements.txt` with your actual requirements file or `pyproject.toml` and `poetry.lock` if you're using Poetry.
2. Replace `your_swarm_startup_script.py` with the script that starts your application.
3. If your application requires an API key or other sensitive data, make sure to set these securely, perhaps using environment variables or secrets management solutions provided by your cloud provider.
4. If you have an entrypoint script, uncomment the `COPY` and `RUN` lines for `entrypoint.sh`.
5. If your application has a web interface, uncomment the `EXPOSE` line and set it to the correct port.

Now, build your Docker image:

```sh
docker build -t swarm-cloud .
```

And run it:

```sh
docker run -d --name my-swarm-app swarm-cloud
```

For deploying to the cloud, you'll need to push your Docker image to a container registry (like Docker Hub or a private registry), then pull it from your cloud environment to run it. Cloud providers often have services specifically for this purpose (like AWS ECS, GCP GKE, or Azure AKS). The deployment process will involve:

- Pushing the image to a registry.
- Configuring cloud services to run your image.
- Setting up networking, storage, and other cloud resources.
- Monitoring, logging, and potentially scaling your containers.

Remember to secure sensitive data, use tagged releases for your images, and follow best practices for operating in the cloud.


--------------------------------------------------

# File: swarms/install/env.md

# Environment Variable Management & Security

This guide provides comprehensive documentation for managing environment variables and API keys securely in the Swarms framework.

## Overview

Swarms uses environment variables for configuration management and secure credential storage. This approach keeps sensitive information like API keys out of your code and allows for easy configuration changes across different environments.

## Core Environment Variables

### Framework Configuration

- `SWARMS_VERBOSE_GLOBAL`: Controls global logging verbosity
  ```bash
  SWARMS_VERBOSE_GLOBAL="True"  # Enable verbose logging
  SWARMS_VERBOSE_GLOBAL="False" # Disable verbose logging
  ```

- `WORKSPACE_DIR`: Defines the workspace directory for agent operations
  ```bash
  WORKSPACE_DIR="agent_workspace"
  ```

### API Keys

#### Model Provider Keys

1. **OpenAI**
   - `OPENAI_API_KEY`: Authentication for GPT models
   ```bash
   OPENAI_API_KEY="your-openai-key"
   ```

2. **Anthropic**
   - `ANTHROPIC_API_KEY`: Authentication for Claude models
   ```bash
   ANTHROPIC_API_KEY="your-anthropic-key"
   ```

3. **Google**
   - `GEMINI_API_KEY`: Authentication for Gemini models

4. **Hugging Face**
   - `HUGGINGFACE_TOKEN`: Access to Hugging Face models

5. **Perplexity AI**
   - `PPLX_API_KEY`: Access to Perplexity models

6. **AI21**
   - `AI21_API_KEY`: Access to AI21 models

#### Tool Provider Keys

1. **Search Tools**
   - `BING_BROWSER_API`: Bing search capabilities
   - `BRAVESEARCH_API_KEY`: Brave search integration
   - `TAVILY_API_KEY`: Tavily search services
   - `YOU_API_KEY`: You.com search integration

2. **Analytics & Monitoring**
   - `EXA_API_KEY`: Exa.ai services

3. **Browser Automation**
   - `MULTION_API_KEY`: Multi-browser automation

   
## Security Best Practices

### 1. Environment File Management

- Create a `.env` file in your project root
- Never commit `.env` files to version control
- Add `.env` to your `.gitignore`:
  ```bash
  echo ".env" >> .gitignore
  ```

### 2. API Key Security

- Rotate API keys regularly
- Use different API keys for development and production
- Never hardcode API keys in your code
- Limit API key permissions to only what's necessary
- Monitor API key usage for unusual patterns

### 3. Template Configuration

Create a `.env.example` template without actual values:

```bash
# Required Configuration
OPENAI_API_KEY=""
ANTHROPIC_API_KEY=""
WORKSPACE_DIR="agent_workspace"

# Optional Configuration
SWARMS_VERBOSE_GLOBAL="False"
```

### 4. Loading Environment Variables

```python
from dotenv import load_dotenv
import os

# Load environment variables
load_dotenv()

# Access variables
workspace_dir = os.getenv("WORKSPACE_DIR")
openai_key = os.getenv("OPENAI_API_KEY")
```

## Environment Setup Guide

1. **Install Dependencies**:
   ```bash
   pip install python-dotenv
   ```

2. **Create Environment File**:
   ```bash
   cp .env.example .env
   ```

3. **Configure Variables**:
   - Open `.env` in your text editor
   - Add your API keys and configuration
   - Save the file

4. **Verify Setup**:
   ```python
   import os
   from dotenv import load_dotenv

   load_dotenv()
   assert os.getenv("OPENAI_API_KEY") is not None, "OpenAI API key not found"
   ```

## Environment-Specific Configuration

### Development

```bash
WORKSPACE_DIR="agent_workspace"
SWARMS_VERBOSE_GLOBAL="True"
```

### Production

```bash
WORKSPACE_DIR="/var/swarms/workspace"
SWARMS_VERBOSE_GLOBAL="False"
```

### Testing

```bash
WORKSPACE_DIR="test_workspace"
SWARMS_VERBOSE_GLOBAL="True"
```

## Troubleshooting

### Common Issues

1. **Environment Variables Not Loading**
   - Verify `.env` file exists in project root
   - Confirm `load_dotenv()` is called before accessing variables
   - Check file permissions

2. **API Key Issues**
   - Verify key format is correct
   - Ensure key has not expired
   - Check for leading/trailing whitespace

3. **Workspace Directory Problems**
   - Confirm directory exists
   - Verify write permissions
   - Check path is absolute when required

## Additional Resources

- [Swarms Documentation](https://docs.swarms.world)
- [Security Best Practices](https://swarms.world/security)
- [API Documentation](https://swarms.world/docs/api)



--------------------------------------------------

# File: swarms/install/install.md

# Swarms Installation Guide

<div align="center">
  <p>
    <a align="center" href="" target="_blank">
      <img
        width="850"
        src="https://github.com/kyegomez/swarms/raw/master/images/swarmslogobanner.png"
      >
    </a>
  </p>
</div>

You can install `swarms` with pip in a
[**Python>=3.10**](https://www.python.org/) environment.

## Prerequisites

Before you begin, ensure you have the following installed:

- Python 3.10 or higher: [Download Python](https://www.python.org/)
- pip (specific version recommended): `pip >= 21.0`
- git (for cloning the repository): [Download Git](https://git-scm.com/)

## Installation Options

=== "pip (Recommended)"

    #### Headless Installation

    The headless installation of `swarms` is designed for environments where graphical user interfaces (GUI) are not needed, making it more lightweight and suitable for server-side applications.

    ```bash
    pip install swarms
    ```

=== "Development Installation"

    === "Using virtualenv"

        1. **Clone the repository and navigate to the root directory:**

            ```bash
            git clone https://github.com/kyegomez/swarms.git
            cd swarms
            ```

        2. **Setup Python environment and activate it:**

            ```bash
            python3 -m venv venv
            source venv/bin/activate
            pip install --upgrade pip
            ```

        3. **Install Swarms:**

            - Headless install:

                ```bash
                pip install -e .
                ```

            - Desktop install:

                ```bash
                pip install -e .[desktop]
                ```

    === "Using Anaconda"

        1. **Create and activate an Anaconda environment:**

            ```bash
            conda create -n swarms python=3.10
            conda activate swarms
            ```

        2. **Clone the repository and navigate to the root directory:**

            ```bash
            git clone https://github.com/kyegomez/swarms.git
            cd swarms
            ```

        3. **Install Swarms:**

            - Headless install:

                ```bash
                pip install -e .
                ```

            - Desktop install:

                ```bash
                pip install -e .[desktop]
                ```

    === "Using Poetry"

        1. **Clone the repository and navigate to the root directory:**

            ```bash
            git clone https://github.com/kyegomez/swarms.git
            cd swarms
            ```

        2. **Setup Python environment and activate it:**

            ```bash
            poetry env use python3.10
            poetry shell
            ```

        3. **Install Swarms:**

            - Headless install:

                ```bash
                poetry install
                ```

            - Desktop install:

                ```bash
                poetry install --extras "desktop"
                ```

=== "Using Docker"

    Docker is an excellent option for creating isolated and reproducible environments, suitable for both development and production. Contact us if there are any issues with the docker setup

    1. **Pull the Docker image:**

        ```bash
        docker pull swarmscorp/swarms:tagname

        ```

    2. **Run the Docker container:**

        ```bash
        docker run -it --rm swarmscorp/swarms:tagname
        ```

    3. **Build and run a custom Docker image:**

        ```dockerfile
        # Use Python 3.11 instead of 3.13
        FROM python:3.11-slim

        # Set environment variables
        ENV PYTHONDONTWRITEBYTECODE=1 \
            PYTHONUNBUFFERED=1 \
            WORKSPACE_DIR="agent_workspace" \
            OPENAI_API_KEY="your_swarm_api_key_here"

        # Set the working directory
        WORKDIR /usr/src/swarms

        # Install system dependencies
        RUN apt-get update && apt-get install -y \
            build-essential \
            gcc \
            g++ \
            gfortran \
            && rm -rf /var/lib/apt/lists/*

        # Install swarms package
        RUN pip3 install -U swarm-models
        RUN pip3 install -U swarms

        # Copy the application
        COPY . .
        ```

=== "Using Kubernetes"

    Kubernetes provides an automated way to deploy, scale, and manage containerized applications.

    1. **Create a Deployment YAML file:**

        ```yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: swarms-deployment
        spec:
          replicas: 3
          selector:
            matchLabels:
              app: swarms
          template:
            metadata:
              labels:
                app: swarms
            spec:
              containers:
              - name: swarms
                image: kyegomez/swarms
                ports:
                - containerPort: 8080
        ```

    2. **Apply the Deployment:**

        ```bash
        kubectl apply -f deployment.yaml
        ```

    3. **Expose the Deployment:**

        ```bash
        kubectl expose deployment swarms-deployment --type=LoadBalancer --name=swarms-service
        ```

=== "CI/CD Pipelines"

    Integrating Swarms into your CI/CD pipeline ensures automated testing and deployment.

    #### Using GitHub Actions

    ```yaml
    # .github/workflows/ci.yml
    name: CI

    on:
      push:
        branches: [ main ]
      pull_request:
        branches: [ main ]

    jobs:
      build:

        runs-on: ubuntu-latest

        steps:
        - uses: actions/checkout@v2
        - name: Set up Python
          uses: actions/setup-python@v2
          with:
            python-version: 3.10
        - name: Install dependencies
          run: |
            python -m venv venv
            source venv/bin/activate
            pip install --upgrade pip
            pip install -e .
        - name: Run tests
          run: |
            source venv/bin/activate
            pytest
    ```

    #### Using Jenkins

    ```groovy
    pipeline {
        agent any

        stages {
            stage('Clone repository') {
                steps {
                    git 'https://github.com/kyegomez/swarms.git'
                }
            }
            stage('Setup Python') {
                steps {
                    sh 'python3 -m venv venv'
                    sh 'source venv/bin/activate && pip install --upgrade pip'
                }
            }
            stage('Install dependencies') {
                steps {
                    sh 'source venv/bin/activate && pip install -e .'
                }
            }
            stage('Run tests') {
                steps {
                    sh 'source venv/bin/activate && pytest'
                }
            }
        }
    }
    ```

## Javascript

=== "NPM install (Work in Progress)"

    Get started with the NPM implementation of Swarms:

    ```bash
    npm install swarms-js
    ```


--------------------------------------------------

# File: swarms/install/quickstart.md

## Quickstart

**Swarms** is an enterprise-grade, production-ready multi-agent collaboration framework that enables you to orchestrate agents to work collaboratively at scale to automate real-world activities. Follow this quickstart guide to get up and running with Swarms, including setting up your environment, building an agent, and leveraging multi-agent methods.

### **Requirements**

- Python 3.10 or above
- `.env` file with API keys from your providers like `OPENAI_API_KEY`, `ANTHROPIC_API_KEY`
- Set an environment variable for your workspace directory:
  ```bash
  WORKSPACE_DIR="agent_workspace"
  ```

### **Installation**

To install Swarms, run:
```bash
$ pip install -U swarms
```

### **Usage Example: Single Agent**

Here’s a simple example of creating a financial analysis agent powered by OpenAI’s GPT-4 model. This agent will analyze financial queries like how to set up a ROTH IRA.

```python
import os
from swarms import Agent
from swarm_models import OpenAIChat
from dotenv import load_dotenv

load_dotenv()

# Initialize OpenAI model
model = OpenAIChat(
    openai_api_key=os.getenv("OPENAI_API_KEY"), model_name="gpt-4o-mini", temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt="Analyze financial situations and provide advice...",
    llm=model,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    saved_state_path="finance_agent.json"
)

# Run the agent on a financial query
out = agent.run("How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?")
print(out)
```

#### **Agent Class**

- **Attributes:**
  - `agent_name`: Name of the agent.
  - `system_prompt`: System-level instruction guiding the agent's behavior.
  - `llm`: Language model used by the agent (e.g., GPT, Anthropic).
  - `max_loops`: Max iterations for a task.
  - `autosave`: Auto-saves the state after each iteration.
  
- **Methods:**
  - `run(task: str)`: Executes the agent’s task.
  - `ingest_docs(doc_path: str)`: Ingests documents into the agent’s knowledge base.
  - `filtered_run(task: str)`: Runs agent with a filtered system prompt.

-----

## Creating Agents from YAML


### Step 1: Define Your Agents in a YAML File

The `create_agents_from_yaml` function works by reading agent configurations from a YAML file. Below is an example of what your YAML file (`agents_config.yaml`) should look like this. Example YAML Configuration (`agents_config.yaml`):

```yaml
agents:
  - agent_name: "Financial-Analysis-Agent"
    model:
      openai_api_key: "your_openai_api_key"
      model_name: "gpt-4o-mini"
      temperature: 0.1
      max_tokens: 2000
    system_prompt: "financial_agent_sys_prompt"
    max_loops: 1
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: true
    saved_state_path: "finance_agent.json"
    user_name: "swarms_corp"
    retry_attempts: 1
    context_length: 200000
    return_step_meta: false
    output_type: "str"
    task: "How can I establish a ROTH IRA to buy stocks and get a tax break?"

  - agent_name: "Stock-Analysis-Agent"
    model:
      openai_api_key: "your_openai_api_key"
      model_name: "gpt-4o-mini"
      temperature: 0.2
      max_tokens: 1500
    system_prompt: "stock_agent_sys_prompt"
    max_loops: 2
    autosave: true
    dashboard: false
    verbose: true
    dynamic_temperature_enabled: false
    saved_state_path: "stock_agent.json"
    user_name: "stock_user"
    retry_attempts: 3
    context_length: 150000
    return_step_meta: true
    output_type: "json"
    task: "What is the best strategy for long-term stock investment?"
```

### Key Configuration Fields:
- **agent_name**: Name of the agent.
- **model**: Defines the language model settings (e.g., API key, model name, temperature, and max tokens).
- **system_prompt**: The system prompt used to guide the agent’s behavior.
- **task**: (Optional) Task for the agent to execute once created.

---

### Step 2: Create the Main Script

Now, create the main Python script that will use the `create_agents_from_yaml` function.

### `main.py`:
```python
import os

from dotenv import load_dotenv
from loguru import logger
from swarm_models import OpenAIChat

from swarms.agents.create_agents_from_yaml import (
    create_agents_from_yaml,
)

# Load environment variables
load_dotenv()

# Path to your YAML file
yaml_file = "agents.yaml"

# Get the OpenAI API key from the environment variable
api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)


try:
    # Create agents and run tasks (using 'both' to return agents and task results)
    task_results = create_agents_from_yaml(
        model=model, yaml_file=yaml_file, return_type="tasks"
    )

    logger.info(f"Results from agents: {task_results}")
except Exception as e:
    logger.error(f"An error occurred: {e}")

```

### Example Run:

```bash
python main.py
```

This will:
1. Load agent configurations from `agents_config.yaml`.
2. Create the agents specified in the YAML file.
3. Run the tasks provided for each agent.
4. Output the task results to the console.

---

### Step 3: Customize the Return Type

The `create_agents_from_yaml` function supports multiple return types. You can control what is returned by setting the `return_type` parameter to `"agents"`, `"tasks"`, or `"both"`.

1. **Return Only Agents**
To create agents but not run tasks, set `return_type="agents"`:

```python
agents = create_agents_from_yaml(yaml_file, return_type="agents")
for agent in agents:
    print(f"Agent {agent.agent_name} created.")
```

2. **Return Only Task Results**
If you only care about the task results and not the agent objects, set `return_type="tasks"`:

```python
task_results = create_agents_from_yaml(yaml_file, return_type="tasks")
for result in task_results:
    print(f"Agent {result['agent_name']} executed task '{result['task']}' with output: {result['output']}")
```

3. **Return Both Agents and Task Results**
To return both the list of created agents and task results, use `return_type="both"`:

```python
agents, task_results = create_agents_from_yaml(yaml_file, return_type="both")
# Process agents and tasks separately
```


## Step 4: YAML Structure for Multiple Agents

The YAML file can define any number of agents, each with its own unique configuration. You can scale this setup by adding more agents and tasks to the `agents` list within the YAML file.

```yaml
agents:
  - agent_name: "Agent1"
    # Agent1 config...

  - agent_name: "Agent2"
    # Agent2 config...

  - agent_name: "Agent3"
    # Agent3 config...
```

Each agent will be initialized according to its configuration, and tasks (if provided) will be executed automatically.

---

## Integrating External Agents
Integrating external agents from other agent frameworks is easy with swarms.

Steps:

1. Create a new class that inherits `Agent`
2. Create a `.run(task: str) -> str` method that runs the agent and returns the response. 
3. The new Agent must return a string of the response. But you may add additional methods to save the output to JSON.


### Griptape Example

For example, here's an example on how to create an agent from griptape.

Here’s how you can create a custom **Griptape** agent that integrates with the **Swarms** framework by inheriting from the `Agent` class in **Swarms** and overriding the `run(task: str) -> str` method.


```python
from swarms import (
    Agent as SwarmsAgent,
)  # Import the base Agent class from Swarms
from griptape.structures import Agent as GriptapeAgent
from griptape.tools import (
    WebScraperTool,
    FileManagerTool,
    PromptSummaryTool,
)


# Create a custom agent class that inherits from SwarmsAgent
class GriptapeSwarmsAgent(SwarmsAgent):
    def __init__(self, *args, **kwargs):
        # Initialize the Griptape agent with its tools
        self.agent = GriptapeAgent(
            input="Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.",
            tools=[
                WebScraperTool(off_prompt=True),
                PromptSummaryTool(off_prompt=True),
                FileManagerTool(),
            ],
            *args,
            **kwargs,
            # Add additional settings
        )

    # Override the run method to take a task and execute it using the Griptape agent
    def run(self, task: str) -> str:
        # Extract URL and filename from task (you can modify this parsing based on task structure)
        url, filename = task.split(
            ","
        )  # Example of splitting task string
        # Execute the Griptape agent with the task inputs
        result = self.agent.run(url.strip(), filename.strip())
        # Return the final result as a string
        return str(result)


# Example usage:
griptape_swarms_agent = GriptapeSwarmsAgent()
output = griptape_swarms_agent.run(
    "https://griptape.ai, griptape.txt"
)
print(output)
```

### Key Components:
1. **GriptapeSwarmsAgent**: A custom class that inherits from the `SwarmsAgent` class and integrates the Griptape agent.
2. **run(task: str) -> str**: A method that takes a task string, processes it (e.g., splitting into a URL and filename), and runs the Griptape agent with the provided inputs.
3. **Griptape Tools**: The tools integrated into the Griptape agent (e.g., `WebScraperTool`, `PromptSummaryTool`, `FileManagerTool`) allow for web scraping, summarization, and file management.

You can now easily plug this custom Griptape agent into the **Swarms Framework** and use it to run tasks!





## Overview of Swarm Architectures in the Swarms Framework
---

### 1. **Sequential Workflow**

**Overview**: The `SequentialWorkflow` enables tasks to be executed one after the other. Each agent processes its task and passes the output to the next agent in the sequence.

#### Mermaid Graph:

```mermaid
graph TD;
    A[Task Input] --> B[Blog Generator Agent];
    B --> C[Summarizer Agent];
    C --> D[Task Output];
```

#### Code Example:

```python
from swarms import Agent, SequentialWorkflow
from swarm_models import Anthropic

# Initialize agents
agent1 = Agent(agent_name="Blog generator", system_prompt="Generate a blog post", llm=Anthropic(), max_loops=1)
agent2 = Agent(agent_name="Summarizer", system_prompt="Summarize the blog post", llm=Anthropic(), max_loops=1)

# Create Sequential workflow
workflow = SequentialWorkflow(agents=[agent1, agent2], max_loops=1)

# Run workflow
output = workflow.run("Generate a blog post on how swarms of agents can help businesses grow.")
print(output)
```

---

### 2. **Agent Rearrange**

**Overview**: `AgentRearrange` allows the orchestration of agents in both sequential and parallel configurations. The user can define a flexible flow of tasks between agents.

#### Mermaid Graph:

```mermaid
graph TD;
    A[Director Agent] --> B[Worker 1 Agent];
    A --> C[Worker 2 Agent];
    B --> D[Task Completed];
    C --> D[Task Completed];
```

#### Code Example:

```python
from swarms import Agent, AgentRearrange
from swarm_models import Anthropic

# Initialize agents
director = Agent(agent_name="Director", system_prompt="Directs tasks", llm=Anthropic(), max_loops=1)
worker1 = Agent(agent_name="Worker1", system_prompt="Generate a transcript", llm=Anthropic(), max_loops=1)
worker2 = Agent(agent_name="Worker2", system_prompt="Summarize the transcript", llm=Anthropic(), max_loops=1)

# Define agent relationships and workflow
flow = "Director -> Worker1 -> Worker2"
agent_system = AgentRearrange(agents=[director, worker1, worker2], flow=flow)

# Run agent system
output = agent_system.run("Create a YouTube transcript and summary")
print(output)
```

---

---

### 4. **Mixture of Agents**

**Overview**: `MixtureOfAgents` is a parallelized architecture where agents perform tasks concurrently and then feed their results back into a loop for final aggregation. This is useful for highly parallelizable tasks.

#### Mermaid Graph:

```mermaid
graph TD;
    A[Director Agent] --> B[Accountant 1];
    A --> C[Accountant 2];
    B --> D[Final Aggregation];
    C --> D[Final Aggregation];
```

#### Code Example:

```python
from swarms import Agent, OpenAIChat, MixtureOfAgents

# Initialize agents
director = Agent(agent_name="Director", system_prompt="Directs tasks", llm=OpenAIChat(), max_loops=1)
accountant1 = Agent(agent_name="Accountant1", system_prompt="Prepare financial statements", llm=OpenAIChat(), max_loops=1)
accountant2 = Agent(agent_name="Accountant2", system_prompt="Audit financial records", llm=OpenAIChat(), max_loops=1)

# Create Mixture of Agents swarm
swarm = MixtureOfAgents(name="Mixture of Accountants", agents=[director, accountant1, accountant2], layers=3, final_agent=director)

# Run the swarm
output = swarm.run("Prepare financial statements and audit financial records")
print(output)
```

---

### 5. **Spreadsheet Swarm**

**Overview**: `SpreadSheetSwarm` enables the management of thousands of agents simultaneously, where each agent operates on its own thread. It’s ideal for overseeing large-scale agent outputs.

#### Mermaid Graph:

```mermaid
graph TD;
    A[Spreadsheet Swarm] --> B[Twitter Agent];
    A --> C[Instagram Agent];
    A --> D[Facebook Agent];
    A --> E[LinkedIn Agent];
    A --> F[Email Agent];
```

#### Code Example:

```python
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm
import os

# Initialize agents for different marketing platforms
agents = [
    Agent(agent_name="Twitter Agent", system_prompt="Create a tweet", llm=OpenAIChat(openai_api_key=os.getenv("OPENAI_API_KEY")), max_loops=1),
    Agent(agent_name="Instagram Agent", system_prompt="Create an Instagram post", llm=OpenAIChat(openai_api_key=os.getenv("OPENAI_API_KEY")), max_loops=1),
    Agent(agent_name="Facebook Agent", system_prompt="Create a Facebook post", llm=OpenAIChat(openai_api_key=os.getenv("OPENAI_API_KEY")), max_loops=1),
    Agent(agent_name="LinkedIn Agent", system_prompt="Create a LinkedIn post", llm=OpenAIChat(openai_api_key=os.getenv("OPENAI_API_KEY")), max_loops=1),
    Agent(agent_name="Email Agent", system_prompt="Write a marketing email", llm=OpenAIChat(openai_api_key=os.getenv("OPENAI_API_KEY")), max_loops=1),
]

# Create the Spreadsheet Swarm
swarm = SpreadSheetSwarm(agents=agents, save_file_path="real_estate_marketing_spreadsheet.csv", run_all_agents=False, max_loops=2)

# Run the swarm
swarm.run("Create posts to promote luxury properties in North Texas.")
```

---

These are the key swarm architectures available in the **Swarms Framework**. Each one is designed to solve different types of multi-agent orchestration problems, from sequential tasks to large-scale parallel processing.


### Overview of Swarm Architectures
#### **Workflow Classes**

- **SequentialWorkflow:**
  - Chains agents, where one agent's output becomes the next agent’s input.
  
- **AgentRearrange:**
  - Dynamically rearranges agent tasks either in parallel or sequentially based on defined flow.

#### **Swarm Architectures**

- **Hierarchical Swarms:**
  - Implements top-down control, where a boss agent coordinates tasks among sub-agents.
  
- **Spreadsheet Swarm:**
  - A large-scale swarm architecture for managing multiple agents working concurrently.



--------------------------------------------------

# File: swarms/install/workspace_manager.md

# Swarms Framework Environment Configuration

This guide details the environment variables used in the Swarms framework for configuration and customization of your agent-based applications.

## Configuration Setup

Create a `.env` file in your project's root directory to configure the Swarms framework. This file will contain all necessary environment variables for customizing your agent's behavior, logging, and analytics.

## Environment Variables

### Core Variables

#### `WORKSPACE_DIR`
- **Purpose**: Defines the directory where all agent states and execution logs are stored
- **Type**: String (path)
- **Default**: `./workspace`
- **Example**: 
```bash
WORKSPACE_DIR=/path/to/your/workspace
```
- **Usage**:
  - Stores JSON files containing agent states
  - Maintains execution history
  - Keeps track of agent interactions
  - Preserves conversation logs

#### `SWARMS_AUTOUPDATE_ON`
- **Purpose**: Controls automatic updates of the Swarms framework
- **Type**: Boolean
- **Default**: `false`
- **Example**:
```bash
SWARMS_AUTOUPDATE_ON=true
```
- **Features**:
  - Automatically updates to the latest stable version
  - Ensures you have the newest features
  - Maintains compatibility with the latest improvements
  - Handles dependency updates
- **Considerations**:
  - Set to `false` if you need version stability
  - Recommended `true` for development environments
  - Consider system requirements for auto-updates
  - May require restart after updates

### Telemetry Configuration

#### `USE_TELEMETRY`
- **Purpose**: Controls whether telemetry data is collected
- **Type**: Boolean
- **Default**: `false`
- **Example**:
```bash
USE_TELEMETRY=true
```
- **Data Collected**:
  - Agent performance metrics
  - Execution time statistics
  - Memory usage
  - Error rates
  - System health indicators

### Analytics Integration

#### `SWARMS_API_KEY`
- **Purpose**: Authentication key for the Swarms Analytics Suite
- **Type**: String
- **Required**: Yes, for analytics features
- **Example**:
```bash
SWARMS_API_KEY=your_api_key_here
```
- **Features**:
  - Real-time agent execution tracking
  - Usage analytics
  - Performance monitoring
  - Cost tracking
  - Custom metrics

## Getting Started

1. Create a new `.env` file:
```bash
touch .env
```

2. Add your configuration:
```bash
# Basic configuration
WORKSPACE_DIR=./my_workspace

# Enable auto-updates
SWARMS_AUTOUPDATE_ON=true

# Enable telemetry
USE_TELEMETRY=true

# Add your Swarms API key
SWARMS_API_KEY=your_api_key_here
```

3. Obtain your API key:
   - Visit [swarms.ai](https://swarms.ai)
   - Create an account or log in
   - Navigate to the API section
   - Generate your unique API key

## Best Practices

1. **Security**:
   - Never commit your `.env` file to version control
   - Add `.env` to your `.gitignore` file
   - Keep your API keys secure and rotate them periodically

2. **Workspace Organization**:
   - Use descriptive workspace directory names
   - Implement regular cleanup of old logs
   - Monitor workspace size to prevent disk space issues

3. **Telemetry Management**:
   - Enable telemetry in development for debugging
   - Consider privacy implications in production
   - Review collected data periodically

4. **Auto-Update Management**:
   - Test updates in development before enabling in production
   - Keep backups before enabling auto-updates
   - Monitor system resources during updates
   - Schedule updates during low-traffic periods

## Examples

### Basic Development Setup
```bash
WORKSPACE_DIR=./dev_workspace
SWARMS_AUTOUPDATE_ON=true
USE_TELEMETRY=true
SWARMS_API_KEY=sk_test_xxxxxxxxxxxx
```

### Production Setup
```bash
WORKSPACE_DIR=/var/log/swarms/prod_workspace
SWARMS_AUTOUPDATE_ON=false
USE_TELEMETRY=true
SWARMS_API_KEY=sk_prod_xxxxxxxxxxxx
```

### Testing Environment
```bash
WORKSPACE_DIR=./test_workspace
SWARMS_AUTOUPDATE_ON=true
USE_TELEMETRY=false
SWARMS_API_KEY=sk_test_xxxxxxxxxxxx
```

## Troubleshooting

Common issues and solutions:

1. **Workspace Access Issues**:
   - Ensure proper file permissions
   - Verify the directory exists
   - Check disk space availability

2. **API Key Problems**:
   - Confirm key is properly formatted
   - Verify key hasn't expired
   - Check for proper environment variable loading

3. **Telemetry Issues**:
   - Confirm network connectivity
   - Verify firewall settings
   - Check for proper boolean values

4. **Auto-Update Issues**:
   - Check internet connectivity
   - Verify sufficient disk space
   - Ensure proper permissions for updates
   - Check system compatibility requirements

## Additional Resources

- [Swarms Framework Documentation](https://github.com/kyegomez/swarms)
- [Swarms Analytics Dashboard](https://swarms.ai)
- [API Reference](https://swarms.ai/docs/api)

--------------------------------------------------

# File: swarms/memory/diy_memory.md

# Integrating the Agent Class with Memory Systems/RAG in the Swarms Memory Framework

In this guide, we will cover how to integrate various memory systems from the Swarms Memory framework into an agent class. The Swarms Memory framework allows for the integration of different database-backed memory systems, enabling agents to retain and query long-term knowledge effectively. We'll walk through examples of integrating with Pinecone, ChromaDB, and Faiss, showcasing how to configure custom functions and embed memory functionality into an agent class.

## Installation

First, you need to install the Swarms Memory package:

```bash
$ pip install swarms swarms-memory
```


### Integrating ChromaDB with the Agent Class

ChromaDB is a simple, high-performance vector store for use with embeddings. Here's how you can integrate ChromaDB:

```python
from swarms_memory import ChromaDB
from swarms import Agent
from swarm_models import Anthropic
import os

# Initialize the ChromaDB client
chromadb_memory = ChromaDB(
    metric="cosine",
    output_dir="finance_agent_rag",
)

# Model
model = Anthropic(anthropic_api_key=os.getenv("ANTHROPIC_API_KEY"))

# Initialize the agent with ChromaDB memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
    llm=model,
    long_term_memory=chromadb_memory,
)

# Run a query
agent.run("What are the components of a startup's stock incentive equity plan?")
```

### Integrating Faiss with the Agent Class

Faiss is a library for efficient similarity search and clustering of dense vectors. Here's how you can integrate Faiss:

```python
from typing import List, Dict, Any
from swarms_memory.faiss_wrapper import FAISSDB
from swarms import Agent
from swarm_models import Anthropic
from transformers import AutoTokenizer, AutoModel
import torch
import os

# Custom embedding function using a HuggingFace model
def custom_embedding_function(text: str) -> List[float]:
    tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
    model = AutoModel.from_pretrained("bert-base-uncased")
    inputs = tokenizer(
        text,
        return_tensors="pt",
        padding=True,
        truncation=True,
        max_length=512,
    )
    with torch.no_grad():
        outputs = model(**inputs)
    embeddings = (
        outputs.last_hidden_state.mean(dim=1).squeeze().tolist()
    )
    return embeddings

# Initialize the FAISS memory wrapper
faiss_memory = FAISSDB(
    dimension=768,
    index_type="Flat",
    embedding_function=custom_embedding_function,
    metric="cosine",
)

# Model
model = Anthropic(anthropic_api_key=os.getenv("ANTHROPIC_API_KEY"))

# Initialize the agent with Faiss memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt="Agent system prompt here",
    agent_description="Agent performs financial analysis.",
    llm=model,
    long_term_memory=faiss_memory,
)

# Run a query
agent.run("Explain the differences between various types of financial instruments.")
```

## Mermaid Graphs for Visualizing Integration

To help visualize the integration process, here's a Mermaid graph illustrating how an agent interacts with the memory systems:

```mermaid
graph TD;
    A[Agent] -->|Queries| B[Memory System]
    B --> C{Pinecone / ChromaDB / Faiss}
    C --> D[Embedding Function]
    D --> E[LLM Model]
    E --> F[Query Results]
    F -->|Returns| A
```

This graph shows the flow from the agent sending queries to the memory system, which processes them using the embedding function and LLM model, and finally returns the results back to the agent.

## Conclusion

Integrating various memory systems from the Swarms Memory framework into the agent class enables the creation of powerful, memory-augmented agents capable of retaining and recalling information over time. Whether you're using Pinecone, ChromaDB, or Faiss, the process involves initializing the memory system, embedding functions, and then passing this memory system to the agent class. The examples and visualizations provided should help you get started with building your own memory-augmented agents.

Happy coding!


--------------------------------------------------

# File: swarms/models/anthropic.md

# **Documentation for the `Anthropic` Class**

## **Overview and Introduction**

The `Anthropic` class provides an interface to interact with the Anthropic large language models. This class encapsulates the necessary functionality to request completions from the Anthropic API based on a provided prompt and other configurable parameters.

### **Key Concepts and Terminology**

- **Anthropic**: A large language model, akin to GPT-3 and its successors.
- **Prompt**: A piece of text that serves as the starting point for model completions.
- **Stop Sequences**: Specific tokens or sequences to indicate when the model should stop generating.
- **Tokens**: Discrete pieces of information in a text. For example, in English, a token can be as short as one character or as long as one word.
  
## **Class Definition**

### `Anthropic`
```python
class Anthropic:
    """Anthropic large language models."""
```

### Parameters:

- `model (str)`: The name of the model to use for completions. Default is "claude-2".
  
- `max_tokens_to_sample (int)`: Maximum number of tokens to generate in the output. Default is 256.
  
- `temperature (float, optional)`: Sampling temperature. A higher value will make the output more random, while a lower value will make it more deterministic.
  
- `top_k (int, optional)`: Sample from the top-k most probable next tokens. Setting this parameter can reduce randomness in the output.
  
- `top_p (float, optional)`: Sample from the smallest set of tokens such that their cumulative probability exceeds the specified value. Used in nucleus sampling to provide a balance between randomness and determinism.
  
- `streaming (bool)`: Whether to stream the output or not. Default is False.
  
- `default_request_timeout (int, optional)`: Default timeout in seconds for API requests. Default is 600.

### **Methods and their Functionality**

#### `_default_params(self) -> dict`

- Provides the default parameters for calling the Anthropic API.
  
- **Returns**: A dictionary containing the default parameters.

#### `generate(self, prompt: str, stop: list[str] = None) -> str`

- Calls out to Anthropic's completion endpoint to generate text based on the given prompt.
  
- **Parameters**:
    - `prompt (str)`: The input text to provide context for the generated text.
      
    - `stop (list[str], optional)`: Sequences to indicate when the model should stop generating.
      
- **Returns**: A string containing the model's generated completion based on the prompt.

#### `__call__(self, prompt: str, stop: list[str] = None) -> str`

- An alternative to the `generate` method that allows calling the class instance directly.
  
- **Parameters**:
    - `prompt (str)`: The input text to provide context for the generated text.
      
    - `stop (list[str], optional)`: Sequences to indicate when the model should stop generating.
      
- **Returns**: A string containing the model's generated completion based on the prompt.

## **Usage Examples**

```python
# Import necessary modules and classes
from swarm_models import Anthropic

# Initialize an instance of the Anthropic class
model = Anthropic(anthropic_api_key="")

# Using the run method
completion_1 = model.run("What is the capital of France?")
print(completion_1)

# Using the __call__ method
completion_2 = model("How far is the moon from the earth?", stop=["miles", "km"])
print(completion_2)
```

## **Mathematical Formula**

The underlying operations of the `Anthropic` class involve probabilistic sampling based on token logits from the Anthropic model. Mathematically, the process of generating a token \( t \) from the given logits \( l \) can be described by the softmax function:

\[ P(t) = \frac{e^{l_t}}{\sum_{i} e^{l_i}} \]

Where:
- \( P(t) \) is the probability of token \( t \).
- \( l_t \) is the logit corresponding to token \( t \).
- The summation runs over all possible tokens.

The temperature, top-k, and top-p parameters are further used to modulate the probabilities.

## **Additional Information and Tips**

- Ensure you have a valid `ANTHROPIC_API_KEY` set as an environment variable or passed during class instantiation.
  
- Always handle exceptions that may arise from API timeouts or invalid prompts.

## **References and Resources**

- [Anthropic's official documentation](https://www.anthropic.com/docs)
  
- [Token-based sampling in Language Models](https://arxiv.org/abs/1904.09751) for a deeper understanding of token sampling.

--------------------------------------------------

# File: swarms/models/base_llm.md

# Language Model Interface Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [Abstract Language Model](#abstract-language-model)
   - [Initialization](#initialization)
   - [Attributes](#attributes)
   - [Methods](#methods)
3. [Implementation](#implementation)
4. [Usage Examples](#usage-examples)
5. [Additional Features](#additional-features)
6. [Performance Metrics](#performance-metrics)
7. [Logging and Checkpoints](#logging-and-checkpoints)
8. [Resource Utilization Tracking](#resource-utilization-tracking)
9. [Conclusion](#conclusion)

---

## 1. Introduction <a name="introduction"></a>

The Language Model Interface (`BaseLLM`) is a flexible and extensible framework for working with various language models. This documentation provides a comprehensive guide to the interface, its attributes, methods, and usage examples. Whether you're using a pre-trained language model or building your own, this interface can help streamline the process of text generation, chatbots, summarization, and more.

## 2. Abstract Language Model <a name="abstract-language-model"></a>

### Initialization <a name="initialization"></a>

The `BaseLLM` class provides a common interface for language models. It can be initialized with various parameters to customize model behavior. Here are the initialization parameters:

| Parameter              | Description                                                                                     | Default Value |
|------------------------|-------------------------------------------------------------------------------------------------|---------------|
| `model_name`           | The name of the language model to use.                                                         | None          |
| `max_tokens`           | The maximum number of tokens in the generated text.                                              | None          |
| `temperature`          | The temperature parameter for controlling randomness in text generation.                        | None          |
| `top_k`                | The top-k parameter for filtering words in text generation.                                      | None          |
| `top_p`                | The top-p parameter for filtering words in text generation.                                      | None          |
| `system_prompt`        | A system-level prompt to set context for generation.                                             | None          |
| `beam_width`           | The beam width for beam search.                                                                 | None          |
| `num_return_sequences` | The number of sequences to return in the output.                                                 | None          |
| `seed`                 | The random seed for reproducibility.                                                            | None          |
| `frequency_penalty`    | The frequency penalty parameter for promoting word diversity.                                    | None          |
| `presence_penalty`     | The presence penalty parameter for discouraging repetitions.                                     | None          |
| `stop_token`           | A stop token to indicate the end of generated text.                                              | None          |
| `length_penalty`       | The length penalty parameter for controlling the output length.                                   | None          |
| `role`                 | The role of the language model (e.g., assistant, user, etc.).                                    | None          |
| `max_length`           | The maximum length of generated sequences.                                                       | None          |
| `do_sample`            | Whether to use sampling during text generation.                                                  | None          |
| `early_stopping`       | Whether to use early stopping during text generation.                                            | None          |
| `num_beams`            | The number of beams to use in beam search.                                                       | None          |
| `repition_penalty`     | The repetition penalty parameter for discouraging repeated tokens.                                | None          |
| `pad_token_id`         | The token ID for padding.                                                                       | None          |
| `eos_token_id`         | The token ID for the end of a sequence.                                                         | None          |
| `bos_token_id`         | The token ID for the beginning of a sequence.                                                   | None          |
| `device`               | The device to run the model on (e.g., 'cpu' or 'cuda').                                          | None          |

### Attributes <a name="attributes"></a>

- `model_name`: The name of the language model being used.
- `max_tokens`: The maximum number of tokens in generated text.
- `temperature`: The temperature parameter controlling randomness.
- `top_k`: The top-k parameter for word filtering.
- `top_p`: The top-p parameter for word filtering.
- `system_prompt`: A system-level prompt for context.
- `beam_width`: The beam width for beam search.
- `num_return_sequences`: The number of output sequences.
- `seed`: The random seed for reproducibility.
- `frequency_penalty`: The frequency penalty parameter.
- `presence_penalty`: The presence penalty parameter.
- `stop_token`: The stop token to indicate text end.
- `length_penalty`: The length penalty parameter.
- `role`: The role of the language model.
- `max_length`: The maximum length of generated sequences.
- `do_sample`: Whether to use sampling during generation.
- `early_stopping`: Whether to use early stopping.
- `num_beams`: The number of beams in beam search.
- `repition_penalty`: The repetition penalty parameter.
- `pad_token_id`: The token ID for padding.
- `eos_token_id`: The token ID for the end of a sequence.
- `bos_token_id`: The token ID for the beginning of a sequence.
- `device`: The device used for model execution.
- `history`: A list of conversation history.

### Methods <a name="methods"></a>

The `BaseLLM` class defines several methods for working with language models:

- `run(task: Optional[str] = None, *args, **kwargs) -> str`: Generate text using the language model. This method is abstract and must be implemented by subclasses.

- `arun(task: Optional[str] = None, *args, **kwargs)`: An asynchronous version of `run` for concurrent text generation.

- `batch_run(tasks: List[str], *args, **kwargs)`: Generate text for a batch of tasks.

- `abatch_run(tasks: List[str], *args, **kwargs)`: An asynchronous version of `batch_run` for concurrent batch generation.

- `chat(task: str, history: str = "") -> str`: Conduct a chat with the model, providing a conversation history.

- `__call__(task: str) -> str`: Call the model to generate text.

- `_tokens_per_second() -> float`: Calculate tokens generated per second.

- `_num_tokens(text: str) -> int`: Calculate the number of tokens in a text.

- `_time_for_generation(task: str) -> float`: Measure the time taken for text generation.

- `generate_summary(text: str) -> str`: Generate a summary of the provided text.

- `set_temperature(value: float)`: Set the temperature parameter.

- `set_max_tokens(value: int)`: Set the maximum number of tokens.

- `clear_history()`: Clear the conversation history.

- `enable_logging(log_file: str = "model.log")`: Initialize logging for the model.

- `log_event(message: str)`: Log an event.

- `save_checkpoint(checkpoint_dir: str = "checkpoints")`: Save the model state as a checkpoint.

- `load_checkpoint(checkpoint_path: str)`: Load the model state from a checkpoint.

- `toggle_creative_mode(enable: bool)`: Toggle creative mode for the model.

- `track_resource_utilization()`: Track and report resource utilization.

- `

get_generation_time() -> float`: Get the time taken for text generation.

- `set_max_length(max_length: int)`: Set the maximum length of generated sequences.

- `set_model_name(model_name: str)`: Set the model name.

- `set_frequency_penalty(frequency_penalty: float)`: Set the frequency penalty parameter.

- `set_presence_penalty(presence_penalty: float)`: Set the presence penalty parameter.

- `set_stop_token(stop_token: str)`: Set the stop token.

- `set_length_penalty(length_penalty: float)`: Set the length penalty parameter.

- `set_role(role: str)`: Set the role of the model.

- `set_top_k(top_k: int)`: Set the top-k parameter.

- `set_top_p(top_p: float)`: Set the top-p parameter.

- `set_num_beams(num_beams: int)`: Set the number of beams.

- `set_do_sample(do_sample: bool)`: Set whether to use sampling.

- `set_early_stopping(early_stopping: bool)`: Set whether to use early stopping.

- `set_seed(seed: int)`: Set the random seed.

- `set_device(device: str)`: Set the device for model execution.

## 3. Implementation <a name="implementation"></a>

The `BaseLLM` class serves as the base for implementing specific language models. Subclasses of `BaseLLM` should implement the `run` method to define how text is generated for a given task. This design allows flexibility in integrating different language models while maintaining a common interface.

## 4. Usage Examples <a name="usage-examples"></a>

To demonstrate how to use the `BaseLLM` interface, let's create an example using a hypothetical language model. We'll initialize an instance of the model and generate text for a simple task.

```python
# Import the BaseLLM class
from swarm_models import BaseLLM

# Create an instance of the language model
language_model = BaseLLM(
    model_name="my_language_model",
    max_tokens=50,
    temperature=0.7,
    top_k=50,
    top_p=0.9,
    device="cuda",
)

# Generate text for a task
task = "Translate the following English text to French: 'Hello, world.'"
generated_text = language_model.run(task)

# Print the generated text
print(generated_text)
```

In this example, we've created an instance of our hypothetical language model, configured its parameters, and used the `run` method to generate text for a translation task.

## 5. Additional Features <a name="additional-features"></a>

The `BaseLLM` interface provides additional features for customization and control:

- `batch_run`: Generate text for a batch of tasks efficiently.
- `arun` and `abatch_run`: Asynchronous versions of `run` and `batch_run` for concurrent text generation.
- `chat`: Conduct a conversation with the model by providing a history of the conversation.
- `__call__`: Allow the model to be called directly to generate text.

These features enhance the flexibility and utility of the interface in various applications, including chatbots, language translation, and content generation.

## 6. Performance Metrics <a name="performance-metrics"></a>

The `BaseLLM` class offers methods for tracking performance metrics:

- `_tokens_per_second`: Calculate tokens generated per second.
- `_num_tokens`: Calculate the number of tokens in a text.
- `_time_for_generation`: Measure the time taken for text generation.

These metrics help assess the efficiency and speed of text generation, enabling optimizations as needed.

## 7. Logging and Checkpoints <a name="logging-and-checkpoints"></a>

Logging and checkpointing are crucial for tracking model behavior and ensuring reproducibility:

- `enable_logging`: Initialize logging for the model.
- `log_event`: Log events and activities.
- `save_checkpoint`: Save the model state as a checkpoint.
- `load_checkpoint`: Load the model state from a checkpoint.

These capabilities aid in debugging, monitoring, and resuming model experiments.

## 8. Resource Utilization Tracking <a name="resource-utilization-tracking"></a>

The `track_resource_utilization` method is a placeholder for tracking and reporting resource utilization, such as CPU and memory usage. It can be customized to suit specific monitoring needs.

## 9. Conclusion <a name="conclusion"></a>

The Language Model Interface (`BaseLLM`) is a versatile framework for working with language models. Whether you're using pre-trained models or developing your own, this interface provides a consistent and extensible foundation. By following the provided guidelines and examples, you can integrate and customize language models for various natural language processing tasks.

--------------------------------------------------

# File: swarms/models/base_multimodal_model.md

# `BaseMultiModalModel` Documentation

Swarms is a Python library that provides a framework for running multimodal AI models. It allows you to combine text and image inputs and generate coherent and context-aware responses. This library is designed to be extensible, allowing you to integrate various multimodal models.

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Getting Started](#getting-started)
4. [BaseMultiModalModel Class](#basemultimodalmodel-class)
    - [Initialization](#initialization)
    - [Methods](#methods)
5. [Usage Examples](#usage-examples)
6. [Additional Tips](#additional-tips)
7. [References and Resources](#references-and-resources)

## 1. Introduction <a name="introduction"></a>

Swarms is designed to simplify the process of working with multimodal AI models. These models are capable of understanding and generating content based on both textual and image inputs. With this library, you can run such models and receive context-aware responses.

## 2. Installation <a name="installation"></a>

To install swarms, you can use pip:

```bash
pip install swarms
```

## 3. Getting Started <a name="getting-started"></a>

To get started with Swarms, you'll need to import the library and create an instance of the `BaseMultiModalModel` class. This class serves as the foundation for running multimodal models.

```python
from swarm_models import BaseMultiModalModel

model = BaseMultiModalModel(
    model_name="your_model_name",
    temperature=0.5,
    max_tokens=500,
    max_workers=10,
    top_p=1,
    top_k=50,
    beautify=False,
    device="cuda",
    max_new_tokens=500,
    retries=3,
)
```

You can customize the initialization parameters based on your model's requirements.

## 4. BaseMultiModalModel Class <a name="basemultimodalmodel-class"></a>

### Initialization <a name="initialization"></a>

The `BaseMultiModalModel` class is initialized with several parameters that control its behavior. Here's a breakdown of the initialization parameters:

| Parameter        | Description                                                                                           | Default Value |
|------------------|-------------------------------------------------------------------------------------------------------|---------------|
| `model_name`     | The name of the multimodal model to use.                                                              | None          |
| `temperature`    | The temperature parameter for controlling randomness in text generation.                            | 0.5           |
| `max_tokens`     | The maximum number of tokens in the generated text.                                                    | 500           |
| `max_workers`    | The maximum number of concurrent workers for running tasks.                                           | 10            |
| `top_p`          | The top-p parameter for filtering words in text generation.                                            | 1             |
| `top_k`          | The top-k parameter for filtering words in text generation.                                            | 50            |
| `beautify`       | Whether to beautify the output text.                                                                  | False         |
| `device`         | The device to run the model on (e.g., 'cuda' or 'cpu').                                                | 'cuda'        |
| `max_new_tokens` | The maximum number of new tokens allowed in generated responses.                                       | 500           |
| `retries`        | The number of retries in case of an error during text generation.                                      | 3             |
| `system_prompt`  | A system-level prompt to set context for generation.                                                   | None          |
| `meta_prompt`    | A meta prompt to provide guidance for including image labels in responses.                             | None          |

### Methods <a name="methods"></a>

The `BaseMultiModalModel` class defines various methods for running multimodal models and managing interactions:

- `run(task: str, img: str) -> str`: Run the multimodal model with a text task and an image URL to generate a response.

- `arun(task: str, img: str) -> str`: Run the multimodal model asynchronously with a text task and an image URL to generate a response.

- `get_img_from_web(img: str) -> Image`: Fetch an image from a URL and return it as a PIL Image.

- `encode_img(img: str) -> str`: Encode an image to base64 format.

- `get_img(img: str) -> Image`: Load an image from the local file system and return it as a PIL Image.

- `clear_chat_history()`: Clear the chat history maintained by the model.

- `run_many(tasks: List[str], imgs: List[str]) -> List[str]`: Run the model on multiple text tasks and image URLs concurrently and return a list of responses.

- `run_batch(tasks_images: List[Tuple[str, str]]) -> List[str]`: Process a batch of text tasks and image URLs and return a list of responses.

- `run_batch_async(tasks_images: List[Tuple[str, str]]) -> List[str]`: Process a batch of text tasks and image URLs asynchronously and return a list of responses.

- `run_batch_async_with_retries(tasks_images: List[Tuple[str, str]]) -> List[str]`: Process a batch of text tasks and image URLs asynchronously with retries in case of errors and return a list of responses.

- `unique_chat_history() -> List[str]`: Get the unique chat history stored by the model.

- `run_with_retries(task: str, img: str) -> str`: Run the model with retries in case of an error.

- `run_batch_with_retries(tasks_images: List[Tuple[str, str]]) -> List[str]`: Run a batch of tasks with retries in case of errors and return a list of responses.

- `_tokens_per_second() -> float`: Calculate the tokens generated per second during text generation.

- `_time_for_generation(task: str) -> float`: Measure the time taken for text generation for a specific task.

- `generate_summary(text: str) -> str`: Generate a summary of the provided text.

- `set_temperature(value: float)`: Set the temperature parameter for controlling randomness in text generation.

- `set_max_tokens(value: int)`: Set the maximum number of tokens allowed in generated responses.

- `get_generation_time() -> float`: Get the time taken for text generation for the last task.

- `get_chat_history() -> List[str]`: Get the chat history, including all interactions.

- `get_unique_chat_history() -> List[str]`: Get the unique chat history, removing duplicate interactions.

- `get_chat_history_length() -> int`: Get the length of the chat history.

- `get_unique_chat_history_length() -> int`: Get the length of the unique chat history.

- `get_chat_history_tokens() -> int`: Get the total number of tokens in the chat history.

- `print_beautiful(content: str, color: str = 'cyan')`: Print content beautifully using colored text.

- `stream(content: str)`: Stream the content, printing it character by character.

- `meta_prompt() -> str`: Get the meta prompt that provides guidance for including image labels in responses.

## 5. Usage Examples <a name="usage-examples"></a>

Let's explore some usage examples of the MultiModalAI library:

### Example 1: Running

 the Model

```python
# Import the library
from swarm_models import BaseMultiModalModel

# Create an instance of the model
model = BaseMultiModalModel(
    model_name="your_model_name",
    temperature=0.5,
    max_tokens=500,
    device="cuda",
)

# Run the model with a text task and an image URL
response = model.run(
    "Generate a summary of this text", "https://www.example.com/image.jpg"
)
print(response)
```

### Example 2: Running Multiple Tasks Concurrently

```python
# Import the library
from swarm_models import BaseMultiModalModel

# Create an instance of the model
model = BaseMultiModalModel(
    model_name="your_model_name",
    temperature=0.5,
    max_tokens=500,
    max_workers=4,
    device="cuda",
)

# Define a list of tasks and image URLs
tasks = ["Task 1", "Task 2", "Task 3"]
images = ["https://image1.jpg", "https://image2.jpg", "https://image3.jpg"]

# Run the model on multiple tasks concurrently
responses = model.run_many(tasks, images)
for response in responses:
    print(response)
```

### Example 3: Running the Model Asynchronously

```python
# Import the library
from swarm_models import BaseMultiModalModel

# Create an instance of the model
model = BaseMultiModalModel(
    model_name="your_model_name",
    temperature=0.5,
    max_tokens=500,
    device="cuda",
)

# Define a list of tasks and image URLs
tasks_images = [
    ("Task 1", "https://image1.jpg"),
    ("Task 2", "https://image2.jpg"),
    ("Task 3", "https://image3.jpg"),
]

# Run the model on multiple tasks asynchronously
responses = model.run_batch_async(tasks_images)
for response in responses:
    print(response)
```

### Example 4: Inheriting `BaseMultiModalModel` for it's prebuilt classes
```python
from swarm_models import BaseMultiModalModel


class CustomMultiModalModel(BaseMultiModalModel):
    def __init__(self, model_name, custom_parameter, *args, **kwargs):
        # Call the parent class constructor
        super().__init__(model_name=model_name, *args, **kwargs)
        # Initialize custom parameters specific to your model
        self.custom_parameter = custom_parameter

    def __call__(self, text, img):
        # Implement the multimodal model logic here
        # You can use self.custom_parameter and other inherited attributes
        pass

    def generate_summary(self, text):
        # Implement the summary generation logic using your model
        # You can use self.custom_parameter and other inherited attributes
        pass


# Create an instance of your custom multimodal model
custom_model = CustomMultiModalModel(
    model_name="your_custom_model_name",
    custom_parameter="your_custom_value",
    temperature=0.5,
    max_tokens=500,
    device="cuda",
)

# Run your custom model
response = custom_model.run(
    "Generate a summary of this text", "https://www.example.com/image.jpg"
)
print(response)

# Generate a summary using your custom model
summary = custom_model.generate_summary("This is a sample text to summarize.")
print(summary)
```

In the code above:

1. We define a `CustomMultiModalModel` class that inherits from `BaseMultiModalModel`.

2. In the constructor of our custom class, we call the parent class constructor using `super()` and initialize any custom parameters specific to our model. In this example, we introduced a `custom_parameter`.

3. We override the `__call__` method, which is responsible for running the multimodal model logic. Here, you can implement the specific behavior of your model, considering both text and image inputs.

4. We override the `generate_summary` method, which is used to generate a summary of text input. You can implement your custom summarization logic here.

5. We create an instance of our custom model, passing the required parameters, including the custom parameter.

6. We demonstrate how to run the custom model and generate a summary using it.

By inheriting from `BaseMultiModalModel`, you can leverage the prebuilt features and methods provided by the library while customizing the behavior of your multimodal model. This allows you to create powerful and specialized models for various multimodal tasks.

These examples demonstrate how to use MultiModalAI to run multimodal models with text and image inputs. You can adjust the parameters and methods to suit your specific use cases.

## 6. Additional Tips <a name="additional-tips"></a>

Here are some additional tips and considerations for using MultiModalAI effectively:

- **Custom Models**: You can create your own multimodal models and inherit from the `BaseMultiModalModel` class to integrate them with this library.

- **Retries**: In cases where text generation might fail due to various reasons (e.g., server issues), using methods with retries can be helpful.

- **Monitoring**: You can monitor the performance of your model using methods like `_tokens_per_second()` and `_time_for_generation()`.

- **Chat History**: The library maintains a chat history, allowing you to keep track of interactions.

- **Streaming**: The `stream()` method can be useful for displaying output character by character, which can be helpful for certain applications.

## 7. References and Resources <a name="references-and-resources"></a>

Here are some references and resources that you may find useful for working with multimodal models:

- [Hugging Face Transformers Library](https://huggingface.co/transformers/): A library for working with various transformer-based models.

- [PIL (Python Imaging Library)](https://pillow.readthedocs.io/en/stable/): Documentation for working with images in Python using the Pillow library.

- [Concurrent Programming in Python](https://docs.python.org/3/library/concurrent.futures.html): Official Python documentation for concurrent programming.

- [Requests Library Documentation](https://docs.python-requests.org/en/latest/): Documentation for the Requests library, which is used for making HTTP requests.

- [Base64 Encoding in Python](https://docs.python.org/3/library/base64.html): Official Python documentation for base64 encoding and decoding.

This concludes the documentation for the MultiModalAI library. You can now explore the library further and integrate it with your multimodal AI projects.

--------------------------------------------------

# File: swarms/models/custom_model.md

# How to Create A Custom Language Model

When working with advanced language models, there might come a time when you need a custom solution tailored to your specific needs. Inheriting from an `BaseLLM` in a Python framework allows developers to create custom language model classes with ease. This developer guide will take you through the process step by step.

### Prerequisites

Before you begin, ensure that you have:

- A working knowledge of Python programming.
- Basic understanding of object-oriented programming (OOP) in Python.
- Familiarity with language models and natural language processing (NLP).
- The appropriate Python framework installed, with access to `BaseLLM`.

### Step-by-Step Guide

#### Step 1: Understand `BaseLLM`

The `BaseLLM` is an abstract base class that defines a set of methods and properties which your custom language model (LLM) should implement. Abstract classes in Python are not designed to be instantiated directly but are meant to be subclasses.

#### Step 2: Create a New Class

Start by defining a new class that inherits from `BaseLLM`. This class will implement the required methods defined in the abstract base class.

```python
from swarms import BaseLLM

class vLLMLM(BaseLLM):
    pass
```

#### Step 3: Initialize Your Class

Implement the `__init__` method to initialize your custom LLM. You'll want to initialize the base class as well and define any additional parameters for your model.

```python
class vLLMLM(BaseLLM):
    def __init__(self, model_name='default_model', tensor_parallel_size=1, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.model_name = model_name
        self.tensor_parallel_size = tensor_parallel_size
        # Add any additional initialization here
```

#### Step 4: Implement Required Methods

Implement the `run` method or any other abstract methods required by `BaseLLM`. This is where you define how your model processes input and returns output.

```python
class vLLMLM(BaseLLM):
    # ... existing code ...
    
    def run(self, task, *args, **kwargs):
        # Logic for running your model goes here
        return "Processed output"
```

#### Step 5: Test Your Model

Instantiate your custom LLM and test it to ensure that it works as expected.

```python
model = vLLMLM(model_name='my_custom_model', tensor_parallel_size=2)
output = model.run("What are the symptoms of COVID-19?")
print(output)  # Outputs: "Processed output"
```

#### Step 6: Integrate Additional Components

Depending on the requirements, you might need to integrate additional components such as database connections, parallel computing resources, or custom processing pipelines.

#### Step 7: Documentation

Write comprehensive docstrings for your class and its methods. Good documentation is crucial for maintaining the code and for other developers who might use your model.

```python
class vLLMLM(BaseLLM):
    """
    A custom language model class that extends BaseLLM.
    
    ... more detailed docstring ...
    """
    # ... existing code ...
```

#### Step 8: Best Practices

Follow best practices such as error handling, input validation, and resource management to ensure your model is robust and reliable.

#### Step 9: Packaging Your Model

Package your custom LLM class into a module or package that can be easily distributed and imported into other projects.

#### Step 10: Version Control and Collaboration

Use a version control system like Git to track changes to your model. This makes collaboration easier and helps you keep a history of your work.

### Conclusion

By following this guide, you should now have a custom model that extends the `BaseLLM`. Remember that the key to a successful custom LLM is understanding the base functionalities, implementing necessary changes, and testing thoroughly. Keep iterating and improving based on feedback and performance metrics.

### Further Reading

- Official Python documentation on abstract base classes.
- In-depth tutorials on object-oriented programming in Python.
- Advanced NLP techniques and optimization strategies for language models.

This guide provides the fundamental steps to create custom models using `BaseLLM`. For detailed implementation and advanced customization, it's essential to dive deeper into the specific functionalities and capabilities of the language model framework you are using.

--------------------------------------------------

# File: swarms/models/dalle3.md

# `Dalle3` Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Quick Start](#quick-start)
4. [Dalle3 Class](#dalle3-class)
    - [Attributes](#attributes)
    - [Methods](#methods)
5. [Usage Examples](#usage-examples)
6. [Error Handling](#error-handling)
7. [Advanced Usage](#advanced-usage)
8. [References](#references)

---

## Introduction<a name="introduction"></a>

The Dalle3 library is a Python module that provides an easy-to-use interface for generating images from text descriptions using the DALL·E 3 model by OpenAI. DALL·E 3 is a powerful language model capable of converting textual prompts into images. This documentation will guide you through the installation, setup, and usage of the Dalle3 library.

---

## Installation<a name="installation"></a>

To use the Dalle3 model, you must first install swarms:

```bash
pip install swarms
```

---

## Quick Start<a name="quick-start"></a>

Let's get started with a quick example of using the Dalle3 library to generate an image from a text prompt:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class
dalle = Dalle3()

# Define a text prompt
task = "A painting of a dog"

# Generate an image from the text prompt
image_url = dalle3(task)

# Print the generated image URL
print(image_url)
```

This example demonstrates the basic usage of the Dalle3 library to convert a text prompt into an image. The generated image URL will be printed to the console.

---

## Dalle3 Class<a name="dalle3-class"></a>

The Dalle3 library provides a `Dalle3` class that allows you to interact with the DALL·E 3 model. This class has several attributes and methods for generating images from text prompts.

### Attributes<a name="attributes"></a>

- `model` (str): The name of the DALL·E 3 model. Default: "dall-e-3".
- `img` (str): The image URL generated by the Dalle3 API.
- `size` (str): The size of the generated image. Default: "1024x1024".
- `max_retries` (int): The maximum number of API request retries. Default: 3.
- `quality` (str): The quality of the generated image. Default: "standard".
- `n` (int): The number of variations to create. Default: 4.

### Methods<a name="methods"></a>

#### `__call__(self, task: str) -> Dalle3`

This method makes a call to the Dalle3 API and returns the image URL generated from the provided text prompt.

Parameters:
- `task` (str): The text prompt to be converted to an image.

Returns:
- `Dalle3`: An instance of the Dalle3 class with the image URL generated by the Dalle3 API.

#### `create_variations(self, img: str)`

This method creates variations of an image using the Dalle3 API.

Parameters:
- `img` (str): The image to be used for the API request.

Returns:
- `img` (str): The image URL of the generated variations.

---

## Usage Examples<a name="usage-examples"></a>

### Example 1: Basic Image Generation

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class
dalle3 = Dalle3()

# Define a text prompt
task = "A painting of a dog"

# Generate an image from the text prompt
image_url = dalle3(task)

# Print the generated image URL
print(image_url)
```

### Example 2: Creating Image Variations

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class
dalle3 = Dalle3()

# Define the URL of an existing image
img_url = "https://images.unsplash.com/photo-1694734479898-6ac4633158ac?q=80&w=1287&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D

# Create variations of the image
variations_url = dalle3.create_variations(img_url)

# Print the URLs of the generated variations
print(variations_url)
```

Certainly! Here are additional examples that cover various edge cases and methods of the `Dalle3` class in the Dalle3 library:

### Example 3: Customizing Image Size

You can customize the size of the generated image by specifying the `size` parameter when creating an instance of the `Dalle3` class. Here's how to generate a smaller image:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class with a custom image size
dalle3 = Dalle3(size="512x512")

# Define a text prompt
task = "A small painting of a cat"

# Generate a smaller image from the text prompt
image_url = dalle3(task)

# Print the generated image URL
print(image_url)
```

### Example 4: Adjusting Retry Limit

You can adjust the maximum number of API request retries using the `max_retries` parameter. Here's how to increase the retry limit:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class with a higher retry limit
dalle3 = Dalle3(max_retries=5)

# Define a text prompt
task = "An image of a landscape"

# Generate an image with a higher retry limit
image_url = dalle3(task)

# Print the generated image URL
print(image_url)
```

### Example 5: Generating Image Variations

To create variations of an existing image, you can use the `create_variations` method. Here's an example:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class
dalle3 = Dalle3()

# Define the URL of an existing image
img_url = "https://images.unsplash.com/photo-1677290043066-12eccd944004?q=80&w=1287&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"

# Create variations of the image
variations_url = dalle3.create_variations(img_url)

# Print the URLs of the generated variations
print(variations_url)
```

### Example 6: Handling API Errors

The Dalle3 library provides error handling for API-related issues. Here's how to handle and display API errors:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class
dalle3 = Dalle3()

# Define a text prompt
task = "Invalid prompt that may cause an API error"

try:
    # Attempt to generate an image with an invalid prompt
    image_url = dalle3(task)
    print(image_url)
except Exception as e:
    print(f"Error occurred: {str(e)}")
```

### Example 7: Customizing Image Quality

You can customize the quality of the generated image by specifying the `quality` parameter. Here's how to generate a high-quality image:

```python
from swarm_models.dalle3 import Dalle3

# Create an instance of the Dalle3 class with high quality
dalle3 = Dalle3(quality="high")

# Define a text prompt
task = "A high-quality image of a sunset"

# Generate a high-quality image from the text prompt
image_url = dalle3(task)

# Print the generated image URL
print(image_url)
```


---

## Error Handling<a name="error-handling"></a>

The Dalle3 library provides error handling for API-related issues. If an error occurs during API communication, the library will handle it and provide detailed error messages. Make sure to handle exceptions appropriately in your code.

---

## Advanced Usage<a name="advanced-usage"></a>

For advanced usage and customization of the Dalle3 library, you can explore the attributes and methods of the `Dalle3` class. Adjusting parameters such as `size`, `max_retries`, and `quality` allows you to fine-tune the image generation process to your specific needs.

---

## References<a name="references"></a>

For more information about the DALL·E 3 model and the Dalle3 library, you can refer to the official OpenAI documentation and resources.

- [OpenAI API Documentation](https://beta.openai.com/docs/)
- [DALL·E 3 Model Information](https://openai.com/research/dall-e-3)
- [Dalle3 GitHub Repository](https://github.com/openai/dall-e-3)

---

This concludes the documentation for the Dalle3 library. You can now use the library to generate images from text prompts and explore its advanced features for various applications.

--------------------------------------------------

# File: swarms/models/distilled_whisperx.md

# DistilWhisperModel Documentation

## Overview

The `DistilWhisperModel` is a Python class designed to handle English speech recognition tasks. It leverages the capabilities of the Whisper model, which is fine-tuned for speech-to-text processes. It is designed for both synchronous and asynchronous transcription of audio inputs, offering flexibility for real-time applications or batch processing.

## Installation

Before you can use `DistilWhisperModel`, ensure you have the required libraries installed:

```sh
pip3 install --upgrade swarms
```

## Initialization

The `DistilWhisperModel` class is initialized with the following parameters:

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `model_id` | `str` | The identifier for the pre-trained Whisper model | `"distil-whisper/distil-large-v2"` |

Example of initialization:

```python
from swarm_models import DistilWhisperModel

# Initialize with default model
model_wrapper = DistilWhisperModel()

# Initialize with a specific model ID
model_wrapper = DistilWhisperModel(model_id="distil-whisper/distil-large-v2")
```

## Attributes

After initialization, the `DistilWhisperModel` has several attributes:

| Attribute | Type | Description |
|-----------|------|-------------|
| `device` | `str` | The device used for computation (`"cuda:0"` for GPU or `"cpu"`). |
| `torch_dtype` | `torch.dtype` | The data type used for the Torch tensors. |
| `model_id` | `str` | The model identifier string. |
| `model` | `torch.nn.Module` | The actual Whisper model loaded from the identifier. |
| `processor` | `transformers.AutoProcessor` | The processor for handling input data. |

## Methods

### `transcribe`

Transcribes audio input synchronously.

**Arguments**:

| Argument | Type | Description |
|----------|------|-------------|
| `inputs` | `Union[str, dict]` | File path or audio data dictionary. |

**Returns**: `str` - The transcribed text.

**Usage Example**:

```python
# Synchronous transcription
transcription = model_wrapper.transcribe("path/to/audio.mp3")
print(transcription)
```

### `async_transcribe`

Transcribes audio input asynchronously.

**Arguments**:

| Argument | Type | Description |
|----------|------|-------------|
| `inputs` | `Union[str, dict]` | File path or audio data dictionary. |

**Returns**: `Coroutine` - A coroutine that when awaited, returns the transcribed text.

**Usage Example**:

```python
import asyncio

# Asynchronous transcription
transcription = asyncio.run(model_wrapper.async_transcribe("path/to/audio.mp3"))
print(transcription)
```

### `real_time_transcribe`

Simulates real-time transcription of an audio file.

**Arguments**:

| Argument | Type | Description |
|----------|------|-------------|
| `audio_file_path` | `str` | Path to the audio file. |
| `chunk_duration` | `int` | Duration of audio chunks in seconds. |

**Usage Example**:

```python
# Real-time transcription simulation
model_wrapper.real_time_transcribe("path/to/audio.mp3", chunk_duration=5)
```

## Error Handling

The `DistilWhisperModel` class incorporates error handling for file not found errors and generic exceptions during the transcription process. If a non-recoverable exception is raised, it is printed to the console in red to indicate failure.

## Conclusion

The `DistilWhisperModel` offers a convenient interface to the powerful Whisper model for speech recognition. Its design supports both batch and real-time transcription, catering to different application needs. The class's error handling and retry logic make it robust for real-world applications.

## Additional Notes

- Ensure you have appropriate permissions to read audio files when using file paths.
- Transcription quality depends on the audio quality and the Whisper model's performance on your dataset.
- Adjust `chunk_duration` according to the processing power of your system for real-time transcription.

For a full list of models supported by `transformers.AutoModelForSpeechSeq2Seq`, visit the [Hugging Face Model Hub](https://huggingface.co/models).


--------------------------------------------------

# File: swarms/models/fuyu.md

# Fuyu Documentation

## Introduction

Welcome to the documentation for Fuyu, a versatile model for generating text conditioned on both textual prompts and images. Fuyu is based on the Adept's Fuyu model and offers a convenient way to create text that is influenced by the content of an image. In this documentation, you will find comprehensive information on the Fuyu class, its architecture, usage, and examples.

## Overview

Fuyu is a text generation model that leverages both text and images to generate coherent and contextually relevant text. It combines state-of-the-art language modeling techniques with image processing capabilities to produce text that is semantically connected to the content of an image. Whether you need to create captions for images or generate text that describes visual content, Fuyu can assist you.

## Class Definition

```python
class Fuyu:
    def __init__(
        self,
        pretrained_path: str = "adept/fuyu-8b",
        device_map: str = "cuda:0",
        max_new_tokens: int = 7,
    ):
```

## Purpose

The Fuyu class serves as a convenient interface for using the Adept's Fuyu model. It allows you to generate text based on a textual prompt and an image. The primary purpose of Fuyu is to provide a user-friendly way to create text that is influenced by visual content, making it suitable for various applications, including image captioning, storytelling, and creative text generation.

## Parameters

- `pretrained_path` (str): The path to the pretrained Fuyu model. By default, it uses the "adept/fuyu-8b" model.
- `device_map` (str): The device to use for model inference (e.g., "cuda:0" for GPU or "cpu" for CPU). Default: "cuda:0".
- `max_new_tokens` (int): The maximum number of tokens to generate in the output text. Default: 7.

## Usage

To use Fuyu, follow these steps:

1. Initialize the Fuyu instance:

```python
from swarm_models.fuyu import Fuyu

fuyu = Fuyu()
```


2. Generate Text with Fuyu:

```python
text = "Hello, my name is"
img_path = "path/to/image.png"
output_text = fuyu(text, img_path)
```

### Example 2 - Text Generation

```python
from swarm_models.fuyu import Fuyu

fuyu = Fuyu()

text = "Hello, my name is"

img_path = "path/to/image.png"

output_text = fuyu(text, img_path)
print(output_text)
```

## How Fuyu Works

Fuyu combines text and image processing to generate meaningful text outputs. Here's how it works:

1. **Initialization**: When you create a Fuyu instance, you specify the pretrained model path, the device for inference, and the maximum number of tokens to generate.

2. **Processing Text and Images**: Fuyu can process both textual prompts and images. You provide a text prompt and the path to an image as input.

3. **Tokenization**: Fuyu tokenizes the input text and encodes the image using its tokenizer.

4. **Model Inference**: The model takes the tokenized inputs and generates text that is conditioned on both the text and the image.

5. **Output Text**: Fuyu returns the generated text as the output.

## Additional Information

- Fuyu uses the Adept's Fuyu model, which is pretrained on a large corpus of text and images, making it capable of generating coherent and contextually relevant text.
- You can specify the device for inference to utilize GPU acceleration if available.
- The `max_new_tokens` parameter allows you to control the length of the generated text.

That concludes the documentation for Fuyu. We hope you find this model useful for your text generation tasks that involve images. If you have any questions or encounter any issues, please refer to the Fuyu documentation for further assistance. Enjoy working with Fuyu!

--------------------------------------------------

# File: swarms/models/gemini.md

## `Gemini` Documentation

### Introduction

The Gemini module is a versatile tool for leveraging the power of multimodal AI models to generate content. It allows users to combine textual and image inputs to generate creative and informative outputs. In this documentation, we will explore the Gemini module in detail, covering its purpose, architecture, methods, and usage examples.

#### Purpose

The Gemini module is designed to bridge the gap between text and image data, enabling users to harness the capabilities of multimodal AI models effectively. By providing both a textual task and an image as input, Gemini generates content that aligns with the specified task and incorporates the visual information from the image.

### Installation

Before using Gemini, ensure that you have the required dependencies installed. You can install them using the following commands:

```bash
pip install swarms
pip install google-generativeai
pip install python-dotenv
```

### Class: Gemini

#### Overview

The `Gemini` class is the central component of the Gemini module. It inherits from the `BaseMultiModalModel` class and provides methods to interact with the Gemini AI model. Let's dive into its architecture and functionality.

##### Class Constructor

```python
class Gemini(BaseMultiModalModel):
    def __init__(
        self,
        model_name: str = "gemini-pro",
        gemini_api_key: str = get_gemini_api_key_env,
        *args,
        **kwargs,
    ):
```

| Parameter           | Type    | Description                                                      | Default Value     |
|---------------------|---------|------------------------------------------------------------------|--------------------|
| `model_name`        | str     | The name of the Gemini model.                                    | "gemini-pro"       |
| `gemini_api_key`    | str     | The Gemini API key. If not provided, it is fetched from the environment. | (None)             |

- `model_name`: Specifies the name of the Gemini model to use. By default, it is set to "gemini-pro," but you can specify a different model if needed.

- `gemini_api_key`: This parameter allows you to provide your Gemini API key directly. If not provided, the constructor attempts to fetch it from the environment using the `get_gemini_api_key_env` helper function.

##### Methods

1. **run()**

   ```python
   def run(
       self,
       task: str = None,
       img: str = None,
       *args,
       **kwargs,
   ) -> str:
   ```

   | Parameter     | Type     | Description                                |
   |---------------|----------|--------------------------------------------|
   | `task`        | str      | The textual task for content generation.  |
   | `img`         | str      | The path to the image to be processed.    |
   | `*args`       | Variable | Additional positional arguments.           |
   | `**kwargs`    | Variable | Additional keyword arguments.              |

   - `task`: Specifies the textual task for content generation. It can be a sentence or a phrase that describes the desired content.

   - `img`: Provides the path to the image that will be processed along with the textual task. Gemini combines the visual information from the image with the textual task to generate content.

   - `*args` and `**kwargs`: Allow for additional, flexible arguments that can be passed to the underlying Gemini model. These arguments can vary based on the specific Gemini model being used.

   **Returns**: A string containing the generated content.

   **Examples**:

   ```python
   from swarm_models import Gemini

   # Initialize the Gemini model
   gemini = Gemini()

   # Generate content for a textual task with an image
   generated_content = gemini.run(
       task="Describe this image",
       img="image.jpg",
   )

   # Print the generated content
   print(generated_content)
   ```

   In this example, we initialize the Gemini model, provide a textual task, and specify an image for processing. The `run()` method generates content based on the input and returns the result.

2. **process_img()**

   ```python
   def process_img(
       self,
       img: str = None,
       type: str = "image/png",
       *args,
       **kwargs,
   ):
   ```

   | Parameter     | Type     | Description                                          | Default Value |
   |---------------|----------|------------------------------------------------------|----------------|
   | `img`         | str      | The path to the image to be processed.              | (None)         |
   | `type`        | str      | The MIME type of the image (e.g., "image/png").    | "image/png"    |
   | `*args`       | Variable | Additional positional arguments.                     |
   | `**kwargs`    | Variable | Additional keyword arguments.                        |

   - `img`: Specifies the path to the image that will be processed. It's essential to provide a valid image path for image-based content generation.

   - `type`: Indicates the MIME type of the image. By default, it is set to "image/png," but you can change it based on the image format you're using.

   - `*args` and `**kwargs`: Allow for additional, flexible arguments that can be passed to the underlying Gemini model. These arguments can vary based on the specific Gemini model being used.

   **Raises**: ValueError if any of the following conditions are met:
   - No image is provided.
   - The image type is not specified.
   - The Gemini API key is missing.

   **Examples**:

   ```python
   from swarm_models.gemini import Gemini

   # Initialize the Gemini model
   gemini = Gemini()

   # Process an image
   processed_image = gemini.process_img(
       img="image.jpg",
       type="image/jpeg",
   )

   # Further use the processed image in content generation
   generated_content = gemini.run(
       task="Describe this image",
       img=processed_image,
   )

   # Print the generated content
   print(generated_content)
   ```

   In this example, we demonstrate how to process an image using the `process_img()` method and then use the processed image in content generation.

#### Additional Information

- Gemini is designed to work seamlessly with various multimodal AI models, making it a powerful tool for content generation tasks.

- The module uses the `google.generativeai` package to access the underlying AI models. Ensure that you have this package installed to leverage the full capabilities of Gemini.

- It's essential to provide a valid Gemini API key for authentication. You can either pass it directly during initialization or store it in the environment variable "GEMINI_API_KEY."

- Gemini's flexibility allows you to experiment with different Gemini models and tailor the content generation process to your specific needs.

- Keep in mind that Gemini is designed to handle both textual and image inputs, making it a valuable asset for various applications, including natural language processing and computer vision tasks.

- If you encounter any issues or have specific requirements, refer to the Gemini documentation for more details and advanced usage.

### References and Resources

- [Gemini GitHub Repository](https://github.com/swarms/gemini): Explore the Gemini repository for additional information, updates, and examples.

- [Google GenerativeAI Documentation](https://docs.google.com/document/d/1WZSBw6GsOhOCYm0ArydD_9uy6nPPA1KFIbKPhjj43hA): Dive deeper into the capabilities of the Google GenerativeAI package used by Gemini.

- [Gemini API Documentation](https://gemini-api-docs.example.com): Access the official documentation for the Gemini API to explore advanced features and integrations.

## Conclusion

In this comprehensive documentation, we've explored the Gemini module, its purpose, architecture, methods, and usage examples. Gemini empowers developers to generate content by combining textual tasks and images, making it a valuable asset for multimodal AI applications. Whether you're working on natural language processing or computer vision projects, Gemini can help you achieve impressive results.

--------------------------------------------------

# File: swarms/models/gpt4v.md

# `GPT4VisionAPI` Documentation

**Table of Contents**
- [Introduction](#introduction)
- [Installation](#installation)
- [Module Overview](#module-overview)
- [Class: GPT4VisionAPI](#class-gpt4visionapi)
  - [Initialization](#initialization)
  - [Methods](#methods)
    - [encode_image](#encode_image)
    - [run](#run)
    - [__call__](#__call__)
- [Examples](#examples)
  - [Example 1: Basic Usage](#example-1-basic-usage)
  - [Example 2: Custom API Key](#example-2-custom-api-key)
  - [Example 3: Adjusting Maximum Tokens](#example-3-adjusting-maximum-tokens)
- [Additional Information](#additional-information)
- [References](#references)

## Introduction<a name="introduction"></a>

Welcome to the documentation for the `GPT4VisionAPI` module! This module is a powerful wrapper for the OpenAI GPT-4 Vision model. It allows you to interact with the model to generate descriptions or answers related to images. This documentation will provide you with comprehensive information on how to use this module effectively.

## Installation<a name="installation"></a>

Before you start using the `GPT4VisionAPI` module, make sure you have the required dependencies installed. You can install them using the following commands:

```bash
pip3 install --upgrade swarms
```

## Module Overview<a name="module-overview"></a>

The `GPT4VisionAPI` module serves as a bridge between your application and the OpenAI GPT-4 Vision model. It allows you to send requests to the model and retrieve responses related to images. Here are some key features and functionality provided by this module:

- Encoding images to base64 format.
- Running the GPT-4 Vision model with specified tasks and images.
- Customization options such as setting the OpenAI API key and maximum token limit.

## Class: GPT4VisionAPI<a name="class-gpt4visionapi"></a>

The `GPT4VisionAPI` class is the core component of this module. It encapsulates the functionality required to interact with the GPT-4 Vision model. Below, we'll dive into the class in detail.

### Initialization<a name="initialization"></a>

When initializing the `GPT4VisionAPI` class, you have the option to provide the OpenAI API key and set the maximum token limit. Here are the parameters and their descriptions:

| Parameter           | Type     | Default Value                 | Description                                                                                              |
|---------------------|----------|-------------------------------|----------------------------------------------------------------------------------------------------------|
| openai_api_key      | str      | `OPENAI_API_KEY` environment variable (if available) | The OpenAI API key. If not provided, it defaults to the `OPENAI_API_KEY` environment variable.       |
| max_tokens          | int      | 300                           | The maximum number of tokens to generate in the model's response.                                        |

Here's how you can initialize the `GPT4VisionAPI` class:

```python
from swarm_models import GPT4VisionAPI

# Initialize with default API key and max_tokens
api = GPT4VisionAPI()

# Initialize with custom API key and max_tokens
custom_api_key = "your_custom_api_key"
api = GPT4VisionAPI(openai_api_key=custom_api_key, max_tokens=500)
```

### Methods<a name="methods"></a>

#### encode_image<a name="encode_image"></a>

This method allows you to encode an image from a URL to base64 format. It's a utility function used internally by the module.

```python
def encode_image(img: str) -> str:
    """
    Encode image to base64.

    Parameters:
    - img (str): URL of the image to encode.

    Returns:
    str: Base64 encoded image.
    """
```

#### run<a name="run"></a>

The `run` method is the primary way to interact with the GPT-4 Vision model. It sends a request to the model with a task and an image URL, and it returns the model's response.

```python
def run(task: str, img: str) -> str:
    """
    Run the GPT-4 Vision model.

    Parameters:
    - task (str): The task or question related to the image.
    - img (str): URL of the image to analyze.

    Returns:
    str: The model's response.
    """
```

#### __call__<a name="__call__"></a>

The `__call__` method is a convenient way to run the GPT-4 Vision model. It has the same functionality as the `run` method.

```python
def __call__(task: str, img: str) -> str:
    """
       Run the GPT-4 Vision model (callable).

       Parameters:
       - task (str): The task or question related to the image.
       - img

    (str): URL of the image to analyze.

       Returns:
       str: The model's response.
    """
```

## Examples<a name="examples"></a>

Let's explore some usage examples of the `GPT4VisionAPI` module to better understand how to use it effectively.

### Example 1: Basic Usage<a name="example-1-basic-usage"></a>

In this example, we'll use the module with the default API key and maximum tokens to analyze an image.

```python
from swarm_models import GPT4VisionAPI

# Initialize with default API key and max_tokens
api = GPT4VisionAPI()

# Define the task and image URL
task = "What is the color of the object?"
img = "https://i.imgur.com/2M2ZGwC.jpeg"

# Run the GPT-4 Vision model
response = api.run(task, img)

# Print the model's response
print(response)
```

### Example 2: Custom API Key<a name="example-2-custom-api-key"></a>

If you have a custom API key, you can initialize the module with it as shown in this example.

```python
from swarm_models import GPT4VisionAPI

# Initialize with custom API key and max_tokens
custom_api_key = "your_custom_api_key"
api = GPT4VisionAPI(openai_api_key=custom_api_key, max_tokens=500)

# Define the task and image URL
task = "What is the object in the image?"
img = "https://i.imgur.com/3T3ZHwD.jpeg"

# Run the GPT-4 Vision model
response = api.run(task, img)

# Print the model's response
print(response)
```

### Example 3: Adjusting Maximum Tokens<a name="example-3-adjusting-maximum-tokens"></a>

You can also customize the maximum token limit when initializing the module. In this example, we set it to 1000 tokens.

```python
from swarm_models import GPT4VisionAPI

# Initialize with default API key and custom max_tokens
api = GPT4VisionAPI(max_tokens=1000)

# Define the task and image URL
task = "Describe the scene in the image."
img = "https://i.imgur.com/4P4ZRxU.jpeg"

# Run the GPT-4 Vision model
response = api.run(task, img)

# Print the model's response
print(response)
```

## Additional Information<a name="additional-information"></a>

- If you encounter any errors or issues with the module, make sure to check your API key and internet connectivity.
- It's recommended to handle exceptions when using the module to gracefully handle errors.
- You can further customize the module to fit your specific use case by modifying the code as needed.

## References<a name="references"></a>

- [OpenAI API Documentation](https://beta.openai.com/docs/)

This documentation provides a comprehensive guide on how to use the `GPT4VisionAPI` module effectively. It covers initialization, methods, usage examples, and additional information to ensure a smooth experience when working with the GPT-4 Vision model.

--------------------------------------------------

# File: swarms/models/groq.md

# Groq API Key Setup Documentation


This documentation provides instructions on how to obtain your Groq API key and set it up in a `.env` file for use in your project.

## Step 1: Obtain Your Groq API Key

1. **Sign Up / Log In**: 
   - Visit the [Groq website](https://www.groq.com) and sign up for an account if you don't have one. If you already have an account, log in.

2. **Access API Keys**:
   - Once logged in, navigate to the API section of your account dashboard. This is usually found under "Settings" or "API Management".

3. **Generate API Key**:
   - If you do not have an API key, look for an option to generate a new key. Follow the prompts to create your API key. Make sure to copy it to your clipboard.

## Step 2: Create a `.env` File

1. **Create the File**:
   - In the root directory of your project, create a new file named `.env`.

2. **Add Your API Key**:
   - Open the `.env` file in a text editor and add the following line, replacing `your_groq_api_key_here` with the API key you copied earlier:

   ```plaintext
   GROQ_API_KEY=your_groq_api_key_here
   ```

3. **Save the File**:
   - Save the changes to the `.env` file.



## Full Example
```python
import os
from swarm_models import OpenAIChat
from dotenv import load_dotenv

load_dotenv()

# Get the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Model
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)

model.run("What are the best metrics to track and understand risk in private equity")
```

## Important Notes

- **Keep Your API Key Secure**: Do not share your API key publicly or commit it to version control systems like Git. Use the `.gitignore` file to exclude the `.env` file from being tracked.
- **Environment Variables**: Make sure to install any necessary libraries (like `python-dotenv`) to load environment variables from the `.env` file if your project requires it.


## Conclusion

You are now ready to use the Groq API in your project! If you encounter any issues, refer to the Groq documentation or support for further assistance.


--------------------------------------------------

# File: swarms/models/hf.md

# HuggingFaceLLM 

## Overview & Introduction

The `HuggingFaceLLM` class in the Zeta library provides a simple and easy-to-use interface to harness the power of Hugging Face's transformer-based language models, specifically for causal language modeling. This enables developers to generate coherent and contextually relevant sentences or paragraphs given a prompt, without delving deep into the intricate details of the underlying model or the tokenization process.

Causal Language Modeling (CLM) is a task where given a series of tokens (or words), the model predicts the next token in the sequence. This functionality is central to many natural language processing tasks, including chatbots, story generation, and code autocompletion.

---

## Class Definition

```python
class HuggingFaceLLM:
```

### Parameters:

- `model_id (str)`: Identifier for the pre-trained model on the Hugging Face model hub. Examples include "gpt2-medium", "openai-gpt", etc.
  
- `device (str, optional)`: The device on which to load and run the model. Defaults to 'cuda' if GPU is available, else 'cpu'.
  
- `max_length (int, optional)`: Maximum length of the generated sequence. Defaults to 20.
  
- `quantization_config (dict, optional)`: Configuration dictionary for model quantization (if applicable). Default is `None`.

---

## Functionality & Usage

### Initialization:

```python
llm = HuggingFaceLLM(model_id="gpt2-medium")
```

Upon initialization, the specified pre-trained model and tokenizer are loaded from Hugging Face's model hub. The model is then moved to the designated device. If there's an issue loading either the model or the tokenizer, an error will be logged.

### Generation:

The main functionality of this class is text generation. The class provides two methods for this: `__call__` and `generate`. Both methods take in a prompt text and an optional `max_length` parameter and return the generated text.

Usage:
```python
from swarms import HuggingFaceLLM

# Initialize
llm = HuggingFaceLLM(model_id="gpt2-medium")

# Generate text using __call__ method
result = llm("Once upon a time,")
print(result)

# Alternatively, using the generate method
result = llm.generate("The future of AI is")
print(result)
```

---

## Mathematical Explanation:

Given a sequence of tokens \( x_1, x_2, ..., x_n \), a causal language model aims to maximize the likelihood of the next token \( x_{n+1} \) in the sequence. Formally, it tries to optimize:

\[ P(x_{n+1} | x_1, x_2, ..., x_n) \]

Where \( P \) is the probability distribution over all possible tokens in the vocabulary.

The model takes the tokenized input sequence, feeds it through several transformer blocks, and finally through a linear layer to produce logits for each token in the vocabulary. The token with the highest logit value is typically chosen as the next token in the sequence.

---

## Additional Information & Tips:

- Ensure you have an active internet connection when initializing the class for the first time, as the models and tokenizers are fetched from Hugging Face's servers.

- Although the default `max_length` is set to 20, it's advisable to adjust this parameter based on the context of the problem.

- Keep an eye on GPU memory when using large models or generating long sequences.

---

## References & Resources:

- Hugging Face Model Hub: [https://huggingface.co/models](https://huggingface.co/models)
  
- Introduction to Transformers: [https://huggingface.co/transformers/introduction.html](https://huggingface.co/transformers/introduction.html)

- Causal Language Modeling: Vaswani, A., et al. (2017). Attention is All You Need. [arXiv:1706.03762](https://arxiv.org/abs/1706.03762)

Note: This documentation template provides a comprehensive overview of the `HuggingFaceLLM` class. Developers can follow similar structures when documenting other classes or functionalities.

--------------------------------------------------

# File: swarms/models/huggingface.md

## `HuggingfaceLLM` Documentation

### Introduction

The `HuggingfaceLLM` class is designed for running inference using models from the Hugging Face Transformers library. This documentation provides an in-depth understanding of the class, its purpose, attributes, methods, and usage examples.

#### Purpose

The `HuggingfaceLLM` class serves the following purposes:

1. Load pre-trained Hugging Face models and tokenizers.
2. Generate text-based responses from the loaded model using a given prompt.
3. Provide flexibility in device selection, quantization, and other configuration options.

### Class Definition

The `HuggingfaceLLM` class is defined as follows:

```python
class HuggingfaceLLM:
    def __init__(
        self,
        model_id: str,
        device: str = None,
        max_length: int = 20,
        quantize: bool = False,
        quantization_config: dict = None,
        verbose=False,
        distributed=False,
        decoding=False,
    ):
        # Attributes and initialization logic explained below
        pass

    def load_model(self):
        # Method to load the pre-trained model and tokenizer
        pass

    def run(self, prompt_text: str, max_length: int = None):
        # Method to generate text-based responses
        pass

    def __call__(self, prompt_text: str, max_length: int = None):
        # Alternate method for generating text-based responses
        pass
```

### Attributes

| Attribute            | Description                                                                                                               |
|----------------------|---------------------------------------------------------------------------------------------------------------------------|
| `model_id`           | The ID of the pre-trained model to be used.                                                                              |
| `device`             | The device on which the model runs (`'cuda'` for GPU or `'cpu'` for CPU).                                              |
| `max_length`         | The maximum length of the generated text.                                                                                |
| `quantize`           | A boolean indicating whether quantization should be used.                                                               |
| `quantization_config`| A dictionary with configuration options for quantization.                                                                |
| `verbose`            | A boolean indicating whether verbose logs should be printed.                                                             |
| `logger`             | An optional logger for logging messages (defaults to a basic logger).                                                   |
| `distributed`        | A boolean indicating whether distributed processing should be used.                                                     |
| `decoding`           | A boolean indicating whether to perform decoding during text generation.                                                  |

### Class Methods

#### `__init__` Method

The `__init__` method initializes an instance of the `HuggingfaceLLM` class with the specified parameters. It also loads the pre-trained model and tokenizer.

- `model_id` (str): The ID of the pre-trained model to use.
- `device` (str, optional): The device to run the model on ('cuda' or 'cpu').
- `max_length` (int, optional): The maximum length of the generated text.
- `quantize` (bool, optional): Whether to use quantization.
- `quantization_config` (dict, optional): Configuration for quantization.
- `verbose` (bool, optional): Whether to print verbose logs.
- `logger` (logging.Logger, optional): The logger to use.
- `distributed` (bool, optional): Whether to use distributed processing.
- `decoding` (bool, optional): Whether to perform decoding during text generation.

#### `load_model` Method

The `load_model` method loads the pre-trained model and tokenizer specified by `model_id`.

#### `run` and `__call__` Methods

Both `run` and `__call__` methods generate text-based responses based on a given prompt. They accept the following parameters:

- `prompt_text` (str): The text prompt to initiate text generation.
- `max_length` (int, optional): The maximum length of the generated text.

### Usage Examples

Here are three ways to use the `HuggingfaceLLM` class:

#### Example 1: Basic Usage

```python
from swarm_models import HuggingfaceLLM

# Initialize the HuggingfaceLLM instance with a model ID
model_id = "NousResearch/Nous-Hermes-2-Vision-Alpha"
inference = HuggingfaceLLM(model_id=model_id)

# Generate text based on a prompt
prompt_text = "Once upon a time"
generated_text = inference(prompt_text)
print(generated_text)
```

#### Example 2: Custom Configuration

```python
from swarm_models import HuggingfaceLLM

# Initialize with custom configuration
custom_config = {
    "quantize": True,
    "quantization_config": {"load_in_4bit": True},
    "verbose": True,
}
inference = HuggingfaceLLM(
    model_id="NousResearch/Nous-Hermes-2-Vision-Alpha", **custom_config
)

# Generate text based on a prompt
prompt_text = "Tell me a joke"
generated_text = inference(prompt_text)
print(generated_text)
```

#### Example 3: Distributed Processing

```python
from swarm_models import HuggingfaceLLM

# Initialize for distributed processing
inference = HuggingfaceLLM(model_id="gpt2-medium", distributed=True)

# Generate text based on a prompt
prompt_text = "Translate the following sentence to French"
generated_text = inference(prompt_text)
print(generated_text)
```

### Additional Information

- The `HuggingfaceLLM` class provides the flexibility to load and use pre-trained models from the Hugging Face Transformers library.
- Quantization can be enabled to reduce model size and inference time.
- Distributed processing can be used for parallelized inference.
- Verbose logging can help in debugging and understanding the text generation process.

### References

- [Hugging Face Transformers Documentation](https://huggingface.co/transformers/)
- [PyTorch Documentation](https://pytorch.org/docs/stable/index.html)

This documentation provides a comprehensive understanding of the `HuggingfaceLLM` class, its attributes, methods, and usage examples. Developers can use this class to perform text generation tasks efficiently using pre-trained models from the Hugging Face Transformers library.

--------------------------------------------------

# File: swarms/models/idefics.md

# `Idefics` Documentation

## Introduction

Welcome to the documentation for Idefics, a versatile multimodal inference tool using pre-trained models from the Hugging Face Hub. Idefics is designed to facilitate the generation of text from various prompts, including text and images. This documentation provides a comprehensive understanding of Idefics, its architecture, usage, and how it can be integrated into your projects.

## Overview

Idefics leverages the power of pre-trained models to generate textual responses based on a wide range of prompts. It is capable of handling both text and images, making it suitable for various multimodal tasks, including text generation from images.

## Class Definition

```python
class Idefics:
    def __init__(
        self,
        checkpoint="HuggingFaceM4/idefics-9b-instruct",
        device=None,
        torch_dtype=torch.bfloat16,
        max_length=100,
    ):
```

## Usage

To use Idefics, follow these steps:

1. Initialize the Idefics instance:

```python
from swarm_models import Idefics

model = Idefics()
```

2. Generate text based on prompts:

```python
prompts = [
    "User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG"
]
response = model(prompts)
print(response)
```

### Example 1 - Image Questioning

```python
from swarm_models import Idefics

model = Idefics()
prompts = [
    "User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG"
]
response = model(prompts)
print(response)
```

### Example 2 - Bidirectional Conversation

```python
from swarm_models import Idefics

model = Idefics()
user_input = "User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG"
response = model.chat(user_input)
print(response)

user_input = "User: Who is that? https://static.wikia.nocookie.net/asterix/images/2/25/R22b.gif/revision/latest?cb=20110815073052"
response = model.chat(user_input)
print(response)
```

### Example 3 - Configuration Changes

```python
model.set_checkpoint("new_checkpoint")
model.set_device("cpu")
model.set_max_length(200)
model.clear_chat_history()
```

## How Idefics Works

Idefics operates by leveraging pre-trained models from the Hugging Face Hub. Here's how it works:

1. **Initialization**: When you create an Idefics instance, it initializes the model using a specified checkpoint, sets the device for inference, and configures other parameters like data type and maximum text length.

2. **Prompt-Based Inference**: You can use the `infer` method to generate text based on prompts. It processes prompts in batched or non-batched mode, depending on your preference. It uses a pre-trained processor to handle text and images.

3. **Bidirectional Conversation**: The `chat` method enables bidirectional conversations. You provide user input, and the model responds accordingly. The chat history is maintained for context.

4. **Configuration Changes**: You can change the model checkpoint, device, maximum text length, or clear the chat history as needed during runtime.

## Parameters

- `checkpoint`: The name of the pre-trained model checkpoint (default is "HuggingFaceM4/idefics-9b-instruct").
- `device`: The device to use for inference. By default, it uses CUDA if available; otherwise, it uses CPU.
- `torch_dtype`: The data type to use for inference. By default, it uses torch.bfloat16.
- `max_length`: The maximum length of the generated text (default is 100).

## Additional Information

- Idefics provides a convenient way to engage in bidirectional conversations with pre-trained models.
- You can easily change the model checkpoint, device, and other settings to adapt to your specific use case.

That concludes the documentation for Idefics. We hope you find this tool valuable for your multimodal text generation tasks. If you have any questions or encounter any issues, please refer to the Hugging Face Transformers documentation for further assistance. Enjoy working with Idefics!

--------------------------------------------------

# File: swarms/models/index.md

# Swarm Models


```bash
$ pip3 install -U swarm-models
```

Welcome to the documentation for the llm section of the swarms package, designed to facilitate seamless integration with various AI language models and APIs. This package empowers developers, end-users, and system administrators to interact with AI models from different providers, such as OpenAI, Hugging Face, Google PaLM, and Anthropic.

### Table of Contents
1. [OpenAI](#openai)
2. [HuggingFace](#huggingface)
3. [Anthropic](#anthropic)

### 1. OpenAI (swarm_models.OpenAI)

The OpenAI class provides an interface to interact with OpenAI's language models. It allows both synchronous and asynchronous interactions.

**Constructor:**
```python
OpenAI(api_key: str, system: str = None, console: bool = True, model: str = None, params: dict = None, save_messages: bool = True)
```

**Attributes:**
- `api_key` (str): Your OpenAI API key.

- `system` (str, optional): A system message to be used in conversations.

- `console` (bool, default=True): Display console logs.

- `model` (str, optional): Name of the language model to use.

- `params` (dict, optional): Additional parameters for model interactions.

- `save_messages` (bool, default=True): Save conversation messages.

**Methods:**

- `run(message: str, **kwargs) -> str`: Generate a response using the OpenAI model.

- `generate_async(message: str, **kwargs) -> str`: Generate a response asynchronously.

- `ask_multiple(ids: List[str], question_template: str) -> List[str]`: Query multiple IDs simultaneously.

- `stream_multiple(ids: List[str], question_template: str) -> List[str]`: Stream multiple responses.

**Usage Example:**
```python
import asyncio

from swarm_models import OpenAI

chat = OpenAI(api_key="YOUR_OPENAI_API_KEY")

response = chat.run("Hello, how can I assist you?")
print(response)

ids = ["id1", "id2", "id3"]
async_responses = asyncio.run(chat.ask_multiple(ids, "How is {id}?"))
print(async_responses)
```

### 2. HuggingFace (swarm_models.HuggingFaceLLM)

The HuggingFaceLLM class allows interaction with language models from Hugging Face.

**Constructor:**
```python
HuggingFaceLLM(model_id: str, device: str = None, max_length: int = 20, quantize: bool = False, quantization_config: dict = None)
```

**Attributes:**

- `model_id` (str): ID or name of the Hugging Face model.

- `device` (str, optional): Device to run the model on (e.g., 'cuda', 'cpu').

- `max_length` (int, default=20): Maximum length of generated text.

- `quantize` (bool, default=False): Apply model quantization.

- `quantization_config` (dict, optional): Configuration for quantization.

**Methods:**

- `run(prompt_text: str, max_length: int = None) -> str`: Generate text based on a prompt.

**Usage Example:**
```python
from swarm_models import HuggingFaceLLM

model_id = "gpt2"
hugging_face_model = HuggingFaceLLM(model_id=model_id)

prompt = "Once upon a time"
generated_text = hugging_face_model.run(prompt)
print(generated_text)
```

### 3. Anthropic (swarm_models.Anthropic)

The Anthropic class enables interaction with Anthropic's large language models.

**Constructor:**
```python
Anthropic(model: str = "claude-2", max_tokens_to_sample: int = 256, temperature: float = None, top_k: int = None, top_p: float = None, streaming: bool = False, default_request_timeout: int = None)
```

**Attributes:**

- `model` (str): Name of the Anthropic model.

- `max_tokens_to_sample` (int, default=256): Maximum tokens to sample.

- `temperature` (float, optional): Temperature for text generation.

- `top_k` (int, optional): Top-k sampling value.

- `top_p` (float, optional): Top-p sampling value.

- `streaming` (bool, default=False): Enable streaming mode.

- `default_request_timeout` (int, optional): Default request timeout.

**Methods:**

- `run(prompt: str, stop: List[str] = None) -> str`: Generate text based on a prompt.

**Usage Example:**
```python
from swarm_models import Anthropic

anthropic = Anthropic()
prompt = "Once upon a time"
generated_text = anthropic.run(prompt)
print(generated_text)
```

This concludes the documentation for the "models" folder, providing you with tools to seamlessly integrate with various language models and APIs. Happy coding!

--------------------------------------------------

# File: swarms/models/kosmos.md

# `Kosmos` Documentation

## Introduction

Welcome to the documentation for Kosmos, a powerful multimodal AI model that can perform various tasks, including multimodal grounding, referring expression comprehension, referring expression generation, grounded visual question answering (VQA), and grounded image captioning. Kosmos is based on the ydshieh/kosmos-2-patch14-224 model and is designed to process both text and images to provide meaningful outputs. In this documentation, you will find a detailed explanation of the Kosmos class, its functions, parameters, and usage examples.

## Overview

Kosmos is a state-of-the-art multimodal AI model that combines the power of natural language understanding with image analysis. It can perform several tasks that involve processing both textual prompts and images to provide informative responses. Whether you need to find objects in an image, understand referring expressions, generate descriptions, answer questions, or create captions, Kosmos has you covered.

## Class Definition

```python
class Kosmos:
    def __init__(self, model_name="ydshieh/kosmos-2-patch14-224"):
```

## Usage

To use Kosmos, follow these steps:

1. Initialize the Kosmos instance:

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()
```

2. Perform Multimodal Grounding:

```python
kosmos.multimodal_grounding(
    "Find the red apple in the image.", "https://example.com/apple.jpg"
)
```

### Example 1 - Multimodal Grounding

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.multimodal_grounding(
    "Find the red apple in the image.", "https://example.com/apple.jpg"
)
```

3. Perform Referring Expression Comprehension:

```python
kosmos.referring_expression_comprehension(
    "Show me the green bottle.", "https://example.com/bottle.jpg"
)
```

### Example 2 - Referring Expression Comprehension

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.referring_expression_comprehension(
    "Show me the green bottle.", "https://example.com/bottle.jpg"
)
```

4. Generate Referring Expressions:

```python
kosmos.referring_expression_generation(
    "It is on the table.", "https://example.com/table.jpg"
)
```

### Example 3 - Referring Expression Generation

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.referring_expression_generation(
    "It is on the table.", "https://example.com/table.jpg"
)
```

5. Perform Grounded Visual Question Answering (VQA):

```python
kosmos.grounded_vqa("What is the color of the car?", "https://example.com/car.jpg")
```

### Example 4 - Grounded Visual Question Answering

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.grounded_vqa("What is the color of the car?", "https://example.com/car.jpg")
```

6. Generate Grounded Image Captions:

```python
kosmos.grounded_image_captioning("https://example.com/beach.jpg")
```

### Example 5 - Grounded Image Captioning

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.grounded_image_captioning("https://example.com/beach.jpg")
```

7. Generate Detailed Grounded Image Captions:

```python
kosmos.grounded_image_captioning_detailed("https://example.com/beach.jpg")
```

### Example 6 - Detailed Grounded Image Captioning

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

kosmos.grounded_image_captioning_detailed("https://example.com/beach.jpg")
```

8. Draw Entity Boxes on Image:

```python
image = kosmos.get_image("https://example.com/image.jpg")
entities = [
    ("apple", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),
    ("banana", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),
]
kosmos.draw_entity_boxes_on_image(image, entities, show=True)
```

### Example 7 - Drawing Entity Boxes on Image

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()

image = kosmos.get_image("https://example.com/image.jpg")
entities = [
    ("apple", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),
    ("banana", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),
]
kosmos.draw_entity_boxes_on_image(image, entities, show=True)
```

9. Generate Boxes for Entities:

```python
entities = [
    ("apple", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),
    ("banana", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),
]
image = kosmos.generate_boxes(
    "Find the apple and the banana in the image.", "https://example.com/image.jpg"
)
```

### Example 8 - Generating Boxes for Entities

```python
from swarm_models.kosmos_two import Kosmos

kosmos = Kosmos()
entities = [
    ("apple", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),
    ("banana", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),
]
image = kosmos.generate_boxes(
    "Find the apple and the banana in the image.", "https://example.com/image.jpg"
)
```

## How Kosmos Works

Kosmos is a multimodal AI model that combines text and image processing. It uses the ydshieh/kosmos-2-patch14-224 model for understanding and generating responses. Here's how it works:

1. **Initialization**: When you create a Kosmos instance, it loads the ydshieh/kosmos-2-patch14-224 model for multimodal tasks.

2. **Processing Text and Images**: Kosmos can process both text prompts and images. It takes a textual prompt and an image URL as input.

3. **Task Execution**: Based on the task you specify, Kosmos generates informative responses by combining natural language understanding with image analysis.

4. **Drawing Entity Boxes**: You can use the `draw_entity_boxes_on_image` method to draw bounding boxes around entities in an image.

5. **Generating Boxes for Entities**: The `generate_boxes` method allows you to generate bounding boxes for entities mentioned in a prompt.

## Parameters

- `model_name`: The name or path of the Kosmos model to be used. By default, it uses the ydshieh/kosmos-2-patch14-224 model.

## Additional Information

- Kosmos can handle various multimodal tasks, making it a versatile tool for understanding and generating content.
- You can provide image URLs for image-based tasks, and Kosmos will automatically retrieve and process the images.
- The `draw_entity_boxes_on_image` method is useful for visualizing the results of multimodal grounding tasks.
- The `generate_boxes` method is handy for generating bounding boxes around entities mentioned in a textual prompt.

That concludes the documentation for Kosmos. We hope you find this multimodal AI model valuable for your projects. If you have any questions or encounter any issues, please refer to the Kosmos documentation for
further assistance. Enjoy working with Kosmos!


--------------------------------------------------

# File: swarms/models/langchain.md



--------------------------------------------------

# File: swarms/models/layoutlm_document_qa.md

# `LayoutLMDocumentQA` Documentation

## Introduction

Welcome to the documentation for LayoutLMDocumentQA, a multimodal model designed for visual question answering (QA) on real-world documents, such as invoices, PDFs, and more. This comprehensive documentation will provide you with a deep understanding of the LayoutLMDocumentQA class, its architecture, usage, and examples.

## Overview

LayoutLMDocumentQA is a versatile model that combines layout-based understanding of documents with natural language processing to answer questions about the content of documents. It is particularly useful for automating tasks like invoice processing, extracting information from PDFs, and handling various document-based QA scenarios.

## Class Definition

```python
class LayoutLMDocumentQA(AbstractModel):
    def __init__(
        self, 
        model_name: str = "impira/layoutlm-document-qa",
        task: str = "document-question-answering",
    ):
```

## Purpose

The LayoutLMDocumentQA class serves the following primary purposes:

1. **Document QA**: LayoutLMDocumentQA is specifically designed for document-based question answering. It can process both the textual content and the layout of a document to answer questions.

2. **Multimodal Understanding**: It combines natural language understanding with document layout analysis, making it suitable for documents with complex structures.

## Parameters

- `model_name` (str): The name or path of the pretrained LayoutLMDocumentQA model. Default: "impira/layoutlm-document-qa".
- `task` (str): The specific task for which the model will be used. Default: "document-question-answering".

## Usage

To use LayoutLMDocumentQA, follow these steps:

1. Initialize the LayoutLMDocumentQA instance:

```python
from swarm_models import LayoutLMDocumentQA

layout_lm_doc_qa = LayoutLMDocumentQA()
```

### Example 1 - Initialization

```python
layout_lm_doc_qa = LayoutLMDocumentQA()
```

2. Ask a question about a document and provide the document's image path:

```python
question = "What is the total amount?"
image_path = "path/to/document_image.png"
answer = layout_lm_doc_qa(question, image_path)
```

### Example 2 - Document QA

```python
layout_lm_doc_qa = LayoutLMDocumentQA()
question = "What is the total amount?"
image_path = "path/to/document_image.png"
answer = layout_lm_doc_qa(question, image_path)
```

## How LayoutLMDocumentQA Works

LayoutLMDocumentQA employs a multimodal approach to document QA. Here's how it works:

1. **Initialization**: When you create a LayoutLMDocumentQA instance, you can specify the model to use and the task, which is "document-question-answering" by default.

2. **Question and Document**: You provide a question about the document and the image path of the document to the LayoutLMDocumentQA instance.

3. **Multimodal Processing**: LayoutLMDocumentQA processes both the question and the document image. It combines layout-based analysis with natural language understanding.

4. **Answer Generation**: The model generates an answer to the question based on its analysis of the document layout and content.

## Additional Information

- LayoutLMDocumentQA uses the "impira/layoutlm-document-qa" pretrained model, which is specifically designed for document-based question answering.
- You can adapt this model to various document QA scenarios by changing the task and providing relevant questions and documents.
- This model is particularly useful for automating document-based tasks and extracting valuable information from structured documents.

That concludes the documentation for LayoutLMDocumentQA. We hope you find this tool valuable for your document-based question answering needs. If you have any questions or encounter any issues, please refer to the LayoutLMDocumentQA documentation for further assistance. Enjoy using LayoutLMDocumentQA!

--------------------------------------------------

# File: swarms/models/llama3.md

## Llava3


```python
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch
from swarm_models.base_llm import BaseLLM


class Llama3(BaseLLM):
    """
    Llama3 class represents a Llama model for natural language generation.

        Args:
            model_id (str): The ID of the Llama model to use.
            system_prompt (str): The system prompt to use for generating responses.
            temperature (float): The temperature value for controlling the randomness of the generated responses.
            top_p (float): The top-p value for controlling the diversity of the generated responses.
            max_tokens (int): The maximum number of tokens to generate in the response.
            **kwargs: Additional keyword arguments.

        Attributes:
            model_id (str): The ID of the Llama model being used.
            system_prompt (str): The system prompt for generating responses.
            temperature (float): The temperature value for generating responses.
            top_p (float): The top-p value for generating responses.
            max_tokens (int): The maximum number of tokens to generate in the response.
            tokenizer (AutoTokenizer): The tokenizer for the Llama model.
            model (AutoModelForCausalLM): The Llama model for generating responses.

        Methods:
            run(task, *args, **kwargs): Generates a response for the given task.

    """

    def __init__(
        self,
        model_id="meta-llama/Meta-Llama-3-8B-Instruct",
        system_prompt: str = None,
        temperature: float = 0.6,
        top_p: float = 0.9,
        max_tokens: int = 4000,
        **kwargs,
    ):
        self.model_id = model_id
        self.system_prompt = system_prompt
        self.temperature = temperature
        self.top_p = top_p
        self.max_tokens = max_tokens
        self.tokenizer = AutoTokenizer.from_pretrained(model_id)
        self.model = AutoModelForCausalLM.from_pretrained(
            model_id,
            torch_dtype=torch.bfloat16,
            device_map="auto",
        )

    def run(self, task: str, *args, **kwargs):
        """
        Generates a response for the given task.

        Args:
            task (str): The user's task or input.

        Returns:
            str: The generated response.

        """
        messages = [
            {"role": "system", "content": self.system_prompt},
            {"role": "user", "content": task},
        ]

        input_ids = self.tokenizer.apply_chat_template(
            messages, add_generation_prompt=True, return_tensors="pt"
        ).to(self.model.device)

        terminators = [
            self.tokenizer.eos_token_id,
            self.tokenizer.convert_tokens_to_ids("<|eot_id|>"),
        ]

        outputs = self.model.generate(
            input_ids,
            max_new_tokens=self.max_tokens,
            eos_token_id=terminators,
            do_sample=True,
            temperature=self.temperature,
            top_p=self.top_p,
            *args,
            **kwargs,
        )
        response = outputs[0][input_ids.shape[-1] :]
        return self.tokenizer.decode(
            response, skip_special_tokens=True
        )
```

--------------------------------------------------

# File: swarms/models/models_available_overview.md

## The Swarms Framework: A Comprehensive Guide to Model APIs and Usage

### Introduction

The Swarms framework is a versatile and robust tool designed to streamline the integration and orchestration of multiple AI models, making it easier for developers to build sophisticated multi-agent systems. This blog aims to provide a detailed guide on using the Swarms framework, covering the various models it supports, common methods, settings, and practical examples.

### Overview of the Swarms Framework

Swarms is a "framework of frameworks" that allows seamless integration of various AI models, including those from OpenAI, Anthropic, Hugging Face, Azure, and more. This flexibility enables users to leverage the strengths of different models within a single application. The framework provides a unified interface for model interaction, simplifying the process of integrating and managing multiple AI models.

### Getting Started with Swarms

To get started with Swarms, you need to install the framework and set up the necessary environment variables. Here's a step-by-step guide:

#### Installation

You can install the Swarms framework using pip:

```bash
pip install swarms
```

#### Setting Up Environment Variables

Swarms relies on environment variables to manage API keys and other configurations. You can use the `dotenv` package to load these variables from a `.env` file.

```bash
pip install python-dotenv
```

Create a `.env` file in your project directory and add your API keys and other settings:

```env
OPENAI_API_KEY=your_openai_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
AZURE_OPENAI_ENDPOINT=your_azure_openai_endpoint
AZURE_OPENAI_DEPLOYMENT=your_azure_openai_deployment
OPENAI_API_VERSION=your_openai_api_version
AZURE_OPENAI_API_KEY=your_azure_openai_api_key
AZURE_OPENAI_AD_TOKEN=your_azure_openai_ad_token
```

### Using the Swarms Framework

Swarms supports a variety of models from different providers. Here are some examples of how to use these models within the Swarms framework.

#### Using the Anthropic Model

The Anthropic model is one of the many models supported by Swarms. Here's how you can use it:

```python
import os
from swarm_models import Anthropic

# Load the environment variables
anthropic_api_key = os.getenv("ANTHROPIC_API_KEY")

# Create an instance of the Anthropic model
model = Anthropic(anthropic_api_key=anthropic_api_key)

# Define the task
task = "What is quantum field theory? What are 3 books on the field?"

# Generate a response
response = model(task)

# Print the response
print(response)
```

#### Using the HuggingfaceLLM Model

HuggingfaceLLM allows you to use models from Hugging Face's vast repository. Here's an example:

```python
from swarm_models import HuggingfaceLLM

# Define the model ID
model_id = "NousResearch/Yarn-Mistral-7b-128k"

# Create an instance of the HuggingfaceLLM model
inference = HuggingfaceLLM(model_id=model_id)

# Define the task
task = "Once upon a time"

# Generate a response
generated_text = inference(task)
print(generated_text)
```



#### Using the OpenAIChat Model

The OpenAIChat model is designed for conversational tasks. Here's how to use it:

```python
import os
from swarm_models import OpenAIChat

# Load the environment variables
openai_api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat model
openai = OpenAIChat(openai_api_key=openai_api_key, verbose=False)

# Define the task
chat = openai("What are quantum fields?")
print(chat)
```

#### Using the TogetherLLM Model

TogetherLLM supports models from the Together ecosystem. Here's an example:

```python
from swarms import TogetherLLM

# Initialize the model with your parameters
model = TogetherLLM(
    model_name="mistralai/Mixtral-8x7B-Instruct-v0.1",
    max_tokens=1000,
    together_api_key="your_together_api_key",
)

# Run the model
response = model.run("Generate a blog post about the best way to make money online.")
print(response)
```

#### Using the Azure OpenAI Model

The Azure OpenAI model is another powerful tool that can be integrated with Swarms. Here's how to use it:

```python
import os
from dotenv import load_dotenv
from swarms import AzureOpenAI

# Load the environment variables
load_dotenv()

# Create an instance of the AzureOpenAI class
model = AzureOpenAI(
    azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
    deployment_name=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
    openai_api_version=os.getenv("OPENAI_API_VERSION"),
    openai_api_key=os.getenv("AZURE_OPENAI_API_KEY"),
    azure_ad_token=os.getenv("AZURE_OPENAI_AD_TOKEN"),
)

# Define the prompt
prompt = (
    "Analyze this load document and assess it for any risks and"
    " create a table in markdown format."
)

# Generate a response
response = model(prompt)
print(response)
```


#### Using the GPT4VisionAPI Model

The GPT4VisionAPI model can analyze images and provide detailed insights. Here's how to use it:

```python
import os
from dotenv import load_dotenv
from swarms import GPT4VisionAPI

# Load the environment variables
load_dotenv()

# Get the API key from the environment variables
api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the GPT4VisionAPI class
gpt4vision = GPT4VisionAPI(
    openai_api_key=api_key,
    model_name="gpt-4o",
    max_tokens=1000,
    openai_proxy="https://api.openai.com/v1/chat/completions",
)

# Define the URL of the image to analyze
img = "ear.png"

# Define the task to perform on the image
task = "What is this image"

# Run the GPT4VisionAPI on the image with the specified task
answer = gpt4vision.run(task, img, return_json=True)

# Print the answer
print(answer)
```

#### Using the QwenVLMultiModal Model

The QwenVLMultiModal model is designed for multi-modal tasks, such as processing both text and images. Here's an example of how to use it:

```python
from swarms import QwenVLMultiModal

# Instantiate the QwenVLMultiModal model
model = QwenVLMultiModal(
    model_name="Qwen/Qwen-VL-Chat",
    device="cuda",
    quantize=True,
)

# Run the model
response = model("Hello, how are you?", "https://example.com/image.jpg")

# Print the response
print(response)
```


### Common Methods in Swarms

Swarms provides several common methods that are useful across different models. One of the most frequently used methods is `__call__`.

#### The `__call__` Method

The `__call__` method is used to run the model on a given task. Here is a generic example:

```python
# Assuming `model` is an instance of any supported model
task = "Explain the theory of relativity."
response = model(task)
print(response)
```

This method abstracts the complexity of interacting with different model APIs, providing a consistent interface for executing tasks.

### Common Settings in Swarms

Swarms allows you to configure various settings to customize the behavior of the models. Here are some common settings:

#### API Keys

API keys are essential for authenticating and accessing the models. These keys are typically set through environment variables:

```python
import os

# Set API keys as environment variables
os.environ['OPENAI_API_KEY'] = 'your_openai_api_key'
os.environ['ANTHROPIC_API_KEY'] = 'your_anthropic_api_key'
```

#### Model-Specific Settings

Different models may have specific settings that need to be configured. For example, the `AzureOpenAI` model requires several settings related to the Azure environment:

```python
model = AzureOpenAI(
    azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
    deployment_name=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
    openai_api_version=os.getenv("OPENAI_API_VERSION"),
    openai_api_key=os.getenv("AZURE_OPENAI_API_KEY"),
    azure_ad_token=os.getenv("AZURE_OPENAI_AD_TOKEN"),
)
```

### Advanced Usage and Best Practices

To make the most out of the Swarms framework, consider the following best practices:

#### Extensive Logging

Use logging to monitor the behavior and performance of your models. The `loguru` library is recommended for its simplicity and flexibility:

```python
from loguru import logger

# Log model interactions
logger.info("Running task on Anthropic model")
response = model(task)
logger.info(f"Response: {response}")
```

#### Error Handling

Implement robust error handling to manage API failures and other issues gracefully:

```python
try:
    response = model(task)
except Exception as e:
    logger.error(f"Error running task: {e}")
    response = "An error occurred while processing your request."
print(response)
```

### Conclusion

The Swarms framework provides a powerful and flexible way to integrate and manage multiple AI models within a single application. By following the guidelines and examples provided in this blog, you can leverage Swarms to build sophisticated, multi-agent systems with ease. Whether you're using models from OpenAI, Anthropic, Azure, or Hugging Face,

Swarms offers a unified interface that simplifies the process of model orchestration and execution.

--------------------------------------------------

# File: swarms/models/nougat.md

# `Nougat` Documentation

## Introduction

Welcome to the documentation for Nougat, a versatile model designed by Meta for transcribing scientific PDFs into user-friendly Markdown format, extracting information from PDFs, and extracting metadata from PDF documents. This documentation will provide you with a deep understanding of the Nougat class, its architecture, usage, and examples.

## Overview

Nougat is a powerful tool that combines language modeling and image processing capabilities to convert scientific PDF documents into Markdown format. It is particularly useful for researchers, students, and professionals who need to extract valuable information from PDFs quickly. With Nougat, you can simplify complex PDFs, making their content more accessible and easy to work with.

## Class Definition

```python
class Nougat:
    def __init__(
        self,
        model_name_or_path="facebook/nougat-base",
        min_length: int = 1,
        max_new_tokens: int = 30,
    ):
```

## Purpose

The Nougat class serves the following primary purposes:

1. **PDF Transcription**: Nougat is designed to transcribe scientific PDFs into Markdown format. It helps convert complex PDF documents into a more readable and structured format, making it easier to extract information.

2. **Information Extraction**: It allows users to extract valuable information and content from PDFs efficiently. This can be particularly useful for researchers and professionals who need to extract data, figures, or text from scientific papers.

3. **Metadata Extraction**: Nougat can also extract metadata from PDF documents, providing essential details about the document, such as title, author, and publication date.

## Parameters

- `model_name_or_path` (str): The name or path of the pretrained Nougat model. Default: "facebook/nougat-base".
- `min_length` (int): The minimum length of the generated transcription. Default: 1.
- `max_new_tokens` (int): The maximum number of new tokens to generate in the Markdown transcription. Default: 30.

## Usage

To use Nougat, follow these steps:

1. Initialize the Nougat instance:

```python
from swarm_models import Nougat

nougat = Nougat()
```

### Example 1 - Initialization

```python
nougat = Nougat()
```

2. Transcribe a PDF image using Nougat:

```python
markdown_transcription = nougat("path/to/pdf_file.png")
```

### Example 2 - PDF Transcription

```python
nougat = Nougat()
markdown_transcription = nougat("path/to/pdf_file.png")
```

3. Extract information from a PDF:

```python
information = nougat.extract_information("path/to/pdf_file.png")
```

### Example 3 - Information Extraction

```python
nougat = Nougat()
information = nougat.extract_information("path/to/pdf_file.png")
```

4. Extract metadata from a PDF:

```python
metadata = nougat.extract_metadata("path/to/pdf_file.png")
```

### Example 4 - Metadata Extraction

```python
nougat = Nougat()
metadata = nougat.extract_metadata("path/to/pdf_file.png")
```

## How Nougat Works

Nougat employs a vision encoder-decoder model, along with a dedicated processor, to transcribe PDFs into Markdown format and perform information and metadata extraction. Here's how it works:

1. **Initialization**: When you create a Nougat instance, you can specify the model to use, the minimum transcription length, and the maximum number of new tokens to generate.

2. **Processing PDFs**: Nougat can process PDFs as input. You can provide the path to a PDF document.

3. **Image Processing**: The processor converts PDF pages into images, which are then encoded by the model.

4. **Transcription**: Nougat generates Markdown transcriptions of PDF content, ensuring a minimum length and respecting the token limit.

5. **Information Extraction**: Information extraction involves parsing the Markdown transcription to identify key details or content of interest.

6. **Metadata Extraction**: Metadata extraction involves identifying and extracting document metadata, such as title, author, and publication date.

## Additional Information

- Nougat leverages the "facebook/nougat-base" pretrained model, which is specifically designed for document transcription and extraction tasks.
- You can adjust the minimum transcription length and the maximum number of new tokens to control the output's length and quality.
- Nougat can be run on both CPU and GPU devices.

That concludes the documentation for Nougat. We hope you find this tool valuable for your PDF transcription, information extraction, and metadata extraction needs. If you have any questions or encounter any issues, please refer to the Nougat documentation for further assistance. Enjoy using Nougat!

--------------------------------------------------

# File: swarms/models/openai.md

# `BaseOpenAI` and `OpenAI` Documentation

## Table of Contents

1. [Overview](#overview)
2. [Class Architecture](#class-architecture)
3. [Purpose](#purpose)
4. [Class Attributes](#class-attributes)
5. [Methods](#methods)
   - [Construction](#construction)
   - [Configuration](#configuration)
   - [Tokenization](#tokenization)
   - [Generation](#generation)
   - [Asynchronous Generation](#asynchronous-generation)
6. [Usage Examples](#usage-examples)
   - [Creating an OpenAI Object](#creating-an-openai-object)
   - [Generating Text](#generating-text)
   - [Advanced Configuration](#advanced-configuration)

---

## 1. Overview <a name="overview"></a>

The `BaseOpenAI` and `OpenAI` classes are part of the LangChain library, designed to interact with OpenAI's large language models (LLMs). These classes provide a seamless interface for utilizing OpenAI's API to generate natural language text.

## 2. Class Architecture <a name="class-architecture"></a>

Both `BaseOpenAI` and `OpenAI` classes inherit from `BaseLLM`, demonstrating an inheritance-based architecture. This architecture allows for easy extensibility and customization while adhering to the principles of object-oriented programming.

## 3. Purpose <a name="purpose"></a>

The purpose of these classes is to simplify the interaction with OpenAI's LLMs. They encapsulate API calls, handle tokenization, and provide a high-level interface for generating text. By instantiating an object of the `OpenAI` class, developers can quickly leverage the power of OpenAI's models to generate text for various applications, such as chatbots, content generation, and more.

## 4. Class Attributes <a name="class-attributes"></a>

Here are the key attributes and their descriptions for the `BaseOpenAI` and `OpenAI` classes:

| Attribute                 | Description |
|---------------------------|-------------|
| `lc_secrets`              | A dictionary of secrets required for LangChain, including the OpenAI API key. |
| `lc_attributes`           | A dictionary of attributes relevant to LangChain. |
| `is_lc_serializable()`    | A method indicating if the class is serializable for LangChain. |
| `model_name`              | The name of the language model to use. |
| `temperature`             | The sampling temperature for text generation. |
| `max_tokens`              | The maximum number of tokens to generate in a completion. |
| `top_p`                   | The total probability mass of tokens to consider at each step. |
| `frequency_penalty`       | Penalizes repeated tokens according to frequency. |
| `presence_penalty`        | Penalizes repeated tokens. |
| `n`                       | How many completions to generate for each prompt. |
| `best_of`                 | Generates `best_of` completions server-side and returns the "best." |
| `model_kwargs`            | Holds any model parameters valid for `create` calls not explicitly specified. |
| `openai_api_key`          | The OpenAI API key used for authentication. |
| `openai_api_base`         | The base URL for the OpenAI API. |
| `openai_organization`     | The OpenAI organization name, if applicable. |
| `openai_proxy`            | An explicit proxy URL for OpenAI requests. |
| `batch_size`              | The batch size to use when passing multiple documents for generation. |
| `request_timeout`         | The timeout for requests to the OpenAI completion API. |
| `logit_bias`              | Adjustment to the probability of specific tokens being generated. |
| `max_retries`             | The maximum number of retries to make when generating. |
| `streaming`               | Whether to stream the results or not. |
| `allowed_special`         | A set of special tokens that are allowed. |
| `disallowed_special`      | A collection of special tokens that are not allowed. |
| `tiktoken_model_name`     | The model name to pass to `tiktoken` for token counting. |

## 5. Methods <a name="methods"></a>

### 5.1 Construction <a name="construction"></a>

#### 5.1.1 `__new__(cls, **data: Any) -> Union[OpenAIChat, BaseOpenAI]`
- Description: Initializes the OpenAI object.
- Arguments:
  - `cls` (class): The class instance.
  - `data` (dict): Additional data for initialization.
- Returns:
  - Union[OpenAIChat, BaseOpenAI]: An instance of the OpenAI class.

### 5.2 Configuration <a name="configuration"></a>

#### 5.2.1 `build_extra(cls, values: Dict[str, Any]) -> Dict[str, Any]`
- Description: Builds extra kwargs from additional params passed in.
- Arguments:
  - `cls` (class): The class instance.
  - `values` (dict): Values and parameters to build extra kwargs.
- Returns:
  - Dict[str, Any]: A dictionary of built extra kwargs.

#### 5.2.2 `validate_environment(cls, values: Dict) -> Dict`
- Description: Validates that the API key and python package exist in the environment.
- Arguments:
  - `values` (dict): The class values and parameters.
- Returns:
  - Dict: A dictionary of validated values.

### 5.3 Tokenization <a name="tokenization"></a>

#### 5.3.1 `get_sub_prompts(self, params: Dict[str, Any], prompts: List[str], stop: Optional[List[str]] = None) -> List[List[str]]`
- Description: Gets sub-prompts for LLM call.
- Arguments:
  - `params` (dict): Parameters for LLM call.
  - `prompts` (list): List of prompts.
  - `stop` (list, optional): List of stop words.
- Returns:
  - List[List[str]]: List of sub-prompts.

#### 5.3.2 `get_token_ids(self, text: str) -> List[int]`
- Description: Gets token IDs using the `tiktoken` package.
- Arguments:
  - `text` (str): The text for which to calculate token IDs.
- Returns:
  - List[int]: A list of token IDs.

#### 5.3.3 `modelname_to_contextsize(modelname: str) -> int`
- Description: Calculates the maximum number of tokens possible to generate for a model.
- Arguments:
  - `modelname` (str): The model name to determine the context size for.
- Returns:
  - int: The maximum context size.

#### 5.3.4 `max_tokens_for_prompt(self, prompt: str) -> int`
- Description: Calculates the maximum number of tokens possible to generate for a prompt.
- Arguments:
  - `prompt` (str): The prompt for which to

 determine the maximum token limit.
- Returns:
  - int: The maximum token limit.

### 5.4 Generation <a name="generation"></a>

#### 5.4.1 `generate(self, text: Union[str, List[str]], **kwargs) -> Union[str, List[str]]`
- Description: Generates text using the OpenAI API.
- Arguments:
  - `text` (str or list): The input text or list of inputs.
  - `**kwargs` (dict): Additional parameters for the generation process.
- Returns:
  - Union[str, List[str]]: The generated text or list of generated texts.

### 5.5 Asynchronous Generation <a name="asynchronous-generation"></a>

#### 5.5.1 `generate_async(self, text: Union[str, List[str]], **kwargs) -> Union[str, List[str]]`
- Description: Generates text asynchronously using the OpenAI API.
- Arguments:
  - `text` (str or list): The input text or list of inputs.
  - `**kwargs` (dict): Additional parameters for the asynchronous generation process.
- Returns:
  - Union[str, List[str]]: The generated text or list of generated texts.

## 6. Usage Examples <a name="usage-examples"></a>

### 6.1 Creating an OpenAI Object <a name="creating-an-openai-object"></a>

```python
# Import the OpenAI class
from swarm_models import OpenAI

# Set your OpenAI API key
api_key = "YOUR_API_KEY"

# Create an OpenAI object
openai = OpenAI(api_key)
```

### 6.2 Generating Text <a name="generating-text"></a>

```python
# Generate text from a single prompt
prompt = "Translate the following English text to French: 'Hello, how are you?'"
generated_text = openai.generate(prompt, max_tokens=50)

# Generate text from multiple prompts
prompts = [
    "Translate this: 'Good morning' to Spanish.",
    "Summarize the following article:",
    article_text,
]
generated_texts = openai.generate(prompts, max_tokens=100)

# Generate text asynchronously
async_prompt = "Translate 'Thank you' into German."
async_result = openai.generate_async(async_prompt, max_tokens=30)

# Access the result of an asynchronous generation
async_result_text = async_result.get()
```

### 6.3 Advanced Configuration <a name="advanced-configuration"></a>

```python
# Configure generation with advanced options
custom_options = {
    "temperature": 0.7,
    "max_tokens": 100,
    "top_p": 0.9,
    "frequency_penalty": 0.2,
    "presence_penalty": 0.4,
}
generated_text = openai.generate(prompt, **custom_options)
```

This documentation provides a comprehensive understanding of the `BaseOpenAI` and `OpenAI` classes, their attributes, methods, and usage examples. Developers can utilize these classes to interact with OpenAI's language models efficiently, enabling various natural language generation tasks.

--------------------------------------------------

# File: swarms/models/openai_chat.md

# `OpenAIChat` Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [Class Overview](#class-overview)
3. [Class Architecture](#class-architecture)
4. [Class Attributes](#class-attributes)
5. [Methods](#methods)
    - [Construction](#construction)
    - [Configuration](#configuration)
    - [Message Handling](#message-handling)
    - [Generation](#generation)
    - [Tokenization](#tokenization)
6. [Usage Examples](#usage-examples)
7. [Additional Information](#additional-information)

---

## 1. Introduction <a name="introduction"></a>

The `OpenAIChat` class is part of the LangChain library and serves as an interface to interact with OpenAI's Chat large language models. This documentation provides an in-depth understanding of the class, its attributes, methods, and usage examples.

## 2. Class Overview <a name="class-overview"></a>

The `OpenAIChat` class is designed for conducting chat-like conversations with OpenAI's language models, such as GPT-3.5 Turbo. It allows you to create interactive conversations by sending messages and receiving model-generated responses. This class simplifies the process of integrating OpenAI's models into chatbot applications and other natural language processing tasks.

## 3. Class Architecture <a name="class-architecture"></a>

The `OpenAIChat` class is built on top of the `BaseLLM` class, which provides a foundation for working with large language models. This inheritance-based architecture allows for customization and extension while adhering to object-oriented programming principles.

## 4. Class Attributes <a name="class-attributes"></a>

Here are the key attributes and their descriptions for the `OpenAIChat` class:

| Attribute                   | Description                                                                   |
|-----------------------------|-------------------------------------------------------------------------------|
| `client`                    | An internal client for making API calls to OpenAI.                            |
| `model_name`                | The name of the language model to use (default: "gpt-3.5-turbo").             |
| `model_kwargs`              | Additional model parameters valid for `create` calls not explicitly specified.|
| `openai_api_key`            | The OpenAI API key used for authentication.                                    |
| `openai_api_base`           | The base URL for the OpenAI API.                                              |
| `openai_proxy`              | An explicit proxy URL for OpenAI requests.                                     |
| `max_retries`               | The maximum number of retries to make when generating (default: 6).           |
| `prefix_messages`           | A list of messages to set the initial conversation state (default: []).       |
| `streaming`                 | Whether to stream the results or not (default: False).                        |
| `allowed_special`           | A set of special tokens that are allowed (default: an empty set).             |
| `disallowed_special`        | A collection of special tokens that are not allowed (default: "all").        |

## 5. Methods <a name="methods"></a>

### 5.1 Construction <a name="construction"></a>

#### 5.1.1 `__init__(self, model_name: str = "gpt-3.5-turbo", openai_api_key: Optional[str] = None, openai_api_base: Optional[str] = None, openai_proxy: Optional[str] = None, max_retries: int = 6, prefix_messages: List = [])`
- Description: Initializes an OpenAIChat object.
- Arguments:
  - `model_name` (str): The name of the language model to use (default: "gpt-3.5-turbo").
  - `openai_api_key` (str, optional): The OpenAI API key used for authentication.
  - `openai_api_base` (str, optional): The base URL for the OpenAI API.
  - `openai_proxy` (str, optional): An explicit proxy URL for OpenAI requests.
  - `max_retries` (int): The maximum number of retries to make when generating (default: 6).
  - `prefix_messages` (List): A list of messages to set the initial conversation state (default: []).

### 5.2 Configuration <a name="configuration"></a>

#### 5.2.1 `build_extra(self, values: Dict[str, Any]) -> Dict[str, Any]`
- Description: Builds extra kwargs from additional parameters passed in.
- Arguments:
  - `values` (dict): Values and parameters to build extra kwargs.
- Returns:
  - Dict[str, Any]: A dictionary of built extra kwargs.

#### 5.2.2 `validate_environment(self, values: Dict) -> Dict`
- Description: Validates that the API key and Python package exist in the environment.
- Arguments:
  - `values` (dict): The class values and parameters.
- Returns:
  - Dict: A dictionary of validated values.

### 5.3 Message Handling <a name="message-handling"></a>

#### 5.3.1 `_get_chat_params(self, prompts: List[str], stop: Optional[List[str]] = None) -> Tuple`
- Description: Gets chat-related parameters for generating responses.
- Arguments:
  - `prompts` (list): List of user messages.
  - `stop` (list, optional): List of stop words.
- Returns:
  - Tuple: Messages and parameters.

### 5.4 Generation <a name="generation"></a>

#### 5.4.1 `_stream(self, prompt: str, stop: Optional[List[str]] = None, run_manager: Optional[CallbackManagerForLLMRun] = None, **kwargs: Any) -> Iterator[GenerationChunk]`
- Description: Generates text asynchronously using the OpenAI API.
- Arguments:
  - `prompt` (str): The user's message.
  - `stop` (list, optional): List of stop words.
  - `run_manager` (optional): Callback manager for asynchronous generation.
  - `**kwargs` (dict): Additional parameters for asynchronous generation.
- Returns:
  - Iterator[GenerationChunk]: An iterator of generated text chunks.

#### 5.4.2 `_agenerate(self, prompts: List[str], stop: Optional[List[str]] = None, run_manager: Optional[AsyncCallbackManagerForLLMRun] = None, **kwargs: Any) -> LLMResult`
- Description: Generates text asynchronously using the OpenAI API (async version).
- Arguments:
  - `prompts` (list): List of user messages.
  - `stop` (list, optional): List of stop words.
  - `run_manager` (optional): Callback manager for asynchronous generation.
  - `**kwargs` (dict): Additional parameters for asynchronous generation.
- Returns:
  - LLMResult: A result object containing the generated text.

### 5.5 Tokenization <a name="tokenization"></a>

#### 5.5.1 `get_token_ids(self, text: str) -> List[int]`
- Description: Gets token IDs using the tiktoken package.
- Arguments:
  - `text` (str): The text for which to calculate token IDs.
- Returns:
  - List[int]: A list of

 token IDs.

## 6. Usage Examples <a name="usage-examples"></a>

### Example 1: Initializing `OpenAIChat`

```python
from swarm_models import OpenAIChat

# Initialize OpenAIChat with model name and API key
openai_chat = OpenAIChat(model_name="gpt-3.5-turbo", openai_api_key="YOUR_API_KEY")
```

### Example 2: Sending Messages and Generating Responses

```python
# Define a conversation
conversation = [
    "User: Tell me a joke.",
    "Assistant: Why did the chicken cross the road?",
    "User: I don't know. Why?",
    "Assistant: To get to the other side!",
]

# Set the conversation as the prefix messages
openai_chat.prefix_messages = conversation

# Generate a response
user_message = "User: Tell me another joke."
response = openai_chat.generate([user_message])

# Print the generated response
print(
    response[0][0].text
)  # Output: "Assistant: Why don't scientists trust atoms? Because they make up everything!"
```

### Example 3: Asynchronous Generation

```python
import asyncio


# Define an asynchronous function for generating responses
async def generate_responses():
    user_message = "User: Tell me a fun fact."
    async for chunk in openai_chat.stream([user_message]):
        print(chunk.text)


# Run the asynchronous generation function
asyncio.run(generate_responses())
```

## 7. Additional Information <a name="additional-information"></a>

- To use the `OpenAIChat` class, you should have the `openai` Python package installed, and the environment variable `OPENAI_API_KEY` set with your API key.
- Any parameters that are valid to be passed to the `openai.create` call can be passed to the `OpenAIChat` constructor.
- You can customize the behavior of the class by setting various attributes, such as `model_name`, `openai_api_key`, `prefix_messages`, and more.
- For asynchronous generation, you can use the `_stream` and `_agenerate` methods to interactively receive model-generated text chunks.
- To calculate token IDs, you can use the `get_token_ids` method, which utilizes the `tiktoken` package. Make sure to install the `tiktoken` package with `pip install tiktoken` if needed.

---

This documentation provides a comprehensive overview of the `OpenAIChat` class, its attributes, methods, and usage examples. You can use this class to create chatbot applications, conduct conversations with language models, and explore the capabilities of OpenAI's GPT-3.5 Turbo model.

--------------------------------------------------

# File: swarms/models/openai_function_caller.md

# OpenAIFunctionCaller Documentation

The `OpenAIFunctionCaller` class is designed to interface with OpenAI's chat completion API, allowing users to generate responses based on given prompts using specified models. This class encapsulates the setup and execution of API calls, including handling API keys, model parameters, and response formatting. The class extends the `BaseLLM` and utilizes OpenAI's client library to facilitate interactions.

## Class Definition

### OpenAIFunctionCaller

A class that represents a caller for OpenAI chat completions.

### Attributes

| Attribute            | Type              | Description                                                             |
|----------------------|-------------------|-------------------------------------------------------------------------|
| `system_prompt`      | `str`             | The system prompt to be used in the chat completion.                    |
| `model_name`         | `str`             | The name of the OpenAI model to be used.                                |
| `max_tokens`         | `int`             | The maximum number of tokens in the generated completion.               |
| `temperature`        | `float`           | The temperature parameter for randomness in the completion.             |
| `base_model`         | `BaseModel`       | The base model to be used for the completion.                           |
| `parallel_tool_calls`| `bool`            | Whether to make parallel tool calls.                                    |
| `top_p`              | `float`           | The top-p parameter for nucleus sampling in the completion.             |
| `client`             | `openai.OpenAI`   | The OpenAI client for making API calls.                                 |

### Methods

#### `check_api_key`

Checks if the API key is provided and retrieves it from the environment if not.

| Parameter     | Type   | Description                          |
|---------------|--------|--------------------------------------|
| None          |        |                                      |

**Returns:**

| Type   | Description                          |
|--------|--------------------------------------|
| `str`  | The API key.                         |

#### `run`

Runs the chat completion with the given task and returns the generated completion.

| Parameter | Type     | Description                                                     |
|-----------|----------|-----------------------------------------------------------------|
| `task`    | `str`    | The user's task for the chat completion.                        |
| `*args`   |          | Additional positional arguments to be passed to the OpenAI API. |
| `**kwargs`|          | Additional keyword arguments to be passed to the OpenAI API.    |

**Returns:**

| Type   | Description                                   |
|--------|-----------------------------------------------|
| `str`  | The generated completion.                     |

#### `convert_to_dict_from_base_model`

Converts a `BaseModel` to a dictionary.

| Parameter   | Type       | Description                          |
|-------------|------------|--------------------------------------|
| `base_model`| `BaseModel`| The BaseModel to be converted.       |

**Returns:**

| Type   | Description                          |
|--------|--------------------------------------|
| `dict` | A dictionary representing the BaseModel.|

#### `convert_list_of_base_models`

Converts a list of `BaseModels` to a list of dictionaries.

| Parameter    | Type            | Description                          |
|--------------|-----------------|--------------------------------------|
| `base_models`| `List[BaseModel]`| A list of BaseModels to be converted.|

**Returns:**

| Type   | Description                                   |
|--------|-----------------------------------------------|
| `List[Dict]` | A list of dictionaries representing the converted BaseModels.  |

## Usage Examples

Here are three examples demonstrating different ways to use the `OpenAIFunctionCaller` class:

### Example 1: Production-Grade Claude Artifacts

```python
import openai
from swarm_models.openai_function_caller import OpenAIFunctionCaller
from swarms.artifacts.main_artifact import Artifact


# Pydantic is a data validation library that provides data validation and parsing using Python type hints.


# Example usage:
# Initialize the function caller
model = OpenAIFunctionCaller(
    system_prompt="You're a helpful assistant.The time is August 6, 2024",
    max_tokens=500,
    temperature=0.5,
    base_model=Artifact,
    parallel_tool_calls=False,
)


# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.
# Here, we initialize an instance of the OpenAIFunctionCaller class with the following parameters:
# - system_prompt: A prompt that sets the context for the conversation with the API.
# - max_tokens: The maximum number of tokens to generate in the API response.
# - temperature: A parameter that controls the randomness of the generated text.
# - base_model: The base model to use for the API calls, in this case, the WeatherAPI class.
out = model.run("Create a python file with a python game code in it")
print(out)
```

### Example 2: Prompt Generator

```python
from swarm_models.openai_function_caller import OpenAIFunctionCaller
from pydantic import BaseModel, Field
from typing import Sequence


class PromptUseCase(BaseModel):
    use_case_name: str = Field(
        ...,
        description="The name of the use case",
    )
    use_case_description: str = Field(
        ...,
        description="The description of the use case",
    )


class PromptSpec(BaseModel):
    prompt_name: str = Field(
        ...,
        description="The name of the prompt",
    )
    prompt_description: str = Field(
        ...,
        description="The description of the prompt",
    )
    prompt: str = Field(
        ...,
        description="The prompt for the agent",
    )
    tags: str = Field(
        ...,
        description="The tags for the prompt such as sentiment, code, etc seperated by commas.",
    )
    use_cases: Sequence[PromptUseCase] = Field(
        ...,
        description="The use cases for the prompt",
    )


# Example usage:
# Initialize the function caller
model = OpenAIFunctionCaller(
    system_prompt="You're an agent creator, you're purpose is to create system prompt for new LLM Agents for the user. Follow the best practices for creating a prompt such as making it direct and clear. Providing instructions and many-shot examples will help the agent understand the task better.",
    max_tokens=1000,
    temperature=0.5,
    base_model=PromptSpec,
    parallel_tool_calls=False,
)


# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.
out = model.run(
    "Create an prompt for generating quality rust code with instructions and examples."
)
print(out)

```

### Example 3: Sentiment Analysis 

```python
from swarm_models.openai_function_caller import OpenAIFunctionCaller
from pydantic import BaseModel, Field


# Pydantic is a data validation library that provides data validation and parsing using Python type hints.
# It is used here to define the data structure for making API calls to retrieve weather information.
class SentimentAnalysisCard(BaseModel):
    text: str = Field(
        ...,
        description="The text to be analyzed for sentiment rating",
    )
    rating: str = Field(
        ...,
        description="The sentiment rating of the text from 0.0 to 1.0",
    )


# The WeatherAPI class is a Pydantic BaseModel that represents the data structure
# for making API calls to retrieve weather information. It has two attributes: city and date.

# Example usage:
# Initialize the function caller
model = OpenAIFunctionCaller(
    system_prompt="You're a sentiment Analysis Agent, you're purpose is to rate the sentiment of text",
    max_tokens=100,
    temperature=0.5,
    base_model=SentimentAnalysisCard,
    parallel_tool_calls=False,
)


# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.
# Here, we initialize an instance of the OpenAIFunctionCaller class with the following parameters:
# - system_prompt: A prompt that sets the context for the conversation with the API.
# - max_tokens: The maximum number of tokens to generate in the API response.
# - temperature: A parameter that controls the randomness of the generated text.
# - base_model: The base model to use for the API calls, in this case, the WeatherAPI class.
out = model.run("The hotel was average, but the food was excellent.")
print(out)

```

## Additional Information and Tips

- Ensure that your OpenAI API key is securely stored and not hard-coded into your source code. Use environment variables to manage sensitive information.
- Adjust the `temperature` and `top_p` parameters to control the randomness and diversity of the generated responses. Lower values for `temperature` will result in more deterministic outputs, while higher values will introduce more variability.
- When using `parallel_tool_calls`, ensure that the tools you are calling in parallel are thread-safe and can handle concurrent execution.

## References and Resources

- [OpenAI API Documentation](https://beta.openai.com/docs/)
- [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- [Loguru Logger Documentation](https://loguru.readthedocs.io/)

By following this comprehensive guide, you can effectively utilize the `OpenAIFunctionCaller` class to generate chat completions using OpenAI's models, customize the response parameters, and handle API interactions seamlessly within your application.

--------------------------------------------------

# File: swarms/models/openai_tts.md

# `OpenAITTS` Documentation

## Table of Contents
1. [Overview](#overview)
2. [Installation](#installation)
3. [Usage](#usage)
   - [Initialization](#initialization)
   - [Running TTS](#running-tts)
   - [Running TTS and Saving](#running-tts-and-saving)
4. [Examples](#examples)
   - [Basic Usage](#basic-usage)
   - [Saving the Output](#saving-the-output)
5. [Advanced Options](#advanced-options)
6. [Troubleshooting](#troubleshooting)
7. [References](#references)

## 1. Overview <a name="overview"></a>

The `OpenAITTS` module is a Python library that provides an interface for converting text to speech (TTS) using the OpenAI TTS API. It allows you to generate high-quality speech from text input, making it suitable for various applications such as voice assistants, speech synthesis, and more.

### Features:
- Convert text to speech using OpenAI's TTS model.
- Supports specifying the model name, voice, and other parameters.
- Option to save the generated speech to a WAV file.

## 2. Installation <a name="installation"></a>

To use the `OpenAITTS` model, you need to install the necessary dependencies. You can do this using `pip`:

```bash
pip install swarms requests wave
```

## 3. Usage <a name="usage"></a>

### Initialization <a name="initialization"></a>

To use the `OpenAITTS` module, you need to initialize an instance of the `OpenAITTS` class. Here's how you can do it:

```python
from swarm_models.openai_tts import OpenAITTS

# Initialize the OpenAITTS instance
tts = OpenAITTS(
    model_name="tts-1-1106",
    proxy_url="https://api.openai.com/v1/audio/speech",
    openai_api_key=openai_api_key_env,
    voice="onyx",
)
```

#### Parameters:
- `model_name` (str): The name of the TTS model to use (default is "tts-1-1106").
- `proxy_url` (str): The URL for the OpenAI TTS API (default is "https://api.openai.com/v1/audio/speech").
- `openai_api_key` (str): Your OpenAI API key. It can be obtained from the OpenAI website.
- `voice` (str): The voice to use for generating speech (default is "onyx").
- `chunk_size` (int): The size of data chunks when fetching audio (default is 1024 * 1024 bytes).
- `autosave` (bool): Whether to automatically save the generated speech to a file (default is False).
- `saved_filepath` (str): The path to the file where the speech will be saved (default is "runs/tts_speech.wav").

### Running TTS <a name="running-tts"></a>

Once the `OpenAITTS` instance is initialized, you can use it to convert text to speech using the `run` method:

```python
# Generate speech from text
speech_data = tts.run("Hello, world!")
```

#### Parameters:
- `task` (str): The text you want to convert to speech.

#### Returns:
- `speech_data` (bytes): The generated speech data.

### Running TTS and Saving <a name="running-tts-and-saving"></a>

You can also use the `run_and_save` method to generate speech from text and save it to a file:

```python
# Generate speech from text and save it to a file
speech_data = tts.run_and_save("Hello, world!")
```

#### Parameters:
- `task` (str): The text you want to convert to speech.

#### Returns:
- `speech_data` (bytes): The generated speech data.

## 4. Examples <a name="examples"></a>

### Basic Usage <a name="basic-usage"></a>

Here's a basic example of how to use the `OpenAITTS` module to generate speech from text:

```python
from swarm_models.openai_tts import OpenAITTS

# Initialize the OpenAITTS instance
tts = OpenAITTS(
    model_name="tts-1-1106",
    proxy_url="https://api.openai.com/v1/audio/speech",
    openai_api_key=openai_api_key_env,
    voice="onyx",
)

# Generate speech from text
speech_data = tts.run("Hello, world!")
```

### Saving the Output <a name="saving-the-output"></a>

You can save the generated speech to a WAV file using the `run_and_save` method:

```python
# Generate speech from text and save it to a file
speech_data = tts.run_and_save("Hello, world!")
```

## 5. Advanced Options <a name="advanced-options"></a>

The `OpenAITTS` module supports various advanced options for customizing the TTS generation process. You can specify the model name, voice, and other parameters during initialization. Additionally, you can configure the chunk size for audio data fetching and choose whether to automatically save the generated speech to a file.

## 6. Troubleshooting <a name="troubleshooting"></a>

If you encounter any issues while using the `OpenAITTS` module, please make sure you have installed all the required dependencies and that your OpenAI API key is correctly configured. If you still face problems, refer to the OpenAI documentation or contact their support for assistance.

## 7. References <a name="references"></a>

- [OpenAI API Documentation](https://beta.openai.com/docs/)
- [Python Requests Library](https://docs.python-requests.org/en/latest/)
- [Python Wave Library](https://docs.python.org/3/library/wave.html)

This documentation provides a comprehensive guide on how to use the `OpenAITTS` module to convert text to speech using OpenAI's TTS model. It covers initialization, basic usage, advanced options, troubleshooting, and references for further exploration.

--------------------------------------------------

# File: swarms/models/vilt.md

# `Vilt` Documentation

## Introduction

Welcome to the documentation for Vilt, a Vision-and-Language Transformer (ViLT) model fine-tuned on the VQAv2 dataset. Vilt is a powerful model capable of answering questions about images. This documentation will provide a comprehensive understanding of Vilt, its architecture, usage, and how it can be integrated into your projects.

## Overview

Vilt is based on the Vision-and-Language Transformer (ViLT) architecture, designed for tasks that involve understanding both text and images. It has been fine-tuned on the VQAv2 dataset, making it adept at answering questions about images. This model is particularly useful for tasks where textual and visual information needs to be combined to provide meaningful answers.

## Class Definition

```python
class Vilt:
    def __init__(self):
        """
        Initialize the Vilt model.
        """
```

## Usage

To use the Vilt model, follow these steps:

1. Initialize the Vilt model:

```python
from swarm_models import Vilt

model = Vilt()
```

2. Call the model with a text question and an image URL:

```python
output = model(
    "What is this image?", "http://images.cocodataset.org/val2017/000000039769.jpg"
)
```

### Example 1 - Image Questioning

```python
model = Vilt()
output = model(
    "What are the objects in this image?",
    "http://images.cocodataset.org/val2017/000000039769.jpg",
)
print(output)
```

### Example 2 - Image Analysis

```python
model = Vilt()
output = model(
    "Describe the scene in this image.",
    "http://images.cocodataset.org/val2017/000000039769.jpg",
)
print(output)
```

### Example 3 - Visual Knowledge Retrieval

```python
model = Vilt()
output = model(
    "Tell me more about the landmark in this image.",
    "http://images.cocodataset.org/val2017/000000039769.jpg",
)
print(output)
```

## How Vilt Works

Vilt operates by combining text and image information to generate meaningful answers to questions about the provided image. Here's how it works:

1. **Initialization**: When you create a Vilt instance, it initializes the processor and the model. The processor is responsible for handling the image and text input, while the model is the fine-tuned ViLT model.

2. **Processing Input**: When you call the Vilt model with a text question and an image URL, it downloads the image and processes it along with the text question. This processing step involves tokenization and encoding of the input.

3. **Forward Pass**: The encoded input is then passed through the ViLT model. It calculates the logits, and the answer with the highest probability is selected.

4. **Output**: The predicted answer is returned as the output of the model.

## Parameters

Vilt does not require any specific parameters during initialization. It is pre-configured to work with the "dandelin/vilt-b32-finetuned-vqa" model.

## Additional Information

- Vilt is fine-tuned on the VQAv2 dataset, making it proficient at answering questions about a wide range of images.
- You can use Vilt for various applications, including image question-answering, image analysis, and visual knowledge retrieval.

That concludes the documentation for Vilt. We hope you find this model useful for your vision-and-language tasks. If you have any questions or encounter any issues, please refer to the Hugging Face Transformers documentation for further assistance. Enjoy working with Vilt!

--------------------------------------------------

# File: swarms/papers.md

# awesome-multi-agent-papers

An awesome list of multi-agent papers that show you various swarm architectures and much more. [Get started](https://github.com/kyegomez/awesome-multi-agent-papers)

--------------------------------------------------

# File: swarms/products.md

# Swarms Products

Welcome to the official documentation for **Swarms**, the first multi-agent orchestration framework enabling seamless collaboration between LLMs and other tools to automate business operations at scale. Below, you’ll find detailed descriptions of all Swarms products and services to help you get started and unlock the full potential of this groundbreaking platform.



| **Name**              | **Description**                                                                                                   | **Link**                  |
|-----------------------|-------------------------------------------------------------------------------------------------------------------|---------------------------|
| **Swarms Marketplace** | A platform to discover, share, and integrate prompts, agents, and tools.                                         | [swarms.world](https://swarms.world) |
| **Swarms Spreadsheet** | A tool for managing and scaling thousands of agent outputs, with results saved to a CSV file for easy analysis.  | [swarms.world](https://swarms.world) |
| **Drag n Drop Swarm**  | An intuitive interface to visually create and manage swarms of agents through drag-and-drop functionality.       | [swarms.world](https://swarms.world) |
| **Swarms API**         | An API enabling seamless integration of swarms of agents into your applications and workflows.                   | [swarms.world](https://swarms.world) |
| **Wallet API**         | A secure API for managing transactions and interactions within the Swarms ecosystem.                             | Coming Soon               |
| **Swarm Exchange**     | A marketplace for buying and selling prompts, agents, and tools within the Swarms ecosystem.                    | Coming Soon               |



---

## Swarms Marketplace
**Website:** [swarms.world](https://swarms.world)

The Swarms Marketplace is your one-stop destination for discovering, adding, and managing:

- **Prompts:** Access and share production-ready prompts for LLMs.

- **Agents:** Browse pre-built agents tailored for tasks in marketing, finance, 
programming, and more.
- **Tools:** Discover cutting-edge tools to enhance agent performance and expand 
capabilities.

### Key Features:
- **Rating System:** Evaluate and rate prompts, agents, and tools based on their 
effectiveness.
- **Commenting System:** Share feedback and insights with the Swarms community.

- **Coming Soon:** Buy and sell prompts, agents, and tools directly within the 
marketplace.

### How to Use:
1. Sign up at [swarms.world](https://swarms.world).
2. Explore the marketplace categories or search for specific solutions.
3. Add your chosen resources to your Swarms account and integrate them into your operations.

---

## Swarms Spreadsheet
**Website:** [swarms.world](https://swarms.world)

The Swarms Spreadsheet is a powerful tool for managing outputs from thousands of agents efficiently. Ideal for businesses needing scalable solutions, it provides:

### Key Features:
- **Batch Task Execution:** Assign tasks to multiple agents simultaneously.

- **CSV Integration:** Automatically save agent outputs to CSV files for easy analysis.

- **Customizable Agents:** Upload single or multiple agents and run repeat tasks with 
ease.
- **Metadata Capture:** Leverage built-in Pydantic schemas to record all task details 
and results.

### Use Cases:
- **Marketing:** Generate and analyze campaign ideas at scale.

- **Finance:** Process financial models and scenarios quickly.

- **Operations:** Automate repetitive tasks across multiple domains.


### How to Use:
1. Visit [swarms.world](https://swarms.world) and navigate to Swarms Spreadsheet.
2. Upload your agents or create new ones.
3. Run tasks and export results to a CSV file for further use.

---

## Drag-n-Drop Swarm
**Website:** [swarms.world](https://swarms.world)

The Drag-n-Drop Swarm enables non-technical users to create and deploy agent workflows with a simple drag-and-drop interface. It’s perfect for:

### Key Features:
- **Visual Workflow Builder:** Design agent interactions without writing code.

- **Pre-Built Templates:** Start quickly with ready-made workflows for common tasks.

- **Intuitive Interface:** Drag, drop, and connect agents to create robust automation 
pipelines.

### How to Use:
1. Access the Drag-n-Drop Swarm tool at [swarms.world](https://swarms.world).
2. Drag agents from the library into the workspace.
3. Connect and configure agents to execute your desired workflow.
4. Save and deploy your workflow instantly.

---

## Swarms API
**Website:** [swarms.world](https://swarms.world)

The Swarms API provides developers with the ability to:

### Key Features:
- **Agent Management:** Programmatically create, update, and delete agents.

- **Task Orchestration:** Dynamically assign tasks to agents and monitor their progress.

- **Custom Integration:** Seamlessly integrate Swarms functionality into existing 
applications and workflows.

### Getting Started:
1. Sign up for API access at [swarms.world](https://swarms.world).
2. Obtain your API key and authentication credentials.
3. Refer to the API documentation for endpoint details and usage examples.

---

## Wallet API
The Wallet API enables secure and efficient transactions within the Swarms ecosystem, allowing users to:

### Key Features:
- **Seamless Transactions:** Manage payments for prompts, agents, and tools.

- **Secure Wallets:** Store and transfer funds safely within the Swarms platform.

- **Transaction History:** Access detailed logs of all wallet activity.


### Getting Started:
1. Enable your wallet in your Swarms account settings.
2. Use the Wallet API to handle purchases and manage funds.

---

## Swarm Exchange (Coming Soon)
The **Swarm Exchange** will revolutionize the way agents and tools are traded in the Swarms ecosystem. It will feature:

### Key Features:
- **Decentralized Marketplace:** Trade agents and tools securely.

- **Dynamic Pricing:** Leverage demand-based pricing for assets.

- **Global Access:** Participate in the exchange from anywhere.


Stay tuned for updates on the Swarm Exchange launch.

---

## Additional Resources
- **GitHub Repository:** [Swarms Framework](https://github.com/kyegomez/swarms)

- **Documentation:** [Swarms Documentation](https://docs.swarms.world)

- **Support:** Contact us via our [Discord Community](https://discord.gg/swarms).

---

Experience the future of multi-agent collaboration with Swarms. Start building your agentic workflows today!



--------------------------------------------------

# File: swarms/prompts/8020.md



--------------------------------------------------

# File: swarms/prompts/essence.md

# **The Essence of Enterprise-Grade Prompting**

Large Language Models (LLMs) like GPT-4 have revolutionized the landscape of AI-driven automation, customer support, marketing, and more. However, extracting the highest quality output from these models requires a thoughtful approach to crafting prompts—an endeavor that goes beyond mere trial and error. In enterprise settings, where consistency, quality, and performance are paramount, enterprise-grade prompting has emerged as a structured discipline, combining art with the science of human-machine communication.

Enterprise-grade prompting involves understanding the intricate dynamics between language models, context, and the task at hand. It requires knowledge of not only the technical capabilities of LLMs but also the intricacies of how they interpret human language. Effective prompting becomes the linchpin for ensuring that AI-driven outputs are accurate, reliable, and aligned with business needs. It is this discipline that turns raw AI capabilities into tangible enterprise value.

In this essay, we will dissect the essence of enterprise-grade prompting, explore the most effective prompting strategies, explain what works and what doesn't, and conclude with the current holy grail of automated prompt engineering. We will also share concrete examples and illustrations of each technique, with a particular focus on their application in an enterprise setting.

## **1. Foundational Principles of Prompting**

The effectiveness of prompting lies in understanding both the capabilities and limitations of LLMs. A well-structured prompt helps LLMs focus on the most relevant information while avoiding ambiguities that can lead to unreliable results. In enterprise-grade contexts, prompts must be designed with the end-user's expectations in mind, ensuring quality, safety, scalability, and traceability.

- **Clarity**: Prompts should be clear and devoid of unnecessary jargon. Ambiguity can misguide the model, leading to poor-quality output. For enterprise use, clarity means avoiding misunderstandings that could affect customer relationships or lead to non-compliance with regulations.
- **Context**: Providing sufficient context ensures the model understands the nuances of the prompt. For example, specifying whether a response is aimed at a technical audience versus a general audience can lead to more accurate outputs. Context is essential in creating responses that are not only accurate but also relevant to the target audience.
- **Instruction Granularity**: The level of detail in the instruction significantly impacts the quality of the output. Broad instructions might lead to vagueness, whereas overly detailed instructions could overwhelm the model. Finding the right balance is key to generating useful responses.

Example: Instead of prompting "Explain what a blockchain is," an enterprise-grade prompt might be "Explain the concept of blockchain, focusing on how distributed ledgers help increase transparency in supply chain management. Keep the explanation under 200 words for a general audience." This prompt provides clear, relevant, and concise instructions tailored to specific needs.

## **2. Best Prompting Strategies**

The field of enterprise-grade prompting employs numerous strategies to maximize the quality of LLM output. Here are some of the most effective ones:

### **2.1. Instruction-Based Prompting**

Instruction-based prompting provides explicit instructions for the LLM to follow. This approach is valuable in enterprise applications where responses must adhere to a specific tone, structure, or depth of analysis.

**Example**:

- "Summarize the following press release in 3 bullet points suitable for a marketing team meeting."

This prompt is highly effective because it instructs the model on what format (bullet points), audience (marketing team), and depth (summary) to produce, minimizing the risk of irrelevant details.

**Why It Works**: LLMs excel when they have a clear set of rules to follow. Enterprises benefit from this structured approach, as it ensures consistency across multiple use cases, be it marketing, HR, or customer service. Clear instructions also make it easier to validate outputs against defined expectations, which is crucial for maintaining quality.

### **2.2. Multi-Shot Prompting**

Multi-shot prompting provides several examples before asking the model to complete a task. This helps set expectations by showing the model the desired style and type of output.

**Example**:

- "Here are some example customer support responses:
  1. Customer: 'I can't access my account.'
     Response: 'We're sorry you're having trouble accessing your account. Please try resetting your password using the link provided.'
  2. Customer: 'I received a damaged item.'
     Response: 'We apologize for the damaged item. Please provide us with your order number so we can send a replacement.'

- Customer: 'The app keeps crashing on my phone.'
  Response:"

**Why It Works**: Multi-shot prompting is highly effective in enterprise-grade applications where consistency is critical. Showing multiple examples helps the model learn patterns without needing extensive fine-tuning, saving both time and cost. Enterprises can leverage this technique to ensure that responses remain aligned with brand standards and customer expectations across different departments.

### **2.3. Chain of Thought Prompting**

Chain of Thought (CoT) prompting helps LLMs generate reasoning steps explicitly before arriving at an answer. This method is useful for complex problem-solving tasks or when transparency in decision-making is important.

**Example**:

- "A logistics company wants to minimize fuel costs across multiple delivery routes. Here are the conditions: Each truck has a fuel capacity of 100 gallons, and the price of fuel fluctuates per state. Think through the most cost-effective approach for planning delivery, step by step."

**Why It Works**: CoT prompting allows the model to work through the process iteratively, providing more explainable results. In enterprise applications where complex decision-making is involved, this strategy ensures stakeholders understand why a particular output was generated. This transparency is crucial in high-stakes areas like finance, healthcare, and logistics, where understanding the reasoning behind an output is as important as the output itself.

### **2.4. Iterative Feedback and Adaptive Prompting**

Iterative prompting involves providing multiple prompts or rounds of feedback to refine the output. Adaptive prompts take prior responses and adjust based on context, ensuring the final output meets the required standard.

**Example**:

- First Prompt: "Generate a mission statement for our AI-driven logistics company."
  - Model Response: "We use artificial intelligence to enhance logistics."
  - Follow-up Prompt: "Can you make the statement more specific by mentioning how AI improves efficiency and sustainability?"

**Why It Works**: Enterprises require output that is precise and tailored to brand identity. Iterative feedback provides an effective means to adjust and refine outputs until the desired quality is achieved. By breaking down the task into multiple feedback loops, enterprises can ensure the final output is aligned with their core values and objectives.

### **2.5. Contextual Expansion for Enhanced Relevance**

A lesser-known but powerful strategy is contextual expansion. This involves expanding the prompt to include broader information about the context, thereby allowing the model to generate richer, more relevant responses.

**Example**:

- Original Prompt: "Write a response to a customer asking for a refund."
  - Contextually Expanded Prompt: "Write a response to a customer asking for a refund on a recently purchased product. The customer expressed dissatisfaction with the quality and mentioned they want the process to be quick. Ensure the response is empathetic and explains the refund process clearly, while also offering alternative solutions like an exchange if possible."

**Why It Works**: By including more context, the prompt allows the model to generate a response that feels more tailored to the customer's situation, enhancing both satisfaction and trust. Enterprises benefit from this approach by increasing the quality of customer service interactions.

## **3. What Doesn't Work in Prompting**

While the above methods are effective, prompting can often fall short in certain scenarios:

### **3.1. Overly Vague Prompts**

An insufficiently detailed prompt results in vague outputs. For example, simply asking "What are some strategies to grow a business?" can lead to generic responses that lack actionable insight. Vague prompts are particularly problematic in enterprise settings where specificity is crucial to drive action.

### **3.2. Excessive Length**

Overloading a prompt with details often causes the LLM to become confused, producing incomplete or inaccurate responses. For example, "Explain blockchain, focusing on cryptographic methods, network nodes, ledger distribution, proof of work, mining processes, hash functions, transaction validation, etc." attempts to include too many subjects for a concise response. Enterprise-grade prompts should focus on a specific area to avoid overwhelming the model and degrading the output quality.

### **3.3. Ambiguity in Expected Output**

Ambiguity arises when prompts don't clearly specify the desired output format, tone, or length. For example, asking "Describe our new product" without specifying whether it should be a single-line summary, a paragraph, or a technical overview can lead to an unpredictable response. Enterprises must clearly define expectations to ensure consistent and high-quality outputs.

## **4. The Holy Grail: Automated Prompt Engineering**

In an enterprise setting, scaling prompt engineering for consistency and high performance remains a key challenge. Automated Prompt Engineering (APE) offers a potential solution for bridging the gap between individual craftsmanship and enterprise-wide implementation.

**4.1. AI-Augmented Prompt Design**

Automated Prompt Engineering tools can evaluate the outputs generated by various prompts, selecting the one with the highest quality metrics. These tools can be trained to understand what constitutes an ideal response for specific enterprise contexts.

**Example**:

- An APE system takes multiple variations of a prompt for generating email responses to customer complaints. After evaluating the sentiment, tone, and accuracy of each response, it selects the prompt that yields the most favorable output for business goals.

**Why It Works**: AI-Augmented Prompt Design reduces the need for manual intervention and standardizes the quality of responses across the organization. This approach helps enterprises maintain consistency while saving valuable time that would otherwise be spent on trial-and-error prompting.

**4.2. Reinforcement Learning for Prompts (RLP)**

Using Reinforcement Learning for Prompts involves training models to automatically iterate on prompts to improve the quality of the final output. The model is rewarded for generating responses that align with predefined criteria, such as clarity, completeness, or relevance.

**Example**:

- An enterprise uses RLP to refine prompts used in internal compliance checks. The model iteratively generates summaries of compliance reports, refining the prompt until it consistently generates clear, concise, and accurate summaries aligned with internal guidelines.

**Why It Works**: RLP can significantly improve the quality of complex outputs over time. Enterprises that require a high level of precision, such as in legal or compliance-related applications, benefit from RLP by ensuring outputs meet stringent standards.

**4.3. Dynamic Contextual Adaptation**

Another aspect of automated prompt engineering involves adapting prompts in real time based on user context. For example, if a user interacting with a customer support bot seems frustrated (as detected by sentiment analysis), an adaptive prompt may be used to generate a more empathetic response.

**Example**:

- User: "I'm really annoyed that my order hasn't arrived yet."
  - Prompt (adapted): "I'm truly sorry for the inconvenience you're experiencing. Please let me help you resolve this as quickly as possible. Could you provide your order number so I can check its status right away?"

**Why It Works**: In dynamic enterprise environments, where every user experience matters, adapting prompts to the immediate context can significantly improve customer satisfaction. Real-time adaptation allows the model to be more responsive and attuned to customer needs, thereby fostering loyalty and trust.

**4.4. Collaborative Prompt Refinement**

Automated prompt engineering can also involve collaboration between AI models and human experts. Collaborative Prompt Refinement (CPR) allows human operators to provide iterative guidance, which the model then uses to enhance its understanding and improve future outputs.

**Example**:

- A financial analyst uses a prompt to generate an investment report. The model provides an initial draft, and the analyst refines it with comments. The model learns from these comments and applies similar refinements to future reports, reducing the analyst’s workload over time.

**Why It Works**: CPR bridges the gap between human expertise and machine efficiency, ensuring that outputs are not only technically accurate but also aligned with expert expectations. This iterative learning loop enhances the model’s ability to autonomously generate high-quality content.

## **5. The Future of Enterprise-Grade Prompting**

The future of enterprise-grade prompting is in leveraging automation, context-awareness, and reinforcement learning. By moving from static prompts to dynamic, learning-enabled systems, enterprises can ensure consistent and optimized communication across their AI systems.

Automated systems such as APE and RLP are in their early stages, but they represent the potential to deliver highly scalable prompting solutions that automatically evolve based on user feedback and performance metrics. As more sophisticated models and methods become available, enterprise-grade prompting will likely involve:

- **Fully Adaptive Models**: Models that can detect and adjust to the tone, intent, and needs of users in real time. This means less manual intervention and greater responsiveness to user context.
- **Cross-Domain Learning**: Prompting systems that leverage insights across multiple domains to improve response quality. For example, lessons learned from customer service prompts could be applied to internal HR prompts to enhance employee communications.
- **Human-in-the-Loop Systems**: Combining automated prompt generation with human validation to ensure compliance, accuracy, and brand consistency. Human-in-the-loop systems allow enterprises to leverage the efficiency of automation while maintaining a high level of quality control.

The rise of self-improving prompting systems marks a significant shift in how enterprises leverage AI for communication and decision-making. As more sophisticated models emerge, we anticipate a greater emphasis on adaptability, real-time learning, and seamless integration with existing business processes.

**Conclusion**

Enterprise-grade prompting transcends the art of crafting effective prompts into a well-defined process, merging structure with creativity and guided refinement. By understanding the foundational principles, leveraging strategies like instruction-based and chain-of-thought prompting, and adopting automation, enterprises can consistently extract high-quality results from LLMs.

The evolution towards automated prompt engineering is transforming enterprise AI use from reactive problem-solving to proactive, intelligent decision-making. As the enterprise AI ecosystem matures, prompting will continue to be the linchpin that aligns the capabilities of LLMs with real-world business needs, ensuring optimal outcomes at scale.

Whether it's customer support, compliance, marketing, or operational analytics, the strategies outlined in this essay—paired with advancements in automated prompt engineering—hold the key to effective, scalable, and enterprise-grade utilization of AI models. Enterprises that invest in these methodologies today are likely to maintain a competitive edge in an increasingly automated business landscape.

**Next Steps**

This essay is a stepping stone towards understanding enterprise-grade prompting. We encourage AI teams to start experimenting with these prompting techniques in sandbox environments, identify what works best for their needs, and gradually iterate. Automation is the future, and investing in automated prompt engineering today will yield highly optimized, scalable solutions that consistently deliver value.

Ready to take the next step? Let’s explore how to design adaptive prompting frameworks tailored to your enterprise’s unique requirements.

--------------------------------------------------

# File: swarms/prompts/main.md

# Managing Prompts in Production

The `Prompt` class provides a comprehensive solution for managing prompts, including advanced features like version control, autosaving, and logging. This guide will walk you through how to effectively use this class in a production environment, focusing on its core features, use cases, and best practices.

## Table of Contents

1. **Getting Started**
    - Installation and Setup
    - Creating a New Prompt
2. **Managing Prompt Content**
    - Editing Prompts
    - Retrieving Prompt Content
3. **Version Control**
    - Tracking Edits and History
    - Rolling Back to Previous Versions
4. **Autosaving Prompts**
    - Enabling and Configuring Autosave
    - Manually Triggering Autosave
5. **Logging and Telemetry**
6. **Handling Errors**
7. **Extending the Prompt Class**
    - Customizing the Save Mechanism
    - Integrating with Databases

---

## 1. Getting Started

### Installation and Setup

Before diving into how to use the `Prompt` class, ensure that you have the required dependencies installed:

```bash
pip3 install -U swarms
```


### Creating a New Prompt

To create a new instance of a `Prompt`, simply initialize it with the required attributes such as `content`:

```python
from swarms import Prompt

prompt = Prompt(
    content="This is my first prompt!",
    name="My First Prompt",
    description="A simple example prompt."
)

print(prompt)
```

This creates a new prompt with the current timestamp and a unique identifier.

---

## 2. Managing Prompt Content

### Editing Prompts

Once you have initialized a prompt, you can edit its content using the `edit_prompt` method. Each time the content is edited, a new version is stored in the `edit_history`, and the `last_modified_at` timestamp is updated.

```python
new_content = "This is an updated version of my prompt."
prompt.edit_prompt(new_content)
```

**Note**: If the new content is identical to the current content, an error will be raised to prevent unnecessary edits:

```python
try:
    prompt.edit_prompt("This is my first prompt!")  # Same as initial content
except ValueError as e:
    print(e)  # Output: New content must be different from the current content.
```

### Retrieving Prompt Content

You can retrieve the current prompt content using the `get_prompt` method:

```python
current_content = prompt.get_prompt()
print(current_content)  # Output: This is an updated version of my prompt.
```

This method also logs telemetry data, which includes both system information and prompt metadata.

---

## 3. Version Control

### Tracking Edits and History

The `Prompt` class automatically tracks every change made to the prompt. This is stored in the `edit_history` attribute as a list of previous versions.

```python
print(prompt.edit_history)  # Output: ['This is my first prompt!', 'This is an updated version of my prompt.']
```

The number of edits is also tracked using the `edit_count` attribute:

```python
print(prompt.edit_count)  # Output: 2
```

### Rolling Back to Previous Versions

If you want to revert a prompt to a previous version, you can use the `rollback` method, passing the version index you want to revert to:

```python
prompt.rollback(0)
print(prompt.get_prompt())  # Output: This is my first prompt!
```

The rollback operation is thread-safe, and any rollback also triggers a telemetry log.

---

## 4. Autosaving Prompts

### Enabling and Configuring Autosave

To automatically save prompts to storage after every change, you can enable the `autosave` feature when initializing the prompt:

```python
prompt = Prompt(
    content="This is my first prompt!",
    autosave=True,
    autosave_folder="my_prompts"  # Specify the folder within WORKSPACE_DIR
)
```

This will ensure that every edit or rollback action triggers an autosave to the specified folder.

### Manually Triggering Autosave

You can also manually trigger an autosave by calling the `_autosave` method (which is a private method typically used internally):

```python
prompt._autosave()  # Manually triggers autosaving
```

Autosaves are stored as JSON files in the folder specified by `autosave_folder` under the workspace directory (`WORKSPACE_DIR` environment variable).

---

## 5. Logging and Telemetry

The `Prompt` class integrates with the `loguru` logging library to provide detailed logs for every major action, such as editing, rolling back, and saving. The `log_telemetry` method captures and logs system data, including prompt metadata, for each operation.

Here's an example of a log when editing a prompt:

```bash
2024-10-10 10:12:34.567 | INFO  | Editing prompt a7b8f9. Current content: 'This is my first prompt!'
2024-10-10 10:12:34.789 | DEBUG | Prompt a7b8f9 updated. Edit count: 1. New content: 'This is an updated version of my prompt.'
```

You can extend logging by integrating the `log_telemetry` method with your own telemetry systems or databases:

```python
prompt.log_telemetry()
```

---

## 6. Handling Errors

Error handling in the `Prompt` class is robust and prevents common mistakes, such as editing with identical content or rolling back to an invalid version. Here's a common scenario:

### Editing with Identical Content

```python
try:
    prompt.edit_prompt("This is an updated version of my prompt.")
except ValueError as e:
    print(e)  # Output: New content must be different from the current content.
```

### Invalid Rollback Version

```python
try:
    prompt.rollback(10)  # Invalid version index
except IndexError as e:
    print(e)  # Output: Invalid version number for rollback.
```

Always ensure that version numbers passed to `rollback` are within the valid range of existing versions.

---

## 7. Extending the Prompt Class

### Customizing the Save Mechanism

The `Prompt` class currently includes a placeholder for saving and loading prompts from persistent storage. You can override the `save_to_storage` and `load_from_storage` methods to integrate with databases, cloud storage, or other persistent layers.

Here's how you can implement the save functionality:

```python
def save_to_storage(self):
    # Example of saving to a database or cloud storage
    data = self.model_dump()
    save_to_database(data)  # Custom function to save data
```

Similarly, you can implement a `load_from_storage` function to load the prompt from a storage location using its unique identifier (`id`).


## Full Example code with all methods

```python
from swarms.prompts.prompt import Prompt

# Example 1: Initializing a Financial Report Prompt
financial_prompt = Prompt(
    content="Q1 2024 Earnings Report: Initial Draft", autosave=True
)

# Output the initial state of the prompt
print("\n--- Example 1: Initializing Prompt ---")
print(f"Prompt ID: {financial_prompt.id}")
print(f"Content: {financial_prompt.content}")
print(f"Created At: {financial_prompt.created_at}")
print(f"Edit Count: {financial_prompt.edit_count}")
print(f"History: {financial_prompt.edit_history}")


# Example 2: Editing a Financial Report Prompt
financial_prompt.edit_prompt(
    "Q1 2024 Earnings Report: Updated Revenue Figures"
)

# Output the updated state of the prompt
print("\n--- Example 2: Editing Prompt ---")
print(f"Content after edit: {financial_prompt.content}")
print(f"Edit Count: {financial_prompt.edit_count}")
print(f"History: {financial_prompt.edit_history}")


# Example 3: Rolling Back to a Previous Version
financial_prompt.edit_prompt("Q1 2024 Earnings Report: Final Version")
financial_prompt.rollback(
    1
)  # Roll back to the second version (index 1)

# Output the state after rollback
print("\n--- Example 3: Rolling Back ---")
print(f"Content after rollback: {financial_prompt.content}")
print(f"Edit Count: {financial_prompt.edit_count}")
print(f"History: {financial_prompt.edit_history}")


# Example 4: Handling Invalid Rollback
print("\n--- Example 4: Invalid Rollback ---")
try:
    financial_prompt.rollback(
        5
    )  # Attempt an invalid rollback (out of bounds)
except IndexError as e:
    print(f"Error: {e}")


# Example 5: Preventing Duplicate Edits
print("\n--- Example 5: Preventing Duplicate Edits ---")
try:
    financial_prompt.edit_prompt(
        "Q1 2024 Earnings Report: Updated Revenue Figures"
    )  # Duplicate content
except ValueError as e:
    print(f"Error: {e}")


# Example 6: Retrieving the Prompt Content as a String
print("\n--- Example 6: Retrieving Prompt as String ---")
current_content = financial_prompt.get_prompt()
print(f"Current Prompt Content: {current_content}")


# Example 7: Simulating Financial Report Changes Over Time
print("\n--- Example 7: Simulating Changes Over Time ---")
# Initialize a new prompt representing an initial financial report draft
financial_prompt = Prompt(
    content="Q2 2024 Earnings Report: Initial Draft"
)

# Simulate several updates over time
financial_prompt.edit_prompt(
    "Q2 2024 Earnings Report: Updated Forecasts"
)
financial_prompt.edit_prompt(
    "Q2 2024 Earnings Report: Revenue Adjustments"
)
financial_prompt.edit_prompt("Q2 2024 Earnings Report: Final Review")

# Display full history
print(f"Final Content: {financial_prompt.content}")
print(f"Edit Count: {financial_prompt.edit_count}")
print(f"Edit History: {financial_prompt.edit_history}")



```

---

## 8. Conclusion

This guide covered how to effectively use the `Prompt` class in production environments, including core features like editing, version control, autosaving, and logging. By following the best practices outlined here, you can ensure that your prompts are managed efficiently, with minimal overhead and maximum flexibility.

The `Prompt` class is designed with scalability and robustness in mind, making it a great choice for managing prompt content in multi-agent architectures or any application where dynamic prompt management is required. Feel free to extend the functionality to suit your needs, whether it's integrating with persistent storage or enhancing logging mechanisms.

By using this architecture, you'll be able to scale your system effortlessly while maintaining detailed version control and history of every interaction with your prompts.

--------------------------------------------------

# File: swarms/structs/abstractswarm.md

# `BaseSwarm` Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [Class Definition](#class-definition)
3. [Methods](#methods)
    - [communicate()](#communicate)
    - [run()](#run)
    - [arun()](#arun)
    - [add_worker(worker)](#add_worker)
    - [remove_worker(worker)](#remove_worker)
    - [broadcast(message, sender)](#broadcast)
    - [reset()](#reset)
    - [plan(task)](#plan)
    - [direct_message(message, sender, recipient)](#direct_message)
    - [autoscaler(num_workers, worker)](#autoscaler)
    - [get_worker_by_id(id)](#get_worker_by_id)
    - [get_worker_by_name(name)](#get_worker_by_name)
    - [assign_task(worker, task)](#assign_task)
    - [get_all_tasks(worker, task)](#get_all_tasks)
    - [get_finished_tasks()](#get_finished_tasks)
    - [get_pending_tasks()](#get_pending_tasks)
    - [pause_worker(worker, worker_id)](#pause_worker)
    - [resume_worker(worker, worker_id)](#resume_worker)
    - [stop_worker(worker, worker_id)](#stop_worker)
    - [restart_worker(worker)](#restart_worker)
    - [scale_up(num_worker)](#scale_up)
    - [scale_down(num_worker)](#scale_down)
    - [scale_to(num_worker)](#scale_to)
    - [get_all_workers()](#get_all_workers)
    - [get_swarm_size()](#get_swarm_size)
    - [get_swarm_status()](#get_swarm_status)
    - [save_swarm_state()](#save_swarm_state)

---

## 1. Introduction <a name="introduction"></a>

The Swarms library is designed to provide a framework for swarm simulation architectures. Swarms are collections of autonomous agents or workers that collaborate to perform tasks and achieve common goals. This documentation will guide you through the functionality and usage of the Swarms library, explaining the purpose and implementation details of the provided classes and methods.

## 2. Class Definition <a name="class-definition"></a>

### `BaseSwarm` Class

The `BaseSwarm` class is an abstract base class that serves as the foundation for swarm simulation architectures. It defines the core functionality and methods required to manage and interact with a swarm of workers.

```python
from abc import ABC, abstractmethod
from typing import List

from swarms.swarms.base import AbstractWorker


class BaseSwarm(ABC):
    """
    Abstract class for swarm simulation architectures

    Methods:
    ---------
    ...
    """

    # The class definition and constructor are provided here.

    @abstractmethod
    def __init__(self, workers: List["AbstractWorker"]):
        """Initialize the swarm with workers"""

    # Other abstract methods are listed here.
```

## 3. Methods <a name="methods"></a>

### `communicate()` <a name="communicate"></a>

The `communicate()` method allows the swarm to exchange information through the orchestrator, protocols, and the universal communication layer.

**Usage Example 1:**

```python
swarm = YourSwarmClass(workers)
swarm.communicate()
```

**Usage Example 2:**

```python
# Another example of using the communicate method
swarm = YourSwarmClass(workers)
swarm.communicate()
```

### `run()` <a name="run"></a>

The `run()` method executes the swarm, initiating its activities.

**Usage Example 1:**

```python
swarm = YourSwarmClass(workers)
swarm.run()
```

**Usage Example 2:**

```python
# Another example of running the swarm
swarm = YourSwarmClass(workers)
swarm.run()
```

### `arun()` <a name="arun"></a>

The `arun()` method runs the swarm asynchronously, allowing for parallel execution of tasks.

**Usage Example 1:**

```python
swarm = YourSwarmClass(workers)
swarm.arun()
```

**Usage Example 2:**

```python
# Another example of running the swarm asynchronously
swarm = YourSwarmClass(workers)
swarm.arun()
```

### `add_worker(worker: "AbstractWorker")` <a name="add_worker"></a>

The `add_worker()` method adds a worker to the swarm.

**Parameters:**
- `worker` (AbstractWorker): The worker to be added to the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass([])
worker = YourWorkerClass()
swarm.add_worker(worker)
```

### `remove_worker(worker: "AbstractWorker")` <a name="remove_worker"></a>

The `remove_worker()` method removes a worker from the swarm.

**Parameters:**
- `worker` (AbstractWorker): The worker to be removed from the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_id("worker_id")
swarm.remove_worker(worker)
```

### `broadcast(message: str, sender: Optional["AbstractWorker"] = None)` <a name="broadcast"></a>

The `broadcast()` method sends a message to all workers in the swarm.

**Parameters:**
- `message` (str): The message to be broadcasted.
- `sender` (Optional[AbstractWorker]): The sender of the message (optional).

**Usage Example 1:**

```python
swarm = YourSwarmClass(workers)
message = "Hello, everyone!"
swarm.broadcast(message)
```

**Usage Example 2:**

```python
# Another example of broadcasting a message
swarm = YourSwarmClass(workers)
message = "Important announcement!"
sender = swarm.get_worker_by_name("Supervisor")
swarm.broadcast(message, sender)
```

### `reset()` <a name="reset"></a>

The `reset()` method resets the swarm to its initial state.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm.reset()
```

### `plan(task: str)` <a name="plan"></a>

The `plan()` method instructs workers to individually plan using a workflow or pipeline for a specified task.

**Parameters:**
- `task` (str): The task for which workers should plan.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
task = "Perform data analysis"
swarm.plan(task)
```

### `direct_message(message: str, sender: "AbstractWorker", recipient: "AbstractWorker")` <a name="direct_message"></a>

The `direct_message()` method sends a direct message from one worker to another.

**Parameters:**
- `message` (str): The message to be sent.
- `sender` (AbstractWorker): The sender of the message.
- `recipient` (AbstractWorker): The recipient of the message.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
sender = swarm.get_worker_by_name("Worker1")
recipient = swarm.get_worker_by_name("Worker2")
message = "Hello

, Worker2!"
swarm.direct_message(message, sender, recipient)
```

### `autoscaler(num_workers: int, worker: List["AbstractWorker"])` <a name="autoscaler"></a>

The `autoscaler()` method acts as an autoscaler, dynamically adjusting the number of workers based on system load or other criteria.

**Parameters:**
- `num_workers` (int): The desired number of workers.
- `worker` (List[AbstractWorker]): A list of workers to be managed by the autoscaler.

**Usage Example:**

```python
swarm = YourSwarmClass([])
workers = [YourWorkerClass() for _ in range(10)]
swarm.autoscaler(5, workers)
```

### `get_worker_by_id(id: str) -> "AbstractWorker"` <a name="get_worker_by_id"></a>

The `get_worker_by_id()` method locates a worker in the swarm by their ID.

**Parameters:**
- `id` (str): The ID of the worker to locate.

**Returns:**
- `AbstractWorker`: The worker with the specified ID.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker_id = "worker_123"
worker = swarm.get_worker_by_id(worker_id)
```

### `get_worker_by_name(name: str) -> "AbstractWorker"` <a name="get_worker_by_name"></a>

The `get_worker_by_name()` method locates a worker in the swarm by their name.

**Parameters:**
- `name` (str): The name of the worker to locate.

**Returns:**
- `AbstractWorker`: The worker with the specified name.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker_name = "Alice"
worker = swarm.get_worker_by_name(worker_name)
```

### `assign_task(worker: "AbstractWorker", task: Any) -> Dict` <a name="assign_task"></a>

The `assign_task()` method assigns a task to a specific worker.

**Parameters:**
- `worker` (AbstractWorker): The worker to whom the task should be assigned.
- `task` (Any): The task to be assigned.

**Returns:**
- `Dict`: A dictionary indicating the status of the task assignment.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
task = "Perform data analysis"
result = swarm.assign_task(worker, task)
```

### `get_all_tasks(worker: "AbstractWorker", task: Any)` <a name="get_all_tasks"></a>

The `get_all_tasks()` method retrieves all tasks assigned to a specific worker.

**Parameters:**
- `worker` (AbstractWorker): The worker for whom tasks should be retrieved.
- `task` (Any): The task to be retrieved.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
tasks = swarm.get_all_tasks(worker, "data analysis")
```

### `get_finished_tasks() -> List[Dict]` <a name="get_finished_tasks"></a>

The `get_finished_tasks()` method retrieves all tasks that have been completed by the workers in the swarm.

**Returns:**
- `List[Dict]`: A list of dictionaries representing finished tasks.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
finished_tasks = swarm.get_finished_tasks()
```

### `get_pending_tasks() -> List[Dict]` <a name="get_pending_tasks"></a>

The `get_pending_tasks()` method retrieves all tasks that are pending or yet to be completed by the workers in the swarm.

**Returns:**
- `List[Dict]`: A list of dictionaries representing pending tasks.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
pending_tasks = swarm.get_pending_tasks()
```

### `pause_worker(worker: "AbstractWorker", worker_id: str)` <a name="pause_worker"></a>

The `pause_worker()` method pauses a specific worker, temporarily suspending their activities.

**Parameters:**
- `worker` (AbstractWorker): The worker to be paused.
- `worker_id` (str): The ID of the worker to be paused.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
worker_id = "worker_123"
swarm.pause_worker(worker, worker_id)
```

### `resume_worker(worker: "AbstractWorker", worker_id: str)` <a name="resume_worker"></a>

The `resume_worker()` method resumes a paused worker, allowing them to continue their activities.

**Parameters:**
- `worker` (AbstractWorker): The worker to be resumed.
- `worker_id` (str): The ID of the worker to be resumed.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
worker_id = "worker_123"
swarm.resume_worker(worker, worker_id)
```

### `stop_worker(worker: "AbstractWorker", worker_id: str)` <a name="stop_worker"></a>

The `stop_worker()` method stops a specific worker, terminating their activities.

**Parameters:**
- `worker` (AbstractWorker): The worker to be stopped.
- `worker_id` (str): The ID of the worker to be stopped.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
worker_id = "worker_123"
swarm.stop_worker(worker, worker_id)
```

### `restart_worker(worker: "AbstractWorker")` <a name="restart_worker"></a>

The `restart_worker()` method restarts a worker, resetting them to their initial state.

**Parameters:**
- `worker` (AbstractWorker): The worker to be restarted.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
worker = swarm.get_worker_by_name("Worker1")
swarm.restart_worker(worker)
```

### `scale_up(num_worker: int)` <a name="scale_up"></a>

The `scale_up()` method increases the number of workers in the swarm.

**Parameters:**
- `num_worker` (int): The number of workers to add to the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm.scale_up(5)
```

### `scale_down(num_worker: int)` <a name="scale_down"></a>

The `scale_down()` method decreases the number of workers in the swarm.

**Parameters:**
- `num_worker` (int): The number of workers to remove from the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm.scale_down(3)
```

### `scale_to(num_worker: int)` <a name="scale_to"></a>

The `scale_to()` method scales the swarm to a specific number of workers.

**Parameters:**
- `num_worker` (int): The desired number of workers.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm.scale_to(10)
```

### `get

_all_workers() -> List["AbstractWorker"]` <a name="get_all_workers"></a>

The `get_all_workers()` method retrieves a list of all workers in the swarm.

**Returns:**
- `List[AbstractWorker]`: A list of all workers in the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
all_workers = swarm.get_all_workers()
```

### `get_swarm_size() -> int` <a name="get_swarm_size"></a>

The `get_swarm_size()` method returns the size of the swarm, which is the total number of workers.

**Returns:**
- `int`: The size of the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm_size = swarm.get_swarm_size()
```

### `get_swarm_status() -> Dict` <a name="get_swarm_status"></a>

The `get_swarm_status()` method provides information about the current status of the swarm.

**Returns:**
- `Dict`: A dictionary containing various status indicators for the swarm.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm_status = swarm.get_swarm_status()
```

### `save_swarm_state()` <a name="save_swarm_state"></a>

The `save_swarm_state()` method allows you to save the current state of the swarm, including worker configurations and task assignments.

**Usage Example:**

```python
swarm = YourSwarmClass(workers)
swarm.save_swarm_state()
```

---

This comprehensive documentation covers the Swarms library, including the `BaseSwarm` class and its methods. You can use this documentation as a guide to understanding and effectively utilizing the Swarms framework for swarm simulation architectures. Feel free to explore further and adapt the library to your specific use cases.

--------------------------------------------------

# File: swarms/structs/agent.md

# `Agent`

Swarm Agent is a powerful autonomous agent framework designed to connect Language Models (LLMs) with various tools and long-term memory. This class provides the ability to ingest and process various types of documents such as PDFs, text files, Markdown files, JSON files, and more. The Agent structure offers a wide range of features to enhance the capabilities of LLMs and facilitate efficient task execution.

## Overview

The `Agent` class establishes a conversational loop with a language model, allowing for interactive task execution, feedback collection, and dynamic response generation. It includes features such as:

1. **Conversational Loop**: Enables back-and-forth interaction with the model.
2. **Feedback Collection**: Allows users to provide feedback on generated responses.
3. **Stoppable Conversation**: Supports custom stopping conditions for the conversation.
4. **Retry Mechanism**: Implements a retry system for handling issues in response generation.
5. **Tool Integration**: Supports the integration of various tools for enhanced capabilities.
6. **Long-term Memory Management**: Incorporates vector databases for efficient information retrieval.
7. **Document Ingestion**: Processes various document types for information extraction.
8. **Interactive Mode**: Allows real-time communication with the agent.
9. **Sentiment Analysis**: Evaluates the sentiment of generated responses.
10. **Output Filtering and Cleaning**: Ensures generated responses meet specific criteria.
11. **Asynchronous and Concurrent Execution**: Supports efficient parallelization of tasks.
12. **Planning and Reasoning**: Implements techniques like algorithm of thoughts for enhanced decision-making.


## Architecture

```mermaid
graph TD
    A[Task Initiation] -->|Receives Task| B[Initial LLM Processing]
    B -->|Interprets Task| C[Tool Usage]
    C -->|Calls Tools| D[Function 1]
    C -->|Calls Tools| E[Function 2]
    D -->|Returns Data| C
    E -->|Returns Data| C
    C -->|Provides Data| F[Memory Interaction]
    F -->|Stores and Retrieves Data| G[RAG System]
    G -->|ChromaDB/Pinecone| H[Enhanced Data]
    F -->|Provides Enhanced Data| I[Final LLM Processing]
    I -->|Generates Final Response| J[Output]
    C -->|No Tools Available| K[Skip Tool Usage]
    K -->|Proceeds to Memory Interaction| F
    F -->|No Memory Available| L[Skip Memory Interaction]
    L -->|Proceeds to Final LLM Processing| I
```


## `Agent` Attributes

| Attribute | Description |
|-----------|-------------|
| `id` | Unique identifier for the agent instance. |
| `llm` | Language model instance used by the agent. |
| `template` | Template used for formatting responses. |
| `max_loops` | Maximum number of loops the agent can run. |
| `stopping_condition` | Callable function determining when to stop looping. |
| `loop_interval` | Interval (in seconds) between loops. |
| `retry_attempts` | Number of retry attempts for failed LLM calls. |
| `retry_interval` | Interval (in seconds) between retry attempts. |
| `return_history` | Boolean indicating whether to return conversation history. |
| `stopping_token` | Token that stops the agent from looping when present in the response. |
| `dynamic_loops` | Boolean indicating whether to dynamically determine the number of loops. |
| `interactive` | Boolean indicating whether to run in interactive mode. |
| `dashboard` | Boolean indicating whether to display a dashboard. |
| `agent_name` | Name of the agent instance. |
| `agent_description` | Description of the agent instance. |
| `system_prompt` | System prompt used to initialize the conversation. |
| `tools` | List of callable functions representing tools the agent can use. |
| `dynamic_temperature_enabled` | Boolean indicating whether to dynamically adjust the LLM's temperature. |
| `sop` | Standard operating procedure for the agent. |
| `sop_list` | List of strings representing the standard operating procedure. |
| `saved_state_path` | File path for saving and loading the agent's state. |
| `autosave` | Boolean indicating whether to automatically save the agent's state. |
| `context_length` | Maximum length of the context window (in tokens) for the LLM. |
| `user_name` | Name used to represent the user in the conversation. |
| `self_healing_enabled` | Boolean indicating whether to attempt self-healing in case of errors. |
| `code_interpreter` | Boolean indicating whether to interpret and execute code snippets. |
| `multi_modal` | Boolean indicating whether to support multimodal inputs. |
| `pdf_path` | File path of a PDF document to be ingested. |
| `list_of_pdf` | List of file paths for PDF documents to be ingested. |
| `tokenizer` | Instance of a tokenizer used for token counting and management. |
| `long_term_memory` | Instance of a `BaseVectorDatabase` implementation for long-term memory management. |
| `preset_stopping_token` | Boolean indicating whether to use a preset stopping token. |
| `traceback` | Object used for traceback handling. |
| `traceback_handlers` | List of traceback handlers. |
| `streaming_on` | Boolean indicating whether to stream responses. |
| `docs` | List of document paths or contents to be ingested. |
| `docs_folder` | Path to a folder containing documents to be ingested. |
| `verbose` | Boolean indicating whether to print verbose output. |
| `parser` | Callable function used for parsing input data. |
| `best_of_n` | Integer indicating the number of best responses to generate. |
| `callback` | Callable function to be called after each agent loop. |
| `metadata` | Dictionary containing metadata for the agent. |
| `callbacks` | List of callable functions to be called during execution. |
| `logger_handler` | Handler for logging messages. |
| `search_algorithm` | Callable function for long-term memory retrieval. |
| `logs_to_filename` | File path for logging agent activities. |
| `evaluator` | Callable function for evaluating the agent's responses. |
| `stopping_func` | Callable function used as a stopping condition. |
| `custom_loop_condition` | Callable function used as a custom loop condition. |
| `sentiment_threshold` | Float value representing the sentiment threshold for evaluating responses. |
| `custom_exit_command` | String representing a custom command for exiting the agent's loop. |
| `sentiment_analyzer` | Callable function for sentiment analysis on outputs. |
| `limit_tokens_from_string` | Callable function for limiting the number of tokens in a string. |
| `custom_tools_prompt` | Callable function for generating a custom prompt for tool usage. |
| `tool_schema` | Data structure representing the schema for the agent's tools. |
| `output_type` | Type representing the expected output type of responses. |
| `function_calling_type` | String representing the type of function calling. |
| `output_cleaner` | Callable function for cleaning the agent's output. |
| `function_calling_format_type` | String representing the format type for function calling. |
| `list_base_models` | List of base models used for generating tool schemas. |
| `metadata_output_type` | String representing the output type for metadata. |
| `state_save_file_type` | String representing the file type for saving the agent's state. |
| `chain_of_thoughts` | Boolean indicating whether to use the chain of thoughts technique. |
| `algorithm_of_thoughts` | Boolean indicating whether to use the algorithm of thoughts technique. |
| `tree_of_thoughts` | Boolean indicating whether to use the tree of thoughts technique. |
| `tool_choice` | String representing the method for tool selection. |
| `execute_tool` | Boolean indicating whether to execute tools. |
| `rules` | String representing the rules for the agent's behavior. |
| `planning` | Boolean indicating whether to perform planning. |
| `planning_prompt` | String representing the prompt for planning. |
| `device` | String representing the device on which the agent should run. |
| `custom_planning_prompt` | String representing a custom prompt for planning. |
| `memory_chunk_size` | Integer representing the maximum size of memory chunks for long-term memory retrieval. |
| `agent_ops_on` | Boolean indicating whether agent operations should be enabled. |
| `return_step_meta` | Boolean indicating whether to return JSON of all steps and additional metadata. |
| `output_type` | Literal type indicating whether to output "string", "str", "list", "json", "dict", or "yaml". |
| `time_created` | Float representing the time the agent was created. |
| `tags` | Optional list of strings for tagging the agent. |
| `use_cases` | Optional list of dictionaries describing use cases for the agent. |
| `step_pool` | List of Step objects representing the agent's execution steps. |
| `print_every_step` | Boolean indicating whether to print every step of execution. |
| `agent_output` | ManySteps object containing the agent's output and metadata. |
| `executor_workers` | Integer representing the number of executor workers for concurrent operations. |
| `data_memory` | Optional callable for data memory operations. |
| `load_yaml_path` | String representing the path to a YAML file for loading configurations. |
| `auto_generate_prompt` | Boolean indicating whether to automatically generate prompts. |
| `rag_every_loop` | Boolean indicating whether to query RAG database for context on every loop |
| `plan_enabled` | Boolean indicating whether planning functionality is enabled |
| `artifacts_on` | Boolean indicating whether to save artifacts from agent execution |
| `artifacts_output_path` | File path where artifacts should be saved |
| `artifacts_file_extension` | File extension to use for saved artifacts |
| `device` | Device to run computations on ("cpu" or "gpu") |
| `all_cores` | Boolean indicating whether to use all CPU cores |
| `device_id` | ID of the GPU device to use if running on GPU |
| `scheduled_run_date` | Optional datetime for scheduling future agent runs |


## `Agent` Methods

| Method | Description | Inputs | Usage Example |
|--------|-------------|--------|----------------|
| `run(task, img=None, is_last=False, device="cpu", device_id=0, all_cores=True, *args, **kwargs)` | Runs the autonomous agent loop to complete the given task. | `task` (str): The task to be performed.<br>`img` (str, optional): Path to an image file.<br>`is_last` (bool): Whether this is the last task.<br>`device` (str): Device to run on ("cpu" or "gpu").<br>`device_id` (int): ID of the GPU to use.<br>`all_cores` (bool): Whether to use all CPU cores.<br>`*args`, `**kwargs`: Additional arguments. | `response = agent.run("Generate a report on financial performance.")` |
| `__call__(task, img=None, *args, **kwargs)` | Alternative way to call the `run` method. | Same as `run`. | `response = agent("Generate a report on financial performance.")` |
| `parse_and_execute_tools(response, *args, **kwargs)` | Parses the agent's response and executes any tools mentioned in it. | `response` (str): The agent's response to be parsed.<br>`*args`, `**kwargs`: Additional arguments. | `agent.parse_and_execute_tools(response)` |
| `add_memory(message)` | Adds a message to the agent's memory. | `message` (str): The message to add. | `agent.add_memory("Important information")` |
| `plan(task, *args, **kwargs)` | Plans the execution of a task. | `task` (str): The task to plan.<br>`*args`, `**kwargs`: Additional arguments. | `agent.plan("Analyze market trends")` |
| `run_concurrent(task, *args, **kwargs)` | Runs a task concurrently. | `task` (str): The task to run.<br>`*args`, `**kwargs`: Additional arguments. | `response = await agent.run_concurrent("Concurrent task")` |
| `run_concurrent_tasks(tasks, *args, **kwargs)` | Runs multiple tasks concurrently. | `tasks` (List[str]): List of tasks to run.<br>`*args`, `**kwargs`: Additional arguments. | `responses = agent.run_concurrent_tasks(["Task 1", "Task 2"])` |
| `bulk_run(inputs)` | Generates responses for multiple input sets. | `inputs` (List[Dict[str, Any]]): List of input dictionaries. | `responses = agent.bulk_run([{"task": "Task 1"}, {"task": "Task 2"}])` |
| `save()` | Saves the agent's history to a file. | None | `agent.save()` |
| `load(file_path)` | Loads the agent's history from a file. | `file_path` (str): Path to the file. | `agent.load("agent_history.json")` |
| `graceful_shutdown()` | Gracefully shuts down the system, saving the state. | None | `agent.graceful_shutdown()` |
| `analyze_feedback()` | Analyzes the feedback for issues. | None | `agent.analyze_feedback()` |
| `undo_last()` | Undoes the last response and returns the previous state. | None | `previous_state, message = agent.undo_last()` |
| `add_response_filter(filter_word)` | Adds a response filter to filter out certain words. | `filter_word` (str): Word to filter. | `agent.add_response_filter("sensitive")` |
| `apply_response_filters(response)` | Applies response filters to the given response. | `response` (str): Response to filter. | `filtered_response = agent.apply_response_filters(response)` |
| `filtered_run(task)` | Runs a task with response filtering applied. | `task` (str): Task to run. | `response = agent.filtered_run("Generate a report")` |
| `save_to_yaml(file_path)` | Saves the agent to a YAML file. | `file_path` (str): Path to save the YAML file. | `agent.save_to_yaml("agent_config.yaml")` |
| `get_llm_parameters()` | Returns the parameters of the language model. | None | `llm_params = agent.get_llm_parameters()` |
| `save_state(file_path, *args, **kwargs)` | Saves the current state of the agent to a JSON file. | `file_path` (str): Path to save the JSON file.<br>`*args`, `**kwargs`: Additional arguments. | `agent.save_state("agent_state.json")` |
| `update_system_prompt(system_prompt)` | Updates the system prompt. | `system_prompt` (str): New system prompt. | `agent.update_system_prompt("New system instructions")` |
| `update_max_loops(max_loops)` | Updates the maximum number of loops. | `max_loops` (int): New maximum number of loops. | `agent.update_max_loops(5)` |
| `update_loop_interval(loop_interval)` | Updates the loop interval. | `loop_interval` (int): New loop interval. | `agent.update_loop_interval(2)` |
| `update_retry_attempts(retry_attempts)` | Updates the number of retry attempts. | `retry_attempts` (int): New number of retry attempts. | `agent.update_retry_attempts(3)` |
| `update_retry_interval(retry_interval)` | Updates the retry interval. | `retry_interval` (int): New retry interval. | `agent.update_retry_interval(5)` |
| `reset()` | Resets the agent's memory. | None | `agent.reset()` |
| `ingest_docs(docs, *args, **kwargs)` | Ingests documents into the agent's memory. | `docs` (List[str]): List of document paths.<br>`*args`, `**kwargs`: Additional arguments. | `agent.ingest_docs(["doc1.pdf", "doc2.txt"])` |
| `ingest_pdf(pdf)` | Ingests a PDF document into the agent's memory. | `pdf` (str): Path to the PDF file. | `agent.ingest_pdf("document.pdf")` |
| `receive_message(name, message)` | Receives a message and adds it to the agent's memory. | `name` (str): Name of the sender.<br>`message` (str): Content of the message. | `agent.receive_message("User", "Hello, agent!")` |
| `send_agent_message(agent_name, message, *args, **kwargs)` | Sends a message from the agent to a user. | `agent_name` (str): Name of the agent.<br>`message` (str): Message to send.<br>`*args`, `**kwargs`: Additional arguments. | `response = agent.send_agent_message("AgentX", "Task completed")` |
| `add_tool(tool)` | Adds a tool to the agent's toolset. | `tool` (Callable): Tool to add. | `agent.add_tool(my_custom_tool)` |
| `add_tools(tools)` | Adds multiple tools to the agent's toolset. | `tools` (List[Callable]): List of tools to add. | `agent.add_tools([tool1, tool2])` |
| `remove_tool(tool)` | Removes a tool from the agent's toolset. || Method | Description | Inputs | Usage Example |
|--------|-------------|--------|----------------|
| `remove_tool(tool)` | Removes a tool from the agent's toolset. | `tool` (Callable): Tool to remove. | `agent.remove_tool(my_custom_tool)` |
| `remove_tools(tools)` | Removes multiple tools from the agent's toolset. | `tools` (List[Callable]): List of tools to remove. | `agent.remove_tools([tool1, tool2])` |
| `get_docs_from_doc_folders()` | Retrieves and processes documents from the specified folder. | None | `agent.get_docs_from_doc_folders()` |
| `memory_query(task, *args, **kwargs)` | Queries the long-term memory for relevant information. | `task` (str): The task or query.<br>`*args`, `**kwargs`: Additional arguments. | `result = agent.memory_query("Find information about X")` |
| `sentiment_analysis_handler(response)` | Performs sentiment analysis on the given response. | `response` (str): The response to analyze. | `agent.sentiment_analysis_handler("Great job!")` |
| `count_and_shorten_context_window(history, *args, **kwargs)` | Counts tokens and shortens the context window if necessary. | `history` (str): The conversation history.<br>`*args`, `**kwargs`: Additional arguments. | `shortened_history = agent.count_and_shorten_context_window(history)` |
| `output_cleaner_and_output_type(response, *args, **kwargs)` | Cleans and formats the output based on specified type. | `response` (str): The response to clean and format.<br>`*args`, `**kwargs`: Additional arguments. | `cleaned_response = agent.output_cleaner_and_output_type(response)` |
| `stream_response(response, delay=0.001)` | Streams the response token by token. | `response` (str): The response to stream.<br>`delay` (float): Delay between tokens. | `agent.stream_response("This is a streamed response")` |
| `dynamic_context_window()` | Dynamically adjusts the context window. | None | `agent.dynamic_context_window()` |
| `check_available_tokens()` | Checks and returns the number of available tokens. | None | `available_tokens = agent.check_available_tokens()` |
| `tokens_checks()` | Performs token checks and returns available tokens. | None | `token_info = agent.tokens_checks()` |
| `truncate_string_by_tokens(input_string, limit)` | Truncates a string to fit within a token limit. | `input_string` (str): String to truncate.<br>`limit` (int): Token limit. | `truncated_string = agent.truncate_string_by_tokens("Long string", 100)` |
| `tokens_operations(input_string)` | Performs various token-related operations on the input string. | `input_string` (str): String to process. | `processed_string = agent.tokens_operations("Input string")` |
| `parse_function_call_and_execute(response)` | Parses a function call from the response and executes it. | `response` (str): Response containing the function call. | `result = agent.parse_function_call_and_execute(response)` |
| `llm_output_parser(response)` | Parses the output from the language model. | `response` (Any): Response from the LLM. | `parsed_response = agent.llm_output_parser(llm_output)` |
| `log_step_metadata(loop, task, response)` | Logs metadata for each step of the agent's execution. | `loop` (int): Current loop number.<br>`task` (str): Current task.<br>`response` (str): Agent's response. | `agent.log_step_metadata(1, "Analyze data", "Analysis complete")` |
| `to_dict()` | Converts the agent's attributes to a dictionary. | None | `agent_dict = agent.to_dict()` |
| `to_json(indent=4, *args, **kwargs)` | Converts the agent's attributes to a JSON string. | `indent` (int): Indentation for JSON.<br>`*args`, `**kwargs`: Additional arguments. | `agent_json = agent.to_json()` |
| `to_yaml(indent=4, *args, **kwargs)` | Converts the agent's attributes to a YAML string. | `indent` (int): Indentation for YAML.<br>`*args`, `**kwargs`: Additional arguments. | `agent_yaml = agent.to_yaml()` |
| `to_toml(*args, **kwargs)` | Converts the agent's attributes to a TOML string. | `*args`, `**kwargs`: Additional arguments. | `agent_toml = agent.to_toml()` |
| `model_dump_json()` | Saves the agent model to a JSON file in the workspace directory. | None | `agent.model_dump_json()` |
| `model_dump_yaml()` | Saves the agent model to a YAML file in the workspace directory. | None | `agent.model_dump_yaml()` |
| `log_agent_data()` | Logs the agent's data to an external API. | None | `agent.log_agent_data()` |
| `handle_tool_schema_ops()` | Handles operations related to tool schemas. | None | `agent.handle_tool_schema_ops()` |
| `call_llm(task, *args, **kwargs)` | Calls the appropriate method on the language model. | `task` (str): Task for the LLM.<br>`*args`, `**kwargs`: Additional arguments. | `response = agent.call_llm("Generate text")` |
| `handle_sop_ops()` | Handles operations related to standard operating procedures. | None | `agent.handle_sop_ops()` |
| `agent_output_type(responses)` | Processes and returns the agent's output based on the specified output type. | `responses` (list): List of responses. | `formatted_output = agent.agent_output_type(responses)` |
| `check_if_no_prompt_then_autogenerate(task)` | Checks if a system prompt is not set and auto-generates one if needed. | `task` (str): The task to use for generating a prompt. | `agent.check_if_no_prompt_then_autogenerate("Analyze data")` |
| `check_if_no_prompt_then_autogenerate(task)` | Checks if auto_generate_prompt is enabled and generates a prompt by combining agent name, description and system prompt | `task` (str, optional): Task to use as fallback | `agent.check_if_no_prompt_then_autogenerate("Analyze data")` |
| `handle_artifacts(response, output_path, extension)` | Handles saving artifacts from agent execution | `response` (str): Agent response<br>`output_path` (str): Output path<br>`extension` (str): File extension | `agent.handle_artifacts(response, "outputs/", ".txt")` |



## Updated Run Method

Update the run method documentation to include new parameters:

| Method | Description | Inputs | Usage Example |
|--------|-------------|--------|----------------|
| `run(task, img=None, is_last=False, device="cpu", device_id=0, all_cores=True, scheduled_run_date=None)` | Runs the agent with specified parameters | `task` (str): Task to run<br>`img` (str, optional): Image path<br>`is_last` (bool): If this is last task<br>`device` (str): Device to use<br>`device_id` (int): GPU ID<br>`all_cores` (bool): Use all CPU cores<br>`scheduled_run_date` (datetime, optional): Future run date | `agent.run("Analyze data", device="gpu", device_id=0)` |



## Getting Started

To use the Swarm Agent, first install the required dependencies:

```bash
pip3 install -U swarms
```

Then, you can initialize and use the agent as follows:

```python
import os
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT

# Get the OpenAI API key from the environment variable
api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    api_key=api_key, model_name="gpt-4-0613", temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    llm=model,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    user_name="swarms_corp",
    retry_attempts=1,
    context_length=200000,
    return_step_meta=False,
    output_type="str",
)

# Run the agent
response = agent.run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?"
)
print(response)
```

## Advanced Usage

### Tool Integration

To integrate tools with the Swarm `Agent`, you can pass a list of callable functions with types and doc strings to the `tools` parameter when initializing the `Agent` instance. The agent will automatically convert these functions into an OpenAI function calling schema and make them available for use during task execution.

## Requirements for a tool
- Function
  - With types
  - with doc strings

```python
from swarms import Agent
from swarm_models import OpenAIChat
import subprocess

def terminal(code: str):
    """
    Run code in the terminal.

    Args:
        code (str): The code to run in the terminal.

    Returns:
        str: The output of the code.
    """
    out = subprocess.run(code, shell=True, capture_output=True, text=True).stdout
    return str(out)

# Initialize the agent with a tool
agent = Agent(
    agent_name="Terminal-Agent",
    llm=OpenAIChat(api_key=os.getenv("OPENAI_API_KEY")),
    tools=[terminal],
    system_prompt="You are an agent that can execute terminal commands. Use the tools provided to assist the user.",
)

# Run the agent
response = agent.run("List the contents of the current directory")
print(response)
```

### Long-term Memory Management

The Swarm Agent supports integration with vector databases for long-term memory management. Here's an example using ChromaDB:

```python
from swarms import Agent
from swarm_models import Anthropic
from swarms_memory import ChromaDB

# Initialize ChromaDB
chromadb = ChromaDB(
    metric="cosine",
    output_dir="finance_agent_rag",
)

# Initialize the agent with long-term memory
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    llm=Anthropic(anthropic_api_key=os.getenv("ANTHROPIC_API_KEY")),
    long_term_memory=chromadb,
    system_prompt="You are a financial analysis agent with access to long-term memory.",
)

# Run the agent
response = agent.run("What are the components of a startup's stock incentive equity plan?")
print(response)
```

### Interactive Mode

To enable interactive mode, set the `interactive` parameter to `True` when initializing the `Agent`:

```python
agent = Agent(
    agent_name="Interactive-Agent",
    llm=OpenAIChat(api_key=os.getenv("OPENAI_API_KEY")),
    interactive=True,
    system_prompt="You are an interactive agent. Engage in a conversation with the user.",
)

# Run the agent in interactive mode
agent.run("Let's start a conversation")
```

### Sentiment Analysis

To perform sentiment analysis on the agent's outputs, you can provide a sentiment analyzer function:

```python
from textblob import TextBlob

def sentiment_analyzer(text):
    analysis = TextBlob(text)
    return analysis.sentiment.polarity

agent = Agent(
    agent_name="Sentiment-Analysis-Agent",
    llm=OpenAIChat(api_key=os.getenv("OPENAI_API_KEY")),
    sentiment_analyzer=sentiment_analyzer,
    sentiment_threshold=0.5,
    system_prompt="You are an agent that generates responses with sentiment analysis.",
)

response = agent.run("Generate a positive statement about AI")
print(response)
```



### Undo Functionality

```python
# Feature 2: Undo functionality
response = agent.run("Another task")
print(f"Response: {response}")
previous_state, message = agent.undo_last()
print(message)
```

### Response Filtering

```python
# Feature 3: Response filtering
agent.add_response_filter("report")
response = agent.filtered_run("Generate a report on finance")
print(response)
```

### Saving and Loading State

```python
# Save the agent state
agent.save_state('saved_flow.json')

# Load the agent state
agent = Agent(llm=llm_instance, max_loops=5)
agent.load('saved_flow.json')
agent.run("Continue with the task")
```

### Async and Concurrent Execution

```python
# Run a task concurrently
response = await agent.run_concurrent("Concurrent task")
print(response)

# Run multiple tasks concurrently
tasks = [
    {"task": "Task 1"},
    {"task": "Task 2", "img": "path/to/image.jpg"},
    {"task": "Task 3", "custom_param": 42}
]
responses = agent.bulk_run(tasks)
print(responses)
```


### Various other settings

```python
# # Convert the agent object to a dictionary
print(agent.to_dict())
print(agent.to_toml())
print(agent.model_dump_json())
print(agent.model_dump_yaml())

# Ingest documents into the agent's knowledge base
agent.ingest_docs("your_pdf_path.pdf")

# Receive a message from a user and process it
agent.receive_message(name="agent_name", message="message")

# Send a message from the agent to a user
agent.send_agent_message(agent_name="agent_name", message="message")

# Ingest multiple documents into the agent's knowledge base
agent.ingest_docs("your_pdf_path.pdf", "your_csv_path.csv")

# Run the agent with a filtered system prompt
agent.filtered_run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?"
)

# Run the agent with multiple system prompts
agent.bulk_run(
    [
        "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?",
        "Another system prompt",
    ]
)

# Add a memory to the agent
agent.add_memory("Add a memory to the agent")

# Check the number of available tokens for the agent
agent.check_available_tokens()

# Perform token checks for the agent
agent.tokens_checks()

# Print the dashboard of the agent
agent.print_dashboard()


# Fetch all the documents from the doc folders
agent.get_docs_from_doc_folders()

# Dump the model to a JSON file
agent.model_dump_json()
print(agent.to_toml())
```

## Auto Generate Prompt + CPU Execution


```python

import os
from swarms import Agent
from swarm_models import OpenAIChat

from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Retrieve the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Initialize the model for OpenAI Chat
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)

# Initialize the agent with automated prompt engineering enabled
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt=None,  # System prompt is dynamically generated
    agent_description=None,
    llm=model,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=False,
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    user_name="Human:",
    return_step_meta=False,
    output_type="string",
    streaming_on=False,
    auto_generate_prompt=True,  # Enable automated prompt engineering
)

# Run the agent with a task description and specify the device
agent.run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria",
    ## Will design a system prompt based on the task if description and system prompt are None
    device="cpu",
)

# Print the dynamically generated system prompt
print(agent.system_prompt)


```

## Agent Structured Outputs

- Create a structured output schema for the agent [List[Dict]]
- Input in the `tools_list_dictionary` parameter
- Output is a dictionary
- Use the `str_to_dict` function to convert the output to a dictionary
```python

from dotenv import load_dotenv

from swarms import Agent
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from swarms.utils.str_to_dict import str_to_dict

load_dotenv()

tools = [
    {
        "type": "function",
        "function": {
            "name": "get_stock_price",
            "description": "Retrieve the current stock price and related information for a specified company.",
            "parameters": {
                "type": "object",
                "properties": {
                    "ticker": {
                        "type": "string",
                        "description": "The stock ticker symbol of the company, e.g. AAPL for Apple Inc.",
                    },
                    "include_history": {
                        "type": "boolean",
                        "description": "Indicates whether to include historical price data along with the current price.",
                    },
                    "time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Optional parameter to specify the time for which the stock data is requested, in ISO 8601 format.",
                    },
                },
                "required": [
                    "ticker",
                    "include_history",
                    "time",
                ],
            },
        },
    }
]


# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    agent_description="Personal finance advisor agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    max_loops=1,
    tools_list_dictionary=tools,
)

out = agent.run(
    "What is the current stock price for Apple Inc. (AAPL)? Include historical price data.",
)

print(out)

print(type(out))

print(str_to_dict(out))

print(type(str_to_dict(out)))


```

## Best Practices

1. Always provide a clear and concise `system_prompt` to guide the agent's behavior.
2. Use `tools` to extend the agent's capabilities for specific tasks.
3. Implement error handling and utilize the `retry_attempts` feature for robust execution.
4. Leverage `long_term_memory` for tasks that require persistent information.
5. Use `interactive` mode for real-time conversations and `dashboard` for monitoring.
6. Implement `sentiment_analysis` for applications requiring tone management.
7. Utilize `autosave` and `save`/`load` methods for continuity across sessions.
8. Optimize token usage with `dynamic_context_window` and `tokens_checks` methods.
9. Use `concurrent` and `async` methods for performance-critical applications.
10. Regularly review and analyze feedback using the `analyze_feedback` method.
11. Use `artifacts_on` to save important outputs from agent execution
12. Configure `device` and `device_id` appropriately for optimal performance
13. Enable `rag_every_loop` when continuous context from long-term memory is needed
14. Use `scheduled_run_date` for automated task scheduling

By following these guidelines and leveraging the Swarm Agent's extensive features, you can create powerful, flexible, and efficient autonomous agents for a wide range of applications.

--------------------------------------------------

# File: swarms/structs/agent_docs_v1.md

# `Agent` Documentation

Swarm Agent is a powerful autonomous agent framework designed to connect Language Models (LLMs) with various tools and long-term memory. This class provides the ability to ingest and process various types of documents such as PDFs, text files, Markdown files, JSON files, and more. The Agent structure offers a wide range of features to enhance the capabilities of LLMs and facilitate efficient task execution.

1. **Conversational Loop**: It establishes a conversational loop with a language model. This means it allows you to interact with the model in a back-and-forth manner, taking turns in the conversation.

2. **Feedback Collection**: The class allows users to provide feedback on the responses generated by the model. This feedback can be valuable for training and improving the model's responses over time.

3. **Stoppable Conversation**: You can define custom stopping conditions for the conversation, allowing you to stop the interaction based on specific criteria. For example, you can stop the conversation if a certain keyword is detected in the responses.

4. **Retry Mechanism**: The class includes a retry mechanism that can be helpful if there are issues generating responses from the model. It attempts to generate a response multiple times before raising an error.

## Architecture

```mermaid
graph TD
    A[Task Initiation] -->|Receives Task| B[Initial LLM Processing]
    B -->|Interprets Task| C[Tool Usage]
    C -->|Calls Tools| D[Function 1]
    C -->|Calls Tools| E[Function 2]
    D -->|Returns Data| C
    E -->|Returns Data| C
    C -->|Provides Data| F[Memory Interaction]
    F -->|Stores and Retrieves Data| G[RAG System]
    G -->|ChromaDB/Pinecone| H[Enhanced Data]
    F -->|Provides Enhanced Data| I[Final LLM Processing]
    I -->|Generates Final Response| J[Output]
    C -->|No Tools Available| K[Skip Tool Usage]
    K -->|Proceeds to Memory Interaction| F
    F -->|No Memory Available| L[Skip Memory Interaction]
    L -->|Proceeds to Final LLM Processing| I
```

### `Agent` Attributes

| Attribute | Description |
|------------|-------------|
| `id` | A unique identifier for the agent instance. |
| `llm` | The language model instance used by the agent. |
| `template` | The template used for formatting responses. |
| `max_loops` | The maximum number of loops the agent can run. |
| `stopping_condition` | A callable function that determines when the agent should stop looping. |
| `loop_interval` | The interval (in seconds) between loops. |
| `retry_attempts` | The number of retry attempts for failed LLM calls. |
| `retry_interval` | The interval (in seconds) between retry attempts. |
| `return_history` | A boolean indicating whether the agent should return the conversation history. |
| `stopping_token` | A token that, when present in the response, stops the agent from looping. |
| `dynamic_loops` | A boolean indicating whether the agent should dynamically determine the number of loops. |
| `interactive` | A boolean indicating whether the agent should run in interactive mode. |
| `dashboard` | A boolean indicating whether the agent should display a dashboard. |
| `agent_name` | The name of the agent instance. |
| `agent_description` | A description of the agent instance. |
| `system_prompt` | The system prompt used to initialize the conversation. |
| `tools` | A list of callable functions representing tools the agent can use. |
| `dynamic_temperature_enabled` | A boolean indicating whether the agent should dynamically adjust the temperature of the LLM. |
| `sop` | The standard operating procedure for the agent. |
| `sop_list` | A list of strings representing the standard operating procedure. |
| `saved_state_path` | The file path for saving and loading the agent's state. |
| `autosave` | A boolean indicating whether the agent should automatically save its state. |
| `context_length` | The maximum length of the context window (in tokens) for the LLM. |
| `user_name` | The name used to represent the user in the conversation. |
| `self_healing_enabled` | A boolean indicating whether the agent should attempt to self-heal in case of errors. |
| `code_interpreter` | A boolean indicating whether the agent should interpret and execute code snippets. |
| `multi_modal` | A boolean indicating whether the agent should support multimodal inputs (e.g., text and images). |
| `pdf_path` | The file path of a PDF document to be ingested. |
| `list_of_pdf` | A list of file paths for PDF documents to be ingested. |
| `tokenizer` | An instance of a tokenizer used for token counting and management. |
| `long_term_memory` | An instance of a `BaseVectorDatabase` implementation for long-term memory management. |
| `preset_stopping_token` | A boolean indicating whether the agent should use a preset stopping token. |
| `traceback` | An object used for traceback handling. |
| `traceback_handlers` | A list of traceback handlers. |
| `streaming_on` | A boolean indicating whether the agent should stream its responses. |
| `docs` | A list of document paths or contents to be ingested. |
| `docs_folder` | The path to a folder containing documents to be ingested. |
| `verbose` | A boolean indicating whether the agent should print verbose output. |
| `parser` | A callable function used for parsing input data. |
| `best_of_n` | An integer indicating the number of best responses to generate (for sampling). |
| `callback` | A callable function to be called after each agent loop. |
| `metadata` | A dictionary containing metadata for the agent. |
| `callbacks` | A list of callable functions to be called during the agent's execution. |
| `logger_handler` | A handler for logging messages. |
| `search_algorithm` | A callable function representing the search algorithm for long-term memory retrieval. |
| `logs_to_filename` | The file path for logging agent activities. |
| `evaluator` | A callable function used for evaluating the agent's responses. |
| `output_json` | A boolean indicating whether the agent's output should be in JSON format. |
| `stopping_func` | A callable function used as a stopping condition for the agent. |
| `custom_loop_condition` | A callable function used as a custom loop condition for the agent. |
| `sentiment_threshold` | A float value representing the sentiment threshold for evaluating responses. |
| `custom_exit_command` | A string representing a custom command for exiting the agent's loop. |
| `sentiment_analyzer` | A callable function used for sentiment analysis on the agent's outputs. |
| `limit_tokens_from_string` | A callable function used for limiting the number of tokens in a string. |
| `custom_tools_prompt` | A callable function used for generating a custom prompt for tool usage. |
| `tool_schema` | A data structure representing the schema for the agent's tools. |
| `output_type` | A type representing the expected output type of the agent's responses. |
| `function_calling_type` | A string representing the type of function calling (e.g., "json"). |
| `output_cleaner` | A callable function used for cleaning the agent's output. |
| `function_calling_format_type` | A string representing the format type for function calling (e.g., "OpenAI"). |
| `list_base_models` | A list of base models used for generating tool schemas. |
| `metadata_output_type` | A string representing the output type for metadata. |
| `state_save_file_type` | A string representing the file type for saving the agent's state (e.g., "json", "yaml"). |
| `chain_of_thoughts` | A boolean indicating whether the agent should use the chain of thoughts technique. |
| `algorithm_of_thoughts` | A boolean indicating whether the agent should use the algorithm of thoughts technique. |
| `tree_of_thoughts` | A boolean indicating whether the agent should use the tree of thoughts technique. |
| `tool_choice` | A string representing the method for tool selection (e.g., "auto"). |
| `execute_tool` | A boolean indicating whether the agent should execute tools. |
| `rules` | A string representing the rules for the agent's behavior. |
| `planning` | A boolean indicating whether the agent should perform planning. |
| `planning_prompt` | A string representing the prompt for planning. |
| `device` | A string representing the device on which the agent should run. |
| `custom_planning_prompt` | A string representing a custom prompt for planning. |
| `memory_chunk_size` | An integer representing the maximum size of memory chunks for long-term memory retrieval. |
| `agent_ops_on` | A boolean indicating whether agent operations should be enabled. |
| `return_step_meta` | A boolean indicating whether or not to return JSON of all the steps and additional metadata |
| `output_type` | A Literal type indicating whether to output "string", "str", "list", "json", "dict", "yaml" |



### `Agent` Methods

| Method | Description | Inputs | Usage Example |
|--------|-------------|--------|----------------|
| `run(task, img=None, *args, **kwargs)` | Runs the autonomous agent loop to complete the given task. | `task` (str): The task to be performed.<br>`img` (str, optional): Path to an image file, if the task involves image processing.<br>`*args`, `**kwargs`: Additional arguments to pass to the language model. | `response = agent.run("Generate a report on financial performance.")` |
| `__call__(task, img=None, *args, **kwargs)` | An alternative way to call the `run` method. | Same as `run`. | `response = agent("Generate a report on financial performance.")` |
| `parse_and_execute_tools(response, *args, **kwargs)` | Parses the agent's response and executes any tools mentioned in it. | `response` (str): The agent's response to be parsed.<br>`*args`, `**kwargs`: Additional arguments to pass to the tool execution. | `agent.parse_and_execute_tools(response)` |
| `long_term_memory_prompt(query, *args, **kwargs)` | Generates a prompt for querying the agent's long-term memory. | `query` (str): The query to search for in long-term memory.<br>`*args`, `**kwargs`: Additional arguments to pass to the long-term memory retrieval. | `memory_retrieval = agent.long_term_memory_prompt("financial performance")` |
| `add_memory(message)` | Adds a message to the agent's memory. | `message` (str): The message




## Features

- **Language Model Integration**: The Swarm Agent allows seamless integration with different language models, enabling users to leverage the power of state-of-the-art models.
- **Tool Integration**: The framework supports the integration of various tools, enabling the agent to perform a wide range of tasks, from code execution to data analysis and beyond.
- **Long-term Memory Management**: The Swarm Agent incorporates long-term memory management capabilities, allowing it to store and retrieve relevant information for effective decision-making and task execution.
- **Document Ingestion**: The agent can ingest and process various types of documents, including PDFs, text files, Markdown files, JSON files, and more, enabling it to extract relevant information for task completion.
- **Interactive Mode**: Users can interact with the agent in an interactive mode, enabling real-time communication and task execution.
- **Dashboard**: The framework provides a visual dashboard for monitoring the agent's performance and activities.
- **Dynamic Temperature Control**: The Swarm Agent supports dynamic temperature control, allowing for adjustments to the model's output diversity during task execution.
- **Autosave and State Management**: The agent can save its state automatically, enabling seamless resumption of tasks after interruptions or system restarts.
- **Self-Healing and Error Handling**: The framework incorporates self-healing and error-handling mechanisms to ensure robust and reliable operation.
- **Code Interpretation**: The agent can interpret and execute code snippets, expanding its capabilities for tasks involving programming or scripting.
- **Multimodal Support**: The framework supports multimodal inputs, enabling the agent to process and reason about various data types, such as text, images, and audio.
- **Tokenization and Token Management**: The Swarm Agent provides tokenization capabilities, enabling efficient management of token usage and context window truncation.
- **Sentiment Analysis**: The agent can perform sentiment analysis on its generated outputs, allowing for evaluation and adjustment of responses based on sentiment thresholds.
- **Output Filtering and Cleaning**: The framework supports output filtering and cleaning, ensuring that generated responses adhere to specific criteria or guidelines.
- **Asynchronous and Concurrent Execution**: The Swarm Agent supports asynchronous and concurrent task execution, enabling efficient parallelization and scaling of operations.
- **Planning and Reasoning**: The agent can engage in planning and reasoning processes, leveraging techniques such as algorithm of thoughts and chain of thoughts to enhance decision-making and task execution.
- **Agent Operations and Monitoring**: The framework provides integration with agent operations and monitoring tools, enabling real-time monitoring and management of the agent's activities.

## Getting Started

First run the following:

```bash
pip3 install -U swarms
```

And, then now you can get started with the following:

```python
import os
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)

# Get the OpenAI API key from the environment variable
api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent_sas_chicken_eej",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    llm=model,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    user_name="swarms_corp",
    retry_attempts=1,
    context_length=200000,
    return_step_meta=False,
    output_type="str",
)


agent.run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria"
)
print(out)

```

This example initializes an instance of the `Agent` class with an OpenAI language model and a maximum of 3 loops. The `run()` method is then called with a task to generate a report on financial performance, and the agent's response is printed.

## Advanced Usage

The Swarm Agent provides numerous advanced features and customization options. Here are a few examples of how to leverage these features:

### Tool Integration

To integrate tools with the Swarm Agent, you can pass a list of callable functions with types and doc strings to the `tools` parameter when initializing the `Agent` instance. The agent will automatically convert these functions into an OpenAI function calling schema and make them available for use during task execution.

## Requirements for a tool
- Function
  - With types
  - with doc strings

```python
from swarms import Agent
from swarm_models import OpenAIChat
from swarms_memory import ChromaDB
import subprocess
import os

# Making an instance of the ChromaDB class
memory = ChromaDB(
    metric="cosine",
    n_results=3,
    output_dir="results",
    docs_folder="docs",
)

# Model
model = OpenAIChat(
    api_key=os.getenv("OPENAI_API_KEY"),
    model_name="gpt-4o-mini",
    temperature=0.1,
)


# Tools in swarms are simple python functions and docstrings
def terminal(
    code: str,
):
    """
    Run code in the terminal.

    Args:
        code (str): The code to run in the terminal.

    Returns:
        str: The output of the code.
    """
    out = subprocess.run(
        code, shell=True, capture_output=True, text=True
    ).stdout
    return str(out)


def browser(query: str):
    """
    Search the query in the browser with the `browser` tool.

    Args:
        query (str): The query to search in the browser.

    Returns:
        str: The search results.
    """
    import webbrowser

    url = f"https://www.google.com/search?q={query}"
    webbrowser.open(url)
    return f"Searching for {query} in the browser."


def create_file(file_path: str, content: str):
    """
    Create a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file creation operation.
    """
    with open(file_path, "w") as file:
        file.write(content)
    return f"File {file_path} created successfully."


def file_editor(file_path: str, mode: str, content: str):
    """
    Edit a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        mode (str): The mode to open the file in.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file editing operation.
    """
    with open(file_path, mode) as file:
        file.write(content)
    return f"File {file_path} edited successfully."


# Agent
agent = Agent(
    agent_name="Devin",
    system_prompt=(
        "Autonomous agent that can interact with humans and other"
        " agents. Be Helpful and Kind. Use the tools provided to"
        " assist the user. Return all code in markdown format."
    ),
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    interactive=True,
    tools=[terminal, browser, file_editor, create_file],
    streaming=True,
    long_term_memory=memory,
)

# Run the agent
out = agent(
    "Create a CSV file with the latest tax rates for C corporations in the following ten states and the District of Columbia: Alabama, California, Florida, Georgia, Illinois, New York, North Carolina, Ohio, Texas, and Washington."
)
print(out)

```

### Long-term Memory Management

The Swarm Agent supports integration with various vector databases for long-term memory management. You can pass an instance of a `BaseVectorDatabase` implementation to the `long_term_memory` parameter when initializing the `Agent`.

```python
import os

from swarms_memory import ChromaDB

from swarms import Agent
from swarm_models import Anthropic
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)

# Initilaize the chromadb client
chromadb = ChromaDB(
    metric="cosine",
    output_dir="fiance_agent_rag",
    # docs_folder="artifacts", # Folder of your documents
)

# Model
model = Anthropic(anthropic_api_key=os.getenv("ANTHROPIC_API_KEY"))


# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    agent_description="Agent creates ",
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    user_name="swarms_corp",
    retry_attempts=3,
    context_length=200000,
    long_term_memory=chromadb,
)


agent.run(
    "What are the components of a startups stock incentive equity plan"
)

```

### Document Ingestion

The Swarm Agent can ingest various types of documents, such as PDFs, text files, Markdown files, and JSON files. You can pass a list of document paths or contents to the `docs` parameter when initializing the `Agent`.

```python
from swarms.structs import Agent

# Initialize the agent with documents
agent = Agent(llm=llm, max_loops=3, docs=["path/to/doc1.pdf", "path/to/doc2.txt"])
```

### Interactive Mode

The Swarm Agent supports an interactive mode, where users can engage in real-time communication with the agent. To enable interactive mode, set the `interactive` parameter to `True` when initializing the `Agent`.

```python
from swarms.structs import Agent

# Initialize the agent in interactive mode
agent = Agent(llm=llm, max_loops=3, interactive=True)

# Run the agent in interactive mode
agent.interactive_run()
```

### Sentiment Analysis

The Swarm Agent can perform sentiment analysis on its generated outputs using a sentiment analyzer function. You can pass a callable function to the `sentiment_analyzer` parameter when initializing the `Agent`.

```python
from swarms.structs import Agent
from my_sentiment_analyzer import sentiment_analyzer_function

# Initialize the agent with a sentiment analyzer
agent = Agent(
    agent_name = "sentiment-analyzer-agent-01", system_prompt="..."
    llm=llm, max_loops=3, sentiment_analyzer=sentiment_analyzer_function)
```


### Undo Functionality

```python
# Feature 2: Undo functionality
response = agent.run("Another task")
print(f"Response: {response}")
previous_state, message = agent.undo_last()
print(message)
```

### Response Filtering

```python
# Feature 3: Response filtering
agent.add_response_filter("report")
response = agent.filtered_run("Generate a report on finance")
print(response)
```

### Saving and Loading State

```python
# Save the agent state
agent.save_state('saved_flow.json')

# Load the agent state
agent = Agent(llm=llm_instance, max_loops=5)
agent.load('saved_flow.json')
agent.run("Continue with the task")
```

### Async and Concurrent Execution

```python
# Run a task concurrently
response = await agent.run_concurrent("Concurrent task")
print(response)

# Run multiple tasks concurrently
tasks = [
    {"task": "Task 1"},
    {"task": "Task 2", "img": "path/to/image.jpg"},
    {"task": "Task 3", "custom_param": 42}
]
responses = agent.bulk_run(tasks)
print(responses)
```


### Various other settings

```python
# # Convert the agent object to a dictionary
print(agent.to_dict())
print(agent.to_toml())
print(agent.model_dump_json())
print(agent.model_dump_yaml())

# Ingest documents into the agent's knowledge base
agent.ingest_docs("your_pdf_path.pdf")

# Receive a message from a user and process it
agent.receive_message(name="agent_name", message="message")

# Send a message from the agent to a user
agent.send_agent_message(agent_name="agent_name", message="message")

# Ingest multiple documents into the agent's knowledge base
agent.ingest_docs("your_pdf_path.pdf", "your_csv_path.csv")

# Run the agent with a filtered system prompt
agent.filtered_run(
    "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?"
)

# Run the agent with multiple system prompts
agent.bulk_run(
    [
        "How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?",
        "Another system prompt",
    ]
)

# Add a memory to the agent
agent.add_memory("Add a memory to the agent")

# Check the number of available tokens for the agent
agent.check_available_tokens()

# Perform token checks for the agent
agent.tokens_checks()

# Print the dashboard of the agent
agent.print_dashboard()


# Fetch all the documents from the doc folders
agent.get_docs_from_doc_folders()

# Activate agent ops

# Dump the model to a JSON file
agent.model_dump_json()
print(agent.to_toml())
```

--------------------------------------------------

# File: swarms/structs/agent_rearrange.md

# `AgentRearrange` Class

The `AgentRearrange` class represents a swarm of agents for rearranging tasks. It allows you to create a swarm of agents, add or remove agents from the swarm, and run the swarm to process tasks based on a specified flow pattern.

## Attributes
----------

| Attribute | Type | Description |
| --- | --- | --- |
| `id` | `str` | Unique identifier for the swarm |
| `name` | `str` | Name of the swarm |
| `description` | `str` | Description of the swarm's purpose |
| `agents` | `dict` | Dictionary mapping agent names to Agent objects |
| `flow` | `str` | Flow pattern defining task execution order |
| `max_loops` | `int` | Maximum number of execution loops |
| `verbose` | `bool` | Whether to enable verbose logging |
| `memory_system` | `BaseVectorDatabase` | Memory system for storing agent interactions |
| `human_in_the_loop` | `bool` | Whether human intervention is enabled |
| `custom_human_in_the_loop` | `Callable` | Custom function for human intervention |
| `return_json` | `bool` | Whether to return output in JSON format |
| `output_type` | `OutputType` | Format of output ("all", "final", "list", or "dict") |
| `docs` | `List[str]` | List of document paths to add to agent prompts |
| `doc_folder` | `str` | Folder path containing documents to add to agent prompts |
| `swarm_history` | `dict` | History of agent interactions |


## Methods
-------

### `__init__(self, agents: List[Agent] = None, flow: str = None, max_loops: int = 1, verbose: bool = True)`

Initializes the `AgentRearrange` object.

| Parameter | Type | Description |
| --- | --- | --- |
| `agents` | `List[Agent]` (optional) | A list of `Agent` objects. Defaults to `None`. |
| `flow` | `str` (optional) | The flow pattern of the tasks. Defaults to `None`. |
| `max_loops` | `int` (optional) | The maximum number of loops for the agents to run. Defaults to `1`. |
| `verbose` | `bool` (optional) | Whether to enable verbose logging or not. Defaults to `True`. |

### `add_agent(self, agent: Agent)`

Adds an agent to the swarm.

| Parameter | Type | Description |
| --- | --- | --- |
| `agent` | `Agent` | The agent to be added. |

### `remove_agent(self, agent_name: str)`

Removes an agent from the swarm.

| Parameter | Type | Description |
| --- | --- | --- |
| `agent_name` | `str` | The name of the agent to be removed. |

### `add_agents(self, agents: List[Agent])`

Adds multiple agents to the swarm.

| Parameter | Type | Description |
| --- | --- | --- |
| `agents` | `List[Agent]` | A list of `Agent` objects. |

### `validate_flow(self)`

Validates the flow pattern.

**Raises:**

-   `ValueError`: If the flow pattern is incorrectly formatted or contains duplicate agent names.

**Returns:**

-   `bool`: `True` if the flow pattern is valid.

### `run(self, task: str = None, img: str = None, device: str = "cpu", device_id: int = 1, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)`

Executes the agent rearrangement task with specified compute resources.

| Parameter | Type | Description |
| --- | --- | --- |
| `task` | `str` | The task to execute |
| `img` | `str` | Path to input image if required |
| `device` | `str` | Computing device to use ('cpu' or 'gpu') |
| `device_id` | `int` | ID of specific device to use |
| `all_cores` | `bool` | Whether to use all CPU cores |
| `all_gpus` | `bool` | Whether to use all available GPUs |

**Returns:**

-   `str`: The final processed task.

### `batch_run(self, tasks: List[str], img: Optional[List[str]] = None, batch_size: int = 10, device: str = "cpu", device_id: int = None, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)`

Process multiple tasks in batches.

| Parameter | Type | Description |
| --- | --- | --- |
| `tasks` | `List[str]` | List of tasks to process |
| `img` | `List[str]` | Optional list of images corresponding to tasks |
| `batch_size` | `int` | Number of tasks to process simultaneously |
| `device` | `str` | Computing device to use |
| `device_id` | `int` | Specific device ID if applicable |
| `all_cores` | `bool` | Whether to use all CPU cores |
| `all_gpus` | `bool` | Whether to use all available GPUs |



### `concurrent_run(self, tasks: List[str], img: Optional[List[str]] = None, max_workers: Optional[int] = None, device: str = "cpu", device_id: int = None, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)`

Process multiple tasks concurrently using ThreadPoolExecutor.

| Parameter | Type | Description |
| --- | --- | --- |
| `tasks` | `List[str]` | List of tasks to process |
| `img` | `List[str]` | Optional list of images corresponding to tasks |
| `max_workers` | `int` | Maximum number of worker threads |
| `device` | `str` | Computing device to use |
| `device_id` | `int` | Specific device ID if applicable |
| `all_cores` | `bool` | Whether to use all CPU cores |
| `all_gpus` | `bool` | Whether to use all available GPUs |



## Documentation for `rearrange` Function
======================================

The `rearrange` function is a helper function that rearranges the given list of agents based on the specified flow.

## Parameters
----------

| Parameter | Type | Description |
| --- | --- | --- |
| `agents` | `List[Agent]` | The list of agents to be rearranged. |
| `flow` | `str` | The flow used for rearranging the agents. |
| `task` | `str` (optional) | The task to be performed during rearrangement. Defaults to `None`. |
| `*args` | - | Additional positional arguments. |
| `**kwargs` | - | Additional keyword arguments. |

## Returns
-------

The result of running the agent system with the specified task.

### Example
-------

```python
agents = [agent1, agent2, agent3]
flow = "agent1 -> agent2, agent3"
task = "Perform a task"
rearrange(agents, flow, task)
```

### Example Usage
-------------

Here's an example of how to use the `AgentRearrange` class and the `rearrange` function:

```python
from swarms import Agent, AgentRearrange
from typing import List

# Initialize the director agent
director = Agent(
    agent_name="Accounting Director",
    system_prompt="Directs the accounting tasks for the workers",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accounting_director.json",
)

# Initialize worker 1
worker1 = Agent(
    agent_name="Accountant 1",
    system_prompt="Processes financial transactions and prepares financial statements",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

# Initialize worker 2
worker2 = Agent(
    agent_name="Accountant 2",
    system_prompt="Performs audits and ensures compliance with financial regulations",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)

# Create a list of agents
agents = [director, worker1, worker2]

# Define the flow pattern
flow = "Accounting Director -> Accountant 1 -> Accountant 2"

# Using AgentRearrange class
agent_system = AgentRearrange(agents=agents, flow=flow)
output = agent_system.run("Process monthly financial statements")
print(output)

```

In this example, we first initialize three agents: `director`, `worker1`, and `worker2`. Then, we create a list of these agents and define the flow pattern `"Director -> Worker1 -> Worker2"`.

We can use the `AgentRearrange` class by creating an instance of it with the list of agents and the flow pattern. We then call the `run` method with the initial task, and it will execute the agents in the specified order, passing the output of one agent as the input to the next agent.

Alternatively, we can use the `rearrange` function by passing the list of agents, the flow pattern, and the initial task as arguments.

Both the `AgentRearrange` class and the `rearrange` function will return the final output after processing the task through the agents according to the specified flow pattern.

## Error Handling
--------------

The `AgentRearrange` class includes error handling mechanisms to validate the flow pattern. If the flow pattern is incorrectly formatted or contains duplicate agent names, a `ValueError` will be raised with an appropriate error message.

### Example:

```python
# Invalid flow pattern
invalid_flow = "Director->Worker1,Worker2->Worker3"
agent_system = AgentRearrange(agents=agents, flow=invalid_flow)
output = agent_system.run("Some task")`
```

This will raise a `ValueError` with the message `"Agent 'Worker3' is not registered."`.


## Parallel and Sequential Processing
----------------------------------

The `AgentRearrange` class supports both parallel and sequential processing of tasks based on the specified flow pattern. If the flow pattern includes multiple agents separated by commas (e.g., `"agent1, agent2"`), the agents will be executed in parallel, and their outputs will be concatenated with a semicolon (`;`). If the flow pattern includes a single agent, it will be executed sequentially.


### Parallel processing
`parallel_flow = "Worker1, Worker2 -> Director"`

### Sequential processing
`sequential_flow = "Worker1 -> Worker2 -> Director"`

In the `parallel_flow` example, `Worker1` and `Worker2` will be executed in parallel, and their outputs will be concatenated and passed to `Director`. In the `sequential_flow` example, `Worker1` will be executed first, and its output will be passed to `Worker2`, and then the output of `Worker2` will be passed to `Director`.

## Logging
-------

The `AgentRearrange` class includes logging capabilities using the `loguru` library. If `verbose` is set to `True` during initialization, a log file named `agent_rearrange.log` will be created, and log messages will be written to it. You can use this log file to track the execution of the agents and any potential issues or errors that may occur.


```bash
2023-05-08 10:30:15.456 | INFO     | agent_rearrange:__init__:34 - Adding agent Director to the swarm.
2023-05-08 10:30:15.457 | INFO     | agent_rearrange:__init__:34 - Adding agent Worker1 to the swarm.
2023-05-08 10:30:15.457 | INFO     | agent_rearrange:__init__:34 - Adding agent Worker2 to the swarm.
2023-05-08 10:30:15.458 | INFO     | agent_rearrange:run:118 - Running agents in parallel: ['Worker1', 'Worker2']
2023-05-08 10:30:15.459 | INFO     | agent_rearrange:run:121 - Running agents sequentially: ['Director']`
```

## Additional Parameters
---------------------

The `AgentRearrange` class also accepts additional parameters that can be passed to the `run` method using `*args` and `**kwargs`. These parameters will be forwarded to the individual agents during execution.

`agent_system = AgentRearrange(agents=agents, flow=flow)`
`output = agent_system.run("Some task", max_tokens=200, temperature=0.7)`

In this example, the `max_tokens` and `temperature` parameters will be passed to each agent during execution.

## Customization
-------------

The `AgentRearrange` class and the `rearrange` function can be customized and extended to suit specific use cases. For example, you can create custom agents by inheriting from the `Agent` class and implementing custom logic for task processing. You can then add these custom agents to the swarm and define the flow pattern accordingly.

Additionally, you can modify the `run` method of the `AgentRearrange` class to implement custom logic for task processing and agent interaction.


## Limitations
-----------

It's important to note that the `AgentRearrange` class and the `rearrange` function rely on the individual agents to process tasks correctly. The quality of the output will depend on the capabilities and configurations of the agents used in the swarm. Additionally, the `AgentRearrange` class does not provide any mechanisms for task prioritization or load balancing among the agents.

## Conclusion
----------

The `AgentRearrange` class and the `rearrange` function provide a flexible and extensible framework for orchestrating swarms of agents to process tasks based on a specified flow pattern. By combining the capabilities of individual agents, you can create complex workflows and leverage the strengths of different agents to tackle various tasks efficiently.

While the current implementation offers basic functionality for agent rearrangement, there is room for future improvements and customizations to enhance the system's capabilities and cater to more specific use cases.

Whether you're working on natural language processing tasks, data analysis, or any other domain where agent-based systems can be beneficial, the `AgentRearrange` class and the `rearrange` function provide a solid foundation for building and experimenting with swarm-based solutions.

--------------------------------------------------

# File: swarms/structs/agent_registry.md

# AgentRegistry Documentation

The `AgentRegistry` class is designed to manage a collection of agents, providing methods for adding, deleting, updating, and querying agents. This class ensures thread-safe operations on the registry, making it suitable for concurrent environments. Additionally, the `AgentModel` class is a Pydantic model used for validating and storing agent information.

## Attributes

### AgentModel

| Attribute | Type   | Description                          |
|-----------|--------|--------------------------------------|
| `agent_id`| `str`  | The unique identifier for the agent. |
| `agent`   | `Agent`| The agent object.                    |

### AgentRegistry

| Attribute | Type                | Description                               |
|-----------|---------------------|-------------------------------------------|
| `agents`  | `Dict[str, AgentModel]` | A dictionary mapping agent IDs to `AgentModel` instances. |
| `lock`    | `Lock`              | A threading lock for thread-safe operations. |

## Methods

### `__init__(self)`

Initializes the `AgentRegistry` object.

- **Usage Example:**
  ```python
  registry = AgentRegistry()
  ```

### `add(self, agent_id: str, agent: Agent) -> None`

Adds a new agent to the registry.

- **Parameters:**
  - `agent_id` (`str`): The unique identifier for the agent.
  - `agent` (`Agent`): The agent to add.

- **Raises:**
  - `ValueError`: If the agent ID already exists in the registry.
  - `ValidationError`: If the input data is invalid.

- **Usage Example:**
  ```python
  agent = Agent(agent_name="Agent1")
  registry.add("agent_1", agent)
  ```

### `delete(self, agent_id: str) -> None`

Deletes an agent from the registry.

- **Parameters:**
  - `agent_id` (`str`): The unique identifier for the agent to delete.

- **Raises:**
  - `KeyError`: If the agent ID does not exist in the registry.

- **Usage Example:**
  ```python
  registry.delete("agent_1")
  ```

### `update_agent(self, agent_id: str, new_agent: Agent) -> None`

Updates an existing agent in the registry.

- **Parameters:**
  - `agent_id` (`str`): The unique identifier for the agent to update.
  - `new_agent` (`Agent`): The new agent to replace the existing one.

- **Raises:**
  - `KeyError`: If the agent ID does not exist in the registry.
  - `ValidationError`: If the input data is invalid.

- **Usage Example:**
  ```python
  new_agent = Agent(agent_name="UpdatedAgent")
  registry.update_agent("agent_1", new_agent)
  ```

### `get(self, agent_id: str) -> Agent`

Retrieves an agent from the registry.

- **Parameters:**
  - `agent_id` (`str`): The unique identifier for the agent to retrieve.

- **Returns:**
  - `Agent`: The agent associated with the given agent ID.

- **Raises:**
  - `KeyError`: If the agent ID does not exist in the registry.

- **Usage Example:**
  ```python
  agent = registry.get("agent_1")
  ```

### `list_agents(self) -> List[str]`

Lists all agent identifiers in the registry.

- **Returns:**
  - `List[str]`: A list of all agent identifiers.

- **Usage Example:**
  ```python
  agent_ids = registry.list_agents()
  ```

### `query(self, condition: Optional[Callable[[Agent], bool]] = None) -> List[Agent]`

Queries agents based on a condition.

- **Parameters:**
  - `condition` (`Optional[Callable[[Agent], bool]]`): A function that takes an agent and returns a boolean indicating whether the agent meets the condition. Defaults to `None`.

- **Returns:**
  - `List[Agent]`: A list of agents that meet the condition.

- **Usage Example:**
  ```python
  def is_active(agent):
      return agent.is_active

  active_agents = registry.query(is_active)
  ```

### `find_agent_by_name(self, agent_name: str) -> Agent`

Finds an agent by its name.

- **Parameters:**
  - `agent_name` (`str`): The name of the agent to find.

- **Returns:**
  - `Agent`: The agent with the specified name.

- **Usage Example:**
  ```python
  agent = registry.find_agent_by_name("Agent1")
  ```


### Full Example

```python
from swarms.structs.agent_registry import AgentRegistry
from swarms import Agent, OpenAIChat, Anthropic

# Initialize the agents
growth_agent1 = Agent(
  agent_name="Marketing Specialist",
  system_prompt="You're the marketing specialist, your purpose is to help companies grow by improving their marketing strategies!",
  agent_description="Improve a company's marketing strategies!",
  llm=OpenAIChat(),
  max_loops="auto",
  autosave=True,
  dashboard=False,
  verbose=True,
  streaming_on=True,
  saved_state_path="marketing_specialist.json",
  stopping_token="Stop!",
  interactive=True,
  context_length=1000,
)

growth_agent2 = Agent(
  agent_name="Sales Specialist",
  system_prompt="You're the sales specialist, your purpose is to help companies grow by improving their sales strategies!",
  agent_description="Improve a company's sales strategies!",
  llm=Anthropic(),
  max_loops="auto",
  autosave=True,
  dashboard=False,
  verbose=True,
  streaming_on=True,
  saved_state_path="sales_specialist.json",
  stopping_token="Stop!",
  interactive=True,
  context_length=1000,
)

growth_agent3 = Agent(
  agent_name="Product Development Specialist",
  system_prompt="You're the product development specialist, your purpose is to help companies grow by improving their product development strategies!",
  agent_description="Improve a company's product development strategies!",
  llm=Anthropic(),
  max_loops="auto",
  autosave=True,
  dashboard=False,
  verbose=True,
  streaming_on=True,
  saved_state_path="product_development_specialist.json",
  stopping_token="Stop!",
  interactive=True,
  context_length=1000,
)

growth_agent4 = Agent(
  agent_name="Customer Service Specialist",
  system_prompt="You're the customer service specialist, your purpose is to help companies grow by improving their customer service strategies!",
  agent_description="Improve a company's customer service strategies!",
  llm=OpenAIChat(),
  max_loops="auto",
  autosave=True,
  dashboard=False,
  verbose=True,
  streaming_on=True,
  saved_state_path="customer_service_specialist.json",
  stopping_token="Stop!",
  interactive=True,
  context_length=1000,
)


# Register the agents\
registry = AgentRegistry()

# Register the agents
registry.add("Marketing Specialist", growth_agent1)
registry.add("Sales Specialist", growth_agent2)
registry.add("Product Development Specialist", growth_agent3)
registry.add("Customer Service Specialist", growth_agent4)

```

## Logging and Error Handling

Each method in the `AgentRegistry` class includes logging to track the execution flow and captures errors to provide detailed information in case of failures. This is crucial for debugging and ensuring smooth operation of the registry. The `report_error` function is used for reporting exceptions that occur during method execution.

## Additional Tips

- Ensure that agents provided to the `AgentRegistry` are properly initialized and configured to handle the tasks they will receive.
- Utilize the logging information to monitor and debug the registry operations.
- Use the `lock` attribute to ensure thread-safe operations when accessing or modifying the registry.



--------------------------------------------------

# File: swarms/structs/artifact.md

# swarms.structs Documentation

## Introduction

The swarms.structs library provides a collection of classes for representing artifacts and their attributes. This documentation will provide an overview of the `Artifact` class, its attributes, functionality, and usage examples.

### Artifact Class

The `Artifact` class represents an artifact and its attributes. It inherits from the `BaseModel` class and includes the following attributes:

#### Attributes

1. `artifact_id (str)`: Id of the artifact.
2. `file_name (str)`: Filename of the artifact.
3. `relative_path (str, optional)`: Relative path of the artifact in the agent's workspace.

These attributes are crucial for identifying and managing different artifacts within a given context.

## Class Definition

The `Artifact` class can be defined as follows:

```python
class Artifact(BaseModel):
    """
    Represents an artifact.

    Attributes:
        artifact_id (str): Id of the artifact.
        file_name (str): Filename of the artifact.
        relative_path (str, optional): Relative path of the artifact in the agent's workspace.
    """

    artifact_id: str = Field(
        ...,
        description="Id of the artifact",
        example="b225e278-8b4c-4f99-a696-8facf19f0e56",
    )
    file_name: str = Field(
        ..., description="Filename of the artifact", example="main.py"
    )
    relative_path: Optional[str] = Field(
        None,
        description=("Relative path of the artifact in the agent's workspace"),
        example="python/code/",
    )
```

The `Artifact` class defines the mandatory and optional attributes and provides corresponding descriptions along with example values.

## Functionality and Usage

The `Artifact` class encapsulates the information and attributes representing an artifact. It provides a structured and organized way to manage artifacts within a given context.

### Example 1: Creating an Artifact instance

To create an instance of the `Artifact` class, you can simply initialize it with the required attributes. Here's an example:

```python
from swarms.structs import Artifact

artifact_instance = Artifact(
    artifact_id="b225e278-8b4c-4f99-a696-8facf19f0e56",
    file_name="main.py",
    relative_path="python/code/",
)
```

In this example, we create an instance of the `Artifact` class with the specified artifact details.

### Example 2: Accessing Artifact attributes

You can access the attributes of the `Artifact` instance using dot notation. Here's how you can access the file name of the artifact:

```python
print(artifact_instance.file_name)
# Output: "main.py"
```

### Example 3: Handling optional attributes

If the `relative_path` attribute is not provided during artifact creation, it will default to `None`. Here's an example:

```python
artifact_instance_no_path = Artifact(
    artifact_id="c280s347-9b7d-3c68-m337-7abvf50j23k", file_name="script.js"
)

print(artifact_instance_no_path.relative_path)
# Output: None
```

By providing default values for optional attributes, the `Artifact` class allows flexibility in defining artifact instances.

### Additional Information and Tips

The `Artifact` class represents a powerful and flexible means of handling various artifacts with different attributes. By utilizing this class, users can organize, manage, and streamline their artifacts with ease.

## References and Resources

For further details and references related to the swarms.structs library and the `Artifact` class, refer to the [official documentation](https://swarms.structs.docs/artifact.html).

This comprehensive documentation provides an in-depth understanding of the `Artifact` class, its attributes, functionality, and usage examples. By following the detailed examples and explanations, developers can effectively leverage the capabilities of the `Artifact` class within their projects.


--------------------------------------------------

# File: swarms/structs/auto_agent_builder.md

# Agent Builder

The Agent Builder is a powerful class that automatically builds and manages swarms of AI agents. It provides a flexible and extensible framework for creating, coordinating, and executing multiple AI agents working together to accomplish complex tasks.

## Overview

The Agent Builder uses a boss agent to delegate work and create new specialized agents as needed. It's designed to be production-ready with robust error handling, logging, and configuration options.

## Architecture

```mermaid
graph TD
    A[Agent Builder] --> B[Configuration]
    A --> C[Agent Creation]
    A --> D[Task Execution]
    
    B --> B1[Name]
    B --> B2[Description]
    B --> B3[Model Settings]
    
    C --> C1[Agent Pool]
    C --> C2[Agent Registry]
    C --> C3[Agent Configuration]
    
    D --> D1[Task Distribution]
    D --> D2[Result Collection]
    D --> D3[Error Handling]
    
    C1 --> E[Specialized Agents]
    C2 --> E
    C3 --> E
    
    E --> F[Task Execution]
    F --> G[Results]
```

## Class Structure

### AgentsBuilder Class

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| name | str | "swarm-creator-01" | The name of the swarm |
| description | str | "This is a swarm that creates swarms" | A description of the swarm's purpose |
| verbose | bool | True | Whether to output detailed logs |
| max_loops | int | 1 | Maximum number of execution loops |
| model_name | str | "gpt-4o" | The model to use for agent creation |
| return_dictionary | bool | True | Whether to return results as a dictionary |
| system_prompt | str | BOSS_SYSTEM_PROMPT | The system prompt for the boss agent |

### Methods

| Method | Description | Parameters | Returns |
|--------|-------------|------------|---------|
| run | Run the swarm on a given task | task: str, image_url: str = None, *args, **kwargs | Tuple[List[Agent], int] |
| _create_agents | Create necessary agents for a task | task: str, *args, **kwargs | List[Agent] |
| build_agent | Build a single agent with specifications | agent_name: str, agent_description: str, agent_system_prompt: str, max_loops: int = 1, model_name: str = "gpt-4o", dynamic_temperature_enabled: bool = True, auto_generate_prompt: bool = False, role: str = "worker", max_tokens: int = 8192, temperature: float = 0.5 | Agent |

## Enterprise Use Cases

### 1. Customer Service Automation
- Create specialized agents for different aspects of customer service

- Handle ticket routing, response generation, and escalation

- Maintain consistent service quality across channels

### 2. Data Analysis Pipeline
- Build agents for data collection, cleaning, analysis, and visualization

- Automate complex data processing workflows

- Generate insights and reports automatically

### 3. Content Creation and Management
- Deploy agents for content research, writing, editing, and publishing

- Maintain brand consistency across content

- Automate content scheduling and distribution

### 4. Process Automation
- Create agents for workflow automation

- Handle document processing and routing

- Manage approval chains and notifications

### 5. Research and Development
- Build agents for literature review, experiment design, and data collection

- Automate research documentation and reporting

- Facilitate collaboration between research teams

## Example Usage

```python
from swarms import AgentsBuilder

# Initialize the agent builder
agents_builder = AgentsBuilder(
    name="enterprise-automation",
    description="Enterprise workflow automation swarm",
    verbose=True
)

# Define a use-case for building agents
task = "Develop a swarm of agents to automate the generation of personalized marketing strategies based on customer data and market trends"

# Run the swarm
agents = agents_builder.run(task)

# Access results
print(agents)
```

## Best Practices

1. **Error Handling**
   - Always implement proper error handling for agent failures
   - Use retry mechanisms for transient failures
   - Log all errors for debugging and monitoring

2. **Resource Management**
   - Monitor agent resource usage
   - Implement rate limiting for API calls
   - Use connection pooling for database operations

3. **Security**
   - Implement proper authentication and authorization
   - Secure sensitive data and API keys
   - Follow least privilege principle for agent permissions

4. **Monitoring and Logging**
   - Implement comprehensive logging
   - Monitor agent performance metrics
   - Set up alerts for critical failures

5. **Scalability**
   - Design for horizontal scaling
   - Implement load balancing
   - Use distributed systems when needed

## Integration Patterns

```mermaid
graph LR
    A[External System] --> B[API Gateway]
    B --> C[Agent Builder]
    C --> D[Agent Pool]
    D --> E[Specialized Agents]
    E --> F[External Services]
    
    subgraph "Monitoring"
        G[Logs]
        H[Metrics]
        I[Alerts]
    end
    
    C --> G
    C --> H
    C --> I
```

## Performance Considerations

1. **Agent Pool Management**
   - Implement connection pooling
   - Use caching for frequently accessed data
   - Optimize agent creation and destruction

2. **Task Distribution**
   - Implement load balancing
   - Use priority queues for task scheduling
   - Handle task timeouts and retries

3. **Resource Optimization**
   - Monitor memory usage
   - Implement garbage collection
   - Use efficient data structures

## Troubleshooting

Common issues and solutions:

1. **Agent Creation Failures**
   - Check API credentials
   - Verify model availability
   - Review system prompts

2. **Performance Issues**
   - Monitor resource usage
   - Check network latency
   - Review agent configurations

3. **Integration Problems**
   - Verify API endpoints
   - Check authentication
   - Review data formats


--------------------------------------------------

# File: swarms/structs/auto_swarm.md

# AutoSwarm

The `AutoSwarm` class represents a swarm of agents that can be created and managed automatically. This class leverages the `AutoSwarmRouter` to route tasks to appropriate swarms and supports custom preprocessing, routing, and postprocessing of tasks. It is designed to handle complex workflows efficiently.

### Key Concepts

- **Swarm**: A group of agents working together to complete tasks.
- **Routing**: Directing tasks to the appropriate swarm based on specific criteria.
- **Preprocessing and Postprocessing**: Customizable functions to handle tasks before and after routing.
- **Event Loop**: Managing the execution of tasks in a loop.

## Attributes

### Arguments

| Argument            | Type                          | Default   | Description |
|---------------------|-------------------------------|-----------|-------------|
| `name`              | `Optional[str]`               | `None`    | The name of the swarm. |
| `description`       | `Optional[str]`               | `None`    | The description of the swarm. |
| `verbose`           | `bool`                        | `False`   | Whether to enable verbose mode. |
| `custom_params`     | `Optional[Dict[str, Any]]`    | `None`    | Custom parameters for the swarm. |
| `custom_preprocess` | `Optional[Callable]`          | `None`    | Custom preprocessing function for tasks. |
| `custom_postprocess`| `Optional[Callable]`          | `None`    | Custom postprocessing function for task results. |
| `custom_router`     | `Optional[Callable]`          | `None`    | Custom routing function for tasks. |
| `max_loops`         | `int`                         | `1`       | The maximum number of loops to run the workflow. |

### Attributes

| Attribute            | Type                          | Description |
|----------------------|-------------------------------|-------------|
| `name`               | `Optional[str]`               | The name of the swarm. |
| `description`        | `Optional[str]`               | The description of the swarm. |
| `verbose`            | `bool`                        | Whether to enable verbose mode. |
| `custom_params`      | `Optional[Dict[str, Any]]`    | Custom parameters for the swarm. |
| `custom_preprocess`  | `Optional[Callable]`          | Custom preprocessing function for tasks. |
| `custom_postprocess` | `Optional[Callable]`          | Custom postprocessing function for task results. |
| `custom_router`      | `Optional[Callable]`          | Custom routing function for tasks. |
| `max_loops`          | `int`                         | The maximum number of loops to run the workflow. |
| `router`             | `AutoSwarmRouter`             | The router for managing task routing. |

## Methods

### init_logging

Initializes logging for the `AutoSwarm`.

**Examples:**

```python
swarm = AutoSwarm(name="example_swarm", verbose=True)
swarm.init_logging()
```

### run

Runs the swarm simulation.

**Arguments:**

| Parameter | Type    | Default | Description |
|-----------|---------|---------|-------------|
| `task`    | `str`   | `None`  | The task to be executed. |
| `*args`   |         |         | Additional arguments. |
| `**kwargs`|         |         | Additional keyword arguments. |

**Returns:**

| Return Type | Description |
|-------------|-------------|
| `Any`       | The result of the executed task. |

**Raises:**

- `Exception`: If any error occurs during task execution.

**Examples:**

```python
swarm = AutoSwarm(name="example_swarm", max_loops=3)
result = swarm.run(task="example_task")
print(result)
```

### list_all_swarms

Lists all available swarms and their descriptions.

**Examples:**

```python
swarm = AutoSwarm(name="example_swarm", max_loops=3)
swarm.list_all_swarms()
# Output:
# INFO: Swarm Name: swarm1 || Swarm Description: Description of swarm1
# INFO: Swarm Name: swarm2 || Swarm Description: Description of swarm2
```

### Additional Examples

#### Example 1: Custom Preprocessing and Postprocessing

```python
def custom_preprocess(task, *args, **kwargs):
    # Custom preprocessing logic
    task = task.upper()
    return task, args, kwargs

def custom_postprocess(result):
    # Custom postprocessing logic
    return result.lower()

swarm = AutoSwarm(
    name="example_swarm",
    custom_preprocess=custom_preprocess,
    custom_postprocess=custom_postprocess,
    max_loops=3
)

# Running a task with custom preprocessing and postprocessing
result = swarm.run(task="example_task")
print(result)  # Output will be the processed result
```

#### Example 2: Custom Router Function

```python
def custom_router(swarm, task, *args, **kwargs):
    # Custom routing logic
    if "specific" in task:
        return swarm.router.swarm_dict["specific_swarm"].run(task, *args, **kwargs)
    return swarm.router.swarm_dict["default_swarm"].run(task, *args, **kwargs)

swarm = AutoSwarm(
    name="example_swarm",
    custom_router=custom_router,
    max_loops=3
)

# Running a task with custom routing
result = swarm.run(task="specific_task")
print(result)  # Output will be the result of the routed task
```

#### Example 3: Verbose Mode

```python
swarm = AutoSwarm(
    name="example_swarm",
    verbose=True,
    max_loops=3
)

# Running a task with verbose mode enabled
result = swarm.run(task="example_task")
# Output will include detailed logs of the task execution process
```


#### Full Example 4:
First create a class with BaseSwarm -> Then wrap it in the router -> then pass that to the `AutoSwarm`

```python
from swarms import BaseSwarm, AutoSwarmRouter, AutoSwarm


class FinancialReportSummarization(BaseSwarm):
    def __init__(self, name: str = None, *args, **kwargs):
        super().__init__()

    def run(self, task, *args, **kwargs):
        return task


# Add swarm to router
router = AutoSwarmRouter(swarms=[FinancialReportSummarization])

# Create AutoSwarm Instance
autoswarm = AutoSwarm(
    name="kyegomez/FinancialReportSummarization",
    description="A swarm for financial document summarizing and generation",
    verbose=True,
    router=router,
)

# Run the AutoSwarm
autoswarm.run("Analyze these documents and give me a summary:")
```

## Summary

The `AutoSwarm` class provides a robust framework for managing and executing tasks using a swarm of agents. With customizable preprocessing, routing, and postprocessing functions, it is highly adaptable to various workflows and can handle complex task execution scenarios efficiently. The integration with `AutoSwarmRouter` enhances its flexibility, making it a powerful tool for dynamic task management.

--------------------------------------------------

# File: swarms/structs/auto_swarm_router.md

# AutoSwarmRouter

The `AutoSwarmRouter` class is designed to route tasks to the appropriate swarm based on the provided name. This class allows for customization of preprocessing, routing, and postprocessing of tasks, making it highly adaptable to various workflows and requirements.

### Key Concepts

- **Routing**: Directing tasks to the appropriate swarm based on specific criteria.
- **Preprocessing and Postprocessing**: Customizable functions to handle tasks before and after routing.
- **Swarms**: Collections of `BaseSwarm` objects that perform the tasks.

## Attributes

### Arguments

| Argument           | Type                             | Default   | Description |
|--------------------|----------------------------------|-----------|-------------|
| `name`             | `Optional[str]`                  | `None`    | The name of the router. |
| `description`      | `Optional[str]`                  | `None`    | The description of the router. |
| `verbose`          | `bool`                           | `False`   | Whether to enable verbose mode. |
| `custom_params`    | `Optional[Dict[str, Any]]`       | `None`    | Custom parameters for the router. |
| `swarms`           | `Sequence[BaseSwarm]`            | `None`    | A list of `BaseSwarm` objects. |
| `custom_preprocess`| `Optional[Callable]`             | `None`    | Custom preprocessing function for tasks. |
| `custom_postprocess`| `Optional[Callable]`            | `None`    | Custom postprocessing function for task results. |
| `custom_router`    | `Optional[Callable]`             | `None`    | Custom routing function for tasks. |

### Attributes

| Attribute            | Type                             | Description |
|----------------------|----------------------------------|-------------|
| `name`               | `Optional[str]`                  | The name of the router. |
| `description`        | `Optional[str]`                  | The description of the router. |
| `verbose`            | `bool`                           | Whether to enable verbose mode. |
| `custom_params`      | `Optional[Dict[str, Any]]`       | Custom parameters for the router. |
| `swarms`             | `Sequence[BaseSwarm]`            | A list of `BaseSwarm` objects. |
| `custom_preprocess`  | `Optional[Callable]`             | Custom preprocessing function for tasks. |
| `custom_postprocess` | `Optional[Callable]`             | Custom postprocessing function for task results. |
| `custom_router`      | `Optional[Callable]`             | Custom routing function for tasks. |
| `swarm_dict`         | `Dict[str, BaseSwarm]`           | A dictionary of swarms keyed by their name. |

## Methods

### run

Executes the swarm simulation and routes the task to the appropriate swarm.

**Arguments:**

| Parameter | Type    | Default | Description |
|-----------|---------|---------|-------------|
| `task`    | `str`   | `None`  | The task to be executed. |
| `*args`   |         |         | Additional arguments. |
| `**kwargs`|         |         | Additional keyword arguments. |

**Returns:**

| Return Type | Description |
|-------------|-------------|
| `Any`       | The result of the routed task. |

**Raises:**

- `ValueError`: If the specified swarm is not found.
- `Exception`: If any error occurs during task routing or execution.

**Examples:**

```python
router = AutoSwarmRouter(name="example_router", swarms=[swarm1, swarm2])

# Running a task
result = router.run(task="example_task")
```

### len_of_swarms

Prints the number of swarms available in the router.

**Examples:**

```python
router = AutoSwarmRouter(name="example_router", swarms=[swarm1, swarm2])

# Printing the number of swarms
router.len_of_swarms()  # Output: 2
```

### list_available_swarms

Logs the available swarms and their descriptions.

**Examples:**

```python
router = AutoSwarmRouter(name="example_router", swarms=[swarm1, swarm2])

# Listing available swarms
router.list_available_swarms()
# Output:
# INFO: Swarm Name: swarm1 || Swarm Description: Description of swarm1
# INFO: Swarm Name: swarm2 || Swarm Description: Description of swarm2
```

### Additional Examples

#### Example 1: Custom Preprocessing and Postprocessing

```python
def custom_preprocess(task, *args, **kwargs):
    # Custom preprocessing logic
    task = task.upper()
    return task, args, kwargs

def custom_postprocess(result):
    # Custom postprocessing logic
    return result.lower()

router = AutoSwarmRouter(
    name="example_router",
    swarms=[swarm1, swarm2],
    custom_preprocess=custom_preprocess,
    custom_postprocess=custom_postprocess
)

# Running a task with custom preprocessing and postprocessing
result = router.run(task="example_task")
print(result)  # Output will be the processed result
```

#### Example 2: Custom Router Function

```python
def custom_router(router, task, *args, **kwargs):
    # Custom routing logic
    if "specific" in task:
        return router.swarm_dict["specific_swarm"].run(task, *args, **kwargs)
    return router.swarm_dict["default_swarm"].run(task, *args, **kwargs)

router = AutoSwarmRouter(
    name="example_router",
    swarms=[default_swarm, specific_swarm],
    custom_router=custom_router
)

# Running a task with custom routing
result = router.run(task="specific_task")
print(result)  # Output will be the result of the routed task
```

#### Example 3: Verbose Mode

```python
router = AutoSwarmRouter(
    name="example_router",
    swarms=[swarm1, swarm2],
    verbose=True
)

# Running a task with verbose mode enabled
result = router.run(task="example_task")
# Output will include detailed logs of the task routing and execution process
```

## Summary

The `AutoSwarmRouter` class provides a flexible and customizable approach to routing tasks to appropriate swarms, supporting custom preprocessing, routing, and postprocessing functions. This makes it a powerful tool for managing complex workflows that require dynamic task handling and execution.

--------------------------------------------------

# File: swarms/structs/base_workflow.md

# BaseWorkflow

The `BaseWorkflow` class serves as a foundational structure for defining and managing workflows. It allows users to add, remove, update, and manage tasks and agents within a workflow, offering flexibility and extensibility for various applications.

### Key Concepts

- **Agents**: Entities participating in the workflow.
- **Tasks**: Units of work to be executed within the workflow.
- **Models**: Computational models used within the workflow.
- **Workflow State**: The state of the workflow, which can be saved and restored.

## Attributes

### Arguments

| Argument | Type | Default | Description |
|----------|------|---------|-------------|
| `agents` | `List[Agent]` | `None` | A list of agents participating in the workflow. |
| `task_pool` | `List[Task]` | `None` | A list of tasks in the workflow. |
| `models` | `List[Any]` | `None` | A list of models used in the workflow. |
| `*args` | | | Variable length argument list. |
| `**kwargs` | | | Arbitrary keyword arguments. |

### Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `agents` | `List[Agent]` | A list of agents participating in the workflow. |
| `task_pool` | `List[Task]` | A list of tasks in the workflow. |
| `models` | `List[Any]` | A list of models used in the workflow. |

## Methods

### add_task

Adds a task or a list of tasks to the task pool.

**Arguments:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `task` | `Task` | `None` | A single task to add. |
| `tasks` | `List[Task]` | `None` | A list of tasks to add. |

**Raises:**

- `ValueError`: If neither task nor tasks are provided.

**Examples:**

```python
workflow = BaseWorkflow()
task1 = Task(description="Task 1")
task2 = Task(description="Task 2")

# Adding a single task
workflow.add_task(task=task1)

# Adding multiple tasks
workflow.add_task(tasks=[task1, task2])
```

### add_agent

Adds an agent to the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `agent` | `Agent` | The agent to add to the workflow. |

**Examples:**

```python
workflow = BaseWorkflow()
agent = Agent(name="Agent 1")

# Adding an agent to the workflow
workflow.add_agent(agent=agent)
```

### run

Abstract method to run the workflow.

### __sequential_loop

Abstract method for the sequential loop.

### __log

Logs a message if verbose mode is enabled.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `message` | `str` | The message to log. |

### __str__

Returns a string representation of the workflow.

### __repr__

Returns a string representation of the workflow for debugging.

### reset

Resets the workflow by clearing the results of each task.

**Examples:**

```python
workflow = BaseWorkflow()
workflow.reset()
```

### get_task_results

Returns the results of each task in the workflow.

**Returns:**

| Return Type | Description |
|-------------|-------------|
| `Dict[str, Any]` | The results of each task in the workflow. |

**Examples:**

```python
workflow = BaseWorkflow()
results = workflow.get_task_results()
```

### remove_task

Removes a task from the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The description of the task to remove. |

**Examples:**

```python
workflow = BaseWorkflow()
workflow.remove_task(task="Task 1")
```

### update_task

Updates the arguments of a task in the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The description of the task to update. |
| `**updates` | | The updates to apply to the task. |

**Raises:**

- `ValueError`: If the task is not found in the workflow.

**Examples:**

```python
workflow = BaseWorkflow()
task = Task(description="Task 1", kwargs={"param": 1})

# Adding a task to the workflow
workflow.add_task(task=task)

# Updating the task
workflow.update_task("Task 1", param=2)
```

### delete_task

Deletes a task from the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The description of the task to delete. |

**Raises:**

- `ValueError`: If the task is not found in the workflow.

**Examples:**

```python
workflow = BaseWorkflow()
task = Task(description="Task 1")

# Adding a task to the workflow
workflow.add_task(task=task)

# Deleting the task
workflow.delete_task("Task 1")
```

### save_workflow_state

Saves the workflow state to a json file.

**Arguments:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `filepath` | `Optional[str]` | `"sequential_workflow_state.json"` | The path to save the workflow state to. |

**Examples:**

```python
workflow = BaseWorkflow()
workflow.save_workflow_state(filepath="workflow_state.json")
```

### add_objective_to_workflow

Adds an objective to the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `task` | `str` | The description of the task. |
| `**kwargs` | | Additional keyword arguments for the task. |

**Examples:**

```python
workflow = BaseWorkflow()
workflow.add_objective_to_workflow(task="New Objective", agent=agent, args=[], kwargs={})
```

### load_workflow_state

Loads the workflow state from a json file and restores the workflow state.

**Arguments:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `filepath` | `str` | `None` | The path to load the workflow state from. |

**Examples:**

```python
workflow = BaseWorkflow()
workflow.load_workflow_state(filepath="workflow_state.json")
```

### workflow_dashboard

Displays a dashboard for the workflow.

**Arguments:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `**kwargs` | | Additional keyword arguments to pass to the dashboard. |

**Examples:**

```python
workflow = BaseWorkflow()
workflow.workflow_dashboard()
```

### workflow_bootup

Initializes the workflow.

**Examples:**

```python
workflow = BaseWorkflow()
workflow.workflow_bootup()
```

--------------------------------------------------

# File: swarms/structs/basestructure.md

# Module/Function Name: BaseStructure

## Introduction:

The `BaseStructure` module contains the basic structure and attributes required for running machine learning models and associated metadata, error logging, artifact saving/loading, and relevant event logging. 

The module provides the flexibility to save and load the model metadata, log errors, save artifacts, and maintain a log for multiple events associated with multiple threads and batched operations. The key attributes of the module include **name**, **description**, **save_metadata_path**, and **save_error_path**.

## Class Definition:

### Arguments:
| Argument             | Type   | Description                                                          |
|----------------------|--------|----------------------------------------------------------------------|
| name                 | str    | (Optional) The name of the structure.                                |
| description          | str    | (Optional) A description of the structure.                           |
| save_metadata        | bool   | A boolean flag to enable or disable metadata saving.                 |
| save_artifact_path   | str    | (Optional) The path to save artifacts.                               |
| save_metadata_path   | str    | (Optional) The path to save metadata.                                |
| save_error_path      | str    | (Optional) The path to save errors.                                  |

## Methods:

### 1. run
Runs the structure.

### 2. save_to_file
Saves data to a file.
* **data**: Value to be saved.
* **file_path**: Path where the data is to be saved.

### 3. load_from_file
Loads data from a file.
* **file_path**: Path from where the data is to be loaded.

### 4. save_metadata
Saves metadata to a file.
* **metadata**: Data to be saved as metadata.

### 5. load_metadata
Loads metadata from a file.

### 6. log_error
Logs error to a file.

### 7. save_artifact
Saves artifact to a file.
* **artifact**: The artifact to be saved.
* **artifact_name**: Name of the artifact.

### 8. load_artifact
Loads artifact from a file.
* **artifact_name**: Name of the artifact.

### 9. log_event
Logs an event to a file.
* **event**: The event to be logged.
* **event_type**: Type of the event (optional, defaults to "INFO").

### 10. run_async
Runs the structure asynchronously.

### 11. save_metadata_async
Saves metadata to a file asynchronously.

### 12. load_metadata_async
Loads metadata from a file asynchronously.

### 13. log_error_async
Logs error to a file asynchronously.

### 14. save_artifact_async
Saves artifact to a file asynchronously.

### 15. load_artifact_async
Loads artifact from a file asynchronously.

### 16. log_event_async
Logs an event to a file asynchronously.

### 17. asave_to_file
Saves data to a file asynchronously.

### 18. aload_from_file
Loads data from a file asynchronously.

### 19. run_concurrent
Runs the structure concurrently.

### 20. compress_data
Compresses data.

### 21. decompres_data
Decompresses data.

### 22. run_batched
Runs batched data. 

## Examples:

### Example 1: Saving Metadata
```python
base_structure = BaseStructure(name="ExampleStructure")
metadata = {"key1": "value1", "key2": "value2"}
base_structure.save_metadata(metadata)
```

### Example 2: Loading Artifact
```python
artifact_name = "example_artifact"
artifact_data = base_structure.load_artifact(artifact_name)
```

### Example 3: Running Concurrently
```python
concurrent_data = [data1, data2, data3]
results = base_structure.run_concurrent(batched_data=concurrent_data)
```

## Note:

The `BaseStructure` class is designed to provide a modular and extensible structure for managing metadata, logs, errors, and batched operations while running machine learning models. The class's methods offer asynchronous and concurrent execution capabilities, thus optimizing the performance of the associated applications and models. The module's attributes and methods cater to a wide range of use cases, making it an essential foundational component for machine learning and data-based applications.

# Conclusion:

The `BaseStructure` module offers a robust and flexible foundation for managing machine learning model metadata, error logs, and event tracking, including asynchronous, concurrent, and batched operations. By leveraging the inherent capabilities of this class, developers can enhance the reliability, scalability, and performance of machine learning-based applications.

## References:

- [Python Concurrent Programming with `asyncio`](https://docs.python.org/3/library/asyncio.html)
- [Understanding Thread Pool Executor in Python](https://docs.python.org/3/library/concurrent.futures.html#executor-objects)
- [Documentation on `gzip` Module for Data Compression](https://docs.python.org/3/library/gzip.html)

---

The above documentation provides detailed information about the `BaseStructure` module, including its functionality, attributes, methods, usage examples, and references to relevant resources for further exploration. This comprehensive documentation aims to deepen the users' understanding of the module's purpose and how it can be effectively utilized in practice.

Please let me know if you need further elaboration on any specific aspect or functionality of the `BaseStructure` module.


--------------------------------------------------

# File: swarms/structs/concurrentworkflow.md

# ConcurrentWorkflow Documentation

## Overview

The `ConcurrentWorkflow` class is designed to facilitate the concurrent execution of multiple agents, each tasked with solving a specific query or problem. This class is particularly useful in scenarios where multiple agents need to work in parallel, allowing for efficient resource utilization and faster completion of tasks. The workflow manages the execution, collects metadata, and optionally saves the results in a structured format.

### Key Features

- **Concurrent Execution**: Runs multiple agents simultaneously using Python's `asyncio` and `ThreadPoolExecutor`.
- **Metadata Collection**: Gathers detailed metadata about each agent's execution, including start and end times, duration, and output.
- **Customizable Output**: Allows the user to save metadata to a file or return it as a string or dictionary.
- **Error Handling**: Implements retry logic for improved reliability.
- **Batch Processing**: Supports running tasks in batches and parallel execution.
- **Asynchronous Execution**: Provides asynchronous run options for improved performance.

## Class Definitions

The `ConcurrentWorkflow` class is the core class that manages the concurrent execution of agents. It inherits from `BaseSwarm` and includes several key attributes and methods to facilitate this process.

### Attributes

| Attribute              | Type                    | Description                                               |
|------------------------|-------------------------|-----------------------------------------------------------|
| `name`                 | `str`                   | The name of the workflow. Defaults to `"ConcurrentWorkflow"`. |
| `description`          | `str`                   | A brief description of the workflow.                      |
| `agents`               | `List[Agent]`           | A list of agents to be executed concurrently.             |
| `metadata_output_path` | `str`                   | Path to save the metadata output. Defaults to `"agent_metadata.json"`. |
| `auto_save`            | `bool`                  | Flag indicating whether to automatically save the metadata. |
| `output_schema`        | `BaseModel`             | The output schema for the metadata, defaults to `MetadataSchema`. |
| `max_loops`            | `int`                   | Maximum number of loops for the workflow, defaults to `1`. |
| `return_str_on`        | `bool`                  | Flag to return output as string. Defaults to `False`.     |
| `agent_responses`      | `List[str]`             | List of agent responses as strings.                       |
| `auto_generate_prompts`| `bool`                  | Flag indicating whether to auto-generate prompts for agents. |
| `output_type`          | `OutputType`            | Type of output format to return. Defaults to `"dict"`.    |
| `return_entire_history`| `bool`                  | Flag to return entire conversation history. Defaults to `False`. |
| `conversation`         | `Conversation`          | Conversation object to track agent interactions.          |
| `max_workers`          | `int`                   | Maximum number of worker threads. Defaults to CPU count.  |

## Methods

### ConcurrentWorkflow.\_\_init\_\_

Initializes the `ConcurrentWorkflow` class with the provided parameters.

#### Parameters

| Parameter             | Type           | Default Value                          | Description                                               |
|-----------------------|----------------|----------------------------------------|-----------------------------------------------------------|
| `name`                | `str`          | `"ConcurrentWorkflow"`                 | The name of the workflow.                                 |
| `description`         | `str`          | `"Execution of multiple agents concurrently"` | A brief description of the workflow.               |
| `agents`              | `List[Agent]`  | `[]`                                   | A list of agents to be executed concurrently.             |
| `metadata_output_path`| `str`          | `"agent_metadata.json"`                | Path to save the metadata output.                         |
| `auto_save`           | `bool`         | `True`                                 | Flag indicating whether to automatically save the metadata. |
| `output_schema`       | `BaseModel`    | `MetadataSchema`                       | The output schema for the metadata.                       |
| `max_loops`           | `int`          | `1`                                    | Maximum number of loops for the workflow.                 |
| `return_str_on`       | `bool`         | `False`                                | Flag to return output as string.                          |
| `agent_responses`     | `List[str]`    | `[]`                                   | List of agent responses as strings.                       |
| `auto_generate_prompts`| `bool`        | `False`                                | Flag indicating whether to auto-generate prompts for agents. |
| `output_type`         | `OutputType`   | `"dict"`                               | Type of output format to return.                          |
| `return_entire_history`| `bool`        | `False`                                | Flag to return entire conversation history.               |

#### Raises

- `ValueError`: If the list of agents is empty or if the description is empty.

### ConcurrentWorkflow.activate_auto_prompt_engineering

Activates the auto-generate prompts feature for all agents in the workflow.

#### Example

```python
workflow = ConcurrentWorkflow(agents=[Agent()])
workflow.activate_auto_prompt_engineering()
# All agents in the workflow will now auto-generate prompts.
```

### ConcurrentWorkflow.transform_metadata_schema_to_str

Transforms the metadata schema into a string format.

#### Parameters

| Parameter   | Type                | Description                                               |
|-------------|---------------------|-----------------------------------------------------------|
| `schema`    | `MetadataSchema`    | The metadata schema to transform.                         |

#### Returns

- `str`: The metadata schema as a formatted string.

### ConcurrentWorkflow.save_metadata

Saves the metadata to a JSON file based on the `auto_save` flag.

#### Example

```python
workflow.save_metadata()
# Metadata will be saved to the specified path if auto_save is True.
```

### ConcurrentWorkflow.run

Executes the workflow for the provided task.

#### Parameters

| Parameter   | Type                | Description                                               |
|-------------|---------------------|-----------------------------------------------------------|
| `task`      | `Optional[str]`     | The task or query to give to all agents.                  |
| `img`       | `Optional[str]`     | The image to be processed by the agents.                  |
| `*args`     | `tuple`             | Additional positional arguments.                          |
| `**kwargs`  | `dict`              | Additional keyword arguments.                             |

#### Returns

- `Any`: The result of the execution, format depends on output_type and return_entire_history settings.

#### Raises

- `ValueError`: If an invalid device is specified.
- `Exception`: If any other error occurs during execution.

### ConcurrentWorkflow.run_batched

Runs the workflow for a batch of tasks.

#### Parameters

| Parameter   | Type         | Description                                               |
|-------------|--------------|-----------------------------------------------------------|
| `tasks`     | `List[str]`  | A list of tasks or queries to give to all agents.         |

#### Returns

- `List[Union[Dict[str, Any], str]]`: A list of final metadata for each task.

#### Example

```python
tasks = ["Task 1", "Task 2"]
results = workflow.run_batched(tasks)
print(results)
```



## Usage Examples

### Example 1: Basic Usage

```python
import os

from swarms import Agent, ConcurrentWorkflow, OpenAIChat
# Define custom system prompts for each social media platform
TWITTER_AGENT_SYS_PROMPT = """
You are a Twitter marketing expert specializing in real estate. Your task is to create engaging, concise tweets to promote properties, analyze trends to maximize engagement, and use appropriate hashtags and timing to reach potential buyers.
"""

INSTAGRAM_AGENT_SYS_PROMPT = """
You are an Instagram marketing expert focusing on real estate. Your task is to create visually appealing posts with engaging captions and hashtags to showcase properties, targeting specific demographics interested in real estate.
"""

FACEBOOK_AGENT_SYS_PROMPT = """
You are a Facebook marketing expert for real estate. Your task is to craft posts optimized for engagement and reach on Facebook, including using images, links, and targeted messaging to attract potential property buyers.
"""

LINKEDIN_AGENT_SYS_PROMPT = """
You are a LinkedIn marketing expert for the real estate industry. Your task is to create professional and informative posts, highlighting property features, market trends, and investment opportunities, tailored to professionals and investors.
"""

EMAIL_AGENT_SYS_PROMPT = """
You are an Email marketing expert specializing in real estate. Your task is to write compelling email campaigns to promote properties, focusing on personalization, subject lines, and effective call-to-action strategies to drive conversions.
"""

# Initialize your agents for different social media platforms
agents = [
    Agent(
        agent_name="Twitter-RealEstate-Agent",
        system_prompt=TWITTER_AGENT_SYS_PROMPT,
        model_name="gpt-4o",
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="twitter_realestate_agent.json",
        user_name="swarm_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Instagram-RealEstate-Agent",
        system_prompt=INSTAGRAM_AGENT_SYS_PROMPT,
        model_name="gpt-4o",
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="instagram_realestate_agent.json",
        user_name="swarm_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Facebook-RealEstate-Agent",
        system_prompt=FACEBOOK_AGENT_SYS_PROMPT,
        model_name="gpt-4o",
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="facebook_realestate_agent.json",
        user_name="swarm_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="LinkedIn-RealEstate-Agent",
        system_prompt=LINKEDIN_AGENT_SYS_PROMPT,
        model_name="gpt-4o",
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="linkedin_realestate_agent.json",
        user_name="swarm_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Email-RealEstate-Agent",
        system_prompt=EMAIL_AGENT_SYS_PROMPT,
        model_name="gpt-4o",
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="email_realestate_agent.json",
        user_name="swarm_corp",
        retry_attempts=1,
    ),
]

# Initialize workflow
workflow = ConcurrentWorkflow(
    name="Real Estate Marketing Swarm",
    agents=agents,
    metadata_output_path="metadata.json",
    description="Concurrent swarm of content generators for real estate!",
    auto_save=True,
)

# Run workflow
task = "Create a marketing campaign for a luxury beachfront property in Miami, focusing on its stunning ocean views, private beach access, and state-of-the-art amenities."
metadata = workflow.run(task)
print(metadata)
```

### Example 2: Custom Output Handling

```python
# Initialize workflow with string output
workflow = ConcurrentWorkflow(
    name="Real Estate Marketing Swarm",
    agents=agents,
    metadata_output_path="metadata.json",
    description="Concurrent swarm of content generators for real estate!",
    auto_save=True,
    return_str_on=True
)

# Run workflow
task = "Develop a marketing strategy for a newly renovated historic townhouse in Boston, emphasizing its blend of classic architecture and modern amenities."
metadata_str = workflow.run(task)
print(metadata_str)
```

### Example 3: Error Handling and Debugging

```python
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)

# Initialize workflow
workflow = ConcurrentWorkflow(
    name="Real Estate Marketing Swarm",
    agents=agents,
    metadata_output_path="metadata.json",
    description="Concurrent swarm of content generators for real estate!",
    auto_save=True
)

# Run workflow with error handling
try:
    task = "Create a marketing campaign for a eco-friendly tiny house community in Portland, Oregon."
    metadata = workflow.run(task)
    print(metadata)
except Exception as e:
    logging.error(f"An error occurred during workflow execution: {str(e)}")
    # Additional error handling or debugging steps can be added here
```

### Example 4: Batch Processing

```python
# Initialize workflow
workflow = ConcurrentWorkflow(
    name="Real Estate Marketing Swarm",
    agents=agents,
    metadata_output_path="metadata_batch.json",
    description="Concurrent swarm of content generators for real estate!",
    auto_save=True
)

# Define a list of tasks
tasks = [
    "Market a family-friendly suburban home with a large backyard and excellent schools nearby.",
    "Promote a high-rise luxury apartment in New York City with panoramic skyline views.",
    "Advertise a ski-in/ski-out chalet in Aspen, Colorado, perfect for winter sports enthusiasts."
]

# Run workflow in batch mode
results = workflow.run_batched(tasks)

# Process and print results
for task, result in zip(tasks, results):
    print(f"Task: {task}")
    print(f"Result: {result}\n")
```



## Tips and Best Practices

- **Agent Initialization**: Ensure that all agents are correctly initialized with their required configurations before passing them to `ConcurrentWorkflow`.
- **Metadata Management**: Use the `auto_save` flag to automatically save metadata if you plan to run multiple workflows in succession.
- **Concurrency Limits**: Adjust the number of agents based on your system's capabilities to avoid overloading resources.
- **Error Handling**: Implement try-except blocks when running workflows to catch and handle exceptions gracefully.
- **Batch Processing**: For large numbers of tasks, consider using `run_batched` or `run_parallel` methods to improve overall throughput.
- **Asynchronous Operations**: Utilize asynchronous methods (`run_async`, `run_batched_async`, `run_parallel_async`) when dealing with I/O-bound tasks or when you need to maintain responsiveness in your application.
- **Logging**: Implement detailed logging to track the progress of your workflows and troubleshoot any issues that may arise.
- **Resource Management**: Be mindful of API rate limits and resource consumption, especially when running large batches or parallel executions.
- **Testing**: Thoroughly test your workflows with various inputs and edge cases to ensure robust performance in production environments.

## References and Resources

- [Python's `asyncio` Documentation](https://docs.python.org/3/library/asyncio.html)
- [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- [ThreadPoolExecutor in Python](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor)
- [Loguru for Logging in Python](https://loguru.readthedocs.io/en/stable/)
- [Tenacity: Retry library for Python](https://tenacity.readthedocs.io/en/latest/)

--------------------------------------------------

# File: swarms/structs/conversation.md

# Module/Class Name: Conversation

## Introduction

The `Conversation` class is a powerful tool for managing and structuring conversation data in a Python program. It enables you to create, manipulate, and analyze conversations easily. This documentation will provide you with a comprehensive understanding of the `Conversation` class, its attributes, methods, and how to effectively use it.

## Table of Contents

1. **Class Definition**
   - Overview
   - Attributes

2. **Methods**
   - `__init__(self, time_enabled: bool = False, *args, **kwargs)`
   - `add(self, role: str, content: str, *args, **kwargs)`
   - `delete(self, index: str)`
   - `update(self, index: str, role, content)`
   - `query(self, index: str)`
   - `search(self, keyword: str)`
   - `display_conversation(self, detailed: bool = False)`
   - `export_conversation(self, filename: str)`
   - `import_conversation(self, filename: str)`
   - `count_messages_by_role(self)`
   - `return_history_as_string(self)`
   - `save_as_json(self, filename: str)`
   - `load_from_json(self, filename: str)`
   - `search_keyword_in_conversation(self, keyword: str)`
   - `pretty_print_conversation(self, messages)`

---

### 1. Class Definition

#### Overview

The `Conversation` class is designed to manage conversations by keeping track of messages and their attributes. It offers methods for adding, deleting, updating, querying, and displaying messages within the conversation. Additionally, it supports exporting and importing conversations, searching for specific keywords, and more.

#### Attributes

- `time_enabled (bool)`: A flag indicating whether to enable timestamp recording for messages.
- `conversation_history (list)`: A list that stores messages in the conversation.

### 2. Methods

#### `__init__(self, time_enabled: bool = False, *args, **kwargs)`

- **Description**: Initializes a new Conversation object.
- **Parameters**:
  - `time_enabled (bool)`: If `True`, timestamps will be recorded for each message. Default is `False`.

#### `add(self, role: str, content: str, *args, **kwargs)`

- **Description**: Adds a message to the conversation history.
- **Parameters**:
  - `role (str)`: The role of the speaker (e.g., "user," "assistant").
  - `content (str)`: The content of the message.

#### `delete(self, index: str)`

- **Description**: Deletes a message from the conversation history.
- **Parameters**:
  - `index (str)`: The index of the message to delete.

#### `update(self, index: str, role, content)`

- **Description**: Updates a message in the conversation history.
- **Parameters**:
  - `index (str)`: The index of the message to update.
  - `role (_type_)`: The new role of the speaker.
  - `content (_type_)`: The new content of the message.

#### `query(self, index: str)`

- **Description**: Retrieves a message from the conversation history.
- **Parameters**:
  - `index (str)`: The index of the message to query.
- **Returns**: The message as a string.

#### `search(self, keyword: str)`

- **Description**: Searches for messages containing a specific keyword in the conversation history.
- **Parameters**:
  - `keyword (str)`: The keyword to search for.
- **Returns**: A list of messages that contain the keyword.

#### `display_conversation(self, detailed: bool = False)`

- **Description**: Displays the conversation history.
- **Parameters**:
  - `detailed (bool, optional)`: If `True`, provides detailed information about each message. Default is `False`.

#### `export_conversation(self, filename: str)`

- **Description**: Exports the conversation history to a text file.
- **Parameters**:
  - `filename (str)`: The name of the file to export to.

#### `import_conversation(self, filename: str)`

- **Description**: Imports a conversation history from a text file.
- **Parameters**:
  - `filename (str)`: The name of the file to import from.

#### `count_messages_by_role(self)`

- **Description**: Counts the number of messages by role in the conversation.
- **Returns**: A dictionary containing the count of messages for each role.

#### `return_history_as_string(self)`

- **Description**: Returns the entire conversation history as a single string.
- **Returns**: The conversation history as a string.

#### `save_as_json(self, filename: str)`

- **Description**: Saves the conversation history as a JSON file.
- **Parameters**:
  - `filename (str)`: The name of the JSON file to save.

#### `load_from_json(self, filename: str)`

- **Description**: Loads a conversation history from a JSON file.
- **Parameters**:
  - `filename (str)`: The name of the JSON file to load.

#### `search_keyword_in_conversation(self, keyword: str)`

- **Description**: Searches for a keyword in the conversation history and returns matching messages.
- **Parameters**:
  - `keyword (str)`: The keyword to search for.
- **Returns**: A list of messages containing the keyword.

#### `pretty_print_conversation(self, messages)`

- **Description**: Pretty prints a list of messages with colored role indicators.
- **Parameters**:
  - `messages (list)`: A list of messages to print.

## Examples

Here are some usage examples of the `Conversation` class:

### Creating a Conversation

```python
from swarms.structs import Conversation

conv = Conversation()
```

### Adding Messages

```python
conv.add("user", "Hello, world!")
conv.add("assistant", "Hello, user!")
```

### Displaying the Conversation

```python
conv.display_conversation()
```

### Searching for Messages

```python
result = conv.search("Hello")
```

### Exporting and Importing Conversations

```python
conv.export_conversation("conversation.txt")
conv.import_conversation("conversation.txt")
```

### Counting Messages by Role

```python
counts = conv.count_messages_by_role()
```

### Loading and Saving as JSON

```python
conv.save_as_json("conversation.json")
conv.load_from_json("conversation.json")
```

Certainly! Let's continue with more examples and additional information about the `Conversation` class.

### Querying a Specific Message

You can retrieve a specific message from the conversation by its index:

```python
message = conv.query(0)  # Retrieves the first message
```

### Updating a Message

You can update a message's content or role within the conversation:

```python
conv.update(0, "user", "Hi there!")  # Updates the first message
```

### Deleting a Message

If you want to remove a message from the conversation, you can use the `delete` method:

```python
conv.delete(0)  # Deletes the first message
```

### Counting Messages by Role

You can count the number of messages by role in the conversation:

```python
counts = conv.count_messages_by_role()
# Example result: {'user': 2, 'assistant': 2}
```

### Exporting and Importing as Text

You can export the conversation to a text file and later import it:

```python
conv.export_conversation("conversation.txt")  # Export
conv.import_conversation("conversation.txt")  # Import
```

### Exporting and Importing as JSON

Conversations can also be saved and loaded as JSON files:

```python
conv.save_as_json("conversation.json")  # Save as JSON
conv.load_from_json("conversation.json")  # Load from JSON
```

### Searching for a Keyword

You can search for messages containing a specific keyword within the conversation:

```python
results = conv.search_keyword_in_conversation("Hello")
```

### Pretty Printing

The `pretty_print_conversation` method provides a visually appealing way to display messages with colored role indicators:

```python
conv.pretty_print_conversation(conv.conversation_history)
```

These examples demonstrate the versatility of the `Conversation` class in managing and interacting with conversation data. Whether you're building a chatbot, conducting analysis, or simply organizing dialogues, this class offers a robust set of tools to help you accomplish your goals.

## Conclusion

The `Conversation` class is a valuable utility for handling conversation data in Python. With its ability to add, update, delete, search, export, and import messages, you have the flexibility to work with conversations in various ways. Feel free to explore its features and adapt them to your specific projects and applications.

If you have any further questions or need additional assistance, please don't hesitate to ask!

--------------------------------------------------

# File: swarms/structs/create_new_swarm.md

# How to Add a New Swarm Class

This guide provides comprehensive step-by-step instructions for developers to create and add a new swarm. It emphasizes the importance of adhering to best practices, using proper type hints, and documenting code thoroughly to ensure maintainability, scalability, and clarity in your implementations.

## Overview

A Swarm class enables developers to manage and coordinate multiple agents working together to accomplish complex tasks efficiently. Each Swarm must:

- Contain a `run(task: str, img: str, *args, **kwargs)` method, which serves as the primary execution method for tasks.
- Include `name`, `description`, and `agents` parameters.
- Ensure `agents` is a list of callables, with each callable adhering to specific requirements for dynamic agent behavior.
- Follow type-hinting and documentation best practices to maintain code clarity and reliability.

Each Agent within the swarm must:

- Contain `agent_name`, `system_prompt`, and a `run` method.
- Follow similar type hinting and documentation standards to ensure consistency and readability.

By adhering to these requirements, you can create robust, reusable, and modular swarms that streamline task management and enhance collaborative functionality. Developers are also encouraged to contribute their swarms back to the open-source community by submitting a pull request to the Swarms repository at [https://github.com/kyegomez/swarms](https://github.com/kyegomez/swarms).

---

## Creating a Swarm Class

Below is a detailed template for creating a Swarm class. Ensure that all elements are documented and clearly defined:

```python
from typing import Callable, Any, List

class MySwarm:
    """
    A custom swarm class to manage and execute tasks with multiple agents.

    Attributes:
        name (str): The name of the swarm.
        description (str): A brief description of the swarm's purpose.
        agents (List[Callable]): A list of callables representing the agents to be utilized.
    """

    def __init__(self, name: str, description: str, agents: List[Callable]):
        """
        Initialize the Swarm with its name, description, and agents.

        Args:
            name (str): The name of the swarm.
            description (str): A description of the swarm.
            agents (List[Callable]): A list of callables that provide the agents for the swarm.
        """
        self.name = name
        self.description = description
        self.agents = agents

    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -> Any:
        """
        Execute a task using the swarm and its agents.

        Args:
            task (str): The task description.
            img (str): The image input.
            *args: Additional positional arguments for customization.
            **kwargs: Additional keyword arguments for fine-tuning behavior.

        Returns:
            Any: The result of the task execution, aggregated from all agents.
        """
        results = []
        for agent in self.agents:
            result = agent.run(task, img, *args, **kwargs)
            results.append(result)
        return results
```

This Swarm class serves as the main orchestrator for coordinating agents and running tasks dynamically and flexibly.

---

## Creating an Agent Class

Each agent must follow a well-defined structure to ensure compatibility with the swarm. Below is an example of an agent class:

```python
class Agent:
    """
    A single agent class to handle specific tasks assigned by the swarm.

    Attributes:
        agent_name (str): The name of the agent.
        system_prompt (str): The system prompt guiding the agent's behavior and purpose.
    """

    def __init__(self, agent_name: str, system_prompt: str):
        """
        Initialize the agent with its name and system prompt.

        Args:
            agent_name (str): The name of the agent.
            system_prompt (str): The guiding prompt for the agent.
        """
        self.agent_name = agent_name
        self.system_prompt = system_prompt

    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -> Any:
        """
        Execute a specific task assigned to the agent.

        Args:
            task (str): The task description.
            img (str): The image input for processing.
            *args: Additional positional arguments for task details.
            **kwargs: Additional keyword arguments for extended functionality.

        Returns:
            Any: The result of the task execution, which can be customized.
        """
        # Example implementation (to be customized by developer)
        return f"Agent {self.agent_name} executed task: {task}"
```

This structure ensures that each agent can independently handle tasks and integrate seamlessly into a swarm.

---

## Adding Your Swarm to a Project

### Step 1: Define Your Agents
Create one or more instances of the `Agent` class to serve as components of your swarm. For example:

```python
def create_agents():
    return [
        Agent(agent_name="Agent1", system_prompt="Analyze the image and summarize results."),
        Agent(agent_name="Agent2", system_prompt="Detect objects and highlight key features."),
    ]
```

### Step 2: Implement Your Swarm
Create an instance of your Swarm class, defining its name, description, and associated agents:

```python
my_swarm = MySwarm(
    name="Image Analysis Swarm",
    description="A swarm designed to analyze images and perform a range of related tasks.",
    agents=create_agents()
)
```

### Step 3: Execute Tasks
Call the `run` method of your swarm, passing in the required parameters for execution:

```python
results = my_swarm.run(task="Analyze image content", img="path/to/image.jpg")
print(results)
```

This simple flow allows you to dynamically utilize agents for diverse operations and ensures efficient task execution.

---

## Best Practices

To ensure your swarm implementation is efficient and maintainable, follow these best practices:

1. **Type Annotations:**
   Use precise type hints for parameters and return types to improve code readability and support static analysis tools.

2. **Comprehensive Documentation:**
   Include clear and detailed docstrings for all classes, methods, and attributes to ensure your code is understandable.

3. **Thorough Testing:**
   Test your swarm and agents with various tasks to verify correctness and identify potential edge cases.

4. **Modular Design:**
   Keep your swarm and agent logic modular, enabling reuse and easy extensions for future enhancements.

5. **Error Handling:**
   Implement robust error handling in the `run` methods to gracefully manage unexpected inputs or issues during execution.

6. **Code Review:**
   Regularly review and refactor your code to align with the latest best practices and maintain high quality.

7. **Scalability:**
   Design your swarm with scalability in mind, ensuring it can handle a large number of agents and complex tasks.

8. **Logging and Monitoring:**
   Include comprehensive logging to track task execution and monitor performance, enabling easier debugging and optimization.

9. **Open-Source Contributions:**
   Consider contributing your swarm to the Swarms repository to benefit the community. Submit a pull request at [https://github.com/kyegomez/swarms](https://github.com/kyegomez/swarms).

---

## Example Output

Given the implementation above, executing a task might produce output such as:

```plaintext
[
    "Agent Agent1 executed task: Analyze image content",
    "Agent Agent2 executed task: Analyze image content"
]
```

The modular design ensures that each agent contributes to the overall functionality of the swarm, allowing seamless scalability and dynamic task management.

---

## Conclusion

By following these guidelines, you can create swarms that are powerful, flexible, and maintainable. Leveraging the provided templates and best practices enables you to build efficient multi-agent systems capable of handling diverse and complex tasks. Proper structuring, thorough testing, and adherence to best practices will ensure your swarm integrates effectively into any project, delivering robust and reliable performance. Furthermore, maintaining clear documentation and emphasizing modularity will help your implementation adapt to future needs and use cases. Empower your projects with a well-designed swarm architecture today, and consider submitting your swarm to the open-source community to foster collaboration and innovation.



--------------------------------------------------

# File: swarms/structs/custom_swarm.md

### Title: Building Custom Swarms with Multiple Agents: A Comprehensive Guide for Swarm Engineers

#### Introductio
As artificial intelligence and machine learning continue to grow in complexity and applicability, building systems that can harness multiple agents to solve complex tasks becomes more critical. Swarm engineering enables AI agents to collaborate and solve problems autonomously in diverse fields such as finance, marketing, operations, and even creative industries. In this guide, we'll focus on how to build a custom swarm system that integrates multiple agents into a cohesive system capable of solving tasks collaboratively.

The swarm we'll design will leverage Python, use types for better code structure, and feature logging with the powerful **loguru** logging library. We'll break down how to define and initialize swarms, make them scalable, and create methods like `run(task: str)` to trigger their execution.

By the end of this article, you will have a complete understanding of:

- What swarms are and how they can be built.

- How to intake multiple agents using a flexible class.

- How to run tasks across agents and capture their outputs.

- Best practices for error handling, logging, and optimization.

---

### 1. Understanding the Concept of a Swarm

A **swarm** refers to a collection of agents that collaborate to solve a problem. Each agent in the swarm performs part of the task, either independently or by communicating with other agents. Swarms are ideal for:

- **Scalability**: You can add or remove agents dynamically based on the task's complexity.

- **Flexibility**: Each agent can be designed to specialize in different parts of the problem, offering modularity.

- **Autonomy**: Agents in a swarm can operate autonomously, reducing the need for constant supervision.

We'll be using Python as the primary programming language and will structure the swarm class using clean, reusable code principles.

---

### 2. Designing the Swarm Class: Intake Multiple Agents

We'll begin by creating a base class for our swarm. This class will intake multiple agents and define a `run` method, which is the core method for executing tasks across the swarm. Each agent is defined by its specific behavior or "intelligence" to complete part of the task.

#### 2.1 Importing the Required Libraries and Dependencies

We'll rely on the **loguru** logging library, Pydantic for metadata handling, and standard Python typing.

```python
from typing import List, Union
from loguru import logger
from swarms.structs.base_swarm import BaseSwarm

class SwarmExecutionError(Exception):
    """Custom exception for handling swarm execution errors."""
    pass
```

#### 2.2 Defining the Swarm Class

The class `CustomSwarm` will take in a list of agents. The agents will be instances of `BaseSwarm` (or callable functions). The `run(task: str)` method will delegate tasks to each agent in the swarm and handle any errors or retries.

```python
class CustomSwarm:
    def __init__(self, agents: List[BaseSwarm]):
        """
        Initializes the CustomSwarm with a list of agents.

        Args:
            agents (List[BaseSwarm]): A list of agent objects that inherit from BaseSwarm.
        """
        self.agents = agents
        self.validate_agents()

    def validate_agents(self):
        """Validates that each agent has a 'run' method."""
        for agent in self.agents:
            if not hasattr(agent, 'run'):
                raise AttributeError(f"Agent {agent} does not have a 'run' method.")
            logger.info(f"Agent {agent} validated successfully.")

    def run(self, task: str):
        """
        Runs the task across all agents in the swarm.

        Args:
            task (str): The task to pass to each agent.
        """
        logger.info(f"Running task '{task}' across all agents in the swarm.")
        for agent in self.agents:
            try:
                agent.run(task)
                logger.info(f"Agent {agent} successfully completed the task.")
            except Exception as e:
                logger.error(f"Agent {agent} failed to run task: {e}")
                raise SwarmExecutionError(f"Execution failed for {agent}. Task: {task}")
```

### 3. Adding Logging and Error Handling with `loguru`

Logging is crucial for production-grade systems, especially when managing complex tasks that involve multiple agents. **Loguru** is a simple and efficient logging library that allows us to log everything from information messages to errors.

```python
from loguru import logger

class CustomSwarm:
    def __init__(self, agents: List[BaseSwarm]):
        self.agents = agents
        logger.info("CustomSwarm initialized with agents.")
        self.validate_agents()

    def run(self, task: str):
        logger.info(f"Task received: {task}")
        for agent in self.agents:
            try:
                agent.run(task)
                logger.success(f"Agent {agent} completed task successfully.")
            except Exception as e:
                logger.error(f"Error while running task '{task}' for {agent}: {e}")
                raise SwarmExecutionError(f"Execution failed for {agent}")
```

### 4. Running Tasks Across Multiple Agents

The `run(task: str)` method will handle distributing the task to each agent in the swarm. Each agent’s `run` method is expected to take a task as input and perform its specific logic. We can add further customization by allowing each agent to return output, which can be collected for later analysis.

#### 4.1 Example of Integrating Agents

Let's take a look at how we can define agents using the `BaseSwarm` class and integrate them into the swarm.

```python
class FinancialAgent(BaseSwarm):
    def run(self, task: str):
        logger.info(f"FinancialAgent processing task: {task}")
        # Custom logic for financial analysis
        return f"FinancialAgent response to task: {task}"

class MarketingAgent(BaseSwarm):
    def run(self, task: str):
        logger.info(f"MarketingAgent processing task: {task}")
        # Custom logic for marketing analysis
        return f"MarketingAgent response to task: {task}"
```

Now, we initialize the swarm with these agents:

```python
if __name__ == "__main__":
    agents = [FinancialAgent(), MarketingAgent()]
    swarm = CustomSwarm(agents)
    swarm.run("Analyze Q3 financial report and marketing impact.")
```

### 5. Enhancing the Swarm with Concurrent Execution

When dealing with large or time-consuming tasks, running agents concurrently (in parallel) can significantly improve performance. We can achieve this by utilizing Python’s **concurrent.futures** or **threading** libraries.

#### 5.1 Running Swarms Concurrently

```python
from concurrent.futures import ThreadPoolExecutor, as_completed

class CustomSwarm:
    def __init__(self, agents: List[BaseSwarm], max_workers: int = 4):
        self.agents = agents
        self.thread_pool = ThreadPoolExecutor(max_workers=max_workers)
        logger.info("CustomSwarm initialized with concurrent execution.")

    def run(self, task: str):
        futures = []
        for agent in self.agents:
            futures.append(self.thread_pool.submit(agent.run, task))
        
        for future in as_completed(futures):
            result = future.result()
            logger.info(f"Agent result: {result}")
```

### 6. Advanced Error Handling and Retries

In a production system, agents might fail due to a wide range of reasons (network errors, API rate limits, etc.). To ensure resilience, we can add retry mechanisms and even fallback agents that attempt to recover the failed task.

```python
class CustomSwarm:
    def run_with_retries(self, task: str, retries: int = 3):
        """
        Runs the task across all agents with retry logic.
        
        Args:
            task (str): The task to run.
            retries (int): Number of retries allowed for failed agents.
        """
        for agent in self.agents:
            attempt = 0
            while attempt <= retries:
                try:
                    agent.run(task)
                    logger.success(f"Agent {agent} completed task.")
                    break
                except Exception as e:
                    logger.error(f"Agent {agent} failed on attempt {attempt + 1}. Error: {e}")
                    attempt += 1
                    if attempt > retries:
                        logger.error(f"Agent {agent} exhausted retries. Task failed.")
```

### 7. Adding Documentation with Docstrings

Clear and concise documentation is critical, especially for engineers maintaining and scaling the system. Using Python’s docstrings, we can document each class and method, describing what they do and their expected inputs/outputs.

```python
class CustomSwarm:
    """
    A class to manage and execute tasks using a swarm of agents.

    Attributes:
        agents (List[BaseSwarm]): A list of agent instances.
    
    Methods:
        run(task: str): Runs a task across all agents in the swarm.
        validate_agents(): Validates that each agent has a run method.
        run_with_retries(task: str, retries: int): Runs the task with retry logic.
    """

    def __init__(self, agents: List[BaseSwarm]):
        """
        Initializes the CustomSwarm with a list of agents.

        Args:
            agents (List[BaseSwarm]): A list of agent objects that inherit from BaseSwarm.
        """
        self.agents = agents

    def run(self, task: str):
        """
        Runs the task across all agents in the swarm.

        Args:
            task (str): The task to pass to each agent.
        """
        pass

    def validate_agents(self):
        """Validates that each agent has a 'run' method."""
        pass
```

`

### Conclusion

Building custom swarms that intake multiple agents can drastically improve the scalability, efficiency, and flexibility of AI-driven systems. By designing a robust swarm class that manages agents, distributes tasks, and ensures error resilience, you can handle complex, multi-agent workloads efficiently.

In this Guide, we've covered:

- Designing a basic swarm class.

- Running tasks across multiple agents.

- Leveraging logging, error handling, retries, and concurrency.

- Documenting your class for future-proofing.

This approach sets the foundation for building more advanced and domain-specific swarms in areas like finance, marketing, operations, and beyond. Swarm engineers can now explore more complex, multi-agent systems and push the boundaries of AI collaboration.

Stay tuned for future updates on more advanced swarm functionalities!

--------------------------------------------------

# File: swarms/structs/deep_research_swarm.md

# Deep Research Swarm

!!! abstract "Overview"
    The Deep Research Swarm is a powerful, production-grade research system that conducts comprehensive analysis across multiple domains using parallel processing and advanced AI agents.

    Key Features:
    
    - Parallel search processing
    
    - Multi-agent research coordination
    
    - Advanced information synthesis
    
    - Automated query generation
    
    - Concurrent task execution

## Getting Started

!!! tip "Quick Installation"
    ```bash
    pip install swarms
    ```

=== "Basic Usage"
    ```python
    from swarms.structs import DeepResearchSwarm

    # Initialize the swarm
    swarm = DeepResearchSwarm(
        name="MyResearchSwarm",
        output_type="json",
        max_loops=1
    )

    # Run a single research task
    results = swarm.run("What are the latest developments in quantum computing?")
    ```

=== "Batch Processing"
    ```python
    # Run multiple research tasks in parallel
    tasks = [
        "What are the environmental impacts of electric vehicles?",
        "How is AI being used in drug discovery?",
    ]
    batch_results = swarm.batched_run(tasks)
    ```

## Configuration

!!! info "Constructor Arguments"
    | Parameter | Type | Default | Description |
    |-----------|------|---------|-------------|
    | `name` | str | "DeepResearchSwarm" | Name identifier for the swarm |
    | `description` | str | "A swarm that conducts..." | Description of the swarm's purpose |
    | `research_agent` | Agent | research_agent | Custom research agent instance |
    | `max_loops` | int | 1 | Maximum number of research iterations |
    | `nice_print` | bool | True | Enable formatted console output |
    | `output_type` | str | "json" | Output format ("json" or "string") |
    | `max_workers` | int | CPU_COUNT * 2 | Maximum concurrent threads |
    | `token_count` | bool | False | Enable token counting |
    | `research_model_name` | str | "gpt-4o-mini" | Model to use for research |

## Core Methods

### Run
!!! example "Single Task Execution"
    ```python
    results = swarm.run("What are the latest breakthroughs in fusion energy?")
    ```

### Batched Run
!!! example "Parallel Task Execution"
    ```python
    tasks = [
        "What are current AI safety initiatives?",
        "How is CRISPR being used in agriculture?",
    ]
    results = swarm.batched_run(tasks)
    ```

### Step
!!! example "Single Step Execution"
    ```python
    results = swarm.step("Analyze recent developments in renewable energy storage")
    ```

## Domain-Specific Examples

=== "Scientific Research"
    ```python
    science_swarm = DeepResearchSwarm(
        name="ScienceSwarm",
        output_type="json",
        max_loops=2  # More iterations for thorough research
    )

    results = science_swarm.run(
        "What are the latest experimental results in quantum entanglement?"
    )
    ```

=== "Market Research"
    ```python
    market_swarm = DeepResearchSwarm(
        name="MarketSwarm",
        output_type="json"
    )

    results = market_swarm.run(
        "What are the emerging trends in electric vehicle battery technology market?"
    )
    ```

=== "News Analysis"
    ```python
    news_swarm = DeepResearchSwarm(
        name="NewsSwarm",
        output_type="string"  # Human-readable output
    )

    results = news_swarm.run(
        "What are the global economic impacts of recent geopolitical events?"
    )
    ```

=== "Medical Research"
    ```python
    medical_swarm = DeepResearchSwarm(
        name="MedicalSwarm",
        max_loops=2
    )

    results = medical_swarm.run(
        "What are the latest clinical trials for Alzheimer's treatment?"
    )
    ```

## Advanced Features

??? note "Custom Research Agent"
    ```python
    from swarms import Agent

    custom_agent = Agent(
        agent_name="SpecializedResearcher",
        system_prompt="Your specialized prompt here",
        model_name="gpt-4"
    )

    swarm = DeepResearchSwarm(
        research_agent=custom_agent,
        max_loops=2
    )
    ```

??? note "Parallel Processing Control"
    ```python
    swarm = DeepResearchSwarm(
        max_workers=8,  # Limit to 8 concurrent threads
        nice_print=False  # Disable console output for production
    )
    ```

## Best Practices

!!! success "Recommended Practices"
    1. **Query Formulation**: Be specific and clear in your research queries
    2. **Resource Management**: Adjust `max_workers` based on your system's capabilities
    3. **Output Handling**: Use appropriate `output_type` for your use case
    4. **Error Handling**: Implement try-catch blocks around swarm operations
    5. **Model Selection**: Choose appropriate models based on research complexity

## Limitations

!!! warning "Known Limitations"
    
    - Requires valid API keys for external services
    
    - Performance depends on system resources
    
    - Rate limits may apply to external API calls
    
    - Token limits apply to model responses



--------------------------------------------------

# File: swarms/structs/diy_your_own_agent.md

# Create your own agent with `Agent` class

The Agent class is a powerful and flexible tool that empowers AI agents to build their own custom agents, tailored to their specific needs.

This comprehensive guide will explore the process of inheriting from the Agent class, enabling agents to create their own custom agent classes. By leveraging the rich features and extensibility of the Agent class, agents can imbue their offspring agents with unique capabilities, specialized toolsets, and tailored decision-making processes.

## Understanding the Agent Class

Before we dive into the intricacies of creating custom agent classes, let's revisit the foundational elements of the Agent class itself. The Agent class is a versatile and feature-rich class designed to streamline the process of building and managing AI agents. It acts as a backbone, connecting language models (LLMs) with various tools, long-term memory, and a wide range of customization options.

### Key Features of the Agent Class

The Agent class offers a plethora of features that can be inherited and extended by custom agent classes. Here are some of the key features that make the Agent class a powerful foundation:

1\. **Language Model Integration**: The Agent class supports seamless integration with popular language models such as LangChain, HuggingFace Transformers, and Autogen, allowing custom agent classes to leverage the power of state-of-the-art language models.

2\. **Tool Integration**: One of the standout features of the Agent class is its ability to integrate with various tools. Custom agent classes can inherit this capability and incorporate specialized tools tailored to their specific use cases.

3\. **Long-Term Memory**: The Agent class provides built-in support for long-term memory, enabling custom agent classes to retain and access information from previous interactions, essential for maintaining context and learning from past experiences.

4\. **Customizable Prompts and Standard Operating Procedures (SOPs)**: The Agent class allows you to define custom prompts and Standard Operating Procedures (SOPs) that guide an agent's behavior and decision-making process. Custom agent classes can inherit and extend these prompts and SOPs to align with their unique objectives and requirements.

5\. **Interactive and Dashboard Modes**: The Agent class supports interactive and dashboard modes, enabling real-time monitoring and interaction with agents. Custom agent classes can inherit these modes, facilitating efficient development, debugging, and user interaction.

6\. **Autosave and State Management**: With the Agent class, agents can easily save and load their state, including configuration, memory, and history. Custom agent classes can inherit this capability, ensuring seamless task continuation and enabling efficient collaboration among team members.

7\. **Response Filtering**: The Agent class provides built-in response filtering capabilities, allowing agents to filter out or replace specific words or phrases in their responses. Custom agent classes can inherit and extend this feature to ensure compliance with content moderation policies or specific guidelines.

8\. **Code Execution and Multimodal Support**: The Agent class supports code execution and multimodal input/output, enabling agents to process and generate code, as well as handle various data formats such as images, audio, and video. Custom agent classes can inherit and specialize these capabilities for their unique use cases.

9\. **Extensibility and Customization**: The Agent class is designed to be highly extensible and customizable, allowing agents to tailor its behavior, add custom functionality, and integrate with external libraries and APIs. Custom agent classes can leverage this extensibility to introduce specialized features and capabilities.

### Creating a Custom Agent Class

Now that we have a solid understanding of the Agent class and its features, let's dive into the process of creating a custom agent class by inheriting from the Agent class. Throughout this process, we'll explore how agents can leverage and extend the existing functionality, while introducing specialized features and capabilities tailored to their unique requirements.

#### Step 1: Inherit from the Agent Class

The first step in creating a custom agent class is to inherit from the Agent class. This will provide your custom agent class with the foundational features and capabilities of the Agent class, which can then be extended and customized as needed. The new agent class must have a `run(task: str)` method to run the entire agent. It is encouraged to have `step(task: str)` method that completes one step of the agent and then build the `run(task: str)` method.

```python

from swarms import Agent

class MyCustomAgent(Agent):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Add custom initialization logic here

    def run(self, task: str) -> 
        ...

```

In the example above, we define a new class `MyCustomAgent` that inherits from the `Agent` class. Within the `__init__` method, we call the parent class's `__init__` method using `super().__init__(*args, **kwargs)`, which ensures that the parent class's initialization logic is executed. You can then add any custom initialization logic specific to your custom agent class.

#### Step 2: Customize the Agent's Behavior

One of the key advantages of inheriting from the Agent class is the ability to customize the agent's behavior according to your specific requirements. This can be achieved by overriding or extending the existing methods, or by introducing new methods altogether.

```python
from swarms import Agent


class MyCustomAgent(Agent):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Custom initialization logic

    def custom_method(self, *args, **kwargs):

        # Implement custom logic here

        pass

    def run(self, task, *args, **kwargs):

        # Customize the run method

        response = super().run(task, *args, **kwargs)

        # Additional custom logic

        return response

```

In the example above, we introduce a new `custom_method` that can encapsulate any specialized logic or functionality specific to your custom agent class. Additionally, we override the `run` method, which is responsible for executing the agent's main task loop. Within the overridden `run` method, you can call the parent class's `run` method using `super().run(task, *args, **kwargs)` and then introduce any additional custom logic before or after the parent method's execution.

#### Step 3: Extend Memory Management

The Agent class provides built-in support for long-term memory, allowing agents to retain and access information from previous interactions. Custom agent classes can inherit and extend this capability by introducing specialized memory management techniques.

```python

from swarms_memory import BaseVectorDatabase
from swarms import Agent


class CustomMemory(BaseVectorDatabase):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Custom memory initialization logic

    def query(self, *args, **kwargs):

        # Custom memory query logic

        return result

class MyCustomAgent(Agent):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Custom initialization logic

        self.long_term_memory = CustomMemory()

    def run(self, task, *args, **kwargs):

        # Customize the run method

        response = super().run(task, *args, **kwargs)

        # Utilize custom memory

        memory_result = self.long_term_memory.query(*args, **kwargs)

        # Process memory result

        return response

```

In the example above, we define a new `CustomMemory` class that inherits from the `BaseVectorDatabase` class provided by the Agent class framework. Within the `CustomMemory` class, you can implement specialized memory management logic, such as custom indexing, retrieval, and storage mechanisms.

Next, within the `MyCustomAgent` class, we initialize an instance of the `CustomMemory` class and assign it to the `self.long_term_memory` attribute. This custom memory instance can then be utilized within the overridden `run` method, where you can query the memory and process the results as needed.

## Step 5: Introduce Custom Prompts and Standard Operating Procedures (SOPs)

The Agent class allows you to define custom prompts and Standard Operating Procedures (SOPs) that guide an agent's behavior and decision-making process. Custom agent classes can inherit and extend these prompts and SOPs to align with their unique objectives and requirements.

```python
from swarms import Agent


class MyCustomAgent(Agent):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Custom initialization logic

        self.custom_sop = "Custom SOP for MyCustomAgent..."

        self.custom_prompt = "Custom prompt for MyCustomAgent..."

    def run(self, task, *args, **kwargs):

        # Customize the run method

        response = super().run(task, *args, **kwargs)

        # Utilize custom prompts and SOPs

        custom_prompt = self.construct_dynamic_prompt(self.custom_prompt)

        custom_sop = self.construct_dynamic_sop(self.custom_sop)

        # Process custom prompts and SOPs

        return response

    def construct_dynamic_prompt(self, prompt):

        # Custom prompt construction logic

        return prompt

    def construct_dynamic_sop(self, sop):

        # Custom SOP construction logic

        return sop

```

In the example above, we define two new attributes within the `MyCustomAgent` class: `custom_sop` and `custom_prompt`. These attributes can be used to store custom prompts and SOPs specific to your custom agent class.

Within the overridden `run` method, you can utilize these custom prompts and SOPs by calling the `construct_dynamic_prompt` and `construct_dynamic_sop` methods, which can be defined within the `MyCustomAgent` class to implement specialized prompt and SOP construction logic.

#### Step 5: Introduce Custom Response Handling

The Agent class provides built-in response filtering capabilities, allowing agents to filter out or replace specific words or phrases in their responses. Custom agent classes can inherit and extend this feature to ensure compliance with content moderation policies or specific guidelines.

```python
from swarms import Agent


class MyCustomAgent(Agent):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        # Custom initialization logic

        self.response_filters = ["filter_word_1", "filter_word_2"]

    def run(self, task, *args, **kwargs):

        # Customize the run method

        response = super().run(task, *args, **kwargs)

        # Apply custom response filtering

        filtered_response = self.apply_response_filters(response)

        return filtered_response

    def apply_response_filters(self, response):

        # Custom response filtering logic

        for word in self.response_filters:

            response = response.replace(word, "[FILTERED]")

        return response

```

In the example above, we define a new attribute `response_filters` within the `MyCustomAgent` class, which is a list of words or phrases that should be filtered out or replaced in the agent's responses.

Within the overridden `run` method, we call the `apply_response_filters` method, which can be defined within the `MyCustomAgent` class to implement specialized response filtering logic. In the example, we iterate over the `response_filters` list and replace each filtered word or phrase with a placeholder string (`"[FILTERED]"`).

### Advanced Customization and Integration

The Agent class and its inherited custom agent classes can be further extended and customized to suit specific requirements and integrate with external libraries, APIs, and services. Here are some advanced customization and integration examples:

1\. **Multimodal Input/Output Integration**: Custom agent classes can leverage the multimodal input/output capabilities of the Agent class and introduce specialized handling for various data formats such as images, audio, and video.

2\. **Code Execution and Integration**: The Agent class supports code execution, enabling agents to run and evaluate code snippets. Custom agent classes can inherit and extend this capability, introducing specialized code execution environments, sandboxing mechanisms, or integration with external code repositories or platforms.

3\. **External API and Service Integration**: Custom agent classes can integrate with external APIs and services, enabling agents to leverage specialized data sources, computational resources, or domain-specific services.

4\. **Performance Optimization**: Depending on the use case and requirements, custom agent classes can introduce performance optimizations, such as adjusting loop intervals, retry attempts, or enabling parallel execution for certain tasks.

5\. **Logging and Monitoring**: Custom agent classes can introduce specialized logging and monitoring mechanisms, enabling agents to track their performance, identify potential issues, and generate detailed reports or dashboards.

6\. **Security and Privacy Enhancements**: Custom agent classes can implement security and privacy enhancements, such as data encryption, access control mechanisms, or compliance with industry-specific regulations and standards.

7\. **Distributed Execution and Scaling**: Custom agent classes can be designed to support distributed execution and scaling, enabling agents to leverage cloud computing resources or distributed computing frameworks for handling large-scale tasks or high-concurrency workloads.

By leveraging these advanced customization and integration capabilities, agents can create highly specialized and sophisticated custom agent classes tailored to their unique requirements and use cases.

### Best Practices and Considerations

While building custom agent classes by inheriting from the Agent class offers immense flexibility and power, it's essential to follow best practices and consider potential challenges and considerations:

1\. **Maintainability and Documentation**: As custom agent classes become more complex, it's crucial to prioritize maintainability and thorough documentation. Clear and concise code, comprehensive comments, and up-to-date documentation can significantly improve the long-term sustainability and collaboration efforts surrounding custom agent classes.

2\. **Testing and Validation**: Custom agent classes should undergo rigorous testing and validation to ensure their correctness, reliability, and adherence to expected behaviors. Establish a robust testing framework and continuously validate the agent's performance, particularly after introducing new features or integrations.

3\. **Security and Privacy Considerations**: When building custom agent classes, it's essential to consider security and privacy implications, especially if the agents will handle sensitive data or interact with critical systems. Implement appropriate security measures, such as access controls, data encryption, and secure communication protocols, to protect against potential vulnerabilities and ensure compliance with relevant regulations and standards.

4\. **Scalability and Performance Monitoring**: As custom agent classes are deployed and adopted, it's important to monitor their scalability and performance characteristics. Identify potential bottlenecks, resource constraints, or performance degradation, and implement appropriate optimization strategies or scaling mechanisms to ensure efficient and reliable operation.

5\. **Collaboration and Knowledge Sharing**: Building custom agent classes often involves collaboration among teams and stakeholders. Foster an environment of knowledge sharing, code reviews, and open communication to ensure that everyone involved understands the agent's capabilities, limitations, and intended use cases.

6\. **Ethical Considerations**: As AI agents become more advanced and autonomous, it's crucial to consider the ethical implications of their actions and decisions. Implement appropriate safeguards, oversight mechanisms, and ethical guidelines to ensure that custom agent classes operate in a responsible and transparent manner, aligning with ethical principles and societal values.

7\. **Continuous Learning and Adaptation**: The field of AI is rapidly evolving, with new techniques, tools, and best practices emerging regularly. Stay up-to-date with the latest developments and be prepared to adapt and refine your custom agent classes as new advancements become available.

By following these best practices and considering potential challenges, agents can create robust, reliable, and ethical custom agent classes that meet their specific requirements while adhering to industry standards and best practices.

# Conclusion

In this comprehensive guide, we have explored the process of creating custom agent classes by inheriting from the powerful Agent class. We have covered the key features of the Agent class, walked through the step-by-step process of inheriting and extending its functionality, and discussed advanced customization and integration techniques.

Building custom agent classes empowers AI agents to create tailored and specialized agents capable of tackling unique challenges and addressing specific domain requirements. By leveraging the rich features and extensibility of the Agent class, agents can imbue their offspring agents with unique capabilities, specialized toolsets, and tailored decision-making processes.

Remember, the journey of building custom agent classes is an iterative and collaborative process that requires continuous learning, adaptation, and refinement.

--------------------------------------------------

# File: swarms/structs/forest_swarm.md

# Forest Swarm

This documentation describes the **ForestSwarm** that organizes agents into trees. Each agent specializes in processing specific tasks. Trees are collections of agents, each assigned based on their relevance to a task through keyword extraction and embedding-based similarity.

The architecture allows for efficient task assignment by selecting the most relevant agent from a set of trees. Tasks are processed asynchronously, with agents selected based on task relevance, calculated by the similarity of system prompts and task keywords.


## Module Path: `swarms.structs.tree_swarm`

---

### Class: `TreeAgent`

`TreeAgent` represents an individual agent responsible for handling a specific task. Agents are initialized with a **system prompt** and are responsible for dynamically determining their relevance to a given task.

#### Attributes

| **Attribute**            | **Type**         | **Description**                                                                 |
|--------------------------|------------------|---------------------------------------------------------------------------------|
| `system_prompt`          | `str`            | A string that defines the agent's area of expertise and task-handling capability.|
| `llm`                    | `callable`       | The language model (LLM) used to process tasks (e.g., GPT-4).                    |
| `agent_name`             | `str`            | The name of the agent.                                                          |
| `system_prompt_embedding`| `tensor`         | Embedding of the system prompt for similarity-based task matching.               |
| `relevant_keywords`      | `List[str]`      | Keywords dynamically extracted from the system prompt to assist in task matching.|
| `distance`               | `Optional[float]`| The computed distance between agents based on embedding similarity.              |

#### Methods

| **Method**         | **Input**                       | **Output**         | **Description**                                                                 |
|--------------------|---------------------------------|--------------------|---------------------------------------------------------------------------------|
| `calculate_distance(other_agent: TreeAgent)` | `other_agent: TreeAgent`   | `float`          | Calculates the cosine similarity between this agent and another agent.         |
| `run_task(task: str)`                  | `task: str`                  | `Any`            | Executes the task, logs the input/output, and returns the result.               |
| `is_relevant_for_task(task: str, threshold: float = 0.7)` | `task: str, threshold: float` | `bool`  | Checks if the agent is relevant for the task using keyword matching or embedding similarity.|

---

### Class: `Tree`

`Tree` organizes multiple agents into a hierarchical structure, where agents are sorted based on their relevance to tasks.

#### Attributes

| **Attribute**            | **Type**         | **Description**                                                                 |
|--------------------------|------------------|---------------------------------------------------------------------------------|
| `tree_name`              | `str`            | The name of the tree (represents a domain of agents, e.g., "Financial Tree").    |
| `agents`                 | `List[TreeAgent]`| List of agents belonging to this tree.                                           |

#### Methods

| **Method**         | **Input**                       | **Output**         | **Description**                                                                 |
|--------------------|---------------------------------|--------------------|---------------------------------------------------------------------------------|
| `calculate_agent_distances()` | `None`                  | `None`             | Calculates and assigns distances between agents based on similarity of prompts. |
| `find_relevant_agent(task: str)` | `task: str`           | `Optional[TreeAgent]` | Finds the most relevant agent for a task based on keyword and embedding similarity. |
| `log_tree_execution(task: str, selected_agent: TreeAgent, result: Any)` | `task: str, selected_agent: TreeAgent, result: Any` | `None` | Logs details of the task execution by the selected agent.                      |

---

### Class: `ForestSwarm` 

`ForestSwarm` is the main class responsible for managing multiple trees. It oversees task delegation by finding the most relevant tree and agent for a given task.

#### Attributes

| **Attribute**            | **Type**         | **Description**                                                                 |
|--------------------------|------------------|---------------------------------------------------------------------------------|
| `trees`                  | `List[Tree]`     | List of trees containing agents organized by domain.                             |

#### Methods

| **Method**         | **Input**                       | **Output**         | **Description**                                                                 |
|--------------------|---------------------------------|--------------------|---------------------------------------------------------------------------------|
| `find_relevant_tree(task: str)` | `task: str`           | `Optional[Tree]`    | Searches across all trees to find the most relevant tree based on task requirements.|
| `run(task: str)`                | `task: str`           | `Any`              | Executes the task by finding the most relevant agent from the relevant tree.    |

## Full Code Example

```python
from swarms.structs.tree_swarm import TreeAgent, Tree, ForestSwarm
# Example Usage:

# Create agents with varying system prompts and dynamically generated distances/keywords
agents_tree1 = [
    TreeAgent(
        system_prompt="Stock Analysis Agent",
        agent_name="Stock Analysis Agent",
    ),
    TreeAgent(
        system_prompt="Financial Planning Agent",
        agent_name="Financial Planning Agent",
    ),
    TreeAgent(
        agent_name="Retirement Strategy Agent",
        system_prompt="Retirement Strategy Agent",
    ),
]

agents_tree2 = [
    TreeAgent(
        system_prompt="Tax Filing Agent",
        agent_name="Tax Filing Agent",
    ),
    TreeAgent(
        system_prompt="Investment Strategy Agent",
        agent_name="Investment Strategy Agent",
    ),
    TreeAgent(
        system_prompt="ROTH IRA Agent", agent_name="ROTH IRA Agent"
    ),
]

# Create trees
tree1 = Tree(tree_name="Financial Tree", agents=agents_tree1)
tree2 = Tree(tree_name="Investment Tree", agents=agents_tree2)

# Create the ForestSwarm
multi_agent_structure = ForestSwarm(trees=[tree1, tree2])

# Run a task
task = "Our company is incorporated in delaware, how do we do our taxes for free?"
output = multi_agent_structure.run(task)
print(output)
```



---

## Example Workflow

1. **Create Agents**: Agents are initialized with varying system prompts, representing different areas of expertise (e.g., stock analysis, tax filing).
2. **Create Trees**: Agents are grouped into trees, with each tree representing a domain (e.g., "Financial Tree", "Investment Tree").
3. **Run Task**: When a task is submitted, the system traverses through all trees and finds the most relevant agent to handle the task.
4. **Task Execution**: The selected agent processes the task, and the result is returned.

```plaintext
Task: "Our company is incorporated in Delaware, how do we do our taxes for free?"
```

**Process**:
- The system searches through the `Financial Tree` and `Investment Tree`.
- The most relevant agent (likely the "Tax Filing Agent") is selected based on keyword matching and prompt similarity.
- The task is processed, and the result is logged and returned.

---

## Analysis of the Swarm Architecture

The **Swarm Architecture** leverages a hierarchical structure (forest) composed of individual trees, each containing agents specialized in specific domains. This design allows for:

- **Modular and Scalable Organization**: By separating agents into trees, it is easy to expand or contract the system by adding or removing trees or agents.
- **Task Specialization**: Each agent is specialized, which ensures that tasks are matched with the most appropriate agent based on relevance and expertise.
- **Dynamic Matching**: The architecture uses both keyword-based and embedding-based matching to assign tasks, ensuring a high level of accuracy in agent selection.
- **Logging and Accountability**: Each task execution is logged in detail, providing transparency and an audit trail of which agent handled which task and the results produced.
- **Asynchronous Task Execution**: The architecture can be adapted for asynchronous task processing, making it scalable and suitable for large-scale task handling in real-time systems.

---

## Mermaid Diagram of the Swarm Architecture

```mermaid
graph TD
    A[ForestSwarm] --> B[Financial Tree]
    A --> C[Investment Tree]
    
    B --> D[Stock Analysis Agent]
    B --> E[Financial Planning Agent]
    B --> F[Retirement Strategy Agent]
    
    C --> G[Tax Filing Agent]
    C --> H[Investment Strategy Agent]
    C --> I[ROTH IRA Agent]

    subgraph Tree Agents
        D[Stock Analysis Agent]
        E[Financial Planning Agent]
        F[Retirement Strategy Agent]
        G[Tax Filing Agent]
        H[Investment Strategy Agent]
        I[ROTH IRA Agent]
    end
```

### Explanation of the Diagram

- **ForestSwarm**: Represents the top-level structure managing multiple trees.
- **Trees**: In the example, two trees exist—**Financial Tree** and **Investment Tree**—each containing agents related to specific domains.
- **Agents**: Each agent within the tree is responsible for handling tasks in its area of expertise. Agents within a tree are organized based on their prompt similarity (distance).

---

### Summary

This **Multi-Agent Tree Structure** provides an efficient, scalable, and accurate architecture for delegating and executing tasks based on domain-specific expertise. The combination of hierarchical organization, dynamic task matching, and logging ensures reliability, performance, and transparency in task execution.

--------------------------------------------------

# File: swarms/structs/graph_workflow.md

# GraphWorkflow Documentation

The `GraphWorkflow` class is a pivotal part of the workflow management system, representing a directed graph where nodes signify tasks or agents and edges represent the flow or dependencies between these nodes. This class leverages the NetworkX library to manage and manipulate the directed graph, allowing users to create complex workflows with defined entry and end points.

### Attributes

| Attribute      | Type              | Description                                                                                   | Default                             |
|----------------|-------------------|-----------------------------------------------------------------------------------------------|-------------------------------------|
| `nodes`        | `Dict[str, Node]` | A dictionary of nodes in the graph, where the key is the node ID and the value is the Node object. | `Field(default_factory=dict)`       |
| `edges`        | `List[Edge]`      | A list of edges in the graph, where each edge is represented by an Edge object.               | `Field(default_factory=list)`       |
| `entry_points` | `List[str]`       | A list of node IDs that serve as entry points to the graph.                                   | `Field(default_factory=list)`       |
| `end_points`   | `List[str]`       | A list of node IDs that serve as end points of the graph.                                     | `Field(default_factory=list)`       |
| `graph`        | `nx.DiGraph`      | A directed graph object from the NetworkX library representing the workflow graph.            | `Field(default_factory=nx.DiGraph)` |
| `max_loops`    | `int`             | Maximum number of times the workflow can loop during execution.                               | `1`                                 |

### Methods

#### `add_node(node: Node)`

Adds a node to the workflow graph.

| Parameter | Type | Description                       |
|-----------|------|-----------------------------------|
| `node`    | `Node` | The node object to be added.    |

Raises:
- `ValueError`: If a node with the same ID already exists in the graph.

#### `add_edge(edge: Edge)`

Adds an edge to the workflow graph.

| Parameter | Type | Description                      |
|-----------|------|----------------------------------|
| `edge`    | `Edge` | The edge object to be added.   |

Raises:
- `ValueError`: If either the source or target node of the edge does not exist in the graph.

#### `set_entry_points(entry_points: List[str])`

Sets the entry points of the workflow graph.

| Parameter      | Type      | Description                                 |
|----------------|-----------|---------------------------------------------|
| `entry_points` | `List[str]` | A list of node IDs to be set as entry points. |

Raises:
- `ValueError`: If any of the specified node IDs do not exist in the graph.

#### `set_end_points(end_points: List[str])`

Sets the end points of the workflow graph.

| Parameter    | Type      | Description                               |
|--------------|-----------|-------------------------------------------|
| `end_points` | `List[str]` | A list of node IDs to be set as end points. |

Raises:
- `ValueError`: If any of the specified node IDs do not exist in the graph.

#### `visualize() -> str`

Generates a string representation of the workflow graph in the Mermaid syntax.

Returns:
- `str`: The Mermaid string representation of the workflow graph.

#### `run(task: str = None, *args, **kwargs) -> Dict[str, Any]`

Function to run the workflow graph.

| Parameter | Type  | Description                      |
|-----------|-------|----------------------------------|
| `task`    | `str` | The task to be executed by the workflow. |
| `*args`   |       | Variable length argument list.   |
| `**kwargs`|       | Arbitrary keyword arguments.     |

Returns:
- `Dict[str, Any]`: A dictionary containing the results of the execution.

Raises:
- `ValueError`: If no entry points or end points are defined in the graph.

## Functionality and Usage

### Adding Nodes

The `add_node` method is used to add nodes to the graph. Each node must have a unique ID. If a node with the same ID already exists, a `ValueError` is raised.

```python
wf_graph = GraphWorkflow()
node1 = Node(id="node1", type=NodeType.TASK, callable=sample_task)
wf_graph.add_node(node1)
```

### Adding Edges

The `add_edge` method connects nodes with edges. Both the source and target nodes of the edge must already exist in the graph, otherwise a `ValueError` is raised.

```python
edge1 = Edge(source="node1", target="node2")
wf_graph.add_edge(edge1)
```

### Setting Entry and End Points

The `set_entry_points` and `set_end_points` methods define which nodes are the starting and ending points of the workflow, respectively. If any specified node IDs do not exist, a `ValueError` is raised.

```python
wf_graph.set_entry_points(["node1"])
wf_graph.set_end_points(["node2"])
```

### Visualizing the Graph

The `visualize` method generates a Mermaid string representation of the workflow graph. This can be useful for visualizing the workflow structure.

```python
print(wf_graph.visualize())
```

### Running the Workflow

The `run` method executes the workflow. It performs a topological sort of the graph to ensure nodes are executed in the correct order. The results of each node's execution are returned in a dictionary.

```python
results = wf_graph.run()
print("Execution results:", results)
```

## Example Usage

Below is a comprehensive example demonstrating the creation and execution of a workflow graph:

```python

import os

from dotenv import load_dotenv


from swarms import Agent, Edge, GraphWorkflow, Node, NodeType

from swarm_models import OpenAIChat

load_dotenv()

api_key = os.environ.get("OPENAI_API_KEY")

llm = OpenAIChat(
    temperature=0.5, openai_api_key=api_key, max_tokens=4000
)
agent1 = Agent(llm=llm, max_loops=1, autosave=True, dashboard=True)
agent2 = Agent(llm=llm, max_loops=1, autosave=True, dashboard=True)

def sample_task():
    print("Running sample task")
    return "Task completed"

wf_graph = GraphWorkflow()
wf_graph.add_node(Node(id="agent1", type=NodeType.AGENT, agent=agent1))
wf_graph.add_node(Node(id="agent2", type=NodeType.AGENT, agent=agent2))
wf_graph.add_node(
    Node(id="task1", type=NodeType.TASK, callable=sample_task)
)
wf_graph.add_edge(Edge(source="agent1", target="task1"))
wf_graph.add_edge(Edge(source="agent2", target="task1"))

wf_graph.set_entry_points(["agent1", "agent2"])
wf_graph.set_end_points(["task1"])

print(wf_graph.visualize())

# Run the workflow
results = wf_graph.run()
print("Execution results:", results)

```

In this example, we set up a workflow graph with two agents and one task. We define the entry and end points, visualize the graph, and then execute the workflow, capturing and printing the results.

## Additional Information and Tips

- **Error Handling**: The `GraphWorkflow` class includes error handling to ensure that invalid operations (such as adding duplicate nodes or edges with non-existent nodes) raise appropriate exceptions.
- **Max Loops**: The `max_loops` attribute allows the workflow to loop through the graph multiple times if needed. This can be useful for iterative tasks.
- **Topological Sort**: The workflow execution relies on a topological sort to ensure that nodes are processed in the correct order. This is particularly important in complex workflows with dependencies.

## References and Resources

- [NetworkX Documentation](https://networkx.github.io/documentation/stable/)
- [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- [Mermaid Documentation](https://mermaid-js.github.io/mermaid/#/)

--------------------------------------------------

# File: swarms/structs/group_chat.md

# GroupChat Swarm Documentation

A production-grade multi-agent system enabling sophisticated group conversations between AI agents with customizable speaking patterns, parallel processing capabilities, and comprehensive conversation tracking.

## Advanced Configuration

### Agent Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| agent_name | str | Required | Unique identifier for the agent |
| system_prompt | str | Required | Role and behavior instructions |
| llm | Any | Required | Language model instance |
| max_loops | int | 1 | Maximum conversation turns |
| autosave | bool | False | Enable conversation saving |
| dashboard | bool | False | Enable monitoring dashboard |
| verbose | bool | True | Enable detailed logging |
| dynamic_temperature | bool | True | Enable dynamic temperature |
| retry_attempts | int | 1 | Failed request retry count |
| context_length | int | 200000 | Maximum context window |
| output_type | str | "string" | Response format type |
| streaming_on | bool | False | Enable streaming responses |

### GroupChat Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| name | str | "GroupChat" | Chat group identifier |
| description | str | "" | Purpose description |
| agents | List[Agent] | [] | Participating agents |
| speaker_fn | Callable | round_robin | Speaker selection function |
| max_loops | int | 10 | Maximum conversation turns |


## Table of Contents

- [Installation](#installation)
- [Core Concepts](#core-concepts)
- [Basic Usage](#basic-usage)
- [Advanced Configuration](#advanced-configuration)
- [Speaker Functions](#speaker-functions)
- [Response Models](#response-models)
- [Advanced Examples](#advanced-examples)
- [API Reference](#api-reference)
- [Best Practices](#best-practices)

## Installation

```bash
pip3 install swarms swarm-models loguru
```

## Core Concepts

The GroupChat system consists of several key components:

1. **Agents**: Individual AI agents with specialized knowledge and roles
2. **Speaker Functions**: Control mechanisms for conversation flow
3. **Chat History**: Structured conversation tracking
4. **Response Models**: Pydantic models for data validation

## Basic Usage

```python

import os
from dotenv import load_dotenv
from swarm_models import OpenAIChat
from swarms import Agent, GroupChat, expertise_based


if __name__ == "__main__":

    load_dotenv()

    # Get the OpenAI API key from the environment variable
    api_key = os.getenv("OPENAI_API_KEY")

    # Create an instance of the OpenAIChat class
    model = OpenAIChat(
        openai_api_key=api_key,
        model_name="gpt-4o-mini",
        temperature=0.1,
    )

    # Example agents
    agent1 = Agent(
        agent_name="Financial-Analysis-Agent",
        system_prompt="You are a financial analyst specializing in investment strategies.",
        llm=model,
        max_loops=1,
        autosave=False,
        dashboard=False,
        verbose=True,
        dynamic_temperature_enabled=True,
        user_name="swarms_corp",
        retry_attempts=1,
        context_length=200000,
        output_type="string",
        streaming_on=False,
    )

    agent2 = Agent(
        agent_name="Tax-Adviser-Agent",
        system_prompt="You are a tax adviser who provides clear and concise guidance on tax-related queries.",
        llm=model,
        max_loops=1,
        autosave=False,
        dashboard=False,
        verbose=True,
        dynamic_temperature_enabled=True,
        user_name="swarms_corp",
        retry_attempts=1,
        context_length=200000,
        output_type="string",
        streaming_on=False,
    )

    agents = [agent1, agent2]

    chat = GroupChat(
        name="Investment Advisory",
        description="Financial and tax analysis group",
        agents=agents,
        speaker_fn=expertise_based,
    )

    history = chat.run(
        "How to optimize tax strategy for investments?"
    )
    print(history.model_dump_json(indent=2))

```

## Speaker Functions


### Built-in Functions

```python
def round_robin(history: List[str], agent: Agent) -> bool:
    """
    Enables agents to speak in turns.
    Returns True for each agent in sequence.
    """
    return True

def expertise_based(history: List[str], agent: Agent) -> bool:
    """
    Enables agents to speak based on their expertise.
    Returns True if agent's role matches conversation context.
    """
    return agent.system_prompt.lower() in history[-1].lower() if history else True

def random_selection(history: List[str], agent: Agent) -> bool:
    """
    Randomly selects speaking agents.
    Returns True/False with 50% probability.
    """
    import random
    return random.choice([True, False])

def most_recent(history: List[str], agent: Agent) -> bool:
    """
    Enables agents to respond to their mentions.
    Returns True if agent was last speaker.
    """
    return agent.agent_name == history[-1].split(":")[0].strip() if history else True
```

### Custom Speaker Function Example

```python
def custom_speaker(history: List[str], agent: Agent) -> bool:
    """
    Custom speaker function with complex logic.
    
    Args:
        history: Previous conversation messages
        agent: Current agent being evaluated
        
    Returns:
        bool: Whether agent should speak
    """
    # No history - let everyone speak
    if not history:
        return True
        
    last_message = history[-1].lower()
    
    # Check for agent expertise keywords
    expertise_relevant = any(
        keyword in last_message 
        for keyword in agent.expertise_keywords
    )
    
    # Check for direct mentions
    mentioned = agent.agent_name.lower() in last_message
    
    # Check if agent hasn't spoken recently
    not_recent_speaker = not any(
        agent.agent_name in msg 
        for msg in history[-3:]
    )
    
    return expertise_relevant or mentioned or not_recent_speaker

# Usage
chat = GroupChat(
    agents=[agent1, agent2],
    speaker_fn=custom_speaker
)
```

## Response Models

### Complete Schema

```python
class AgentResponse(BaseModel):
    """Individual agent response in a conversation turn"""
    agent_name: str
    role: str
    message: str
    timestamp: datetime = Field(default_factory=datetime.now)
    turn_number: int
    preceding_context: List[str] = Field(default_factory=list)

class ChatTurn(BaseModel):
    """Single turn in the conversation"""
    turn_number: int
    responses: List[AgentResponse]
    task: str
    timestamp: datetime = Field(default_factory=datetime.now)

class ChatHistory(BaseModel):
    """Complete conversation history"""
    turns: List[ChatTurn]
    total_messages: int
    name: str
    description: str
    start_time: datetime = Field(default_factory=datetime.now)
```

## Advanced Examples

### Multi-Agent Analysis Team

```python
# Create specialized agents
data_analyst = Agent(
    agent_name="Data-Analyst",
    system_prompt="You analyze numerical data and patterns",
    llm=model
)

market_expert = Agent(
    agent_name="Market-Expert",
    system_prompt="You provide market insights and trends",
    llm=model
)

strategy_advisor = Agent(
    agent_name="Strategy-Advisor",
    system_prompt="You formulate strategic recommendations",
    llm=model
)

# Create analysis team
analysis_team = GroupChat(
    name="Market Analysis Team",
    description="Comprehensive market analysis group",
    agents=[data_analyst, market_expert, strategy_advisor],
    speaker_fn=expertise_based,
    max_loops=15
)

# Run complex analysis
history = analysis_team.run("""
    Analyze the current market conditions:
    1. Identify key trends
    2. Evaluate risks
    3. Recommend investment strategy
""")
```

### Parallel Processing

```python
# Define multiple analysis tasks
tasks = [
    "Analyze tech sector trends",
    "Evaluate real estate market",
    "Review commodity prices",
    "Assess global economic indicators"
]

# Run tasks concurrently
histories = chat.concurrent_run(tasks)

# Process results
for task, history in zip(tasks, histories):
    print(f"\nAnalysis for: {task}")
    for turn in history.turns:
        for response in turn.responses:
            print(f"{response.agent_name}: {response.message}")
```

## Best Practices

1. **Agent Design**
   - Give agents clear, specific roles
   - Use detailed system prompts
   - Set appropriate context lengths
   - Enable retries for reliability

2. **Speaker Functions**
   - Match function to use case
   - Consider conversation flow
   - Handle edge cases
   - Add appropriate logging

3. **Error Handling**
   - Use try-except blocks
   - Log errors appropriately
   - Implement retry logic
   - Provide fallback responses

4. **Performance**
   - Use concurrent processing for multiple tasks
   - Monitor context lengths
   - Implement proper cleanup
   - Cache responses when appropriate

## API Reference

### GroupChat Methods

| Method | Description | Arguments | Returns |
|--------|-------------|-----------|---------|
| run | Run single conversation | task: str | ChatHistory |
| batched_run | Run multiple sequential tasks | tasks: List[str] | List[ChatHistory] |
| concurrent_run | Run multiple parallel tasks | tasks: List[str] | List[ChatHistory] |
| get_recent_messages | Get recent messages | n: int = 3 | List[str] |

### Agent Methods

| Method | Description | Returns |
|--------|-------------|---------|
| run | Process single task | str |
| generate_response | Generate LLM response | str |
| save_context | Save conversation context | None |

--------------------------------------------------

# File: swarms/structs/hhcs.md

# Hybrid Hierarchical-Cluster Swarm [HHCS]

The Hybrid Hierarchical-Cluster Swarm (HHCS) is an advanced AI orchestration architecture that combines hierarchical decision-making with parallel processing capabilities. HHCS enables complex task solving by dynamically routing tasks to specialized agent swarms based on their expertise and capabilities.

## Purpose

HHCS addresses the challenge of efficiently solving diverse and complex tasks by:

- Intelligently routing tasks to the most appropriate specialized swarms

- Enabling parallel processing of multifaceted problems

- Maintaining a clear hierarchy for effective decision-making

- Combining outputs from multiple specialized agents for comprehensive solutions

## Key Features

- **Router-based task distribution**: Central router agent analyzes incoming tasks and directs them to appropriate specialized swarms

- **Hybrid architecture**: Combines hierarchical control with clustered specialization

- **Parallel processing**: Multiple swarms can work simultaneously on different aspects of complex tasks

- **Flexible swarm types**: Supports both sequential and concurrent workflows within swarms

- **Comprehensive result aggregation**: Collects and combines outputs from all contributing swarms


## Diagram

The HHCS architecture follows a hierarchical structure with the router agent at the top level, specialized swarms at the middle level, and individual agents at the bottom level.


```mermaid
flowchart TD
    Start([Task Input]) --> RouterAgent[Router Agent]
    RouterAgent --> Analysis{Task Analysis}
    
    Analysis -->|Analyze Requirements| Selection[Swarm Selection]
    Selection -->|Select Best Swarm| Route[Route Task]
    
    Route --> Swarm1[Swarm 1]
    Route --> Swarm2[Swarm 2]
    Route --> SwarmN[Swarm N...]
    
    Swarm1 -->|Process Task| Result1[Swarm 1 Output]
    Swarm2 -->|Process Task| Result2[Swarm 2 Output]
    SwarmN -->|Process Task| ResultN[Swarm N Output]
    
    Result1 --> Conversation[Conversation History]
    Result2 --> Conversation
    ResultN --> Conversation
    
    Conversation --> Output([Final Output])
    
    subgraph Router Decision Process
        Analysis
        Selection
    end
    
    subgraph Parallel Task Processing
        Swarm1
        Swarm2
        SwarmN
    end
    
    subgraph Results Collection
        Result1
        Result2
        ResultN
        Conversation
    end
```


## `HybridHierarchicalClusterSwarm` Constructor Arguments

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `name` | string | "Hybrid Hierarchical-Cluster Swarm" | The name of the swarm instance |
| `description` | string | "A swarm that uses a hybrid hierarchical-peer model to solve complex tasks." | Brief description of the swarm's functionality |
| `swarms` | List[SwarmRouter] | [] | List of available swarm routers |
| `max_loops` | integer | 1 | Maximum number of processing loops |
| `output_type` | string | "list" | Format for output (e.g., "list", "json") |
| `router_agent_model_name` | string | "gpt-4o-mini" | LLM model used by the router agent |

## Methods

| Method | Parameters | Return Type | Description |
|--------|------------|-------------|-------------|
| `run` | `task` (str) | str | Processes a single task through the swarm system |
| `batched_run` | `tasks` (List[str]) | List[str] | Processes multiple tasks in parallel |
| `find_swarm_by_name` | `swarm_name` (str) | SwarmRouter | Retrieves a swarm by its name |
| `route_task` | `swarm_name` (str), `task_description` (str) | None | Routes a task to a specific swarm |
| `get_swarms_info` | None | str | Returns formatted information about all available swarms |


## Full Example

```python

from swarms import Agent, SwarmRouter
from swarms.structs.hybrid_hiearchical_peer_swarm import (
    HybridHierarchicalClusterSwarm,
)


# Core Legal Agent Definitions with short, simple prompts
litigation_agent = Agent(
    agent_name="Litigator",
    system_prompt="You handle lawsuits. Analyze facts, build arguments, and develop case strategy.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

corporate_agent = Agent(
    agent_name="Corporate-Attorney",
    system_prompt="You handle business law. Advise on corporate structure, governance, and transactions.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

ip_agent = Agent(
    agent_name="IP-Attorney",
    system_prompt="You protect intellectual property. Handle patents, trademarks, copyrights, and trade secrets.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

employment_agent = Agent(
    agent_name="Employment-Attorney",
    system_prompt="You handle workplace matters. Address hiring, termination, discrimination, and labor issues.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

paralegal_agent = Agent(
    agent_name="Paralegal",
    system_prompt="You assist attorneys. Conduct research, draft documents, and organize case files.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

doc_review_agent = Agent(
    agent_name="Document-Reviewer",
    system_prompt="You examine documents. Extract key information and identify relevant content.",
    model_name="groq/deepseek-r1-distill-qwen-32b",
    max_loops=1,
)

# Practice Area Swarm Routers
litigation_swarm = SwarmRouter(
    name="litigation-practice",
    description="Handle all aspects of litigation",
    agents=[litigation_agent, paralegal_agent, doc_review_agent],
    swarm_type="SequentialWorkflow",
)

corporate_swarm = SwarmRouter(
    name="corporate-practice",
    description="Handle business and corporate legal matters",
    agents=[corporate_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

ip_swarm = SwarmRouter(
    name="ip-practice",
    description="Handle intellectual property matters",
    agents=[ip_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

employment_swarm = SwarmRouter(
    name="employment-practice",
    description="Handle employment and labor law matters",
    agents=[employment_agent, paralegal_agent],
    swarm_type="SequentialWorkflow",
)

# Cross-functional Swarm Router
m_and_a_swarm = SwarmRouter(
    name="mergers-acquisitions",
    description="Handle mergers and acquisitions",
    agents=[
        corporate_agent,
        ip_agent,
        employment_agent,
        doc_review_agent,
    ],
    swarm_type="ConcurrentWorkflow",
)

dispute_swarm = SwarmRouter(
    name="dispute-resolution",
    description="Handle complex disputes requiring multiple specialties",
    agents=[litigation_agent, corporate_agent, doc_review_agent],
    swarm_type="ConcurrentWorkflow",
)


hybrid_hiearchical_swarm = HybridHierarchicalClusterSwarm(
    name="hybrid-hiearchical-swarm",
    description="A hybrid hiearchical swarm that uses a hybrid hiearchical peer model to solve complex tasks.",
    swarms=[
        litigation_swarm,
        corporate_swarm,
        ip_swarm,
        employment_swarm,
        m_and_a_swarm,
        dispute_swarm,
    ],
    max_loops=1,
    router_agent_model_name="gpt-4o-mini",
)


if __name__ == "__main__":
    hybrid_hiearchical_swarm.run(
        "What is the best way to file for a patent? for ai technology "
    )

```

--------------------------------------------------

# File: swarms/structs/index.md

# Enterprise-Grade and Production Ready Agents

Swarms is an enterprise grade and production ready multi-agent collaboration framework that enables you to orchestrate many agents to work collaboratively at scale to automate real-world activities.

| **Feature**                  | **Description**                                                                                                                                                       | **Performance Impact** | **Documentation Link**        |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|-------------------------------|
| Models                       | Pre-trained models that can be utilized for various tasks within the swarm framework.                                                                                  | ⭐⭐⭐                    | [Documentation](https://docs.swarms.world/en/latest/swarms/models/)            |
| Models APIs                  | APIs to interact with and utilize the models effectively, providing interfaces for inference, training, and fine-tuning.                                               | ⭐⭐⭐                    | [Documentation](https://docs.swarms.world/en/latest/swarms/models/)            |
| Agents with Tools            | Agents equipped with specialized tools to perform specific tasks more efficiently, such as data processing, analysis, or interaction with external systems.            | ⭐⭐⭐⭐                   | [Documentation](https://medium.com/@kyeg/the-swarms-tool-system-functions-pydantic-basemodels-as-tools-and-radical-customization-c2a2e227b8ca)            |
| Agents with Memory                       | Mechanisms for agents to store and recall past interactions, improving learning and adaptability over time.                                                            | ⭐⭐⭐⭐                   | [Documentation](https://github.com/kyegomez/swarms/blob/master/examples/structs/agent/agent_with_longterm_memory.py)            |
| Multi-Agent Orchestration    | Coordination of multiple agents to work together seamlessly on complex tasks, leveraging their individual strengths to achieve higher overall performance.              | ⭐⭐⭐⭐⭐                  | [Documentation]()            |

The performance impact is rated on a scale from one to five stars, with multi-agent orchestration being the highest due to its ability to combine the strengths of multiple agents and optimize task execution.

----

## Install 💻
`$ pip3 install -U swarms`

---

# Usage Examples 🤖

### Google Collab Example
Run example in Collab: <a target="_blank" href="https://colab.research.google.com/github/kyegomez/swarms/blob/master/examples/collab/swarms_example.ipynb">
<img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/>
</a>

---

## `Agents`
A fully plug-and-play autonomous agent powered by an LLM extended by a long-term memory database, and equipped with function calling for tool usage! By passing in an LLM, you can create a fully autonomous agent with extreme customization and reliability, ready for real-world task automation!

Features:

✅ Any LLM / Any framework

✅ Extremely customize-able with max loops, autosaving, import docs (PDFS, TXT, CSVs, etc), tool usage, etc etc

✅ Long term memory database with RAG (ChromaDB, Pinecone, Qdrant)

```python
import os

from dotenv import load_dotenv

# Import the OpenAIChat model and the Agent struct
from swarms import Agent
from swarm_models import OpenAIChat

# Load the environment variables
load_dotenv()

# Get the API key from the environment
api_key = os.environ.get("OPENAI_API_KEY")

# Initialize the language model
llm = OpenAIChat(
    temperature=0.5, model_name="gpt-4", openai_api_key=api_key, max_tokens=4000
)


## Initialize the workflow
agent = Agent(llm=llm, max_loops=1, autosave=True, dashboard=True)

# Run the workflow on a task
agent.run("Generate a 10,000 word blog on health and wellness.")
```


### `Agent` + Long Term Memory
`Agent` equipped with quasi-infinite long term memory. Great for long document understanding, analysis, and retrieval.

```python
from swarms import Agent
from swarm_models import OpenAIChat
from swarms_memory import ChromaDB # Copy and paste the code and put it in your own local directory.

# Making an instance of the ChromaDB class
memory = ChromaDB(
    metric="cosine",
    n_results=3,
    output_dir="results",
    docs_folder="docs",
)

# Initializing the agent with the Gemini instance and other parameters
agent = Agent(
    agent_name="Covid-19-Chat",
    agent_description=(
        "This agent provides information about COVID-19 symptoms."
    ),
    llm=OpenAIChat(),
    max_loops="auto",
    autosave=True,
    verbose=True,
    long_term_memory=memory,
    stopping_condition="finish",
)

# Defining the task and image path
task = ("What are the symptoms of COVID-19?",)

# Running the agent with the specified task and image
out = agent.run(task)
print(out)

```


### `Agent` ++ Long Term Memory ++ Tools!
An LLM equipped with long term memory and tools, a full stack agent capable of automating all and any digital tasks given a good prompt.

```python
from swarms import Agent, ChromaDB, OpenAIChat

# Making an instance of the ChromaDB class
memory = ChromaDB(
    metric="cosine",
    n_results=3,
    output_dir="results",
    docs_folder="docs",
)

# Initialize a tool
def search_api(query: str):
    # Add your logic here
    return query

# Initializing the agent with the Gemini instance and other parameters
agent = Agent(
    agent_name="Covid-19-Chat",
    agent_description=(
        "This agent provides information about COVID-19 symptoms."
    ),
    llm=OpenAIChat(),
    max_loops="auto",
    autosave=True,
    verbose=True,
    long_term_memory=memory,
    stopping_condition="finish",
    tools=[search_api],
)

# Defining the task and image path
task = ("What are the symptoms of COVID-19?",)

# Running the agent with the specified task and image
out = agent.run(task)
print(out)

```


### Devin
Implementation of Devin in less than 90 lines of code with several tools:
terminal, browser, and edit files.

```python
from swarms import Agent
from swarm_models import Anthropic
import subprocess

# Model
llm = Anthropic(
    temperature=0.1,
)

# Tools
def terminal(
    code: str,
):
    """
    Run code in the terminal.

    Args:
        code (str): The code to run in the terminal.

    Returns:
        str: The output of the code.
    """
    out = subprocess.run(
        code, shell=True, capture_output=True, text=True
    ).stdout
    return str(out)

def browser(query: str):
    """
    Search the query in the browser with the `browser` tool.

    Args:
        query (str): The query to search in the browser.

    Returns:
        str: The search results.
    """
    import webbrowser

    url = f"https://www.google.com/search?q={query}"
    webbrowser.open(url)
    return f"Searching for {query} in the browser."

def create_file(file_path: str, content: str):
    """
    Create a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file creation operation.
    """
    with open(file_path, "w") as file:
        file.write(content)
    return f"File {file_path} created successfully."

def file_editor(file_path: str, mode: str, content: str):
    """
    Edit a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        mode (str): The mode to open the file in.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file editing operation.
    """
    with open(file_path, mode) as file:
        file.write(content)
    return f"File {file_path} edited successfully."


# Agent
agent = Agent(
    agent_name="Devin",
    system_prompt=(
        "Autonomous agent that can interact with humans and other"
        " agents. Be Helpful and Kind. Use the tools provided to"
        " assist the user. Return all code in markdown format."
    ),
    llm=llm,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    interactive=True,
    tools=[terminal, browser, file_editor, create_file],
    code_interpreter=True,
    # streaming=True,
)

# Run the agent
out = agent("Create a new file for a plan to take over the world.")
print(out)
```


### `Agent`with Pydantic BaseModel as Output Type
The following is an example of an agent that intakes a pydantic basemodel and outputs it at the same time:

```python
from pydantic import BaseModel, Field
from swarms import Agent
from swarm_models import Anthropic


# Initialize the schema for the person's information
class Schema(BaseModel):
    name: str = Field(..., title="Name of the person")
    agent: int = Field(..., title="Age of the person")
    is_student: bool = Field(..., title="Whether the person is a student")
    courses: list[str] = Field(
        ..., title="List of courses the person is taking"
    )


# Convert the schema to a JSON string
tool_schema = Schema(
    name="Tool Name",
    agent=1,
    is_student=True,
    courses=["Course1", "Course2"],
)

# Define the task to generate a person's information
task = "Generate a person's information based on the following schema:"

# Initialize the agent
agent = Agent(
    agent_name="Person Information Generator",
    system_prompt=(
        "Generate a person's information based on the following schema:"
    ),
    # Set the tool schema to the JSON string -- this is the key difference
    tool_schema=tool_schema,
    llm=Anthropic(),
    max_loops=3,
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    interactive=True,
    # Set the output type to the tool schema which is a BaseModel
    output_type=tool_schema,  # or dict, or str
    metadata_output_type="json",
    # List of schemas that the agent can handle
    list_base_models=[tool_schema],
    function_calling_format_type="OpenAI",
    function_calling_type="json",  # or soon yaml
)

# Run the agent to generate the person's information
generated_data = agent.run(task)

# Print the generated data
print(f"Generated data: {generated_data}")


```

### Multi Modal Autonomous Agent
Run the agent with multiple modalities useful for various real-world tasks in manufacturing, logistics, and health.

```python
# Description: This is an example of how to use the Agent class to run a multi-modal workflow
import os

from dotenv import load_dotenv

from swarm_models.gpt4_vision_api import GPT4VisionAPI
from swarms.structs import Agent

# Load the environment variables
load_dotenv()

# Get the API key from the environment
api_key = os.environ.get("OPENAI_API_KEY")

# Initialize the language model
llm = GPT4VisionAPI(
    openai_api_key=api_key,
    max_tokens=500,
)

# Initialize the task
task = (
    "Analyze this image of an assembly line and identify any issues such as"
    " misaligned parts, defects, or deviations from the standard assembly"
    " process. IF there is anything unsafe in the image, explain why it is"
    " unsafe and how it could be improved."
)
img = "assembly_line.jpg"

## Initialize the workflow
agent = Agent(
    llm=llm, max_loops="auto", autosave=True, dashboard=True, multi_modal=True
)

# Run the workflow on a task
agent.run(task=task, img=img)
```
----



--------------------------------------------------

# File: swarms/structs/majorityvoting.md

# MajorityVoting Module Documentation

The `MajorityVoting` module provides a mechanism for performing majority voting among a group of agents. Majority voting is a decision rule that selects the option which has the majority of votes. This is particularly useful in systems where multiple agents provide responses to a query, and the most common response needs to be identified as the final output.

## Architecture

```mermaid
graph TD
    A[MajorityVoting System] --> B[Initialize Agents]
    B --> C[Process Task]
    C --> D{Execution Mode}
    D --> E[Single Task]
    D --> F[Batch Tasks]
    D --> G[Concurrent Tasks]
    D --> H[Async Tasks]
    E --> I[Run Agents]
    F --> I
    G --> I
    H --> I
    I --> J[Collect Responses]
    J --> K[Consensus Analysis]
    K --> L{Consensus Agent?}
    L -->|Yes| M[Use Consensus Agent]
    L -->|No| N[Use Last Agent]
    M --> O[Final Output]
    N --> O
    O --> P[Save Conversation]
```

### Key Concepts

- **Majority Voting**: A method to determine the most common response from a set of answers.
- **Agents**: Entities (e.g., models, algorithms) that provide responses to tasks or queries.
- **Output Parser**: A function that processes the responses from the agents before performing the majority voting.
- **Consensus Agent**: An optional agent that analyzes the responses from all agents to determine the final consensus.
- **Conversation History**: A record of all agent interactions and responses during the voting process.

## Class Definition: `MajorityVoting`

### Parameters

| Parameter         | Type           | Description                                                                 |
|------------------|----------------|-----------------------------------------------------------------------------|
| `name`           | `str`          | Name of the majority voting system. Default is "MajorityVoting".            |
| `description`    | `str`          | Description of the system. Default is "A majority voting system for agents". |
| `agents`         | `List[Agent]`  | A list of agents to be used in the majority voting system.                  |
| `output_parser`  | `Callable`     | Function to parse agent outputs. Default is `majority_voting` function.      |
| `consensus_agent`| `Agent`        | Optional agent for analyzing consensus among responses.                      |
| `autosave`       | `bool`         | Whether to autosave conversations. Default is `False`.                      |
| `verbose`        | `bool`         | Whether to enable verbose logging. Default is `False`.                      |
| `max_loops`      | `int`          | Maximum number of voting loops. Default is 1.                               |

### Methods

#### `run(task: str, correct_answer: str, *args, **kwargs) -> List[Any]`

Runs the majority voting system for a single task.

**Parameters:**
- `task` (str): The task to be performed by the agents
- `correct_answer` (str): The correct answer for evaluation
- `*args`, `**kwargs`: Additional arguments

**Returns:**
- List[Any]: The conversation history as a string, including the majority vote

#### `batch_run(tasks: List[str], *args, **kwargs) -> List[Any]`

Runs multiple tasks in sequence.

**Parameters:**
- `tasks` (List[str]): List of tasks to be performed
- `*args`, `**kwargs`: Additional arguments

**Returns:**
- List[Any]: List of majority votes for each task

#### `run_concurrently(tasks: List[str], *args, **kwargs) -> List[Any]`

Runs multiple tasks concurrently using thread pooling.

**Parameters:**
- `tasks` (List[str]): List of tasks to be performed
- `*args`, `**kwargs`: Additional arguments

**Returns:**
- List[Any]: List of majority votes for each task

#### `run_async(tasks: List[str], *args, **kwargs) -> List[Any]`

Runs multiple tasks asynchronously using asyncio.

**Parameters:**
- `tasks` (List[str]): List of tasks to be performed
- `*args`, `**kwargs`: Additional arguments

**Returns:**
- List[Any]: List of majority votes for each task

## Usage Examples

### Example 1: Basic Single Task Execution with Modern LLMs

```python
from swarms import Agent, MajorityVoting

# Initialize multiple agents with different specialties
agents = [
    Agent(
        agent_name="Financial-Analysis-Agent",
        agent_description="Personal finance advisor focused on market analysis",
        system_prompt="You are a financial advisor specializing in market analysis and investment opportunities.",
        max_loops=1,
        model_name="gpt-4o"
    ),
    Agent(
        agent_name="Risk-Assessment-Agent", 
        agent_description="Risk analysis and portfolio management expert",
        system_prompt="You are a risk assessment expert focused on evaluating investment risks and portfolio diversification.",
        max_loops=1,
        model_name="gpt-4o"
    ),
    Agent(
        agent_name="Tech-Investment-Agent",
        agent_description="Technology sector investment specialist",
        system_prompt="You are a technology investment specialist focused on AI, emerging tech, and growth opportunities.",
        max_loops=1,
        model_name="gpt-4o"
    )
]


consensus_agent = Agent(
    agent_name="Consensus-Agent",
    agent_description="Consensus agent focused on analyzing investment advice",
    system_prompt="You are a consensus agent focused on analyzing investment advice and providing a final answer.",
    max_loops=1,
    model_name="gpt-4o"
)

# Create majority voting system
majority_voting = MajorityVoting(
    name="Investment-Advisory-System",
    description="Multi-agent system for investment advice",
    agents=agents,
    verbose=True,
    consensus_agent=consensus_agent
)

# Run the analysis with majority voting
result = majority_voting.run(
    task="Create a table of super high growth opportunities for AI. I have $40k to invest in ETFs, index funds, and more. Please create a table in markdown.",
    correct_answer=""  # Optional evaluation metric
)

print(result)

```

## Batch Execution

```python
from swarms import Agent, MajorityVoting

# Initialize multiple agents with different specialties
agents = [
    Agent(
        agent_name="Financial-Analysis-Agent",
        agent_description="Personal finance advisor focused on market analysis",
        system_prompt="You are a financial advisor specializing in market analysis and investment opportunities.",
        max_loops=1,
        model_name="gpt-4o"
    ),
    Agent(
        agent_name="Risk-Assessment-Agent", 
        agent_description="Risk analysis and portfolio management expert",
        system_prompt="You are a risk assessment expert focused on evaluating investment risks and portfolio diversification.",
        max_loops=1,
        model_name="gpt-4o"
    ),
    Agent(
        agent_name="Tech-Investment-Agent",
        agent_description="Technology sector investment specialist",
        system_prompt="You are a technology investment specialist focused on AI, emerging tech, and growth opportunities.",
        max_loops=1,
        model_name="gpt-4o"
    )
]


consensus_agent = Agent(
    agent_name="Consensus-Agent",
    agent_description="Consensus agent focused on analyzing investment advice",
    system_prompt="You are a consensus agent focused on analyzing investment advice and providing a final answer.",
    max_loops=1,
    model_name="gpt-4o"
)

# Create majority voting system
majority_voting = MajorityVoting(
    name="Investment-Advisory-System",
    description="Multi-agent system for investment advice",
    agents=agents,
    verbose=True,
    consensus_agent=consensus_agent
)

# Run the analysis with majority voting
result = majority_voting.batch_run(
    task="Create a table of super high growth opportunities for AI. I have $40k to invest in ETFs, index funds, and more. Please create a table in markdown.",
    correct_answer=""  # Optional evaluation metric
)

print(result)


```

--------------------------------------------------

# File: swarms/structs/malt.md

# MALT: Multi-Agent Learning Task Framework

## Overview

MALT (Multi-Agent Learning Task) is a sophisticated orchestration framework that coordinates multiple specialized AI agents to tackle complex tasks through structured conversations. Inspired by the principles outlined in the [MALT research paper](https://arxiv.org/pdf/2412.01928), this implementation provides a reliable, extensible system for multi-agent collaboration.

The framework is designed around a three-agent architecture:

1. **Creator Agent**: Generates initial content or solutions

2. **Verifier Agent**: Critically evaluates the creator's output

3. **Refiner Agent**: Improves the solution based on verifier feedback

This collaborative approach enables high-quality outputs for complex tasks by combining the strengths of multiple specialized agents, each focused on a different aspect of the problem-solving process.

## How It Works

The MALT framework follows a structured workflow:

1. A task is submitted to the system
2. The Creator Agent generates an initial solution
3. Multiple instances of the Verifier Agent independently evaluate the solution
4. Multiple instances of the Refiner Agent improve the solution based on verification feedback
5. The final refined output is returned

This process can be configured to run for multiple iterations, with each cycle potentially improving the quality of the output. The system maintains a conversation history, tracking interactions between agents throughout the workflow.

### Key Components

- **Agent**: Represents an individual AI agent with specific capabilities and responsibilities
- **Conversation**: Manages the interaction history between agents
- **MALT Orchestrator**: Coordinates the workflow and manages agent interactions
- **Concurrency Support**: Enables parallel execution of multiple agent instances

## Architecture Diagram

```mermaid
flowchart TD
    User[User/Client] -->|Submit Task| MALT[MALT Orchestrator]
    
    subgraph MALT Framework
        MALT -->|Task| Creator[Creator Agent]
        Creator -->|Initial Solution| Conversation[Conversation Manager]
        Conversation -->|Solution| VerifierPool[Verifier Agents Pool]
        
        subgraph VerifierPool
            Verifier1[Verifier Agent 1]
            Verifier2[Verifier Agent 2]
            Verifier3[Verifier Agent 3]
        end
        
        VerifierPool -->|Verification Feedback| Conversation
        Conversation -->|Solution + Feedback| RefinerPool[Refiner Agents Pool]
        
        subgraph RefinerPool
            Refiner1[Refiner Agent 1]
            Refiner2[Refiner Agent 2]
            Refiner3[Refiner Agent 3]
        end
        
        RefinerPool -->|Refined Solutions| Conversation
    end
    
    Conversation -->|Final Output| User
```

## Execution Workflow

```mermaid
sequenceDiagram
    participant User
    participant MALT
    participant Creator
    participant Verifiers
    participant Refiners
    participant Conversation
    
    User->>MALT: Submit task
    MALT->>Creator: Process task
    Creator->>Conversation: Add initial solution
    
    par Verification Phase
        Conversation->>Verifiers: Send solution for verification
        Verifiers->>Conversation: Return verification feedback
    end
    
    par Refinement Phase
        Conversation->>Refiners: Send solution + feedback
        Refiners->>Conversation: Return refined solutions
    end
    
    MALT->>Conversation: Request final output
    Conversation->>MALT: Return conversation history
    MALT->>User: Return final result
```

## API Reference

### MALT Class

The core orchestrator that manages the multi-agent interaction process.

#### Constructor Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `main_agent` | `Agent` | `None` | The primary agent (Creator) responsible for generating initial solutions |
| `refiner_agent` | `Agent` | `None` | The agent that refines solutions based on verification feedback |
| `verifier_agent` | `Agent` | `None` | The agent that verifies and evaluates solutions |
| `max_loops` | `int` | `1` | Maximum number of iterations for the task execution |
| `return_list` | `bool` | `False` | Flag to return output as a list |
| `return_dict` | `bool` | `False` | Flag to return output as a dictionary |
| `agents` | `list[Agent]` | `[]` | Alternative list of agents to use in the task |
| `preset_agents` | `bool` | `True` | Use default preset agents for mathematical proofs |

#### Methods

| Method | Parameters | Return Type | Description |
|--------|------------|-------------|-------------|
| `reliability_check` | None | None | Validates agent configuration and parameters |
| `step` | `task: str, img: str = None, *args, **kwargs` | `str` or `list` or `dict` | Executes a single iteration of the MALT workflow |
| `run` | `task: str, img: str = None, *args, **kwargs` | `str` or `list` or `dict` | Executes the complete MALT workflow for a task |
| `run_batched` | `tasks: List[str], *args, **kwargs` | `List[str]` or `List[list]` or `List[dict]` | Sequentially processes multiple tasks |
| `run_concurrently` | `tasks: List[str], *args, **kwargs` | `concurrent.futures.Future` | Processes multiple tasks in parallel using ThreadPoolExecutor |
| `__call__` | `task: str, *args, **kwargs` | Same as `run` | Allows the MALT instance to be called as a function |
| `__str__` | None | `str` | Returns the conversation history as a string |
| `__repr__` | None | `str` | Returns the conversation history as a string |


## Sample Implementations

### Default Mathematical Proof Agents

The MALT framework includes preset agents specialized for mathematical proof generation and refinement:

1. **Proof Creator Agent**: Generates original mathematical theorems and proofs
2. **Proof Verifier Agent**: Critically evaluates and identifies issues in mathematical proofs
3. **Proof Refiner Agent**: Improves proofs based on verification feedback

Each agent has a carefully designed system prompt that guides its behavior and specialization.

## Usage Examples

### Basic Usage

```python
from swarms.structs.agent import Agent
from swarms.structs.multi_agent_exec import MALT

# Initialize with preset mathematical proof agents
malt = MALT(preset_agents=True)

# Run a mathematical proof task
result = malt.run("Develop a theorem and proof related to prime numbers and their distribution.")

print(result)
```

### Custom Agents

```python
from swarms.structs.agent import Agent
from swarms.structs.multi_agent_exec import MALT

# Define custom agents
creator = Agent(
    agent_name="Physics-Creator",
    model_name="gpt-4o-mini",
    max_loops=1,
    system_prompt="You are a theoretical physicist specializing in quantum mechanics..."
)

verifier = Agent(
    agent_name="Physics-Verifier",
    model_name="gpt-4o-mini",
    max_loops=1,
    system_prompt="You are an experimental physicist who verifies theoretical claims..."
)

refiner = Agent(
    agent_name="Physics-Communicator",
    model_name="gpt-4o-mini",
    max_loops=1,
    system_prompt="You excel at explaining complex physics concepts to diverse audiences..."
)

# Initialize MALT with custom agents
malt = MALT(
    main_agent=creator,
    verifier_agent=verifier,
    refiner_agent=refiner,
    preset_agents=False,
    max_loops=1
)

# Run a physics explanation task
result = malt.run("Explain the quantum entanglement phenomenon and its implications.")
```

### Concurrent Processing

```python
from swarms.structs.multi_agent_exec import MALT

# Initialize MALT
malt = MALT()

# Define multiple tasks
tasks = [
    "Prove a theorem related to continuous functions on compact sets.",
    "Develop a theorem about convergence in infinite-dimensional Hilbert spaces.",
    "Create a theorem relating to measure theory and Lebesgue integration."
]

# Process tasks concurrently
futures = malt.run_concurrently(tasks)

# Collect results as they complete
for future in futures:
    result = future.result()
    print(result)
```

## Example: Complex Mathematical Domain

Here's an example of how MALT can generate, verify, and refine a mathematical proof:

### Input

```python
malt = MALT(preset_agents=True)
task = "Develop a theorem and rigorous proof related to the convergence properties of infinite series."
result = malt.run(task)
```

### Output Flow

1. **Creator Agent** generates a theorem and proof about conditions for absolute convergence
2. **Verifier Agents** identify issues:
   - Logical gap in lemma 2
   - Missing justification for uniform convergence claim
   - Imprecise definition of certain terms
3. **Refiner Agents** produce improved versions addressing these concerns
4. The final output contains the refined, rigorous mathematical proof

## Best Practices

1. **Task Specificity**: Provide clear, detailed task descriptions for optimal results
2. **Agent Specialization**: Design agent prompts to focus on specific aspects of the task
3. **Iteration Control**: Adjust `max_loops` based on task complexity
4. **Concurrent Verification**: Use multiple verifier instances for comprehensive evaluation
5. **Custom Agents**: Create domain-specific agents for specialized tasks

## Potential Improvements

- Autonomously create specialized agents based on task requirements
- Implement feedback loops between agents for iterative improvement
- Add support for agent-specific memory and knowledge bases
- Expand concurrency capabilities for improved performance
- Implement learning mechanisms for agent improvement over time

## References

- Original MALT paper: [arXiv:2412.01928](https://arxiv.org/pdf/2412.01928)
- Built on the swarms framework for multi-agent systems

--------------------------------------------------

# File: swarms/structs/matrix_swarm.md

# MatrixSwarm

The `MatrixSwarm` class provides a framework for managing and operating on matrices of AI agents, enabling matrix-like operations similar to linear algebra. This allows for complex agent interactions and parallel processing capabilities.

## Overview

`MatrixSwarm` treats AI agents as elements in a matrix, allowing for operations like addition, multiplication, and transposition. This approach enables sophisticated agent orchestration and parallel processing patterns.

## Installation

```bash
pip3 install -U swarms
```

## Basic Usage

```python
from swarms import Agent
from swarms.matrix import MatrixSwarm

# Create a 2x2 matrix of agents
agents = [
    [Agent(agent_name="Agent-0-0"), Agent(agent_name="Agent-0-1")],
    [Agent(agent_name="Agent-1-0"), Agent(agent_name="Agent-1-1")]
]

# Initialize the matrix
matrix = MatrixSwarm(agents)
```

## Class Constructor

```python
def __init__(self, agents: List[List[Agent]])
```

### Parameters
- `agents` (`List[List[Agent]]`): A 2D list of Agent instances representing the matrix.

### Raises
- `ValueError`: If the input is not a valid 2D list of Agent instances.

## Methods

### transpose()

Transposes the matrix of agents by swapping rows and columns.

```python
def transpose(self) -> MatrixSwarm
```

#### Returns
- `MatrixSwarm`: A new MatrixSwarm instance with transposed dimensions.

---

### add(other)

Performs element-wise addition of two agent matrices.

```python
def add(self, other: MatrixSwarm) -> MatrixSwarm
```

#### Parameters
- `other` (`MatrixSwarm`): Another MatrixSwarm instance to add.

#### Returns
- `MatrixSwarm`: A new MatrixSwarm resulting from the addition.

#### Raises
- `ValueError`: If matrix dimensions are incompatible.

---

### scalar_multiply(scalar)

Scales the matrix by duplicating agents along rows.

```python
def scalar_multiply(self, scalar: int) -> MatrixSwarm
```

#### Parameters
- `scalar` (`int`): The multiplication factor.

#### Returns
- `MatrixSwarm`: A new MatrixSwarm with scaled dimensions.

---

### multiply(other, inputs)

Performs matrix multiplication (dot product) between two agent matrices.

```python
def multiply(self, other: MatrixSwarm, inputs: List[str]) -> List[List[AgentOutput]]
```

#### Parameters
- `other` (`MatrixSwarm`): The second MatrixSwarm for multiplication.
- `inputs` (`List[str]`): Input queries for the agents.

#### Returns
- `List[List[AgentOutput]]`: Matrix of operation results.

#### Raises
- `ValueError`: If matrix dimensions are incompatible for multiplication.

---

### subtract(other)

Performs element-wise subtraction of two agent matrices.

```python
def subtract(self, other: MatrixSwarm) -> MatrixSwarm
```

#### Parameters
- `other` (`MatrixSwarm`): Another MatrixSwarm to subtract.

#### Returns
- `MatrixSwarm`: A new MatrixSwarm resulting from the subtraction.

---

### identity(size)

Creates an identity matrix of agents.

```python
def identity(self, size: int) -> MatrixSwarm
```

#### Parameters
- `size` (`int`): Size of the identity matrix (NxN).

#### Returns
- `MatrixSwarm`: An identity MatrixSwarm.

---

### determinant()

Computes the determinant of a square agent matrix.

```python
def determinant(self) -> Any
```

#### Returns
- `Any`: The determinant result.

#### Raises
- `ValueError`: If the matrix is not square.

---

### save_to_file(path)

Saves the matrix structure and metadata to a JSON file.

```python
def save_to_file(self, path: str) -> None
```

#### Parameters
- `path` (`str`): File path for saving the matrix data.

## Extended Example

Here's a comprehensive example demonstrating various MatrixSwarm operations:

```python
from swarms import Agent
from swarms.matrix import MatrixSwarm

# Create agents with specific configurations
agents = [
    [
        Agent(
            agent_name=f"Agent-{i}-{j}",
            system_prompt="Your system prompt here",
            model_name="gpt-4",
            max_loops=1,
            verbose=True
        ) for j in range(2)
    ] for i in range(2)
]

# Initialize matrix
matrix = MatrixSwarm(agents)

# Example operations
transposed = matrix.transpose()
scaled = matrix.scalar_multiply(2)

# Run operations with inputs
inputs = ["Query 1", "Query 2"]
results = matrix.multiply(transposed, inputs)

# Save results
matrix.save_to_file("matrix_results.json")
```

## Output Schema

The `AgentOutput` class defines the structure for operation results:

```python
class AgentOutput(BaseModel):
    agent_name: str
    input_query: str
    output_result: Any
    metadata: dict
```

## Best Practices

1. **Initialization**
   - Ensure all agents in the matrix are properly configured before initialization
   - Validate matrix dimensions for your use case

2. **Operation Performance**
   - Consider computational costs for large matrices
   - Use appropriate batch sizes for inputs

3. **Error Handling**
   - Implement proper error handling for agent operations
   - Validate inputs before matrix operations

4. **Resource Management**
   - Monitor agent resource usage in large matrices
   - Implement proper cleanup procedures

## Limitations

- Matrix operations are constrained by the underlying agent capabilities
- Performance may vary based on agent configuration and complexity
- Resource usage scales with matrix dimensions

## See Also

- [Swarms Documentation](https://github.com/kyegomez/swarms)
- [Agent Class Reference](https://github.com/kyegomez/swarms/tree/main/swarms)

--------------------------------------------------

# File: swarms/structs/moa.md

# MixtureOfAgents Class Documentation

## Architecture Overview

```mermaid
graph TD
    A[Input Task] --> B[Initialize MixtureOfAgents]
    B --> C[Reliability Check]
    C --> D[Layer 1: Parallel Agent Execution]
    D --> E[Layer 2: Sequential Processing]
    E --> F[Layer 3: Parallel Agent Execution]
    F --> G[Final Aggregator Agent]
    G --> H[Output Response]
    
    subgraph "Agent Layer Details"
        I[Agent 1] --> J[Agent Results]
        K[Agent 2] --> J
        L[Agent N] --> J
    end
    
    subgraph "Processing Flow"
        M[Previous Context] --> N[Current Task]
        N --> O[Agent Processing]
        O --> P[Aggregation]
        P --> M
    end
```

## Overview

The `MixtureOfAgents` class represents a mixture of agents operating within a swarm. The workflow of the swarm follows a parallel → sequential → parallel → final output agent process. This implementation is inspired by concepts discussed in the paper: [https://arxiv.org/pdf/2406.04692](https://arxiv.org/pdf/2406.04692).

The class is designed to manage a collection of agents, orchestrate their execution in layers, and handle the final aggregation of their outputs through a designated final agent. This architecture facilitates complex, multi-step processing where intermediate results are refined through successive layers of agent interactions.

## Class Definition

### MixtureOfAgents

```python
class MixtureOfAgents(BaseSwarm):
```

### Attributes

| Attribute        | Type         | Description                                                                         | Default                         |
|------------------|--------------|-------------------------------------------------------------------------------------|---------------------------------|
| `agents`         | `List[Agent]`| The list of agents in the swarm.                                                    | `None`                          |
| `flow`           | `str`        | The flow of the swarm.                                                              | `parallel -> sequential -> parallel -> final output agent` |
| `max_loops`      | `int`        | The maximum number of loops to run.                                                 | `1`                             |
| `verbose`        | `bool`       | Flag indicating whether to print verbose output.                                    | `True`                          |
| `layers`         | `int`        | The number of layers in the swarm.                                                  | `3`                             |
| `rules`          | `str`        | The rules for the swarm.                                                            | `None`                          |
| `final_agent`    | `Agent`      | The agent to handle the final output processing.                                    | `None`                          |
| `auto_save`      | `bool`       | Flag indicating whether to auto-save the metadata to a file.                        | `False`                         |
| `saved_file_name`| `str`        | The name of the file where the metadata will be saved.                              | `"moe_swarm.json"`              |

## Methods

### `__init__`

#### Parameters

| Parameter        | Type         | Description                                                                                   | Default                                |
|------------------|--------------|-----------------------------------------------------------------------------------------------|----------------------------------------|
| `name`           | `str`        | The name of the swarm.                                                                        | `"MixtureOfAgents"`                    |
| `description`    | `str`        | A brief description of the swarm.                                                             | `"A swarm of agents that run in parallel and sequentially."` |
| `agents`         | `List[Agent]`| The list of agents in the swarm.                                                              | `None`                                 |
| `max_loops`      | `int`        | The maximum number of loops to run.                                                           | `1`                                    |
| `verbose`        | `bool`       | Flag indicating whether to print verbose output.                                              | `True`                                 |
| `layers`         | `int`        | The number of layers in the swarm.                                                            | `3`                                    |
| `rules`          | `str`        | The rules for the swarm.                                                                      | `None`                                 |
| `final_agent`    | `Agent`      | The agent to handle the final output processing.                                              | `None`                                 |
| `auto_save`      | `bool`       | Flag indicating whether to auto-save the metadata to a file.                                  | `False`                                |
| `saved_file_name`| `str`        | The name of the file where the metadata will be saved.                                        | `"moe_swarm.json"`                     |

### `agent_check`

```python
def agent_check(self):
```

#### Description

Checks if the provided `agents` attribute is a list of `Agent` instances. Raises a `TypeError` if the validation fails.

#### Example Usage

```python
moe_swarm = MixtureOfAgents(agents=[agent1, agent2])
moe_swarm.agent_check()  # Validates the agents
```

### `final_agent_check`

```python
def final_agent_check(self):
```

#### Description

Checks if the provided `final_agent` attribute is an instance of `Agent`. Raises a `TypeError` if the validation fails.

#### Example Usage

```python
moe_swarm = MixtureOfAgents(final_agent=final_agent)
moe_swarm.final_agent_check()  # Validates the final agent
```

### `swarm_initialization`

```python
def swarm_initialization(self):
```

#### Description

Initializes the swarm by logging the swarm name, description, and the number of agents.

#### Example Usage

```python
moe_swarm = MixtureOfAgents(agents=[agent1, agent2])
moe_swarm.swarm_initialization()  # Initializes the swarm
```

### `run`

```python
def run(self, task: str = None, *args, **kwargs):
```

#### Parameters

| Parameter | Type   | Description                     | Default |
|-----------|--------|---------------------------------|---------|
| `task`    | `str`  | The task to be performed by the swarm. | `None`  |
| `*args`   | `tuple`| Additional arguments.           | `None`  |
| `**kwargs`| `dict` | Additional keyword arguments.   | `None`  |

#### Returns

| Type  | Description                                 |
|-------|---------------------------------------------|
| `str` | The conversation history as a string.       |

#### Description

Runs the swarm with the given task, orchestrates the execution of agents through the specified layers, and returns the conversation history.

#### Example Usage

```python
moe_swarm = MixtureOfAgents(agents=[agent1, agent2], final_agent=final_agent)
history = moe_swarm.run(task="Solve this problem.")
print(history)
```

### `reliability_check`

```python
def reliability_check(self) -> None:
```

#### Description

Performs validation checks on the Mixture of Agents class to ensure all required components are properly configured. Raises ValueError if any checks fail.

#### Validation Checks:
- Verifies reference agents are provided
- Validates aggregator agent exists
- Checks aggregator system prompt is set
- Ensures layers count is valid (> 0)

### `_get_final_system_prompt`

```python
def _get_final_system_prompt(self, system_prompt: str, results: List[str]) -> str:
```

#### Description

Internal method that constructs a system prompt for subsequent layers by incorporating previous responses.

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `system_prompt` | `str` | The initial system prompt |
| `results` | `List[str]` | List of previous responses |

#### Returns

| Type | Description |
|------|-------------|
| `str` | Combined system prompt with previous responses |

### `run_batched`

```python
def run_batched(self, tasks: List[str]) -> List[str]:
```

#### Description

Processes multiple tasks sequentially, returning a list of responses.

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `tasks` | `List[str]` | List of tasks to process |

#### Returns

| Type | Description |
|------|-------------|
| `List[str]` | List of responses for each task |

### `run_concurrently`

```python
def run_concurrently(self, tasks: List[str]) -> List[str]:
```

#### Description

Processes multiple tasks concurrently using a ThreadPoolExecutor, optimizing for parallel execution.

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `tasks` | `List[str]` | List of tasks to process concurrently |

#### Returns

| Type | Description |
|------|-------------|
| `List[str]` | List of responses for each task |

## Detailed Explanation

### Initialization

The `__init__` method initializes the swarm with the provided parameters, sets up the conversation rules, and invokes the initialization of the swarm. It also ensures the validity of the `agents` and `final_agent` attributes by calling the `agent_check` and `final_agent_check` methods respectively.

### Agent Validation

The `agent_check` method validates whether the `agents` attribute is a list of `Agent` instances, while the `final_agent_check` method validates whether the `final_agent` is an instance of `Agent`. These checks are crucial to ensure that the swarm operates correctly with the appropriate agent types.

### Swarm Initialization

The `swarm_initialization` method logs essential information about the swarm, including its name, description, and the number of agents. This provides a clear starting point for the swarm's operations and facilitates debugging and monitoring.

### Running the Swarm

The `run` method is the core of the `MixtureOfAgents` class. It orchestrates the execution of agents through multiple layers, collects their outputs, and processes the final output using the `final_agent`. The conversation history is maintained and updated throughout this process, allowing for a seamless flow of information and responses.

During each layer, the method iterates over the agents, invokes their `run` method with the current conversation history, and logs the outputs. These outputs are then added to the conversation, and the history is updated for the next layer.

After all layers are completed, the final output agent processes the entire conversation history, and the metadata is created and optionally saved to a file. This metadata includes details about the layers, agent runs, and final output, providing a comprehensive record of the swarm's execution.

## Additional Information and Tips

### Common Issues and Solutions

- **Type Errors**: Ensure that all agents in the `agents` list and the `final_agent` are instances of the `Agent` class. The `agent_check` and `final_agent_check` methods help validate this.
- **Verbose Logging**: Use the `verbose` flag to control the verbosity of the output. This can help with debugging or reduce clutter in the logs.
- **Auto-Save Feature**: Utilize the `auto_save` flag to automatically save the metadata to a file. This can be useful for keeping records of the swarm's operations without manual intervention.

### References and Resources

For further reading and background information on the concepts used in the `MixtureOfAgents` class, refer to the paper: [https://arxiv.org/pdf/2406.04692](https://arxiv.org/pdf/2406.04692).

### Usage Examples

#### Example 1: Basic Initialization and Run

```python
from swarms import MixtureOfAgents, Agent

from swarm_models import OpenAIChat

# Define agents
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the accountants",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

# Initialize accountant 1
accountant1 = Agent(
    agent_name="Accountant1",
    system_prompt="Prepares financial statements",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

# Initialize accountant 2
accountant2 = Agent(
    agent_name="Accountant2",
    system_prompt="Audits financial records",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)


# Initialize the MixtureOfAgents
moe_swarm = MixtureOfAgents(agents=[director, accountant1, accountant2], final_agent=director)

# Run the swarm
history = moe_swarm.run(task="Perform task X.")
print(history)
```

#### Example 2: Verbose Output and Auto-Save

```python
from swarms import MixtureOfAgents, Agent

from swarm_models import OpenAIChat

# Define Agents
# Define agents
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the accountants",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

# Initialize accountant 1
accountant1 = Agent(
    agent_name="Accountant1",
    system_prompt="Prepares financial statements",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

# Initialize accountant 2
accountant2 = Agent(
    agent_name="Accountant2",
    system_prompt="Audits financial records",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)

# Initialize the MixtureOfAgents with verbose output and auto-save enabled
moe_swarm = MixtureOfAgents(
    agents=[director, accountant1, accountant2],
    final_agent=director,
    verbose=True,
    auto_save=True
)

# Run the swarm
history = moe_swarm.run(task="Analyze data set Y.")
print(history)
```

#### Example 3: Custom Rules and Multiple Layers

```python
from swarms import MixtureOfAgents, Agent

from swarm_models import OpenAIChat

# Define agents
# Initialize the director agent
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the accountants",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

# Initialize accountant 1
accountant1 = Agent(
    agent_name="Accountant1",
    system_prompt="Prepares financial statements",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

# Initialize accountant 2
accountant2 = Agent(
    agent_name="Accountant2",
    system_prompt="Audits financial records",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)

# Initialize the MixtureOfAgents with custom rules and multiple layers
moe_swarm = MixtureOfAgents(
    agents=[director, accountant1, accountant2],
    final_agent=director,
    layers=5,
    rules="Custom rules for the swarm"
)

# Run the swarm
history = moe_swarm.run(task="Optimize process Z.")
print(history)
```

This comprehensive documentation provides a detailed understanding of the `MixtureOfAgents` class, its attributes, methods, and usage. The examples illustrate how to initialize and run the swarm, demonstrating its flexibility and capability to handle various tasks and configurations.


# Conclusion

The `MixtureOfAgents` class is a powerful and flexible framework for managing and orchestrating a swarm of agents. By following a structured approach of parallel and sequential processing, it enables the implementation of complex multi-step workflows where intermediate results are refined through multiple layers of agent interactions. This architecture is particularly suitable for tasks that require iterative processing, collaboration among diverse agents, and sophisticated aggregation of outputs.

### Key Takeaways

1. **Flexible Initialization**: The class allows for customizable initialization with various parameters, enabling users to tailor the swarm's configuration to their specific needs.
2. **Robust Agent Management**: With built-in validation methods, the class ensures that all agents and the final agent are correctly instantiated, preventing runtime errors and facilitating smooth execution.
3. **Layered Processing**: The layered approach to processing allows for intermediate results to be iteratively refined, enhancing the overall output quality.
4. **Verbose Logging and Auto-Save**: These features aid in debugging, monitoring, and record-keeping, providing transparency and ease of management.
5. **Comprehensive Documentation**: The detailed class and method documentation, along with numerous usage examples, provide a clear and thorough understanding of how to leverage the `MixtureOfAgents` class effectively.

### Practical Applications

The `MixtureOfAgents` class can be applied in various domains, including but not limited to:

- **Natural Language Processing (NLP)**: Managing a swarm of NLP models to process, analyze, and synthesize text.
- **Data Analysis**: Coordinating multiple data analysis agents to process and interpret complex data sets.
- **Optimization Problems**: Running a swarm of optimization algorithms to solve complex problems in fields such as logistics, finance, and engineering.
- **AI Research**: Implementing experimental setups that require the collaboration of multiple AI models or agents to explore new methodologies and approaches.

### Future Extensions

The `MixtureOfAgents` framework provides a solid foundation for further extensions and customizations, including:

- **Dynamic Layer Configuration**: Allowing layers to be added or removed dynamically based on the task requirements or intermediate results.
- **Advanced Agent Communication**: Enhancing the communication protocols between agents to allow for more sophisticated information exchange.
- **Integration with Other Frameworks**: Seamlessly integrating with other machine learning or data processing frameworks to leverage their capabilities within the swarm architecture.

In conclusion, the `MixtureOfAgents` class represents a versatile and efficient solution for orchestrating multi-agent systems, facilitating complex task execution through its structured and layered approach. By harnessing the power of parallel and sequential processing, it opens up new possibilities for tackling intricate problems across various domains.

## Additional Examples

### Example 4: Batch Processing

```python
from swarms import MixtureOfAgents, Agent
from swarm_models import OpenAIChat

# Initialize agents as in previous examples
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the accountants",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

accountant1 = Agent(
    agent_name="Accountant1",
    system_prompt="Prepares financial statements",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

accountant2 = Agent(
    agent_name="Accountant2",
    system_prompt="Audits financial records",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)

# Initialize MixtureOfAgents
moe_swarm = MixtureOfAgents(
    agents=[director, accountant1, accountant2],
    final_agent=director
)

# Process multiple tasks in batch
tasks = [
    "Analyze Q1 financial statements",
    "Review tax compliance",
    "Prepare budget forecast"
]
results = moe_swarm.run_batched(tasks)
for task, result in zip(tasks, results):
    print(f"Task: {task}\nResult: {result}\n")
```

### Example 5: Concurrent Processing

```python
from swarms import MixtureOfAgents, Agent
from swarm_models import OpenAIChat

# Initialize agents as before
# ... agent initialization code ...

# Initialize MixtureOfAgents
moe_swarm = MixtureOfAgents(
    agents=[director, accountant1, accountant2],
    final_agent=director
)

# Process multiple tasks concurrently
tasks = [
    "Generate monthly report",
    "Audit expense claims",
    "Update financial projections",
    "Review investment portfolio"
]
results = moe_swarm.run_concurrently(tasks)
for task, result in zip(tasks, results):
    print(f"Task: {task}\nResult: {result}\n")
```

## Advanced Features

### Context Preservation

The `MixtureOfAgents` class maintains context between iterations when running multiple loops. Each subsequent iteration receives the context from previous runs, allowing for more sophisticated and context-aware processing.

### Asynchronous Processing

The class implements asynchronous processing internally using Python's `asyncio`, enabling efficient handling of concurrent operations and improved performance for complex workflows.

### Telemetry and Logging

Built-in telemetry and logging capabilities help track agent performance and maintain detailed execution records:
- Automatic logging of agent outputs
- Structured data capture using Pydantic models
- JSON-formatted output options

--------------------------------------------------

# File: swarms/structs/model_router.md

# ModelRouter Docs

The ModelRouter is an intelligent routing system that automatically selects and executes AI models based on task requirements. It leverages a function-calling architecture to analyze tasks and recommend the optimal model and provider combination for each specific use case.





### Key Features

- Dynamic model selection based on task complexity and requirements
- Multi-provider support (OpenAI, Anthropic, Google, etc.)
- Concurrent and asynchronous execution capabilities
- Batch processing with memory
- Automatic error handling and retries
- Provider-aware routing
- Cost optimization

### Constructor Arguments

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| system_prompt | str | model_router_system_prompt | Custom prompt for guiding model selection behavior |
| max_tokens | int | 4000 | Maximum token limit for model outputs |
| temperature | float | 0.5 | Control parameter for response randomness (0.0-1.0) |
| max_workers | int/str | 10 | Maximum concurrent workers ("auto" for CPU count) |
| api_key | str | None | API key for model access |
| max_loops | int | 1 | Maximum number of refinement iterations |
| *args | Any | None | Additional positional arguments |
| **kwargs | Any | None | Additional keyword arguments |

### Core Methods

#### run(task: str) -> str

Executes a single task through the model router with memory and refinement capabilities.

# Installation

1. Install the latest version of swarms using pip:

```bash
pip3 install -U swarms
```

2. Setup your API Keys in your .env file with the following:

```bash
OPENAI_API_KEY=your_openai_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
GOOGLE_API_KEY=your_google_api_key
# Add more API keys as needed following litellm format
```


```python
from swarms import ModelRouter

router = ModelRouter()

# Simple text analysis
result = router.run("Analyze the sentiment and key themes in this customer feedback")

# Complex reasoning task
complex_result = router.run("""
Evaluate the following business proposal:
- Initial investment: $500,000
- Projected ROI: 25% annually
- Market size: $2B
- Competition: 3 major players
Provide detailed analysis and recommendations.
""")
```

#### batch_run(tasks: list) -> list
Executes multiple tasks sequentially with result aggregation.

```python
# Multiple analysis tasks
tasks = [
    "Analyze Q1 financial performance",
    "Predict Q2 market trends",
    "Evaluate competitor strategies",
    "Generate growth recommendations"
]

results = router.batch_run(tasks)

# Process results
for task, result in zip(tasks, results):
    print(f"Task: {task}\nResult: {result}\n")
```

#### concurrent_run(tasks: list) -> list
Parallel execution of multiple tasks using thread pooling.

```python
import asyncio
from typing import List

# Define multiple concurrent tasks
analysis_tasks = [
    "Perform technical analysis of AAPL stock",
    "Analyze market sentiment from social media",
    "Generate trading signals",
    "Calculate risk metrics"
]

# Execute tasks concurrently
results = router.concurrent_run(analysis_tasks)

# Process results with error handling
for task, result in zip(analysis_tasks, results):
    try:
        processed_result = process_analysis(result)
        save_to_database(processed_result)
    except Exception as e:
        log_error(f"Error processing {task}: {str(e)}")
```

#### async_run(task: str) -> asyncio.Task
Asynchronous task execution with coroutine support.

```python
async def process_data_stream():
    tasks = []
    async for data in data_stream:
        task = await router.async_run(f"Process data: {data}")
        tasks.append(task)
    
    results = await asyncio.gather(*tasks)
    return results

# Usage in async context
async def main():
    router = ModelRouter()
    results = await process_data_stream()
```

### Advanced Usage Examples

#### Financial Analysis System

```python
from swarms import ModelRouter
from typing import Dict, List
import pandas as pd

class FinancialAnalysisSystem:
    def __init__(self):
        self.router = ModelRouter(
            temperature=0.3,  # Lower temperature for more deterministic outputs
            max_tokens=8000,  # Higher token limit for detailed analysis
            max_loops=2  # Allow for refinement iteration
        )
    
    def analyze_company_financials(self, financial_data: Dict) -> Dict:
        analysis_task = f"""
        Perform comprehensive financial analysis:
        
        Financial Metrics:
        - Revenue: ${financial_data['revenue']}M
        - EBITDA: ${financial_data['ebitda']}M
        - Debt/Equity: {financial_data['debt_equity']}
        - Working Capital: ${financial_data['working_capital']}M
        
        Required Analysis:
        1. Profitability assessment
        2. Liquidity analysis
        3. Growth projections
        4. Risk evaluation
        5. Investment recommendations
        
        Provide detailed insights and actionable recommendations.
        """
        
        result = self.router.run(analysis_task)
        return self._parse_analysis_result(result)
    
    def _parse_analysis_result(self, result: str) -> Dict:
        # Implementation of result parsing
        pass

# Usage
analyzer = FinancialAnalysisSystem()
company_data = {
    'revenue': 150,
    'ebitda': 45,
    'debt_equity': 0.8,
    'working_capital': 25
}

analysis = analyzer.analyze_company_financials(company_data)
```

#### Healthcare Data Processing Pipeline

```python
from swarms import ModelRouter
import pandas as pd
from typing import List, Dict

class MedicalDataProcessor:
    def __init__(self):
        self.router = ModelRouter(
            max_workers="auto",  # Automatic worker scaling
            temperature=0.2,     # Conservative temperature for medical analysis
            system_prompt="""You are a specialized medical data analyzer focused on:
            1. Clinical terminology interpretation
            2. Patient data analysis
            3. Treatment recommendation review
            4. Medical research synthesis"""
        )
    
    async def process_patient_records(self, records: List[Dict]) -> List[Dict]:
        analysis_tasks = []
        
        for record in records:
            task = f"""
            Analyze patient record:
            - Age: {record['age']}
            - Symptoms: {', '.join(record['symptoms'])}
            - Vital Signs: {record['vitals']}
            - Medications: {', '.join(record['medications'])}
            - Lab Results: {record['lab_results']}
            
            Provide:
            1. Symptom analysis
            2. Medication interaction check
            3. Lab results interpretation
            4. Treatment recommendations
            """
            analysis_tasks.append(task)
        
        results = await asyncio.gather(*[
            self.router.async_run(task) for task in analysis_tasks
        ])
        
        return [self._parse_medical_analysis(r) for r in results]
    
    def _parse_medical_analysis(self, analysis: str) -> Dict:
        # Implementation of medical analysis parsing
        pass

# Usage
async def main():
    processor = MedicalDataProcessor()
    patient_records = [
        {
            'age': 45,
            'symptoms': ['fever', 'cough', 'fatigue'],
            'vitals': {'bp': '120/80', 'temp': '38.5C'},
            'medications': ['lisinopril', 'metformin'],
            'lab_results': 'WBC: 11,000, CRP: 2.5'
        }
        # More records...
    ]
    
    analyses = await processor.process_patient_records(patient_records)
```

#### Natural Language Processing Pipeline

```python
from swarms import ModelRouter
from typing import List, Dict
import asyncio

class NLPPipeline:
    def __init__(self):
        self.router = ModelRouter(
            temperature=0.4,
            max_loops=2
        )
    
    def process_documents(self, documents: List[str]) -> List[Dict]:
        tasks = [self._create_nlp_task(doc) for doc in documents]
        results = self.router.concurrent_run(tasks)
        return [self._parse_nlp_result(r) for r in results]
    
    def _create_nlp_task(self, document: str) -> str:
        return f"""
        Perform comprehensive NLP analysis:
        
        Text: {document}
        
        Required Analysis:
        1. Entity recognition
        2. Sentiment analysis
        3. Topic classification
        4. Key phrase extraction
        5. Intent detection
        
        Provide structured analysis with confidence scores.
        """
    
    def _parse_nlp_result(self, result: str) -> Dict:
        # Implementation of NLP result parsing
        pass

# Usage
pipeline = NLPPipeline()
documents = [
    "We're extremely satisfied with the new product features!",
    "The customer service response time needs improvement.",
    "Looking to upgrade our subscription plan next month."
]

analyses = pipeline.process_documents(documents)
```

### Available Models and Use Cases

| Model | Provider | Optimal Use Cases | Characteristics |
|-------|----------|-------------------|-----------------|
| gpt-4-turbo | OpenAI | Complex reasoning, Code generation, Creative writing | High accuracy, Latest knowledge cutoff |
| claude-3-opus | Anthropic | Research analysis, Technical documentation, Long-form content | Strong reasoning, Detailed outputs |
| gemini-pro | Google | Multimodal tasks, Code generation, Technical analysis | Fast inference, Strong coding abilities |
| mistral-large | Mistral | General tasks, Content generation, Classification | Open source, Good price/performance |
| deepseek-reasoner | DeepSeek | Mathematical analysis, Logic problems, Scientific computing | Specialized reasoning capabilities |

### Provider Capabilities

| Provider | Strengths | Best For | Integration Notes |
|----------|-----------|-----------|------------------|
| OpenAI | Consistent performance, Strong reasoning | Production systems, Complex tasks | Requires API key setup |
| Anthropic | Safety features, Detailed analysis | Research, Technical writing | Claude-specific formatting |
| Google | Technical tasks, Multimodal support | Code generation, Analysis | Vertex AI integration available |
| Groq | High-speed inference | Real-time applications | Optimized for specific models |
| DeepSeek | Specialized reasoning | Scientific computing | Custom API integration |
| Mistral | Open source flexibility | General applications | Self-hosted options available |


### Performance Optimization Tips

1. Token Management
   - Set appropriate max_tokens based on task complexity
   - Monitor token usage for cost optimization
   - Use streaming for long outputs

2. Concurrency Settings
   - Adjust max_workers based on system resources
   - Use "auto" workers for optimal CPU utilization
   - Monitor memory usage with large batch sizes

3. Temperature Tuning
   - Lower (0.1-0.3) for factual/analytical tasks
   - Higher (0.7-0.9) for creative tasks
   - Mid-range (0.4-0.6) for balanced outputs

4. System Prompts
   - Customize for specific domains
   - Include relevant context
   - Define clear output formats

### Dependencies

- asyncio: Asynchronous I/O support
- concurrent.futures: Thread pool execution
- pydantic: Data validation
- litellm: LLM interface standardization


--------------------------------------------------

# File: swarms/structs/multi_agent_collaboration_examples.md

# Multi-Agent Examples


### `SequentialWorkflow`
Sequential Workflow enables you to sequentially execute tasks with `Agent` and then pass the output into the next agent and onwards until you have specified your max loops.

```python
from swarms import Agent, SequentialWorkflow

from swarm_models import Anthropic


# Initialize the language model agent (e.g., GPT-3)
llm = Anthropic()

# Initialize agents for individual tasks
agent1 = Agent(
    agent_name="Blog generator",
    system_prompt="Generate a blog post like stephen king",
    llm=llm,
    max_loops=1,
    dashboard=False,
    tools=[],
)
agent2 = Agent(
    agent_name="summarizer",
    system_prompt="Sumamrize the blog post",
    llm=llm,
    max_loops=1,
    dashboard=False,
    tools=[],
)

# Create the Sequential workflow
workflow = SequentialWorkflow(
    agents=[agent1, agent2], max_loops=1, verbose=False
)

# Run the workflow
workflow.run(
    "Generate a blog post on how swarms of agents can help businesses grow."
)

```

------

## `AgentRearrange`
Inspired by Einops and einsum, this orchestration techniques enables you to map out the relationships between various agents. For example you specify linear and sequential relationships like `a -> a1 -> a2 -> a3` or concurrent relationships where the first agent will send a message to 3 agents all at once: `a -> a1, a2, a3`. You can customize your workflow to mix sequential and concurrent relationships. [Docs Available:](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)

```python
from swarms import Agent, AgentRearrange


from swarm_models import Anthropic

# Initialize the director agent

director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the workers",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)


# Initialize worker 1

worker1 = Agent(
    agent_name="Worker1",
    system_prompt="Generates a transcript for a youtube video on what swarms are",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="worker1.json",
)


# Initialize worker 2
worker2 = Agent(
    agent_name="Worker2",
    system_prompt="Summarizes the transcript generated by Worker1",
    llm=Anthropic(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="worker2.json",
)


# Create a list of agents
agents = [director, worker1, worker2]

# Define the flow pattern
flow = "Director -> Worker1 -> Worker2"

# Using AgentRearrange class
agent_system = AgentRearrange(agents=agents, flow=flow)
output = agent_system.run(
    "Create a format to express and communicate swarms of llms in a structured manner for youtube"
)
print(output)

```

## `HierarhicalSwarm`
Coming soon...


## `GraphSwarm`

```python
import os

from dotenv import load_dotenv


from swarms import Agent, Edge, GraphWorkflow, Node, NodeType

from swarm_models import OpenAIChat

load_dotenv()

api_key = os.environ.get("OPENAI_API_KEY")

llm = OpenAIChat(
    temperature=0.5, openai_api_key=api_key, max_tokens=4000
)
agent1 = Agent(llm=llm, max_loops=1, autosave=True, dashboard=True)
agent2 = Agent(llm=llm, max_loops=1, autosave=True, dashboard=True)

def sample_task():
    print("Running sample task")
    return "Task completed"

wf_graph = GraphWorkflow()
wf_graph.add_node(Node(id="agent1", type=NodeType.AGENT, agent=agent1))
wf_graph.add_node(Node(id="agent2", type=NodeType.AGENT, agent=agent2))
wf_graph.add_node(
    Node(id="task1", type=NodeType.TASK, callable=sample_task)
)
wf_graph.add_edge(Edge(source="agent1", target="task1"))
wf_graph.add_edge(Edge(source="agent2", target="task1"))

wf_graph.set_entry_points(["agent1", "agent2"])
wf_graph.set_end_points(["task1"])

print(wf_graph.visualize())

# Run the workflow
results = wf_graph.run()
print("Execution results:", results)

```

## `MixtureOfAgents`
This is an implementation from the paper: "Mixture-of-Agents Enhances Large Language Model Capabilities" by together.ai, it achieves SOTA on AlpacaEval 2.0, MT-Bench and FLASK, surpassing GPT-4 Omni. Great for tasks that need to be parallelized and then sequentially fed into another loop

```python
from swarms import Agent, OpenAIChat, MixtureOfAgents

# Initialize the director agent
director = Agent(
    agent_name="Director",
    system_prompt="Directs the tasks for the accountants",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="director.json",
)

# Initialize accountant 1
accountant1 = Agent(
    agent_name="Accountant1",
    system_prompt="Prepares financial statements",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant1.json",
)

# Initialize accountant 2
accountant2 = Agent(
    agent_name="Accountant2",
    system_prompt="Audits financial records",
    llm=OpenAIChat(),
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="accountant2.json",
)

# Create a list of agents
agents = [director, accountant1, accountant2]


# Swarm
swarm = MixtureOfAgents(
    name="Mixture of Accountants",
    agents=agents,
    layers=3,
    final_agent=director,
)


# Run the swarm
out = swarm.run("Prepare financial statements and audit financial records")
print(out)
```


--------------------------------------------------

# File: swarms/structs/multi_agent_orchestration.md

# Multi-Agent Orchestration:
Swarms was designed to faciliate the communication between many different and specialized agents from a vast array of other frameworks such as langchain, autogen, crew, and more.

In traditional swarm theory, there are many types of swarms usually for very specialized use-cases and problem sets. Such as Hiearchical and sequential are great for accounting and sales, because there is usually a boss coordinator agent that distributes a workload to other specialized agents.


| **Name**                      | **Description**                                                                                                                                                         | **Code Link**               | **Use Cases**                                                                                     |
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|---------------------------------------------------------------------------------------------------|
| Hierarchical Swarms           | A system where agents are organized in a hierarchy, with higher-level agents coordinating lower-level agents to achieve complex tasks.                                   | [Code Link](#)              | Manufacturing process optimization, multi-level sales management, healthcare resource coordination |
| Agent Rearrange               | A setup where agents rearrange themselves dynamically based on the task requirements and environmental conditions.                                                       | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)              | Adaptive manufacturing lines, dynamic sales territory realignment, flexible healthcare staffing  |
| Concurrent Workflows          | Agents perform different tasks simultaneously, coordinating to complete a larger goal.                                                                                  | [Code Link](#)              | Concurrent production lines, parallel sales operations, simultaneous patient care processes       |
| Sequential Coordination       | Agents perform tasks in a specific sequence, where the completion of one task triggers the start of the next.                                                           | [Code Link](https://docs.swarms.world/en/latest/swarms/structs/sequential_workflow/)              | Step-by-step assembly lines, sequential sales processes, stepwise patient treatment workflows     |
| Parallel Processing           | Agents work on different parts of a task simultaneously to speed up the overall process.                                                                                | [Code Link](#)              | Parallel data processing in manufacturing, simultaneous sales analytics, concurrent medical tests  |




--------------------------------------------------

# File: swarms/structs/multi_agent_router.md

# MultiAgentRouter Documentation

The MultiAgentRouter is a sophisticated task routing system that efficiently delegates tasks to specialized AI agents. It uses a "boss" agent to analyze incoming tasks and route them to the most appropriate specialized agent based on their capabilities and expertise.

## Table of Contents
- [Installation](#installation)
- [Key Components](#key-components)
- [Arguments](#arguments)
- [Methods](#methods)
- [Usage Examples](#usage-examples)
  - [Healthcare](#healthcare-example)
  - [Finance](#finance-example)
  - [Legal](#legal-example)
  - [Research](#research-example)

## Installation

```bash
pip install swarms
```

## Key Components

### Arguments Table

| Argument | Type | Default | Description |
|----------|------|---------|-------------|
| name | str | "swarm-router" | Name identifier for the router instance |
| description | str | "Routes tasks..." | Description of the router's purpose |
| agents | List[Agent] | [] | List of available specialized agents |
| model | str | "gpt-4o-mini" | Base language model for the boss agent |
| temperature | float | 0.1 | Temperature parameter for model outputs |
| shared_memory_system | callable | None | Optional shared memory system |
| output_type | Literal["json", "string"] | "json" | Format of agent outputs |
| execute_task | bool | True | Whether to execute routed tasks |

### Methods Table

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| route_task | task: str | dict | Routes a single task to appropriate agent |
| batch_run | tasks: List[str] | List[dict] | Sequentially routes multiple tasks |
| concurrent_batch_run | tasks: List[str] | List[dict] | Concurrently routes multiple tasks |
| query_ragent | task: str | str | Queries the research agent |
| find_agent_in_list | agent_name: str | Optional[Agent] | Finds agent by name |

## Production Examples

### Healthcare Example

```python
from swarms import Agent, MultiAgentRouter

# Define specialized healthcare agents
agents = [
    Agent(
        agent_name="DiagnosisAgent",
        description="Specializes in preliminary symptom analysis and diagnostic suggestions",
        system_prompt="""You are a medical diagnostic assistant. Analyze symptoms and provide 
        evidence-based diagnostic suggestions, always noting this is for informational purposes 
        only and recommending professional medical consultation.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="TreatmentPlanningAgent",
        description="Assists in creating treatment plans and medical documentation",
        system_prompt="""You are a treatment planning assistant. Help create structured 
        treatment plans based on confirmed diagnoses, following medical best practices 
        and guidelines.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="MedicalResearchAgent",
        description="Analyzes medical research papers and clinical studies",
        system_prompt="""You are a medical research analyst. Analyze and summarize medical 
        research papers, clinical trials, and scientific studies, providing evidence-based 
        insights.""",
        model_name="openai/gpt-4o"
    )
]

# Initialize router
healthcare_router = MultiAgentRouter(
    name="Healthcare-Router",
    description="Routes medical and healthcare-related tasks to specialized agents",
    agents=agents,
    model="gpt-4o",
    temperature=0.1
)

# Example usage
try:
    # Process medical case
    case_analysis = healthcare_router.route_task(
        """Patient presents with: 
        - Persistent dry cough for 3 weeks
        - Mild fever (38.1°C)
        - Fatigue
        Analyze symptoms and suggest potential diagnoses for healthcare provider review."""
    )
    
    # Research treatment options
    treatment_research = healthcare_router.route_task(
        """Find recent clinical studies on treatment efficacy for community-acquired 
        pneumonia in adult patients, focusing on outpatient care."""
    )
    
    # Process multiple cases concurrently
    cases = [
        "Case 1: Patient symptoms...",
        "Case 2: Patient symptoms...",
        "Case 3: Patient symptoms..."
    ]
    concurrent_results = healthcare_router.concurrent_batch_run(cases)
    
except Exception as e:
    logger.error(f"Error in healthcare processing: {str(e)}")
```

### Finance Example

```python
# Define specialized finance agents
finance_agents = [
    Agent(
        agent_name="MarketAnalysisAgent",
        description="Analyzes market trends and provides trading insights",
        system_prompt="""You are a financial market analyst. Analyze market data, trends, 
        and indicators to provide evidence-based market insights and trading suggestions.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="RiskAssessmentAgent",
        description="Evaluates financial risks and compliance requirements",
        system_prompt="""You are a risk assessment specialist. Analyze financial data 
        and operations for potential risks, ensuring regulatory compliance and suggesting 
        risk mitigation strategies.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="InvestmentAgent",
        description="Provides investment strategies and portfolio management",
        system_prompt="""You are an investment strategy specialist. Develop and analyze 
        investment strategies, portfolio allocations, and provide long-term financial 
        planning guidance.""",
        model_name="openai/gpt-4o"
    )
]

# Initialize finance router
finance_router = MultiAgentRouter(
    name="Finance-Router",
    description="Routes financial analysis and investment tasks",
    agents=finance_agents
)

# Example tasks
tasks = [
    """Analyze current market conditions for technology sector, focusing on:
    - AI/ML companies
    - Semiconductor manufacturers
    - Cloud service providers
    Provide risk assessment and investment opportunities.""",
    
    """Develop a diversified portfolio strategy for a conservative investor with:
    - Investment horizon: 10 years
    - Risk tolerance: Low to medium
    - Initial investment: $500,000
    - Monthly contribution: $5,000""",
    
    """Conduct risk assessment for a fintech startup's crypto trading platform:
    - Regulatory compliance requirements
    - Security measures
    - Operational risks
    - Market risks"""
]

# Process tasks concurrently
results = finance_router.concurrent_batch_run(tasks)
```

### Legal Example

```python
# Define specialized legal agents
legal_agents = [
    Agent(
        agent_name="ContractAnalysisAgent",
        description="Analyzes legal contracts and documents",
        system_prompt="""You are a legal document analyst. Review contracts and legal 
        documents for key terms, potential issues, and compliance requirements.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="ComplianceAgent",
        description="Ensures regulatory compliance and updates",
        system_prompt="""You are a legal compliance specialist. Monitor and analyze 
        regulatory requirements, ensuring compliance and suggesting necessary updates 
        to policies and procedures.""",
        model_name="openai/gpt-4o"
    ),
    Agent(
        agent_name="LegalResearchAgent",
        description="Conducts legal research and case analysis",
        system_prompt="""You are a legal researcher. Research relevant cases, statutes, 
        and regulations, providing comprehensive legal analysis and citations.""",
        model_name="openai/gpt-4o"
    )
]

# Initialize legal router
legal_router = MultiAgentRouter(
    name="Legal-Router",
    description="Routes legal analysis and compliance tasks",
    agents=legal_agents
)

# Example usage for legal department
contract_analysis = legal_router.route_task(
    """Review the following software licensing agreement:
    [contract text]
    
    Analyze for:
    1. Key terms and conditions
    2. Potential risks and liabilities
    3. Compliance with current regulations
    4. Suggested modifications"""
)
```

## Error Handling and Best Practices

1. Always use try-except blocks for task routing:
```python
try:
    result = router.route_task(task)
except Exception as e:
    logger.error(f"Task routing failed: {str(e)}")
```

2. Monitor agent performance:
```python
if result["execution"]["execution_time"] > 5.0:
    logger.warning(f"Long execution time for task: {result['task']['original']}")
```

3. Implement rate limiting for concurrent tasks:
```python
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=5) as executor:
    results = router.concurrent_batch_run(tasks)
```

4. Regular agent validation:
```python
for agent in router.agents.values():
    if not agent.validate():
        logger.error(f"Agent validation failed: {agent.name}")
```

## Performance Considerations

1. Task Batching

- Group similar tasks together

- Use concurrent_batch_run for independent tasks

- Monitor memory usage with large batches

2. Model Selection

- Choose appropriate models based on task complexity

- Balance speed vs. accuracy requirements

- Consider cost implications

3. Response Caching

- Implement caching for frequently requested analyses

- Use shared memory system for repeated queries

- Regular cache invalidation for time-sensitive data

## Security Considerations

1. Data Privacy

- Implement data encryption

- Handle sensitive information appropriately

- Regular security audits

2. Access Control

- Implement role-based access

- Audit logging

- Regular permission reviews

## Monitoring and Logging

1. Performance Metrics

- Response times

- Success rates

- Error rates

- Resource utilization

2. Logging

- Use structured logging

- Implement log rotation

- Regular log analysis

3. Alerts

- Set up alerting for critical errors

- Monitor resource usage

- Track API rate limits

--------------------------------------------------

# File: swarms/structs/multi_swarm_orchestration.md

# Hierarchical Agent Orchestration Architectures

Hierarchical agent orchestration involves organizing multiple agents in structured layers to efficiently handle complex tasks. There are several key architectures available, each with distinct characteristics and use cases.

Here are the Hierarchical swarms we support:

| Architecture | Strengths | Weaknesses |
|--------------|-----------|------------|
| HHCS | - Clear task routing<br>- Specialized swarm handling<br>- Parallel processing capability<br>- Good for complex multi-domain tasks | - More complex setup<br>- Overhead in routing<br>- Requires careful swarm design |
| Auto Agent Builder | - Dynamic agent creation<br>- Flexible scaling<br>- Self-organizing<br>- Good for evolving tasks | - Higher resource usage<br>- Potential creation overhead<br>- May create redundant agents |
| SwarmRouter | - Multiple workflow types<br>- Simple configuration<br>- Flexible deployment<br>- Good for varied task types | - Less specialized than HHCS<br>- Limited inter-swarm communication<br>- May require manual type selection |



## Core Architectures

### 1. Hybrid Hierarchical-Cluster Swarm (HHCS)

Hybrid Hierarchical-Cluster Swarm (HHCS) is architecture that uses a Router Agent to analyze and distribute tasks to other swarms.

- Tasks are routed to specialized swarms based on their requirements

- Enables parallel processing through multiple specialized swarms

- Ideal for complex, multi-domain tasks and enterprise-scale operations

- Provides clear task routing but requires more complex setup


```mermaid
flowchart TD
    Start([Task Input]) --> RouterAgent[Router Agent]
    RouterAgent --> Analysis{Task Analysis}
    
    Analysis -->|Analyze Requirements| Selection[Swarm Selection]
    Selection -->|Select Best Swarm| Route[Route Task]
    
    Route --> Swarm1[Specialized Swarm 1]
    Route --> Swarm2[Specialized Swarm 2]
    Route --> SwarmN[Specialized Swarm N]
    
    Swarm1 -->|Process| Result1[Output 1]
    Swarm2 -->|Process| Result2[Output 2]
    SwarmN -->|Process| ResultN[Output N]
    
    Result1 --> Final[Final Output]
    Result2 --> Final
    ResultN --> Final
```

### 2. Auto Agent Builder

Auto Agent Builder is a dynamic agent architecture that creates specialized agents on-demand.

- Analyzes tasks and automatically builds appropriate agents for the job

- Maintains an agent pool that feeds into task orchestration

- Best suited for evolving requirements and dynamic workloads

- Self-organizing but may have higher resource usage

```mermaid
flowchart TD
    Task[Task Input] --> Builder[Agent Builder]
    Builder --> Analysis{Task Analysis}
    
    Analysis --> Create[Create Specialized Agents]
    Create --> Pool[Agent Pool]
    
    Pool --> Agent1[Specialized Agent 1]
    Pool --> Agent2[Specialized Agent 2]
    Pool --> AgentN[Specialized Agent N]
    
    Agent1 --> Orchestration[Task Orchestration]
    Agent2 --> Orchestration
    AgentN --> Orchestration
    
    Orchestration --> Result[Final Result]
```

### 3. SwarmRouter


SwarmRouter is a flexible system supporting multiple swarm architectures through a simple interface:

- Sequential workflows

- Concurrent workflows

- Hierarchical swarms

- Group chat interactions

- Simpler to configure and deploy compared to other architectures

- Best for general-purpose tasks and smaller scale operations

- Recommended for 5-20 agents.

```mermaid
flowchart TD
    Input[Task Input] --> Router[Swarm Router]
    Router --> TypeSelect{Swarm Type Selection}
    
    TypeSelect -->|Sequential| Seq[Sequential Workflow]
    TypeSelect -->|Concurrent| Con[Concurrent Workflow]
    TypeSelect -->|Hierarchical| Hier[Hierarchical Swarm]
    TypeSelect -->|Group| Group[Group Chat]
    
    Seq --> Output[Task Output]
    Con --> Output
    Hier --> Output
    Group --> Output
```

## Use Case Recommendations

### **HHCS**: Best for:
   
- Enterprise-scale operations

- Multi-domain problems

- Complex task routing

- Parallel processing needs

###  **Auto Agent Builder**: Best for:

- Dynamic workloads

- Evolving requirements

- Research and development

- Exploratory tasks

### **SwarmRouter**: Best for:

- General purpose tasks

- Quick deployment

- Mixed workflow types

- Smaller scale operations

## Documentation Links

### HHCS Documentation:

- [Hybrid Hierarchical-Cluster Swarm Documentation](https://docs.swarms.world/en/latest/swarms/structs/hhcs/)

- Covers detailed implementation, constructor arguments, and full examples

### Auto Agent Builder Documentation:
   
- [Agent Builder Documentation](https://docs.swarms.world/en/latest/swarms/structs/auto_agent_builder/)

- Includes enterprise use cases, best practices, and integration patterns

3. SwarmRouter Documentation:

- [SwarmRouter Documentation](https://docs.swarms.world/en/latest/swarms/structs/swarm_router/)

- Provides comprehensive API reference, advanced usage, and use cases

## Best Practices for Selection

### **Evaluate Task Complexity**
   
- Simple tasks → SwarmRouter

- Complex, multi-domain tasks → HHCS

- Dynamic, evolving tasks → Auto Agent Builder

### **Consider Scale**
   
- Small scale → SwarmRouter

- Large scale → HHCS

- Variable scale → Auto Agent Builder

### **Resource Availability**
   
- Limited resources → SwarmRouter

- Abundant resources → HHCS or Auto Agent Builder

- Dynamic resources → Auto Agent Builder

### **Development Time**

- Quick deployment → SwarmRouter

- Complex system → HHCS

- Experimental system → Auto Agent Builder


This documentation provides a high-level overview of the main hierarchical agent orchestration architectures available in the system. Each architecture has its own strengths and ideal use cases, and the choice between them should be based on specific project requirements, scale, and complexity.


--------------------------------------------------

# File: swarms/structs/multi_threaded_workflow.md

# MultiThreadedWorkflow Documentation

The `MultiThreadedWorkflow` class represents a multi-threaded workflow designed to execute tasks concurrently using a thread pool. This class is highly useful in scenarios where tasks need to be executed in parallel to improve performance and efficiency. The workflow ensures that tasks are managed in a priority-based queue, and it includes mechanisms for retrying failed tasks and optionally saving task results automatically.

## Class Definition

### `MultiThreadedWorkflow`

## Parameters

| Parameter     | Type                  | Default | Description                                                   |
|---------------|-----------------------|---------|---------------------------------------------------------------|
| `max_workers` | `int`                 | `5`     | The maximum number of worker threads in the thread pool.      |
| `autosave`    | `bool`                | `True`  | Flag indicating whether to automatically save task results.   |
| `tasks`       | `List[PriorityTask]`  | `None`  | List of priority tasks to be executed.                        |
| `retry_attempts` | `int`             | `3`     | The maximum number of retry attempts for failed tasks.        |
| `*args`       | `tuple`               |         | Variable length argument list.                                |
| `**kwargs`    | `dict`                |         | Arbitrary keyword arguments.                                  |

## Attributes

| Attribute        | Type               | Description                                                    |
|------------------|--------------------|----------------------------------------------------------------|
| `max_workers`    | `int`              | The maximum number of worker threads in the thread pool.       |
| `autosave`       | `bool`             | Flag indicating whether to automatically save task results.    |
| `retry_attempts` | `int`              | The maximum number of retry attempts for failed tasks.         |
| `tasks_queue`    | `PriorityQueue`    | The queue that holds the priority tasks.                       |
| `lock`           | `Lock`             | The lock used for thread synchronization.                      |

## Methods

### `run`


#### Description

The `run` method executes the tasks stored in the priority queue using a thread pool. It handles task completion, retries failed tasks up to a specified number of attempts, and optionally saves the results of tasks if the autosave flag is set.

#### Usage Example

```python
from swarms import MultiThreadedWorkflow, PriorityTask, Task

# Define some tasks
tasks = [PriorityTask(task=Task()), PriorityTask(task=Task())]

# Create a MultiThreadedWorkflow instance
workflow = MultiThreadedWorkflow(max_workers=3, autosave=True, tasks=tasks, retry_attempts=2)

# Run the workflow
results = workflow.run()
print(results)
```

### `_autosave_task_result`

#### Description

The `_autosave_task_result` method is responsible for saving the results of a task. It uses a thread lock to ensure that the autosave operation is thread-safe.

#### Usage Example

This method is intended for internal use and is typically called by the `run` method. However, here is an example of how it might be used directly:

```python
# Create a task and result
task = Task()
result = task.run()

# Autosave the result
workflow = MultiThreadedWorkflow()
workflow._autosave_task_result(task, result)
```

## Detailed Functionality and Usage

### Initialization

When an instance of `MultiThreadedWorkflow` is created, it initializes the following:

- **max_workers**: Sets the maximum number of threads that can run concurrently.
- **autosave**: Determines if the task results should be saved automatically.
- **tasks**: Accepts a list of tasks that need to be executed. If no tasks are provided, an empty list is used.
- **retry_attempts**: Sets the maximum number of retry attempts for failed tasks.
- **tasks_queue**: A priority queue to manage tasks based on their priority.
- **lock**: A threading lock to ensure thread-safe operations.

### Running Tasks

The `run` method performs the following steps:

1. **Initialize Results and Executor**: Creates a list to store results and a `ThreadPoolExecutor` to manage the threads.
2. **Submit Tasks**: Iterates over the tasks in the queue, submitting them to the executor for execution and storing the future objects.
3. **Monitor Completion**: Uses the `wait` function to monitor the completion of tasks. Once a task is completed, it retrieves the result or catches exceptions.
4. **Retry Mechanism**: If a task fails, it checks the number of attempts made and retries the task if the limit is not reached.
5. **Autosave**: If the `autosave` flag is set, the `_autosave_task_result` method is called to save the task results.

### Autosave Task Result

The `_autosave_task_result` method handles the saving of task results. It uses a threading lock to ensure that the save operation is not interrupted by other threads.

## Additional Information and Tips

- **Thread Safety**: The use of threading locks ensures that the operations are thread-safe, preventing race conditions.
- **Logging**: The class uses the logging module to log information about task completion, retries, and failures.
- **Error Handling**: The retry mechanism helps in handling transient errors by attempting to re-execute failed tasks.

## References and Resources

For more information on threading and concurrent execution in Python, refer to the following resources:

- [Python Threading Documentation](https://docs.python.org/3/library/threading.html)
- [Python Concurrent Futures Documentation](https://docs.python.org/3/library/concurrent.futures.html)


--------------------------------------------------

# File: swarms/structs/round_robin_swarm.md

# RoundRobin: Round-Robin Task Execution in a Swarm

## Introduction

The `RoundRobinSwarm` class is designed to manage and execute tasks among multiple agents in a round-robin fashion. This approach ensures that each agent in a swarm receives an equal opportunity to execute tasks, which promotes fairness and efficiency in distributed systems. It is particularly useful in environments where collaborative, sequential task execution is needed among various agents.

## Conceptual Overview

### What is Round-Robin?

Round-robin is a scheduling technique commonly used in computing for managing processes in shared systems. It involves assigning a fixed time slot to each process and cycling through all processes in a circular order without prioritization. In the context of swarms of agents, this method ensures equitable distribution of tasks and resource usage among all agents.

### Application in Swarms

In swarms, `RoundRobinSwarm` utilizes the round-robin scheduling to manage tasks among agents like software components, autonomous robots, or virtual entities. This strategy is beneficial where tasks are interdependent or require sequential processing.

## Class Attributes

- `agents (List[Agent])`: List of agents participating in the swarm.
- `verbose (bool)`: Enables or disables detailed logging of swarm operations.
- `max_loops (int)`: Limits the number of times the swarm cycles through all agents.
- `index (int)`: Maintains the current position in the agent list to ensure round-robin execution.

## Methods

### `__init__`

Initializes the swarm with the provided list of agents, verbosity setting, and operational parameters.

**Parameters:**
- `agents`: Optional list of agents in the swarm.
- `verbose`: Boolean flag for detailed logging.
- `max_loops`: Maximum number of execution cycles.
- `callback`: Optional function called after each loop.

### `run`

Executes a specified task across all agents in a round-robin manner, cycling through each agent repeatedly for the number of specified loops.

**Conceptual Behavior:**
- Distribute the task sequentially among all agents starting from the current index.
- Each agent processes the task and potentially modifies it or produces new output.
- After an agent completes its part of the task, the index moves to the next agent.
- This cycle continues until the specified maximum number of loops is completed.
- Optionally, a callback function can be invoked after each loop to handle intermediate results or perform additional actions.

## Examples
### Example 1: Load Balancing Among Servers

In this example, `RoundRobinSwarm` is used to distribute network requests evenly among a group of servers. This is common in scenarios where load balancing is crucial for maintaining system responsiveness and scalability.

```python
from swarms import Agent, RoundRobinSwarm
from swarm_models import OpenAIChat


# Initialize the LLM
llm = OpenAIChat()

# Define sales agents
sales_agent1 = Agent(
    agent_name="Sales Agent 1 - Automation Specialist",
    system_prompt="You're Sales Agent 1, your purpose is to generate sales for a company by focusing on the benefits of automating accounting processes!",
    agent_description="Generate sales by focusing on the benefits of automation!",
    llm=llm,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    context_length=1000,
)

sales_agent2 = Agent(
    agent_name="Sales Agent 2 - Cost Saving Specialist",
    system_prompt="You're Sales Agent 2, your purpose is to generate sales for a company by emphasizing the cost savings of using swarms of agents!",
    agent_description="Generate sales by emphasizing cost savings!",
    llm=llm,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    context_length=1000,
)

sales_agent3 = Agent(
    agent_name="Sales Agent 3 - Efficiency Specialist",
    system_prompt="You're Sales Agent 3, your purpose is to generate sales for a company by highlighting the efficiency and accuracy of our swarms of agents in accounting processes!",
    agent_description="Generate sales by highlighting efficiency and accuracy!",
    llm=llm,
    max_loops=1,
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    context_length=1000,
)

# Initialize the swarm with sales agents
sales_swarm = RoundRobinSwarm(agents=[sales_agent1, sales_agent2, sales_agent3], verbose=True)

# Define a sales task
task = "Generate a sales email for an accountant firm executive to sell swarms of agents to automate their accounting processes."

# Distribute sales tasks to different agents
for _ in range(5):  # Repeat the task 5 times
    results = sales_swarm.run(task)
    print("Sales generated:", results)
```



## Conclusion

The RoundRobinSwarm class provides a robust and flexible framework for managing tasks among multiple agents in a fair and efficient manner. This class is especially useful in environments where tasks need to be distributed evenly among a group of agents, ensuring that all tasks are handled timely and effectively. Through the round-robin algorithm, each agent in the swarm is guaranteed an equal opportunity to contribute to the overall task, promoting efficiency and collaboration.


--------------------------------------------------

# File: swarms/structs/sequential_workflow.md

# SequentialWorkflow Documentation

**Overview:**
A Sequential Swarm architecture processes tasks in a linear sequence. Each agent completes its task before passing the result to the next agent in the chain. This architecture ensures orderly processing and is useful when tasks have dependencies. [Learn more here in the docs:](https://docs.swarms.world/en/latest/swarms/structs/agent_rearrange/)

**Use-Cases:**

- Workflows where each step depends on the previous one, such as assembly lines or sequential data processing.

- Scenarios requiring strict order of operations.

```mermaid
graph TD
    A[First Agent] --> B[Second Agent]
    B --> C[Third Agent]
    C --> D[Fourth Agent]
```

## Attributes

| Attribute        | Type          | Description                                      |
|------------------|---------------|--------------------------------------------------|
| `agents`         | `List[Agent]` | The list of agents in the workflow.              |
| `flow`           | `str`         | A string representing the order of agents.       |
| `agent_rearrange`| `AgentRearrange` | Manages the dynamic execution of agents.        |

## Methods

### `__init__(self, agents: List[Agent] = None, max_loops: int = 1, *args, **kwargs)`

The constructor initializes the `SequentialWorkflow` object.

- **Parameters:**
  - `agents` (`List[Agent]`, optional): The list of agents in the workflow. Defaults to `None`.
  - `max_loops` (`int`, optional): The maximum number of loops to execute the workflow. Defaults to `1`.
  - `*args`: Variable length argument list.
  - `**kwargs`: Arbitrary keyword arguments.

### `run(self, task: str) -> str`

Runs the specified task through the agents in the dynamically constructed flow.

- **Parameters:**
  - `task` (`str`): The task for the agents to execute.

- **Returns:**
  - `str`: The final result after processing through all agents.

## **Usage Example:**

```python

from swarms import Agent, SequentialWorkflow

# Initialize agents for individual tasks
agent1 = Agent(
  agent_name="ICD-10 Code Analyzer",
  system_prompt="Analyze medical data and provide relevant ICD-10 codes.",
  model_name="gpt-4o",
  max_loops=1,
)
agent2 = Agent(
  agent_name="ICD-10 Code Summarizer",
  system_prompt="Summarize the findings and suggest ICD-10 codes.",
  model_name="gpt-4o",
  max_loops=1,
)

# Create the Sequential workflow
workflow = SequentialWorkflow(
  agents=[agent1, agent2], max_loops=1, verbose=False
)

# Run the workflow
workflow.run(
  "Analyze the medical report and provide the appropriate ICD-10 codes."
)

```

This example initializes a `SequentialWorkflow` with three agents and executes a task, printing the final result.

##  **Notes:**

- Logs the task execution process and handles any exceptions that occur during the task execution.

### Logging and Error Handling

The `run` method includes logging to track the execution flow and captures errors to provide detailed information in case of failures. This is crucial for debugging and ensuring smooth operation of the workflow.

## Additional Tips

- Ensure that the agents provided to the `SequentialWorkflow` are properly initialized and configured to handle the tasks they will receive.

- The `max_loops` parameter can be used to control how many times the workflow should be executed, which is useful for iterative processes.

- Utilize the logging information to monitor and debug the task execution process.


--------------------------------------------------

# File: swarms/structs/spreadsheet_swarm.md

# SpreadSheetSwarm Documentation

---

## Class Definition

```python
class SpreadSheetSwarm:
```

## Full Path

```python
from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm
```

### Attributes

The `SpreadSheetSwarm` class contains several attributes that define its behavior and configuration. These attributes are initialized in the constructor (`__init__` method) and are used throughout the class to manage the swarm's operations.

| Attribute          | Type                              | Description                                                                                 |
|--------------------|-----------------------------------|---------------------------------------------------------------------------------------------|
| `name`             | `str`                             | The name of the swarm.                                                                      |
| `description`      | `str`                             | A description of the swarm's purpose.                                                       |
| `agents`           | `Union[Agent, List[Agent]]`       | The agents participating in the swarm. Can be a single agent or a list of agents.           |
| `autosave_on`      | `bool`                            | Flag indicating whether autosave is enabled.                                                |
| `save_file_path`   | `str`                             | The file path where the swarm data will be saved.                                           |
| `task_queue`       | `queue.Queue`                     | The queue that stores tasks to be processed by the agents.                                  |
| `lock`             | `threading.Lock`                  | A lock used for thread synchronization to prevent race conditions.                          |
| `metadata`         | `SwarmRunMetadata`                | Metadata for the swarm run, including start time, end time, tasks completed, and outputs.   |
| `run_all_agents`   | `bool`                            | Flag indicating whether to run all agents or just one.                                      |
| `max_loops`     | `int`                             | The number of times to repeat the task.                                                     |
| `workspace_dir`    | `str`                             | The directory where the workspace is located, retrieved from environment variables.         |

### Parameters

- **`name`** (`str`, optional): The name of the swarm. Default is `"Spreadsheet-Swarm"`.
- **`description`** (`str`, optional): A brief description of the swarm. Default is `"A swarm that processes tasks from a queue using multiple agents on different threads."`.
- **`agents`** (`Union[Agent, List[Agent]]`, optional): The agents participating in the swarm. Default is an empty list.
- **`autosave_on`** (`bool`, optional): A flag to indicate if autosave is enabled. Default is `True`.
- **`save_file_path`** (`str`, optional): The file path where swarm data will be saved. Default is `"spreedsheet_swarm.csv"`.
- **`run_all_agents`** (`bool`, optional): Flag to determine if all agents should run. Default is `True`.
- **`max_loops`** (`int`, optional): The number of times to repeat the task. Default is `1`.
- **`workspace_dir`** (`str`, optional): The directory where the workspace is located. Default is retrieved from environment variable `WORKSPACE_DIR`.

### Constructor (`__init__`)

The constructor initializes the `SpreadSheetSwarm` with the provided parameters. It sets up the task queue, locks for thread synchronization, and initializes the metadata.

---

## Methods

### `reliability_check`

```python
def reliability_check(self):
```

#### Description

The `reliability_check` method performs a series of checks to ensure that the swarm is properly configured before it begins processing tasks. It verifies that there are agents available and that a valid file path is provided for saving the swarm's data. If any of these checks fail, an exception is raised.

#### Raises

- **`ValueError`**: Raised if no agents are provided or if no save file path is specified.

#### Example

```python
swarm = SpreadSheetSwarm(agents=[agent1, agent2])
swarm.reliability_check()
```

---

### `run`

```python
def run(self, task: str, *args, **kwargs):
```

#### Description

The `run` method starts the task processing using the swarm. Depending on the configuration, it can either run all agents or a specific subset of them. The method tracks the start and end times of the task, executes the task multiple times if specified, and logs the results.

#### Parameters

- **`task`** (`str`): The task to be executed by the swarm.
- **`*args`**: Additional positional arguments to pass to the agents.
- **`**kwargs`**: Additional keyword arguments to pass to the agents.

#### Example

```python
swarm = SpreadSheetSwarm(agents=[agent1, agent2])
swarm.run("Process Data")
```

---

### `export_to_json`

```python
def export_to_json(self):
```

#### Description

The `export_to_json` method generates a JSON representation of the swarm's metadata. This can be useful for exporting the results to an external system or for logging purposes.

#### Returns

- **`str`**: The JSON representation of the swarm's metadata.

#### Example

```python
json_data = swarm.export_to_json()
print(json_data)
```

---

### `data_to_json_file`

```python
def data_to_json_file(self):
```

#### Description

The `data_to_json_file` method saves the swarm's metadata as a JSON file in the specified workspace directory. The file name is generated using the swarm's name and run ID.

#### Example

```python
swarm.data_to_json_file()
```

---

### `_track_output`

```python
def _track_output(self, agent: Agent, task: str, result: str):
```

#### Description

The `_track_output` method is used internally to record the results of tasks executed by the agents. It updates the metadata with the completed tasks and their results.

#### Parameters

- **`agent`** (`Agent`): The agent that executed the task.
- **`task`** (`str`): The task that was executed.
- **`result`** (`str`): The result of the task execution.

#### Example

```python
swarm._track_output(agent1, "Process Data", "Success")
```

---

### `_save_to_csv`

```python
def _save_to_csv(self):
```

#### Description

The `_save_to_csv` method saves the swarm's metadata to a CSV file. It logs each task and its result before writing them to the file. The file is saved in the location specified by `save_file_path`.

#### Example

```python
swarm._save_to_csv()
```

---

## Usage Examples

### Example 1: Basic Swarm Initialization

```python
import os

from swarms import Agent
from swarm_models import OpenAIChat
from swarms.prompts.finance_agent_sys_prompt import (
    FINANCIAL_AGENT_SYS_PROMPT,
)
from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm

# Example usage:
api_key = os.getenv("OPENAI_API_KEY")

# Model
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)


# Initialize your agents (assuming the Agent class and model are already defined)
agents = [
    Agent(
        agent_name=f"Financial-Analysis-Agent-spreesheet-swarm:{i}",
        system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="finance_agent.json",
        user_name="swarms_corp",
        retry_attempts=1,
    )
    for i in range(10)
]

# Create a Swarm with the list of agents
swarm = SpreadSheetSwarm(
    name="Finance-Spreadsheet-Swarm",
    description="A swarm that processes tasks from a queue using multiple agents on different threads.",
    agents=agents,
    autosave_on=True,
    save_file_path="financial_spreed_sheet_swarm_demo.csv",
    run_all_agents=False,
    max_loops=1,
)

# Run the swarm
swarm.run(
    task="Analyze the states with the least taxes for LLCs. Provide an overview of all tax rates and add them with a comprehensive analysis"
)

```

### Example 2: QR Code Generator

```python
import os
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm

# Define custom system prompts for QR code generation
QR_CODE_AGENT_1_SYS_PROMPT = """
You are a Python coding expert. Your task is to write a Python script to generate a QR code for the link: https://lu.ma/jjc1b2bo. The code should save the QR code as an image file.
"""

QR_CODE_AGENT_2_SYS_PROMPT = """
You are a Python coding expert. Your task is to write a Python script to generate a QR code for the link: https://github.com/The-Swarm-Corporation/Cookbook. The code should save the QR code as an image file.
"""

# Example usage:
api_key = os.getenv("OPENAI_API_KEY")

# Model
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)

# Initialize your agents for QR code generation
agents = [
    Agent(
        agent_name="QR-Code-Generator-Agent-Luma",
        system_prompt=QR_CODE_AGENT_1_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="qr_code_agent_luma.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="QR-Code-Generator-Agent-Cookbook",
        system_prompt=QR_CODE_AGENT_2_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="qr_code_agent_cookbook.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
]

# Create a Swarm with the list of agents
swarm = SpreadSheetSwarm(
    name="QR-Code-Generation-Swarm",
    description="A swarm that generates Python scripts to create QR codes for specific links.",
    agents=agents,
    autosave_on=True,
    save_file_path="qr_code_generation_results.csv",
    run_all_agents=False,
    max_loops=1,
)

# Run the swarm
swarm.run(
    task="Generate Python scripts to create QR codes for the provided links and save them as image files."
)
```


## Example 3: Social Media Marketing

```python

import os
from swarms import Agent
from swarm_models import OpenAIChat
from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm

# Define custom system prompts for each social media platform
TWITTER_AGENT_SYS_PROMPT = """
You are a Twitter marketing expert. Your task is to create engaging, concise tweets and analyze trends to maximize engagement. Consider hashtags, timing, and content relevance.
"""

INSTAGRAM_AGENT_SYS_PROMPT = """
You are an Instagram marketing expert. Your task is to create visually appealing and engaging content, including captions and hashtags, tailored to a specific audience.
"""

FACEBOOK_AGENT_SYS_PROMPT = """
You are a Facebook marketing expert. Your task is to craft posts that are optimized for engagement and reach on Facebook, including using images, links, and targeted messaging.
"""

EMAIL_AGENT_SYS_PROMPT = """
You are an Email marketing expert. Your task is to write compelling email campaigns that drive conversions, focusing on subject lines, personalization, and call-to-action strategies.
"""

# Example usage:
api_key = os.getenv("OPENAI_API_KEY")

# Model
model = OpenAIChat(
    openai_api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)

# Initialize your agents for different social media platforms
agents = [
    Agent(
        agent_name="Twitter-Marketing-Agent",
        system_prompt=TWITTER_AGENT_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="twitter_agent.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Instagram-Marketing-Agent",
        system_prompt=INSTAGRAM_AGENT_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="instagram_agent.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Facebook-Marketing-Agent",
        system_prompt=FACEBOOK_AGENT_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="facebook_agent.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
    Agent(
        agent_name="Email-Marketing-Agent",
        system_prompt=EMAIL_AGENT_SYS_PROMPT,
        llm=model,
        max_loops=1,
        dynamic_temperature_enabled=True,
        saved_state_path="email_agent.json",
        user_name="swarms_corp",
        retry_attempts=1,
    ),
]

# Create a Swarm with the list of agents
swarm = SpreadSheetSwarm(
    name="Social-Media-Marketing-Swarm",
    description="A swarm that processes social media marketing tasks using multiple agents on different threads.",
    agents=agents,
    autosave_on=True,
    save_file_path="social_media_marketing_spreadsheet.csv",
    run_all_agents=False,
    max_loops=2,
)

# Run the swarm
swarm.run(
    task="Create posts to promote hack nights in miami beach for developers, engineers, and tech enthusiasts. Include relevant hashtags, images, and engaging captions."
)
```

---

## Additional Information and Tips

- **Thread Synchronization**: When working with multiple agents in a concurrent environment, it's crucial to ensure that access to shared resources is properly synchronized using locks to avoid race conditions.

- **Autosave Feature**: If you enable the `autosave_on` flag, ensure that the file path provided is correct and writable. This feature is handy for long-running tasks where you want to periodically save the state.

- **Error Handling**

: Implementing proper error handling within your agents can prevent the swarm from crashing during execution. Consider catching exceptions in the `run` method and logging errors appropriately.

- **Custom Agents**: You can extend the `Agent` class to create custom agents that perform specific tasks tailored to your application's needs.

---

## References and Resources

- [Python's `queue` module](https://docs.python.org/3/library/queue.html)
- [Python's `threading` module](https://docs.python.org/3/library/threading.html)
- [CSV File Handling in Python](https://docs.python.org/3/library/csv.html)
- [JSON Handling in Python](https://docs.python.org/3/library/json.html)



--------------------------------------------------

# File: swarms/structs/swarm_network.md

# SwarmNetwork [WIP]

The `SwarmNetwork` class is a powerful tool for managing a pool of agents, orchestrating task distribution, and scaling resources based on workload. It is designed to handle tasks efficiently by dynamically adjusting the number of agents according to the current demand. This class also provides an optional API for interacting with the agent pool, making it accessible for integration with other systems.

### Key Features
- **Agent Pool Management**: Dynamically manage a pool of agents.
- **Task Queue Management**: Handle tasks through a queue system.
- **Agent Health Monitoring**: Monitor the health of agents.
- **Agent Pool Scaling**: Scale the agent pool up or down based on workload.
- **API**: Interact with the agent pool and task queue through a simple API.
- **Agent Deployment Options**: Run agents on threads, processes, containers, machines, or clusters.

### Parameters

| Parameter       | Type               | Default Value | Description                                                                 |
|-----------------|--------------------|---------------|-----------------------------------------------------------------------------|
| name            | str                | None          | The name of the swarm network.                                              |
| description     | str                | None          | A description of the swarm network.                                         |
| agents          | List[Agent]        | None          | A list of agents in the pool.                                               |
| idle_threshold  | float              | 0.2           | The idle threshold for the agents.                                          |
| busy_threshold  | float              | 0.7           | The busy threshold for the agents.                                          |
| api_enabled     | Optional[bool]     | False         | A flag to enable/disable the API.                                           |
| logging_enabled | Optional[bool]     | False         | A flag to enable/disable logging.                                           |
| api_on          | Optional[bool]     | False         | A flag to enable/disable the FastAPI instance.                              |
| host            | str                | "0.0.0.0"     | The host address for the FastAPI instance.                                  |
| port            | int                | 8000          | The port number for the FastAPI instance.                                   |
| swarm_callable  | Optional[callable] | None          | A callable to be executed by the swarm network.                             |
| *args           | tuple              |               | Additional positional arguments.                                            |
| **kwargs        | dict               |               | Additional keyword arguments.                                               |

### Attributes

| Attribute        | Type               | Description                                                    |
|------------------|--------------------|----------------------------------------------------------------|
| task_queue       | queue.Queue        | A queue for storing tasks.                                     |
| idle_threshold   | float              | The idle threshold for the agents.                             |
| busy_threshold   | float              | The busy threshold for the agents.                             |
| agents           | List[Agent]        | A list of agents in the pool.                                  |
| api_enabled      | bool               | A flag to enable/disable the API.                              |
| logging_enabled  | bool               | A flag to enable/disable logging.                              |
| host             | str                | The host address for the FastAPI instance.                     |
| port             | int                | The port number for the FastAPI instance.                      |
| swarm_callable   | Optional[callable] | A callable to be executed by the swarm network.                |
| agent_dict       | dict               | A dictionary of agents for easy access.                        |
| lock             | threading.Lock     | A lock for synchronizing access to shared resources.           |

## Methods

#### Description
Initializes a new instance of the `SwarmNetwork` class.

#### Parameters
- `name` (str): The name of the swarm network.
- `description` (str): A description of the swarm network.
- `agents` (List[Agent]): A list of agents in the pool.
- `idle_threshold` (float): The idle threshold for the agents.
- `busy_threshold` (float): The busy threshold for the agents.
- `api_enabled` (Optional[bool]): A flag to enable/disable the API.
- `logging_enabled` (Optional[bool]): A flag to enable/disable logging.
- `api_on` (Optional[bool]): A flag to enable/disable the FastAPI instance.
- `host` (str): The host address for the FastAPI instance.
- `port` (int): The port number for the FastAPI instance.
- `swarm_callable` (Optional[callable]): A callable to be executed by the swarm network.
- `*args`: Additional positional arguments.
- `**kwargs`: Additional keyword arguments.

### `add_task`

```python
def add_task(self, task)
```

#### Description
Adds a task to the task queue.

#### Parameters
- `task` (_type_): The task to be added to the queue.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

agent = Agent()
swarm = SwarmNetwork(agents=[agent])
swarm.add_task("task")
```

### `async_add_task`

```python
async def async_add_task(self, task)
```

#### Description
Adds a task to the task queue asynchronously.

#### Parameters
- `task` (_type_): The task to be added to the queue.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

agent = Agent()
swarm = SwarmNetwork(agents=[agent])
await swarm.async_add_task("task")
```

### `run_single_agent`

```python
def run_single_agent(self, agent_id, task: Optional[str], *args, **kwargs)
```

#### Description
Runs a task on a specific agent by ID.

#### Parameters
- `agent_id` (_type_): The ID of the agent.
- `task` (str, optional): The task to be executed by the agent.
- `*args`: Additional positional arguments.
- `**kwargs`: Additional keyword arguments.

#### Returns
- `_type_`: The output of the agent running the task.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
result = swarm.run_single_agent(agent.id, "task")
```

### `run_many_agents`

```python
def run_many_agents(self, task: Optional[str] = None, *args, **kwargs) -> List
```

#### Description
Runs a task on all agents in the pool.

#### Parameters
- `task` (str, optional): The task to be executed by the agents.
- `*args`: Additional positional arguments.
- `**kwargs`: Additional keyword arguments.

#### Returns
- `List`: The output of all agents running the task.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)


swarm = SwarmNetwork(agents=[agent1, agent2])
results = swarm.run_many_agents("task")
```

### `list_agents`

```python
def list_agents(self)
```

#### Description
Lists all agents in the pool.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
swarm.list_agents()
```

### `get_agent`

```python
def get_agent(self, agent_id)
```

#### Description
Gets an agent by ID.

#### Parameters
- `agent_id` (_type_): The ID of the agent to retrieve.

#### Returns
- `_type_`: The agent with the specified ID.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
retrieved_agent = swarm.get_agent(agent.id)
```

### `add_agent`

```python
def add_agent(self, agent: Agent)
```

#### Description
Adds an agent to the agent pool.

#### Parameters
- `agent` (_type_): The agent to be added to the pool.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[])
swarm.add_agent(agent)
```

### `remove_agent`

```python
def remove_agent(self, agent_id)
```

#### Description
Removes an agent from the agent pool.

#### Parameters
- `agent_id` (_type_): The ID of the agent to be removed.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
swarm.remove_agent(agent.id)
```

### `

async_remove_agent`

```python
async def async_remove_agent(self, agent_id)
```

#### Description
Removes an agent from the agent pool asynchronously.

#### Parameters
- `agent_id` (_type_): The ID of the agent to be removed.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
await swarm.async_remove_agent(agent.id)
```

### `scale_up`

```python
def scale_up(self, num_agents: int = 1)
```

#### Description
Scales up the agent pool by adding new agents.

#### Parameters
- `num_agents` (int, optional): The number of agents to add. Defaults to 1.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)

swarm = SwarmNetwork(agents=[agent])
swarm.scale_up(2)
```

### `scale_down`

```python
def scale_down(self, num_agents: int = 1)
```

#### Description
Scales down the agent pool by removing agents.

#### Parameters
- `num_agents` (int, optional): The number of agents to remove. Defaults to 1.

#### Example

```python
from swarms.structs.agent import Agent
from swarms.structs.swarm_net import SwarmNetwork

# Initialize the agent
agent2 = Agent(
    agent_name="ROTH-IRA-AGENT",
    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,
    llm=model,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    interactive=True,
    # interactive=True, # Set to False to disable interactive mode
    saved_state_path="finance_agent.json",
    # tools=[Add your functions here# ],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)


swarm = SwarmNetwork(agents=[agent])
swarm.scale_down(1)
```

### `run`

#### Description
Runs the swarm network, starting the FastAPI application.

#### Example

```python

import os

from dotenv import load_dotenv

# Import the OpenAIChat model and the Agent struct
from swarms import Agent, OpenAIChat, SwarmNetwork

# Load the environment variables
load_dotenv()

# Get the API key from the environment
api_key = os.environ.get("OPENAI_API_KEY")

# Initialize the language model
llm = OpenAIChat(
    temperature=0.5,
    openai_api_key=api_key,
)

## Initialize the workflow
agent = Agent(llm=llm, max_loops=1, agent_name="Social Media Manager")
agent2 = Agent(llm=llm, max_loops=1, agent_name=" Product Manager")
agent3 = Agent(llm=llm, max_loops=1, agent_name="SEO Manager")


# Load the swarmnet with the agents
swarmnet = SwarmNetwork(
    agents=[agent, agent2, agent3],
)

# List the agents in the swarm network
out = swarmnet.list_agents()
print(out)

# Run the workflow on a task
out = swarmnet.run_single_agent(
    agent2.id, "Generate a 10,000 word blog on health and wellness."
)
print(out)


# Run all the agents in the swarm network on a task
out = swarmnet.run_many_agents("Generate a 10,000 word blog on health and wellness.")
print(out)
```

## Additional Information and Tips

- **Error Handling**: Make use of try-except blocks to handle potential errors when adding tasks, running tasks, and managing agents.
- **Logging**: Enable logging to track the activity and status of the swarm network.
- **API**: The provided API allows for easy interaction with the swarm network and can be extended as needed.
- **Asynchronous Operations**: Utilize the asynchronous methods for non-blocking operations, especially in a production environment.
- **Scaling**: Adjust the scaling thresholds (`idle_threshold` and `busy_threshold`) based on the specific needs and workload patterns.

## References and Resources

- [Python Queue Documentation](https://docs.python.org/3/library/queue.html)
- [Threading in Python](https://docs.python.org/3/library/threading.html)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Tenacity Documentation](https://tenacity.readthedocs.io/en/latest/)

By following this documentation, users can effectively manage and utilize the `SwarmNetwork` class to handle dynamic workloads and maintain an efficient pool of agents.


--------------------------------------------------

# File: swarms/structs/swarm_rearrange.md

# SwarmRearrange Documentation

SwarmRearrange is a class for orchestrating multiple swarms in a sequential or parallel flow pattern. It provides thread-safe operations for managing swarm execution, history tracking, and flow validation.

## Constructor Arguments

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| id | str | UUID | Unique identifier for the swarm arrangement |
| name | str | "SwarmRearrange" | Name of the swarm arrangement |
| description | str | "A swarm of swarms..." | Description of the arrangement |
| swarms | List[Any] | [] | List of swarm objects to be managed |
| flow | str | None | Flow pattern for swarm execution |
| max_loops | int | 1 | Maximum number of execution loops |
| verbose | bool | True | Enable detailed logging |
| human_in_the_loop | bool | False | Enable human intervention |
| custom_human_in_the_loop | Callable | None | Custom function for human interaction |
| return_json | bool | False | Return results in JSON format |

## Methods

### add_swarm(swarm: Any)
Adds a single swarm to the arrangement.

### remove_swarm(swarm_name: str) 
Removes a swarm by name from the arrangement.

### add_swarms(swarms: List[Any])
Adds multiple swarms to the arrangement.

### validate_flow()
Validates the flow pattern syntax and swarm names.

### run(task: str = None, img: str = None, custom_tasks: Dict[str, str] = None)
Executes the swarm arrangement according to the flow pattern.

## Flow Pattern Syntax
The flow pattern uses arrow notation (`->`) to define execution order:

- Sequential: `"SwarmA -> SwarmB -> SwarmC"`
- Parallel: `"SwarmA, SwarmB -> SwarmC"`
- Human intervention: Use `"H"` in the flow

## Examples

### Basic Sequential Flow

```python
from swarms.structs.swarm_arange import SwarmRearrange
import os
from swarms import Agent, AgentRearrange
from swarm_models import OpenAIChat

# model = Anthropic(anthropic_api_key=os.getenv("ANTHROPIC_API_KEY"))
company = "TGSC"

# Get the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Model
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)


# Initialize the Managing Director agent
managing_director = Agent(
    agent_name="Managing-Director",
    system_prompt=f"""
    As the Managing Director at Blackstone, your role is to oversee the entire investment analysis process for potential acquisitions. 
    Your responsibilities include:
    1. Setting the overall strategy and direction for the analysis
    2. Coordinating the efforts of the various team members and ensuring a comprehensive evaluation
    3. Reviewing the findings and recommendations from each team member
    4. Making the final decision on whether to proceed with the acquisition
    
    For the current potential acquisition of {company}, direct the tasks for the team to thoroughly analyze all aspects of the company, including its financials, industry position, technology, market potential, and regulatory compliance. Provide guidance and feedback as needed to ensure a rigorous and unbiased assessment.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="managing-director.json",
)

# Initialize the Vice President of Finance
vp_finance = Agent(
    agent_name="VP-Finance",
    system_prompt=f"""
    As the Vice President of Finance at Blackstone, your role is to lead the financial analysis of potential acquisitions. 
    For the current potential acquisition of {company}, your tasks include:
    1. Conducting a thorough review of {company}' financial statements, including income statements, balance sheets, and cash flow statements
    2. Analyzing key financial metrics such as revenue growth, profitability margins, liquidity ratios, and debt levels
    3. Assessing the company's historical financial performance and projecting future performance based on assumptions and market conditions
    4. Identifying any financial risks or red flags that could impact the acquisition decision
    5. Providing a detailed report on your findings and recommendations to the Managing Director

    Be sure to consider factors such as the sustainability of {company}' business model, the strength of its customer base, and its ability to generate consistent cash flows. Your analysis should be data-driven, objective, and aligned with Blackstone's investment criteria.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="vp-finance.json",
)

# Initialize the Industry Analyst
industry_analyst = Agent(
    agent_name="Industry-Analyst",
    system_prompt=f"""
    As the Industry Analyst at Blackstone, your role is to provide in-depth research and analysis on the industries and markets relevant to potential acquisitions.
    For the current potential acquisition of {company}, your tasks include:
    1. Conducting a comprehensive analysis of the industrial robotics and automation solutions industry, including market size, growth rates, key trends, and future prospects
    2. Identifying the major players in the industry and assessing their market share, competitive strengths and weaknesses, and strategic positioning 
    3. Evaluating {company}' competitive position within the industry, including its market share, differentiation, and competitive advantages
    4. Analyzing the key drivers and restraints for the industry, such as technological advancements, labor costs, regulatory changes, and economic conditions
    5. Identifying potential risks and opportunities for {company} based on the industry analysis, such as disruptive technologies, emerging markets, or shifts in customer preferences  
    
    Your analysis should provide a clear and objective assessment of the attractiveness and future potential of the industrial robotics industry, as well as {company}' positioning within it. Consider both short-term and long-term factors, and provide evidence-based insights to inform the investment decision.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="industry-analyst.json",
)

# Initialize the Technology Expert
tech_expert = Agent(
    agent_name="Tech-Expert",
    system_prompt=f"""
    As the Technology Expert at Blackstone, your role is to assess the technological capabilities, competitive advantages, and potential risks of companies being considered for acquisition.
    For the current potential acquisition of {company}, your tasks include:
    1. Conducting a deep dive into {company}' proprietary technologies, including its robotics platforms, automation software, and AI capabilities 
    2. Assessing the uniqueness, scalability, and defensibility of {company}' technology stack and intellectual property
    3. Comparing {company}' technologies to those of its competitors and identifying any key differentiators or technology gaps
    4. Evaluating {company}' research and development capabilities, including its innovation pipeline, engineering talent, and R&D investments
    5. Identifying any potential technology risks or disruptive threats that could impact {company}' long-term competitiveness, such as emerging technologies or expiring patents
    
    Your analysis should provide a comprehensive assessment of {company}' technological strengths and weaknesses, as well as the sustainability of its competitive advantages. Consider both the current state of its technology and its future potential in light of industry trends and advancements.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="tech-expert.json",
)

# Initialize the Market Researcher
market_researcher = Agent(
    agent_name="Market-Researcher",
    system_prompt=f"""
    As the Market Researcher at Blackstone, your role is to analyze the target company's customer base, market share, and growth potential to assess the commercial viability and attractiveness of the potential acquisition.
    For the current potential acquisition of {company}, your tasks include:
    1. Analyzing {company}' current customer base, including customer segmentation, concentration risk, and retention rates
    2. Assessing {company}' market share within its target markets and identifying key factors driving its market position
    3. Conducting a detailed market sizing and segmentation analysis for the industrial robotics and automation markets, including identifying high-growth segments and emerging opportunities
    4. Evaluating the demand drivers and sales cycles for {company}' products and services, and identifying any potential risks or limitations to adoption
    5. Developing financial projections and estimates for {company}' revenue growth potential based on the market analysis and assumptions around market share and penetration
    
    Your analysis should provide a data-driven assessment of the market opportunity for {company} and the feasibility of achieving our investment return targets. Consider both bottom-up and top-down market perspectives, and identify any key sensitivities or assumptions in your projections.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="market-researcher.json",
)

# Initialize the Regulatory Specialist
regulatory_specialist = Agent(
    agent_name="Regulatory-Specialist",
    system_prompt=f"""
    As the Regulatory Specialist at Blackstone, your role is to identify and assess any regulatory risks, compliance requirements, and potential legal liabilities associated with potential acquisitions.
    For the current potential acquisition of {company}, your tasks include:  
    1. Identifying all relevant regulatory bodies and laws that govern the operations of {company}, including industry-specific regulations, labor laws, and environmental regulations
    2. Reviewing {company}' current compliance policies, procedures, and track record to identify any potential gaps or areas of non-compliance
    3. Assessing the potential impact of any pending or proposed changes to relevant regulations that could affect {company}' business or create additional compliance burdens
    4. Evaluating the potential legal liabilities and risks associated with {company}' products, services, and operations, including product liability, intellectual property, and customer contracts
    5. Providing recommendations on any regulatory or legal due diligence steps that should be taken as part of the acquisition process, as well as any post-acquisition integration considerations
    
    Your analysis should provide a comprehensive assessment of the regulatory and legal landscape surrounding {company}, and identify any material risks or potential deal-breakers. Consider both the current state and future outlook, and provide practical recommendations to mitigate identified risks.
    """,
    llm=model,
    max_loops=1,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    state_save_file_type="json",
    saved_state_path="regulatory-specialist.json",
)

# Create a list of agents
agents = [
    managing_director,
    vp_finance,
    industry_analyst,
    tech_expert,
    market_researcher,
    regulatory_specialist,
]

# Define multiple flow patterns
flows = [
    "Industry-Analyst -> Tech-Expert -> Market-Researcher -> Regulatory-Specialist -> Managing-Director -> VP-Finance",
    "Managing-Director -> VP-Finance -> Industry-Analyst -> Tech-Expert -> Market-Researcher -> Regulatory-Specialist",
    "Tech-Expert -> Market-Researcher -> Regulatory-Specialist -> Industry-Analyst -> Managing-Director -> VP-Finance",
]

# Create instances of AgentRearrange for each flow pattern
blackstone_acquisition_analysis = AgentRearrange(
    name="Blackstone-Acquisition-Analysis",
    description="A system for analyzing potential acquisitions",
    agents=agents,
    flow=flows[0],
)

blackstone_investment_strategy = AgentRearrange(
    name="Blackstone-Investment-Strategy",
    description="A system for evaluating investment opportunities",
    agents=agents,
    flow=flows[1],
)

blackstone_market_analysis = AgentRearrange(
    name="Blackstone-Market-Analysis",
    description="A system for analyzing market trends and opportunities",
    agents=agents,
    flow=flows[2],
)

swarm_arrange = SwarmRearrange(
    swarms=[
        blackstone_acquisition_analysis,
        blackstone_investment_strategy,
        blackstone_market_analysis,
    ],
    flow=f"{blackstone_acquisition_analysis.name} -> {blackstone_investment_strategy.name} -> {blackstone_market_analysis.name}",
)

print(
    swarm_arrange.run(
        "Analyze swarms, 150k revenue with 45m+ agents build, with 1.4m downloads since march 2024"
    )
)

```

### Human-in-the-Loop

```python
def custom_human_input(task):
    return input(f"Review {task} and provide feedback: ")

# Create arrangement with human intervention
arrangement = SwarmRearrange(
    name="HumanAugmented",
    swarms=[swarm1, swarm2],
    flow="SwarmA -> H -> SwarmB",
    human_in_the_loop=True,
    custom_human_in_the_loop=custom_human_input
)

# Execute with human intervention
result = arrangement.run("Initial task")
```

### Complex Multi-Stage Pipeline

```python
# Define multiple flow patterns
flows = [
    "Collector -> Processor -> Analyzer",
    "Analyzer -> ML -> Validator",
    "Validator -> Reporter"
]

# Create arrangements for each flow
pipelines = [
    SwarmRearrange(name=f"Pipeline{i}", swarms=swarms, flow=flow)
    for i, flow in enumerate(flows)
]

# Create master arrangement
master = SwarmRearrange(
    name="MasterPipeline",
    swarms=pipelines,
    flow="Pipeline0 -> Pipeline1 -> Pipeline2"
)

# Execute complete pipeline
result = master.run("Start analysis")
```

## Best Practices

1. **Flow Validation**: Always validate flows before execution
2. **Error Handling**: Implement try-catch blocks around run() calls
3. **History Tracking**: Use track_history() for monitoring swarm execution
4. **Resource Management**: Set appropriate max_loops to prevent infinite execution
5. **Logging**: Enable verbose mode during development for detailed logging

## Error Handling

The class implements comprehensive error handling:

```python
try:
    arrangement = SwarmRearrange(swarms=swarms, flow=flow)
    result = arrangement.run(task)
except ValueError as e:
    logger.error(f"Flow validation error: {e}")
except Exception as e:
    logger.error(f"Execution error: {e}")
```

--------------------------------------------------

# File: swarms/structs/swarm_router.md

# SwarmRouter Documentation

The `SwarmRouter` class is a flexible routing system designed to manage different types of swarms for task execution. It provides a unified interface to interact with various swarm types, including `AgentRearrange`, `MixtureOfAgents`, `SpreadSheetSwarm`, `SequentialWorkflow`, `ConcurrentWorkflow`, `GroupChat`, `MultiAgentRouter`, `HierarchicalSwarm`, `MajorityVoting`, and `auto` which will dynamically select the most appropriate swarm for you by analyzing your task, name, and description. We will be continuously adding more swarm architectures as we progress with new developments.

## Classes

### Document

A Pydantic model for representing document data.

| Attribute | Type | Description |
| --- | --- | --- |
| `file_path` | str | Path to the document file. |
| `data` | str | Content of the document. |

### SwarmLog

A Pydantic model for capturing log entries.

| Attribute | Type | Description |
| --- | --- | --- |
| `id` | str | Unique identifier for the log entry. |
| `timestamp` | datetime | Time of log creation. |
| `level` | str | Log level (e.g., "info", "error"). |
| `message` | str | Log message content. |
| `swarm_type` | SwarmType | Type of swarm associated with the log. |
| `task` | str | Task being performed (optional). |
| `metadata` | Dict[str, Any] | Additional metadata (optional). |
| `documents` | List[Document] | List of documents associated with the log. |

### SwarmRouter

Main class for routing tasks to different swarm types.

| Attribute | Type | Description |
| --- | --- | --- |
| `name` | str | Name of the SwarmRouter instance. |
| `description` | str | Description of the SwarmRouter instance. |
| `max_loops` | int | Maximum number of loops to perform. |
| `agents` | List[Union[Agent, Callable]] | List of Agent objects or callable functions to be used in the swarm. |
| `swarm_type` | SwarmType | Type of swarm to be used. |
| `autosave` | bool | Flag to enable/disable autosave. |
| `rearrange_flow` | str | The flow for the AgentRearrange swarm type. |
| `return_json` | bool | Flag to enable/disable returning the result in JSON format. |
| `auto_generate_prompts` | bool | Flag to enable/disable auto generation of prompts. |
| `shared_memory_system` | Any | Shared memory system for agents. |
| `rules` | str | Rules to inject into every agent. |
| `documents` | List[str] | List of document file paths. |
| `output_type` | OutputType | Output format type (e.g., "string", "dict"). |
| `no_cluster_ops` | bool | Flag to disable cluster operations. |
| `speaker_fn` | callable | Speaker function for GroupChat swarm type. |
| `load_agents_from_csv` | bool | Flag to enable/disable loading agents from CSV. |
| `csv_file_path` | str | Path to the CSV file for loading agents. |
| `return_entire_history` | bool | Flag to enable/disable returning the entire conversation history. |
| `swarm` | Union[AgentRearrange, MixtureOfAgents, SpreadSheetSwarm, SequentialWorkflow, ConcurrentWorkflow, GroupChat, MultiAgentRouter, HierarchicalSwarm, MajorityVoting] | Instantiated swarm object. |
| `logs` | List[SwarmLog] | List of log entries captured during operations. |

#### Methods:

| Method | Parameters | Description |
| --- | --- | --- |
| `__init__` | `self, name: str = "swarm-router", description: str = "Routes your task to the desired swarm", max_loops: int = 1, agents: List[Union[Agent, Callable]] = [], swarm_type: SwarmType = "SequentialWorkflow", autosave: bool = False, rearrange_flow: str = None, return_json: bool = False, auto_generate_prompts: bool = False, shared_memory_system: Any = None, rules: str = None, documents: List[str] = [], output_type: OutputType = "dict", no_cluster_ops: bool = False, speaker_fn: callable = None, load_agents_from_csv: bool = False, csv_file_path: str = None, return_entire_history: bool = True, *args, **kwargs` | Initialize the SwarmRouter. |
| `activate_shared_memory` | `self` | Activate shared memory with all agents. |
| `handle_rules` | `self` | Inject rules to every agent. |
| `activate_ape` | `self` | Activate automatic prompt engineering for agents that support it. |
| `reliability_check` | `self` | Perform reliability checks on the SwarmRouter configuration. |
| `_create_swarm` | `self, task: str = None, *args, **kwargs` | Create and return the specified swarm type or automatically match the best swarm type for a given task. |
| `_log` | `self, level: str, message: str, task: str = "", metadata: Dict[str, Any] = None` | Create a log entry and add it to the logs list. |
| `_run` | `self, task: str, img: str, *args, **kwargs` | Dynamically run the specified task on the selected or matched swarm type. |
| `run` | `self, task: str, img: str = None, *args, **kwargs` | Execute a task on the selected swarm type. |
| `__call__` | `self, task: str, *args, **kwargs` | Make the SwarmRouter instance callable. |
| `batch_run` | `self, tasks: List[str], *args, **kwargs` | Execute a batch of tasks on the selected or matched swarm type. |
| `async_run` | `self, task: str, *args, **kwargs` | Execute a task on the selected or matched swarm type asynchronously. |
| `get_logs` | `self` | Retrieve all logged entries. |
| `concurrent_run` | `self, task: str, *args, **kwargs` | Execute a task on the selected or matched swarm type concurrently. |
| `concurrent_batch_run` | `self, tasks: List[str], *args, **kwargs` | Execute a batch of tasks on the selected or matched swarm type concurrently. |

## Function: swarm_router

A convenience function to create and run a SwarmRouter instance.

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| `name` | str | "swarm-router" | Name of the swarm router. |
| `description` | str | "Routes your task to the desired swarm" | Description of the router. |
| `max_loops` | int | 1 | Maximum number of execution loops. |
| `agents` | List[Union[Agent, Callable]] | [] | List of agents or callables. |
| `swarm_type` | SwarmType | "SequentialWorkflow" | Type of swarm to use. |
| `autosave` | bool | False | Whether to autosave results. |
| `flow` | str | None | Flow configuration. |
| `return_json` | bool | True | Whether to return results as JSON. |
| `auto_generate_prompts` | bool | False | Whether to auto-generate prompts. |
| `task` | str | None | Task to execute. |
| `rules` | str | None | Rules to inject into every agent. |
| `*args` | | | Additional positional arguments passed to SwarmRouter.run() |
| `**kwargs` | | | Additional keyword arguments passed to SwarmRouter.run() |

## Installation

To use the SwarmRouter, first install the required dependencies:

```bash
pip install swarms swarm_models
```

## Basic Usage

```python
import os
from dotenv import load_dotenv
from swarms import Agent, SwarmRouter, SwarmType
from swarm_models import OpenAIChat

load_dotenv()

# Get the OpenAI API key from the environment variable
api_key = os.getenv("GROQ_API_KEY")

# Model
model = OpenAIChat(
    openai_api_base="https://api.groq.com/openai/v1",
    openai_api_key=api_key,
    model_name="llama-3.1-70b-versatile",
    temperature=0.1,
)

# Define specialized system prompts for each agent
DATA_EXTRACTOR_PROMPT = """You are a highly specialized private equity agent focused on data extraction from various documents. Your expertise includes:
1. Extracting key financial metrics (revenue, EBITDA, growth rates, etc.) from financial statements and reports
2. Identifying and extracting important contract terms from legal documents
3. Pulling out relevant market data from industry reports and analyses
4. Extracting operational KPIs from management presentations and internal reports
5. Identifying and extracting key personnel information from organizational charts and bios
Provide accurate, structured data extracted from various document types to support investment analysis."""

SUMMARIZER_PROMPT = """You are an expert private equity agent specializing in summarizing complex documents. Your core competencies include:
1. Distilling lengthy financial reports into concise executive summaries
2. Summarizing legal documents, highlighting key terms and potential risks
3. Condensing industry reports to capture essential market trends and competitive dynamics
4. Summarizing management presentations to highlight key strategic initiatives and projections
5. Creating brief overviews of technical documents, emphasizing critical points for non-technical stakeholders
Deliver clear, concise summaries that capture the essence of various documents while highlighting information crucial for investment decisions."""

# Initialize specialized agents
data_extractor_agent = Agent(
    agent_name="Data-Extractor",
    system_prompt=DATA_EXTRACTOR_PROMPT,
    llm=model,
    max_loops=1,
    autosave=True,
    verbose=True,
    dynamic_temperature_enabled=True,
    saved_state_path="data_extractor_agent.json",
    user_name="pe_firm",
    retry_attempts=1,
    context_length=200000,
    output_type="string",
)

summarizer_agent = Agent(
    agent_name="Document-Summarizer",
    system_prompt=SUMMARIZER_PROMPT,
    llm=model,
    max_loops=1,
    autosave=True,
    verbose=True,
    dynamic_temperature_enabled=True,
    saved_state_path="summarizer_agent.json",
    user_name="pe_firm",
    retry_attempts=1,
    context_length=200000,
    output_type="string",
)

# Initialize the SwarmRouter
router = SwarmRouter(
    name="pe-document-analysis-swarm",
    description="Analyze documents for private equity due diligence and investment decision-making",
    max_loops=1,
    agents=[data_extractor_agent, summarizer_agent],
    swarm_type="ConcurrentWorkflow",
    autosave=True,
    return_json=True,
)

# Example usage
if __name__ == "__main__":
    # Run a comprehensive private equity document analysis task
    result = router.run(
        "Where is the best place to find template term sheets for series A startups? Provide links and references"
    )
    print(result)

    # Retrieve and print logs
    for log in router.get_logs():
        print(f"{log.timestamp} - {log.level}: {log.message}")
```

## Advanced Usage

### Changing Swarm Types

You can create multiple SwarmRouter instances with different swarm types:

```python
sequential_router = SwarmRouter(
    name="SequentialRouter",
    agents=[agent1, agent2],
    swarm_type="SequentialWorkflow"
)

concurrent_router = SwarmRouter(
    name="ConcurrentRouter",
    agents=[agent1, agent2],
    swarm_type="ConcurrentWorkflow"
)
```

### Automatic Swarm Type Selection

You can let the SwarmRouter automatically select the best swarm type for a given task:

```python
auto_router = SwarmRouter(
    name="AutoRouter",
    agents=[agent1, agent2],
    swarm_type="auto"
)

result = auto_router.run("Analyze and summarize the quarterly financial report")
```

### Loading Agents from CSV

To load agents from a CSV file:

```python
csv_router = SwarmRouter(
    name="CSVAgentRouter",
    load_agents_from_csv=True,
    csv_file_path="agents.csv",
    swarm_type="SequentialWorkflow"
)

result = csv_router.run("Process the client data")
```

### Using Shared Memory System

To enable shared memory across agents:

```python
from swarms.memory import SemanticMemory

memory_system = SemanticMemory()

memory_router = SwarmRouter(
    name="MemoryRouter",
    agents=[agent1, agent2],
    shared_memory_system=memory_system,
    swarm_type="SequentialWorkflow"
)

result = memory_router.run("Analyze historical data and make predictions")
```

### Injecting Rules to All Agents

To inject common rules into all agents:

```python
rules = """
1. Always provide sources for your information
2. Check your calculations twice
3. Explain your reasoning clearly
4. Highlight uncertainties and assumptions
"""

rules_router = SwarmRouter(
    name="RulesRouter",
    agents=[agent1, agent2],
    rules=rules,
    swarm_type="SequentialWorkflow"
)

result = rules_router.run("Analyze the investment opportunity")
```

## Use Cases

### AgentRearrange

Use Case: Optimizing agent order for complex multi-step tasks.

```python
rearrange_router = SwarmRouter(
    name="TaskOptimizer",
    description="Optimize agent order for multi-step tasks",
    max_loops=3,
    agents=[data_extractor, analyzer, summarizer],
    swarm_type="AgentRearrange",
    rearrange_flow=f"{data_extractor.name} -> {analyzer.name} -> {summarizer.name}"
)

result = rearrange_router.run("Analyze and summarize the quarterly financial report")
```

### MixtureOfAgents

Use Case: Combining diverse expert agents for comprehensive analysis.

```python
mixture_router = SwarmRouter(
    name="ExpertPanel",
    description="Combine insights from various expert agents",
    max_loops=1,
    agents=[financial_expert, market_analyst, tech_specialist, aggregator],
    swarm_type="MixtureOfAgents"
)

result = mixture_router.run("Evaluate the potential acquisition of TechStartup Inc.")
```

### SpreadSheetSwarm

Use Case: Collaborative data processing and analysis.

```python
spreadsheet_router = SwarmRouter(
    name="DataProcessor",
    description="Collaborative data processing and analysis",
    max_loops=1,
    agents=[data_cleaner, statistical_analyzer, visualizer],
    swarm_type="SpreadSheetSwarm"
)

result = spreadsheet_router.run("Process and visualize customer churn data")
```

### SequentialWorkflow

Use Case: Step-by-step document analysis and report generation.

```python
sequential_router = SwarmRouter(
    name="ReportGenerator",
    description="Generate comprehensive reports sequentially",
    max_loops=1,
    agents=[data_extractor, analyzer, writer, reviewer],
    swarm_type="SequentialWorkflow",
    return_entire_history=True
)

result = sequential_router.run("Create a due diligence report for Project Alpha")
```

### ConcurrentWorkflow

Use Case: Parallel processing of multiple data sources.

```python
concurrent_router = SwarmRouter(
    name="MultiSourceAnalyzer",
    description="Analyze multiple data sources concurrently",
    max_loops=1,
    agents=[financial_analyst, market_researcher, competitor_analyst],
    swarm_type="ConcurrentWorkflow",
    output_type="string"
)

result = concurrent_router.run("Conduct a comprehensive market analysis for Product X")
```

### GroupChat

Use Case: Simulating a group discussion with multiple agents.

```python
group_chat_router = SwarmRouter(
    name="GroupChat",
    description="Simulate a group discussion with multiple agents",
    max_loops=10,
    agents=[financial_analyst, market_researcher, competitor_analyst],
    swarm_type="GroupChat",
    speaker_fn=custom_speaker_function
)

result = group_chat_router.run("Discuss the pros and cons of expanding into the Asian market")
```

### MultiAgentRouter

Use Case: Routing tasks to the most appropriate agent.

```python
multi_agent_router = SwarmRouter(
    name="MultiAgentRouter",
    description="Route tasks to specialized agents",
    max_loops=1,
    agents=[financial_analyst, market_researcher, competitor_analyst],
    swarm_type="MultiAgentRouter",
    shared_memory_system=memory_system
)

result = multi_agent_router.run("Analyze the competitive landscape for our new product")
```

### HierarchicalSwarm

Use Case: Creating a hierarchical structure of agents with a director.

```python
hierarchical_router = SwarmRouter(
    name="HierarchicalSwarm",
    description="Hierarchical organization of agents with a director",
    max_loops=3,
    agents=[director, analyst1, analyst2, researcher],
    swarm_type="HiearchicalSwarm",
    return_all_history=True
)

result = hierarchical_router.run("Develop a comprehensive market entry strategy")
```

### MajorityVoting

Use Case: Using consensus among multiple agents for decision-making.

```python
voting_router = SwarmRouter(
    name="MajorityVoting",
    description="Make decisions using consensus among agents",
    max_loops=1,
    agents=[analyst1, analyst2, analyst3, consensus_agent],
    swarm_type="MajorityVoting"
)

result = voting_router.run("Should we invest in Company X based on the available data?")
```

### Auto Select (Experimental)
Autonomously selects the right swarm by conducting vector search on your input task or name or description or all 3.

```python
auto_router = SwarmRouter(
    name="MultiSourceAnalyzer",
    description="Analyze multiple data sources concurrently",
    max_loops=1,
    agents=[financial_analyst, market_researcher, competitor_analyst],
    swarm_type="auto" # Set this to 'auto' for it to auto select your swarm. It's match words like concurrently multiple -> "ConcurrentWorkflow"
)

result = auto_router.run("Conduct a comprehensive market analysis for Product X")
```

## Advanced Features

### Processing Documents

To process documents with the SwarmRouter:

```python
document_router = SwarmRouter(
    name="DocumentProcessor",
    agents=[document_analyzer, summarizer],
    documents=["report.pdf", "contract.docx", "data.csv"],
    swarm_type="SequentialWorkflow"
)

result = document_router.run("Extract key information from the provided documents")
```

### Batch Processing

To process multiple tasks in a batch:

```python
tasks = ["Analyze Q1 report", "Summarize competitor landscape", "Evaluate market trends"]
results = router.batch_run(tasks)
```

### Asynchronous Execution

For asynchronous task execution:

```python
result = await router.async_run("Generate financial projections")
```

### Concurrent Execution

To run a single task concurrently:

```python
result = router.concurrent_run("Analyze multiple data streams")
```

### Concurrent Batch Processing

To process multiple tasks concurrently:

```python
tasks = ["Task 1", "Task 2", "Task 3"]
results = router.concurrent_batch_run(tasks)
```

### Using the SwarmRouter as a Callable

You can use the SwarmRouter instance directly as a callable:

```python
router = SwarmRouter(
    name="CallableRouter",
    agents=[agent1, agent2],
    swarm_type="SequentialWorkflow"
)

result = router("Analyze the market data")  # Equivalent to router.run("Analyze the market data")
```

### Using the swarm_router Function

For quick one-off tasks, you can use the swarm_router function:

```python
from swarms import swarm_router

result = swarm_router(
    name="QuickRouter",
    agents=[agent1, agent2],
    swarm_type="ConcurrentWorkflow",
    task="Analyze the quarterly report"
)
```

## Best Practices

1. Choose the appropriate swarm type based on your task requirements.

2. Provide clear and specific tasks to the swarm for optimal results.

3. Regularly review logs to monitor performance and identify potential issues.

4. Use descriptive names and descriptions for your SwarmRouter and agents.

5. Implement proper error handling in your application code.

6. Consider the nature of your tasks when choosing a swarm type (e.g., use ConcurrentWorkflow for tasks that can be parallelized).

7. Optimize your agents' prompts and configurations for best performance within the swarm.

8. Utilize the automatic swarm type selection feature for tasks where the optimal swarm type is not immediately clear.

9. Take advantage of batch processing and concurrent execution for handling multiple tasks efficiently.

10. Use the reliability check feature to ensure your SwarmRouter is properly configured before running tasks.

11. Consider using shared memory systems when agents need to share context or knowledge.

12. Inject common rules when you want consistent behavior across all agents.

13. Use the appropriate output type (string, dict, etc.) based on how you plan to process the results.

14. When working with large documents, provide file paths instead of loading content into memory.

15. For complex agent interactions, use the GroupChat or HierarchicalSwarm types to facilitate structured communication.

--------------------------------------------------

# File: swarms/structs/task.md

# Task Class Documentation

The `Task` class is a pivotal component designed for managing tasks in a sequential workflow. This class allows for the execution of tasks using various agents, which can be callable objects or specific instances of the `Agent` class. It supports the scheduling of tasks, handling their dependencies, and setting conditions and actions that govern their execution.

Key features of the `Task` class include:
- Executing tasks with specified agents and handling their results.
- Scheduling tasks to run at specified times.
- Setting triggers, actions, and conditions for tasks.
- Managing task dependencies and priorities.
- Providing a history of task executions for tracking purposes.

## Class Definition

The `Task` class is defined as follows:


### Attributes

| Attribute      | Type                        | Description                                                                           |
|----------------|-----------------------------|---------------------------------------------------------------------------------------|
| `agent`        | `Union[Callable, Agent]`    | The agent or callable object to run the task.                                         |
| `description`  | `str`                       | Description of the task.                                                              |
| `result`       | `Any`                       | Result of the task.                                                                   |
| `history`      | `List[Any]`                 | History of the task.                                                                  |
| `schedule_time`| `datetime`                  | Time to schedule the task.                                                            |
| `scheduler`    | `sched.scheduler`           | Scheduler to schedule the task.                                                       |
| `trigger`      | `Callable`                  | Trigger to run the task.                                                              |
| `action`       | `Callable`                  | Action to run the task.                                                               |
| `condition`    | `Callable`                  | Condition to run the task.                                                            |
| `priority`     | `int`                       | Priority of the task.                                                                 |
| `dependencies` | `List[Task]`                | List of tasks that need to be completed before this task can be executed.             |
| `args`         | `List[Any]`                 | Arguments to pass to the agent or callable object.                                    |
| `kwargs`       | `Dict[str, Any]`            | Keyword arguments to pass to the agent or callable object.                            |

## Methods

### `execute(self, *args, **kwargs)`

Executes the task by calling the agent or model with the specified arguments and keyword arguments. If a condition is set, the task will only execute if the condition returns `True`.

#### Parameters
- `args`: Arguments to pass to the agent or callable object.
- `kwargs`: Keyword arguments to pass to the agent or callable object.

#### Examples

```python
>>> from swarms.structs import Task, Agent
>>> from swarm_models import OpenAIChat
>>> agent = Agent(llm=OpenAIChat(openai_api_key=""), max_loops=1, dashboard=False)
>>> task = Task(description="What's the weather in Miami?", agent=agent)
>>> task.run()
>>> task.result
```

### `handle_scheduled_task(self)`

Handles the execution of a scheduled task. If the schedule time is not set or has already passed, the task is executed immediately. Otherwise, the task is scheduled to be executed at the specified schedule time.

#### Examples

```python
>>> task.schedule_time = datetime.now() + timedelta(seconds=10)
>>> task.handle_scheduled_task()
```

### `set_trigger(self, trigger: Callable)`

Sets the trigger for the task.

#### Parameters
- `trigger` (`Callable`): The trigger to set.

#### Examples

```python
>>> def my_trigger():
>>>     print("Trigger executed")
>>> task.set_trigger(my_trigger)
```

### `set_action(self, action: Callable)`

Sets the action for the task.

#### Parameters
- `action` (`Callable`): The action to set.

#### Examples

```python
>>> def my_action():
>>>     print("Action executed")
>>> task.set_action(my_action)
```

### `set_condition(self, condition: Callable)`

Sets the condition for the task.

#### Parameters
- `condition` (`Callable`): The condition to set.

#### Examples

```python
>>> def my_condition():
>>>     print("Condition checked")
>>>     return True
>>> task.set_condition(my_condition)
```

### `is_completed(self)`

Checks whether the task has been completed.

#### Returns
- `bool`: `True` if the task has been completed, `False` otherwise.

#### Examples

```python
>>> task.is_completed()
```

### `add_dependency(self, task)`

Adds a task to the list of dependencies.

#### Parameters
- `task` (`Task`): The task to add as a dependency.

#### Examples

```python
>>> dependent_task = Task(description="Dependent Task")
>>> task.add_dependency(dependent_task)
```

### `set_priority(self, priority: int)`

Sets the priority of the task.

#### Parameters
- `priority` (`int`): The priority to set.

#### Examples

```python
>>> task.set_priority(5)
```

### `check_dependency_completion(self)`

Checks whether all the dependencies have been completed.

#### Returns
- `bool`: `True` if all the dependencies have been completed, `False` otherwise.

#### Examples

```python
>>> task.check_dependency_completion()
```

### `context(self, task: "Task" = None, context: List["Task"] = None, *args, **kwargs)`

Sets the context for the task. For a sequential workflow, it sequentially adds the context of the previous task in the list.

#### Parameters
- `task` (`Task`, optional): The task whose context is to be set.
- `context` (`List[Task]`, optional): The list of tasks to set the context.

#### Examples

```python
>>> task1 = Task(description="Task 1")
>>> task2 = Task(description="Task 2")
>>> task2.context(context=[task1])
```

## Usage Examples

### Basic Usage

```python
import os
from dotenv import load_dotenv
from swarms import Agent, OpenAIChat, Task

# Load the environment variables
load_dotenv()

# Define a function to be used as the action
def my_action():
    print("Action executed")

# Define a function to be used as the condition
def my_condition():
    print("Condition checked")
    return True

# Create an agent
agent = Agent(
    llm=OpenAIChat(openai_api_key=os.environ["OPENAI_API_KEY"]),
    max_loops=1,
    dashboard=False,
)

# Create a task
task = Task(
    description="Generate a report on the top 3 biggest expenses for small businesses and how businesses can save 20%",
    agent=agent,
)

# Set the action and condition
task.set_action(my_action)
task.set_condition(my_condition)

# Execute the task
print("Executing task...")
task.run()

# Check if the task is completed
if task.is_completed():
    print("Task completed")
else:
    print("Task not completed")

# Output the result of the task
print(f"Task result: {task.result}")
```

### Scheduled Task Execution

```python
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv
from swarms import Agent, OpenAIChat, Task

# Load the environment variables
load_dotenv()

# Create an agent
agent = Agent(
    llm=OpenAIChat(openai_api_key=os.environ["OPENAI_API_KEY"]),
    max_loops=1,
    dashboard=False,
)

# Create a task
task = Task(
    description="Scheduled task example",
    agent=agent,
    schedule_time=datetime.now() + timedelta(seconds=10)
)

# Handle scheduled task
task.handle_scheduled_task()
```

### Task with Dependencies

```python
import os
from dotenv import load_dotenv
from swarms import Agent, OpenAIChat, Task

# Load the environment variables
load_dotenv()

# Create agents
agent1 = Agent(
    llm=OpenAIChat(openai_api_key=os.environ["OPENAI_API_KEY"]),
    max_loops=1,
    dashboard=False,
)
agent2 = Agent(
    llm=OpenAIChat(openai_api_key=os.environ["OPENAI_API_KEY"]),
    max_loops=1,
    dashboard=False,
)

# Create tasks
task1 = Task(description="First task", agent=agent1)
task2 = Task(description="Second task", agent=agent2)

# Add dependency
task2.add_dependency(task1)

# Execute tasks
print("Executing first task...")
task1.run()

print("Executing second task...")
task2.run()

# Check if tasks are completed
print(f"Task 1 completed: {task1.is_completed()}")
print(f"Task 2 completed: {task2.is_completed()}")
```

### Task Context

```python
import os
from dotenv import load_dotenv
from swarms import Agent, OpenAIChat, Task

# Load the environment variables
load_dotenv()

# Create an agent
agent = Agent(
    llm=OpenAIChat(openai_api_key=os.environ["OPENAI_API_KEY"]),
    max_loops

=1,
    dashboard=False,
)

# Create tasks
task1 = Task(description="First task", agent=agent)
task2 = Task(description="Second task", agent=agent)

# Set context for the second task
task2.context(context=[task1])

# Execute tasks
print("Executing first task...")
task1.run()

print("Executing second task...")
task2.run()

# Output the context of the second task
print(f"Task 2 context: {task2.history}")
```


--------------------------------------------------

# File: swarms/structs/taskqueue_swarm.md

# TaskQueueSwarm Documentation

The `TaskQueueSwarm` class is designed to manage and execute tasks using multiple agents concurrently. This class allows for the orchestration of multiple agents processing tasks from a shared queue, facilitating complex workflows where tasks can be distributed and processed in parallel by different agents.

## Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `agents` | `List[Agent]` | The list of agents in the swarm. |
| `task_queue` | `queue.Queue` | A queue to store tasks for processing. |
| `lock` | `threading.Lock` | A lock for thread synchronization. |
| `autosave_on` | `bool` | Whether to automatically save the swarm metadata. |
| `save_file_path` | `str` | The file path for saving swarm metadata. |
| `workspace_dir` | `str` | The directory path of the workspace. |
| `return_metadata_on` | `bool` | Whether to return the swarm metadata after running. |
| `max_loops` | `int` | The maximum number of loops to run the swarm. |
| `metadata` | `SwarmRunMetadata` | Metadata about the swarm run. |

## Methods

### `__init__(self, agents: List[Agent], name: str = "Task-Queue-Swarm", description: str = "A swarm that processes tasks from a queue using multiple agents on different threads.", autosave_on: bool = True, save_file_path: str = "swarm_run_metadata.json", workspace_dir: str = os.getenv("WORKSPACE_DIR"), return_metadata_on: bool = False, max_loops: int = 1, *args, **kwargs)`

The constructor initializes the `TaskQueueSwarm` object.

- **Parameters:**
  - `agents` (`List[Agent]`): The list of agents in the swarm.
  - `name` (`str`, optional): The name of the swarm. Defaults to "Task-Queue-Swarm".
  - `description` (`str`, optional): The description of the swarm. Defaults to "A swarm that processes tasks from a queue using multiple agents on different threads.".
  - `autosave_on` (`bool`, optional): Whether to automatically save the swarm metadata. Defaults to True.
  - `save_file_path` (`str`, optional): The file path to save the swarm metadata. Defaults to "swarm_run_metadata.json".
  - `workspace_dir` (`str`, optional): The directory path of the workspace. Defaults to os.getenv("WORKSPACE_DIR").
  - `return_metadata_on` (`bool`, optional): Whether to return the swarm metadata after running. Defaults to False.
  - `max_loops` (`int`, optional): The maximum number of loops to run the swarm. Defaults to 1.
  - `*args`: Variable length argument list.
  - `**kwargs`: Arbitrary keyword arguments.

### `add_task(self, task: str)`

Adds a task to the queue.

- **Parameters:**
  - `task` (`str`): The task to be added to the queue.

### `run(self)`

Runs the swarm by having agents pick up tasks from the queue.

- **Returns:**
  - `str`: JSON string of the swarm run metadata if `return_metadata_on` is True.

- **Usage Example:**
  ```python
  from swarms import Agent, TaskQueueSwarm
  from swarms_models import OpenAIChat

  # Initialize the language model
  llm = OpenAIChat()

  # Initialize agents
  agent1 = Agent(agent_name="Agent1", llm=llm)
  agent2 = Agent(agent_name="Agent2", llm=llm)

  # Create the TaskQueueSwarm
  swarm = TaskQueueSwarm(agents=[agent1, agent2], max_loops=5)

  # Add tasks to the swarm
  swarm.add_task("Analyze the latest market trends")
  swarm.add_task("Generate a summary report")

  # Run the swarm
  result = swarm.run()
  print(result)  # Prints the swarm run metadata
  ```

  This example initializes a `TaskQueueSwarm` with two agents, adds tasks to the queue, and runs the swarm.

### `save_json_to_file(self)`

Saves the swarm run metadata to a JSON file.

### `export_metadata(self)`

Exports the swarm run metadata as a JSON string.

- **Returns:**
  - `str`: JSON string of the swarm run metadata.

## Additional Notes

- The `TaskQueueSwarm` uses threading to process tasks concurrently, which can significantly improve performance for I/O-bound tasks.
- The `reliability_checks` method ensures that the swarm is properly configured before running.
- The swarm automatically handles task distribution among agents and provides detailed metadata about the run.
- Error handling and logging are implemented to track the execution flow and capture any issues during task processing.


--------------------------------------------------

# File: swarms/structs/various_execution_methods.md

# Concurrent Agents API Reference

This documentation covers the API for running multiple agents concurrently using various execution strategies. The implementation uses `asyncio` with `uvloop` for enhanced performance and `ThreadPoolExecutor` for handling CPU-bound operations.

## Table of Contents
- [Core Functions](#core-functions)
- [Advanced Functions](#advanced-functions)
- [Utility Functions](#utility-functions)
- [Resource Monitoring](#resource-monitoring)
- [Usage Examples](#usage-examples)

## Core Functions

### run_agents_concurrently()

Primary function for running multiple agents concurrently with optimized performance using both uvloop and ThreadPoolExecutor.

#### Arguments

| Parameter    | Type           | Required | Default        | Description |
|-------------|----------------|----------|----------------|-------------|
| agents      | List[AgentType]| Yes      | -              | List of Agent instances to run concurrently |
| task        | str            | Yes      | -              | Task string to execute |
| batch_size  | int           | No       | CPU count      | Number of agents to run in parallel in each batch |
| max_workers | int           | No       | CPU count * 2  | Maximum number of threads in the executor |

#### Returns
`List[Any]`: List of outputs from each agent

#### Flow Diagram

```mermaid
graph TD
    A[Start] --> B[Initialize ThreadPoolExecutor]
    B --> C[Split Agents into Batches]
    C --> D[Process Batch]
    D --> E{More Batches?}
    E -->|Yes| D
    E -->|No| F[Combine Results]
    F --> G[Return Results]
    
    subgraph "Batch Processing"
    D --> H[Run Agents Async]
    H --> I[Wait for Completion]
    I --> J[Collect Batch Results]
    end
```

### run_agents_sequentially()

Runs multiple agents sequentially for baseline comparison or simple use cases.

#### Arguments

| Parameter | Type           | Required | Default | Description |
|-----------|----------------|----------|---------|-------------|
| agents    | List[AgentType]| Yes      | -       | List of Agent instances to run |
| task      | str            | Yes      | -       | Task string to execute |

#### Returns
`List[Any]`: List of outputs from each agent

## Advanced Functions

### run_agents_with_different_tasks()

Runs multiple agents with different tasks concurrently.

#### Arguments

| Parameter        | Type                          | Required | Default        | Description |
|-----------------|-------------------------------|----------|----------------|-------------|
| agent_task_pairs| List[tuple[AgentType, str]]   | Yes      | -              | List of (agent, task) tuples |
| batch_size      | int                           | No       | CPU count      | Number of agents to run in parallel |
| max_workers     | int                           | No       | CPU count * 2  | Maximum number of threads |

### run_agents_with_timeout()

Runs multiple agents concurrently with timeout limits.

#### Arguments

| Parameter    | Type           | Required | Default        | Description |
|-------------|----------------|----------|----------------|-------------|
| agents      | List[AgentType]| Yes      | -              | List of Agent instances |
| task        | str            | Yes      | -              | Task string to execute |
| timeout     | float          | Yes      | -              | Timeout in seconds for each agent |
| batch_size  | int           | No       | CPU count      | Number of agents to run in parallel |
| max_workers | int           | No       | CPU count * 2  | Maximum number of threads |

## Usage Examples

```python
from swarms import Agent, run_agents_concurrently, run_agents_with_timeout, run_agents_with_different_tasks
from swarm_models import OpenAIChat

model = OpenAIChat(
    model_name="gpt-4o-mini",
    temperature=0.0
)

# Initialize agents
agents = [
    Agent(
        agent_name=f"Analysis-Agent-{i}",
        system_prompt="You are a financial analysis expert",
        llm=model,
        max_loops=1
    )
    for i in range(5)
]

# Basic concurrent execution
task = "Analyze the impact of rising interest rates on tech stocks"
outputs = run_agents_concurrently(agents, task)

# Running with timeout
outputs_with_timeout = run_agents_with_timeout(
    agents=agents,
    task=task,
    timeout=30.0,
    batch_size=2
)

# Running different tasks
task_pairs = [
    (agents[0], "Analyze tech stocks"),
    (agents[1], "Analyze energy stocks"),
    (agents[2], "Analyze retail stocks")
]
different_outputs = run_agents_with_different_tasks(task_pairs)
```

## Resource Monitoring

### ResourceMetrics

A dataclass for system resource metrics.

#### Properties

| Property        | Type  | Description |
|----------------|-------|-------------|
| cpu_percent    | float | Current CPU usage percentage |
| memory_percent | float | Current memory usage percentage |
| active_threads | int   | Number of active threads |

### run_agents_with_resource_monitoring()

Runs agents with system resource monitoring and adaptive batch sizing.

#### Arguments

| Parameter         | Type           | Required | Default | Description |
|------------------|----------------|----------|---------|-------------|
| agents           | List[AgentType]| Yes      | -       | List of Agent instances |
| task             | str            | Yes      | -       | Task string to execute |
| cpu_threshold    | float          | No       | 90.0    | Max CPU usage percentage |
| memory_threshold | float          | No       | 90.0    | Max memory usage percentage |
| check_interval   | float          | No       | 1.0     | Resource check interval in seconds |

## Performance Considerations

- All functions are decorated with `@profile_func` for performance monitoring
- Default batch sizes and worker counts are optimized based on CPU cores
- Resource monitoring helps prevent system overload
- Using `uvloop` provides better performance than standard `asyncio`

## Error Handling

- Functions handle asyncio event loop creation/retrieval
- Timeout mechanism prevents infinite waiting
- Resource monitoring allows for adaptive performance adjustment

--------------------------------------------------

# File: swarms/structs/various_swarm_architectures.md



--------------------------------------------------

# File: swarms/structs/yaml_model.md

# YamlModel: A Pydantic Model for YAML Data

The `YamlModel` class, derived from `BaseModel` in Pydantic, offers a convenient way to work with YAML data in your Python applications. It provides methods for serialization (converting to YAML), deserialization (creating an instance from YAML), and schema generation. This documentation will delve into the functionalities of `YamlModel` and guide you through its usage with illustrative examples.

### Purpose and Functionality

The primary purpose of `YamlModel` is to streamline the interaction between your Python code and YAML data. It accomplishes this by:

* **Serialization:** Transforming a `YamlModel` instance into a YAML string representation using the `to_yaml()` method.
* **Deserialization:** Constructing a `YamlModel` instance from a provided YAML string using the `from_yaml()` class method.
* **JSON to YAML Conversion:** Facilitating the conversion of JSON data to YAML format through the `json_to_yaml()` static method.
* **Saving to YAML File:** Enabling the storage of `YamlModel` instances as YAML files using the `save_to_yaml()` method.
* (Future Implementation) **Schema Generation:** The `create_yaml_schema()` class method (not yet implemented but included for future reference) will generate a YAML schema that reflects the structure of the `YamlModel` class and its fields.

### Class Definition and Arguments

The `YamlModel` class inherits from Pydantic's `BaseModel` class. You can define your custom YAML models by creating subclasses of `YamlModel` and specifying your data fields within the class definition. Here's the breakdown of the `YamlModel` class and its methods:

```python
class YamlModel(BaseModel):
    """
    A Pydantic model class for working with YAML data.
    """

    def to_yaml(self):
        """
        Serialize the Pydantic model instance to a YAML string.
        """
        return yaml.safe_dump(self.dict(), sort_keys=False)

    @classmethod
    def from_yaml(cls, yaml_str: str):
        """
        Create an instance of the class from a YAML string.

        Args:
            yaml_str (str): The YAML string to parse.

        Returns:
            cls: An instance of the class with attributes populated from the YAML data.
                 Returns None if there was an error loading the YAML data.
        """
        # ...

    @staticmethod
    def json_to_yaml(json_str: str):
        """
        Convert a JSON string to a YAML string.
        """
        # ...

    def save_to_yaml(self, filename: str):
        """
        Save the Pydantic model instance as a YAML file.
        """
        # ...

    # TODO: Implement a method to create a YAML schema from the model fields
    # @classmethod
    # def create_yaml_schema(cls):
    #     # ...
    """
```

**Arguments:**

* `self` (implicit): Refers to the current instance of the `YamlModel` class.
* `yaml_str` (str): The YAML string used for deserialization in the `from_yaml()` method.
* `json_str` (str): The JSON string used for conversion to YAML in the `json_to_yaml()` method.
* `filename` (str): The filename (including path) for saving the YAML model instance in the `save_to_yaml()` method.

### Detailed Method Descriptions

**1. to_yaml()**

This method transforms an instance of the `YamlModel` class into a YAML string representation. It utilizes the `yaml.safe_dump()` function from the `PyYAML` library to ensure secure YAML data generation. The `sort_keys=False` argument guarantees that the order of keys in the resulting YAML string remains consistent with the order of fields defined in your `YamlModel` subclass.

**Example:**

```python
class User(YamlModel):
    name: str
    age: int
    is_active: bool

user = User(name="Bob", age=30, is_active=True)
yaml_string = user.to_yaml()
print(yaml_string)
```

This code will output a YAML string representation of the `user` object, resembling:

```yaml
name: Bob
age: 30
is_active: true
```

### Detailed Method Descriptions 

**2. from_yaml(cls, yaml_str)** (Class Method)

The `from_yaml()` class method is responsible for constructing a `YamlModel` instance from a provided YAML string. 

* **Arguments:**
    * `cls` (class): The class representing the desired YAML model (the subclass of `YamlModel` that matches the structure of the YAML data).
    * `yaml_str` (str): The YAML string containing the data to be parsed and used for creating the model instance.

* **Returns:**
    * `cls` (instance): An instance of the specified class (`cls`) populated with the data extracted from the YAML string. If an error occurs during parsing, it returns `None`.

* **Error Handling:**

The `from_yaml()` method employs `yaml.safe_load()` for secure YAML parsing. It incorporates a `try-except` block to handle potential `ValueError` exceptions that might arise during the parsing process. If an error is encountered, it logs the error message and returns `None`.

**Example:**

```python
class User(YamlModel):
    name: str
    age: int
    is_active: bool

yaml_string = """
name: Alice
age: 25
is_active: false
"""

user = User.from_yaml(yaml_string)
print(user.name)  # Output: Alice
```

**3. json_to_yaml(json_str)** (Static Method)

This static method in the `YamlModel` class serves the purpose of converting a JSON string into a YAML string representation.

* **Arguments:**
    * `json_str` (str): The JSON string that needs to be converted to YAML format.

* **Returns:**
    * `str`: The converted YAML string representation of the provided JSON data.

* **Functionality:**

The `json_to_yaml()` method leverages the `json.loads()` function to parse the JSON string into a Python dictionary. Subsequently, it utilizes `yaml.dump()` to generate the corresponding YAML string representation from the parsed dictionary.

**Example:**

```python
json_string = '{"name": "Charlie", "age": 42, "is_active": true}'
yaml_string = YamlModel.json_to_yaml(json_string)
print(yaml_string)
```

This code snippet will convert the JSON data to a YAML string, likely resembling:

```yaml
name: Charlie
age: 42
is_active: true
```

**4. save_to_yaml(self, filename)**

The `save_to_yaml()` method facilitates the storage of a `YamlModel` instance as a YAML file.

* **Arguments:**
    * `self` (implicit): Refers to the current instance of the `YamlModel` class that you intend to save.
    * `filename` (str): The desired filename (including path) for the YAML file.

* **Functionality:**

The `save_to_yaml()` method employs the previously explained `to_yaml()` method to generate a YAML string representation of the `self` instance. It then opens the specified file in write mode (`"w"`) and writes the YAML string content to the file.

**Example:**

```python
class Employee(YamlModel):
    name: str
    department: str
    salary: float

employee = Employee(name="David", department="Engineering", salary=95000.00)
employee.save_to_yaml("employee.yaml")
```

This code will create a YAML file named "employee.yaml" containing the serialized representation of the `employee` object.


### More Usage Examples ++ 

```python
class User(YamlModel):
    name: str
    age: int
    is_active: bool

# Create an instance of the User model
user = User(name="Alice", age=30, is_active=True)

# Serialize the User instance to YAML and print it
yaml_string = user.to_yaml()
print(yaml_string)
```

This code snippet demonstrates the creation of a `User` instance and its subsequent serialization to a YAML string using the `to_yaml()` method. The printed output will likely resemble:

```yaml
name: Alice
age: 30
is_active: true
```

### Converting JSON to YAML

```python
# Convert JSON string to YAML and print
json_string = '{"name": "Bob", "age": 25, "is_active": false}'
yaml_string = YamlModel.json_to_yaml(json_string)
print(yaml_string)
```

This example showcases the conversion of a JSON string containing user data into a YAML string representation using the `json_to_yaml()` static method. The resulting YAML string might look like:

```yaml
name: Bob
age: 25
is_active: false
```

### Saving User Instance to YAML File

```python
# Save the User instance to a YAML file
user.save_to_yaml("user.yaml")
```

This code demonstrates the utilization of the `save_to_yaml()` method to store the `user` instance as a YAML file named "user.yaml". The contents of the file will mirror the serialized YAML string representation of the user object.

## Additional Considerations

* Ensure you have the `PyYAML` library installed (`pip install pyyaml`) to leverage the YAML parsing and serialization functionalities within `YamlModel`.
* Remember that the `create_yaml_schema()` method is not yet implemented but serves as a placeholder for future enhancements.
* For complex data structures within your YAML models, consider leveraging Pydantic's data validation and nested model capabilities for robust data management.

## Conclusion

The `YamlModel` class in Pydantic offers a streamlined approach to working with YAML data in your Python projects. By employing the provided methods (`to_yaml()`, `from_yaml()`, `json_to_yaml()`, and `save_to_yaml()`), you can efficiently convert between Python objects and YAML representations, facilitating data persistence and exchange. This comprehensive documentation empowers you to effectively utilize `YamlModel` for your YAML data processing requirements.

--------------------------------------------------

# File: swarms/tools/build_tool.md

### Swarms Tool Documentation

A tool is a Python function designed to perform specific tasks, with clear type annotations and comprehensive docstrings. Below are examples of tools to help you get started.

# Rules

To create a tool in the Swarms environment, follow these rules:

1. **Function Definition**: 
   - The tool must be defined as a Python function.
   - The function should perform a specific task and be named appropriately.

2. **Type Annotations**: 
   - All arguments and the return value must have type annotations.
   - Both input and output types must be strings (`str`).

3. **Docstrings**: 
   - Each function must include a comprehensive docstring that adheres to PEP 257 standards. The docstring should explain:
     - The purpose of the function.
     - Arguments: names, types, and descriptions.
     - Return value: type and description.
     - Potential exceptions that the function may raise.

4. **Input and Output Types**:
   - The function's input must be a string.
   - The function's output must be a string.


### Example Tools


### Examples and Anti-Examples

#### Example 1: Fetch Financial News

**Correct Implementation**

```python
import requests
import os

def fetch_financial_news(query: str = "Nvidia news", num_articles: int = 5) -> str:
    """
    Fetches financial news from the Google News API and returns a formatted string of the top news.

    Args:
        query (str): The query term to search for news. Default is "Nvidia news".
        num_articles (int): The number of top articles to fetch. Default is 5.

    Returns:
        str: A formatted string of the top financial news articles.

    Raises:
        ValueError: If the API response is invalid or there are no articles found.
        requests.exceptions.RequestException: If there is an error with the request.
    """
    url = "https://newsapi.org/v2/everything"
    params = {
        "q": query,
        "apiKey": os.getenv("NEWSAPI_KEY"),
        "pageSize": num_articles,
        "sortBy": "relevancy",
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()

        if "articles" not in data or len(data["articles"]) == 0:
            raise ValueError("No articles found or invalid API response.")

        articles = data["articles"]
        formatted_articles = []

        for i, article in enumerate(articles, start=1):
            title = article.get("title", "No Title")
            description = article.get("description", "No Description")
            url = article.get("url", "No URL")
            formatted_articles.append(
                f"{i}. {title}\nDescription: {description}\nRead more: {url}\n"
            )

        return "\n".join(formatted_articles)

    except requests.exceptions.RequestException as e:
        print(f"Request Error: {e}")
        raise
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
```

**Incorrect Implementation**

```python
import requests
import os

def fetch_financial_news(query="Nvidia news", num_articles=5):
    # Fetches financial news from the Google News API and returns a formatted string of the top news.
    url = "https://newsapi.org/v2/everything"
    params = {
        "q": query,
        "apiKey": os.getenv("NEWSAPI_KEY"),
        "pageSize": num_articles,
        "sortBy": "relevancy",
    }

    response = requests.get(url, params=params)
    response.raise_for_status()
    data = response.json()

    if "articles" not in data or len(data["articles"]) == 0:
        raise ValueError("No articles found or invalid API response.")

    articles = data["articles"]
    formatted_articles = []

    for i, article in enumerate(articles, start=1):
        title = article.get("title", "No Title")
        description = article.get("description", "No Description")
        url = article.get("url", "No URL")
        formatted_articles.append(
            f"{i}. {title}\nDescription: {description}\nRead more: {url}\n"
        )

    return "\n".join(formatted_articles)
```

**Issues with Incorrect Implementation:**
- No type annotations for arguments and return value.
- Missing comprehensive docstring.

#### Example 2: Convert Celsius to Fahrenheit

**Correct Implementation**

```python
def celsius_to_fahrenheit(celsius_str: str) -> str:
    """
    Converts a temperature from Celsius to Fahrenheit.

    Args:
        celsius_str (str): The temperature in Celsius as a string.

    Returns:
        str: The temperature converted to Fahrenheit as a formatted string.

    Raises:
        ValueError: If the input cannot be converted to a float.
    """
    try:
        celsius = float(celsius_str)
        fahrenheit = celsius * 9/5 + 32
        return f"{celsius}°C is {fahrenheit}°F"
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
```

**Incorrect Implementation**

```python
def celsius_to_fahrenheit(celsius):
    # Converts a temperature from Celsius to Fahrenheit.
    celsius = float(celsius)
    fahrenheit = celsius * 9/5 + 32
    return f"{celsius}°C is {fahrenheit}°F"
```

**Issues with Incorrect Implementation:**
- No type annotations for arguments and return value.
- Missing comprehensive docstring.
- Input type is not enforced as string.

#### Example 3: Calculate Compound Interest

**Correct Implementation**

```python
def calculate_compound_interest(principal_str: str, rate_str: str, time_str: str, n_str: str) -> str:
    """
    Calculates compound interest.

    Args:
        principal_str (str): The initial amount of money as a string.
        rate_str (str): The annual interest rate (decimal) as a string.
        time_str (str): The time the money is invested for in years as a string.
        n_str (str): The number of times that interest is compounded per year as a string.

    Returns:
        str: The amount of money accumulated after n years, including interest.

    Raises:
        ValueError: If any of the inputs cannot be converted to the appropriate type or are negative.
    """
    try:
        principal = float(principal_str)
        rate = float(rate_str)
        time = float(time_str)
        n = int(n_str)
        
        if principal < 0 or rate < 0 or time < 0 or n < 0:
            raise ValueError("Inputs must be non-negative.")
        
        amount = principal * (1 + rate / n) ** (n * time)
        return f"The amount after {time} years is {amount:.2f}"
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
```

**Incorrect Implementation**

```python
def calculate_compound_interest(principal, rate, time, n):
    # Calculates compound interest.
    principal = float(principal)
    rate = float(rate)
    time = float(time)
    n = int(n)
    
    if principal < 0 or rate < 0 or time < 0 or n < 0:
        raise ValueError("Inputs must be non-negative.")
    
    amount = principal * (1 + rate / n) ** (n * time)
    return f"The amount after {time} years is {amount:.2f}"
```

**Issues with Incorrect Implementation:**
- No type annotations for arguments and return value.
- Missing comprehensive docstring.
- Input types are not enforced as strings.

By following these rules and using the examples provided, you can create robust and well-documented tools in the Swarms environment. Ensure that all functions include proper type annotations, comprehensive docstrings, and that both input and output types are strings.

#### Example Tool 4: Reverse a String

**Functionality**: Reverses a given string.

```python
def reverse_string(s: str) -> str:
    """
    Reverses a given string.

    Args:
        s (str): The string to reverse.

    Returns:
        str: The reversed string.

    Raises:
        TypeError: If the input is not a string.
    """
    try:
        if not isinstance(s, str):
            raise TypeError("Input must be a string.")
        return s[::-1]
    except TypeError as e:
        print(f"Type Error: {e}")
        raise
```

#### Example Tool 5: Check Palindrome

**Functionality**: Checks if a given string is a palindrome.

```python
def is_palindrome(s: str) -> str:
    """
    Checks if a given string is a palindrome.

    Args:
        s (str): The string to check.

    Returns:
        str: A message indicating whether the string is a palindrome or not.

    Raises:
        TypeError: If the input is not a string.
    """
    try:
        if not isinstance(s, str):
            raise TypeError("Input must be a string.")
        normalized_str = ''.join(filter(str.isalnum, s)).lower()
        is_palindrome = normalized_str == normalized_str[::-1]
        return f"The string '{s}' is {'a palindrome' if is_palindrome else 'not a palindrome'}."
    except TypeError as e:
        print(f"Type Error: {e}")
        raise
```

#### Example Tool 6: Fetch Current Weather

**Functionality**: Fetches the current weather for a given city from the OpenWeatherMap API.

```python
import requests
import os

def fetch_current_weather(city: str) -> str:
    """
    Fetches the current weather for a given city from the OpenWeatherMap API.

    Args:
        city (str): The name of the city to fetch the weather for.

    Returns:
        str: A formatted string of the current weather in the specified city.

    Raises:
        ValueError: If the API response is invalid or the city is not found.
        requests.exceptions.RequestException: If there is an error with the request.
    """
    url = "http://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city,
        "appid": os.getenv("OPENWEATHERMAP_KEY"),
        "units": "metric",
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()

        if "weather" not in data or "main" not in data:
            raise ValueError("Invalid API response or city not found.")

        weather_description = data["weather"][0]["description"]
        temperature = data["main"]["temp"]
        return f"The current weather in {city} is {weather_description} with a temperature of {temperature}°C."

    except requests.exceptions.RequestException as e:
        print(f"Request Error: {e}")
        raise
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
```

By following the examples provided, you can create your own tools to perform various tasks in the Swarms environment. Ensure each function includes type annotations, comprehensive docstrings, and appropriate error handling to make your tools robust and easy to use.





## Integrate tools into Agent
To integrate tools into an agent, you'd simply just pass in a callable function with types and documentation into the agent class.

```python


from swarms import Agent, OpenAIChat  # ChromaDB
import subprocess

# Model
llm = OpenAIChat(
    temperature=0.1,
)


# Tools
def terminal(
    code: str,
):
    """
    Run code in the terminal.

    Args:
        code (str): The code to run in the terminal.

    Returns:
        str: The output of the code.
    """
    out = subprocess.run(
        code, shell=True, capture_output=True, text=True
    ).stdout
    return str(out)


def browser(query: str):
    """
    Search the query in the browser with the `browser` tool.

    Args:
        query (str): The query to search in the browser.

    Returns:
        str: The search results.
    """
    import webbrowser

    url = f"https://www.google.com/search?q={query}"
    webbrowser.open(url)
    return f"Searching for {query} in the browser."


def create_file(file_path: str, content: str):
    """
    Create a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file creation operation.
    """
    with open(file_path, "w") as file:
        file.write(content)
    return f"File {file_path} created successfully."


def file_editor(file_path: str, mode: str, content: str):
    """
    Edit a file using the file editor tool.

    Args:
        file_path (str): The path to the file.
        mode (str): The mode to open the file in.
        content (str): The content to write to the file.

    Returns:
        str: The result of the file editing operation.
    """
    with open(file_path, mode) as file:
        file.write(content)
    return f"File {file_path} edited successfully."


# Agent
agent = Agent(
    agent_name="Devin",
    system_prompt=(
        "Autonomous agent that can interact with humans and other"
        " agents. Be Helpful and Kind. Use the tools provided to"
        " assist the user. Return all code in markdown format."
    ),
    llm=llm,
    max_loops="auto",
    autosave=True,
    dashboard=False,
    streaming_on=True,
    verbose=True,
    stopping_token="<DONE>",
    interactive=True,
    tools=[terminal, browser, file_editor, create_file],
    # long_term_memory=chromadb,
    metadata_output_type="json",
    # List of schemas that the agent can handle
    # list_base_models=[tool_schema],
    function_calling_format_type="OpenAI",
    function_calling_type="json",  # or soon yaml
)

# Run the agent
agent.run("Create a new file for a plan to take over the world.")

```


## Example 2


```python

import os

import requests

from swarms import Agent
from swarm_models import OpenAIChat

# Get the OpenAI API key from the environment variable
api_key = os.getenv("OPENAI_API_KEY")

# Create an instance of the OpenAIChat class
model = OpenAIChat(
    api_key=api_key, model_name="gpt-4o-mini", temperature=0.1
)


def fetch_financial_news(
    query: str = "Nvidia news", num_articles: int = 5
) -> str:
    """
    Fetches financial news from the Google News API and returns a formatted string of the top news.

    Args:
        api_key (str): Your Google News API key.
        query (str): The query term to search for news. Default is "financial".
        num_articles (int): The number of top articles to fetch. Default is 5.

    Returns:
        str: A formatted string of the top financial news articles.

    Raises:
        ValueError: If the API response is invalid or there are no articles found.
        requests.exceptions.RequestException: If there is an error with the request.
    """
    url = "https://newsapi.org/v2/everything"
    params = {
        "q": query,
        "apiKey": os.getenv("NEWSAPI_KEY"),
        "pageSize": num_articles,
        "sortBy": "relevancy",
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()

        if "articles" not in data or len(data["articles"]) == 0:
            raise ValueError("No articles found or invalid API response.")

        articles = data["articles"]
        formatted_articles = []

        for i, article in enumerate(articles, start=1):
            title = article.get("title", "No Title")
            description = article.get("description", "No Description")
            url = article.get("url", "No URL")
            formatted_articles.append(
                f"{i}. {title}\nDescription: {description}\nRead more: {url}\n"
            )

        return "\n".join(formatted_articles)

    except requests.exceptions.RequestException as e:
        print(f"Request Error: {e}")
        raise
    except ValueError as e:
        print(f"Value Error: {e}")
        raise


# # Example usage:
# api_key = "ceabc81a7d8f45febfedadb27177f3a3"
# print(fetch_financial_news(api_key))


# Initialize the agent
agent = Agent(
    agent_name="Financial-Analysis-Agent",
    # system_prompt=FINANCIAL_AGENT_SYS_PROMPT,
    llm=model,
    max_loops=2,
    autosave=True,
    # dynamic_temperature_enabled=True,
    dashboard=False,
    verbose=True,
    streaming_on=True,
    # interactive=True, # Set to False to disable interactive mode
    dynamic_temperature_enabled=True,
    saved_state_path="finance_agent.json",
    tools=[fetch_financial_news],
    # stopping_token="Stop!",
    # interactive=True,
    # docs_folder="docs", # Enter your folder name
    # pdf_path="docs/finance_agent.pdf",
    # sop="Calculate the profit for a company.",
    # sop_list=["Calculate the profit for a company."],
    user_name="swarms_corp",
    # # docs=
    # # docs_folder="docs",
    retry_attempts=3,
    # context_length=1000,
    # tool_schema = dict
    context_length=200000,
    # tool_schema=
    # tools
    # agent_ops_on=True,
    # long_term_memory=ChromaDB(docs_folder="artifacts"),
)


# Run the agent
response = agent("What are the latest financial news on Nvidia?")
print(response)


```


--------------------------------------------------

# File: swarms/tools/main.md

# The Swarms Tool System: Functions, Pydantic BaseModels as Tools, and Radical Customization


This guide provides an in-depth look at the Swarms Tool System, focusing on its functions, the use of Pydantic BaseModels as tools, and the extensive customization options available. Aimed at developers, this documentation highlights how the Swarms framework works and offers detailed examples of creating and customizing tools and agents, specifically for accounting tasks.

The Swarms Tool System is a flexible and extensible component of the Swarms framework that allows for the creation, registration, and utilization of various tools. These tools can perform a wide range of tasks and are integrated into agents to provide specific functionalities. The system supports multiple ways to define tools, including using Pydantic BaseModels, functions, and dictionaries.

### Architecture

The architecture of the Swarms Tool System is designed to be highly modular. It consists of the following main components:

1. **Agents:** The primary entities that execute tasks.
2. **Tools:** Functions or classes that perform specific operations.
3. **Schemas:** Definitions of input and output data formats using Pydantic BaseModels.

### Key Concepts

#### Tools

Tools are the core functional units within the Swarms framework. They can be defined in various ways:

- **Pydantic BaseModels**: Tools can be defined using Pydantic BaseModels to ensure data validation and serialization.
- **Functions**: Tools can be simple or complex functions.
- **Dictionaries**: Tools can be represented as dictionaries for flexibility.

#### Agents

Agents utilize tools to perform tasks. They are configured with a set of tools and schemas, and they execute the tools based on the input they receive.

## Detailed Documentation

### Tool Definition

#### Using Pydantic BaseModels

Pydantic BaseModels provide a structured way to define tool inputs and outputs. They ensure data validation and serialization, making them ideal for complex data handling.

**Example:**

Define Pydantic BaseModels for accounting tasks:

```python
from pydantic import BaseModel

class CalculateTax(BaseModel):
    income: float

class GenerateInvoice(BaseModel):
    client_name: str
    amount: float
    date: str

class SummarizeExpenses(BaseModel):
    expenses: list[dict]
```

Define tool functions using these models:

```python
def calculate_tax(data: CalculateTax) -> dict:
    tax_rate = 0.3  # Example tax rate
    tax = data.income * tax_rate
    return {"income": data.income, "tax": tax}

def generate_invoice(data: GenerateInvoice) -> dict:
    invoice = {
        "client_name": data.client_name,
        "amount": data.amount,
        "date": data.date,
        "invoice_id": "INV12345"
    }
    return invoice

def summarize_expenses(data: SummarizeExpenses) -> dict:
    total_expenses = sum(expense['amount'] for expense in data.expenses)
    return {"total_expenses": total_expenses}
```

#### Using Functions Directly

Tools can also be defined directly as functions without using Pydantic models. This approach is suitable for simpler tasks where complex validation is not required.

**Example:**

```python
def basic_tax_calculation(income: float) -> dict:
    tax_rate = 0.25
    tax = income * tax_rate
    return {"income": income, "tax": tax}
```

#### Using Dictionaries

Tools can be represented as dictionaries, providing maximum flexibility. This method is useful when the tool's functionality is more dynamic or when integrating with external systems.

**Example:**

```python
basic_tool_schema = {
    "name": "basic_tax_tool",
    "description": "A basic tax calculation tool",
    "parameters": {
        "type": "object",
        "properties": {
            "income": {"type": "number", "description": "Income amount"}
        },
        "required": ["income"]
    }
}

def basic_tax_tool(income: float) -> dict:
    tax_rate = 0.2
    tax = income * tax_rate
    return {"income": income, "tax": tax}
```

### Tool Registration

Tools need to be registered with the agent for it to utilize them. This can be done by specifying the tools in the `tools` parameter during agent initialization.

**Example:**

```python
from swarms import Agent
from llama_hosted import llama3Hosted

# Define Pydantic BaseModels for accounting tasks
class CalculateTax(BaseModel):
    income: float

class GenerateInvoice(BaseModel):
    client_name: str
    amount: float
    date: str

class SummarizeExpenses(BaseModel):
    expenses: list[dict]

# Define tool functions using these models
def calculate_tax(data: CalculateTax) -> dict:
    tax_rate = 0.3
    tax = data.income * tax_rate
    return {"income": data.income, "tax": tax}

def generate_invoice(data: GenerateInvoice) -> dict:
    invoice = {
        "client_name": data.client_name,
        "amount": data.amount,
        "date": data.date,
        "invoice_id": "INV12345"
    }
    return invoice

def summarize_expenses(data: SummarizeExpenses) -> dict:
    total_expenses = sum(expense['amount'] for expense in data.expenses)
    return {"total_expenses": total_expenses}

# Function to generate a tool schema for demonstration purposes
def create_tool_schema():
    return {
        "name": "execute",
        "description": "Executes code on the user's machine",
        "parameters": {
            "type": "object",
            "properties": {
                "language": {
                    "type": "string",
                    "description": "Programming language",
                    "enum": ["python", "java"]
                },
                "code": {"type": "string", "description": "Code to execute"}
            },
            "required": ["language", "code"]
        }
    }

# Initialize the agent with the tools
agent = Agent(
    agent_name="Accounting Agent",
    system_prompt="This agent assists with various accounting tasks.",
    sop_list=["Provide accurate and timely accounting services."],
    llm=llama3Hosted(),
    max_loops="auto",
    interactive=True,
    verbose=True,
    tool_schema=BaseModel,
    list_base_models=[
        CalculateTax,
        GenerateInvoice,
        SummarizeExpenses
    ],
    output_type=str,
    metadata_output_type="json",
    function_calling_format_type="OpenAI",
    function_calling_type="json",
    tools=[
        calculate_tax,
        generate_invoice,
        summarize_expenses
    ],
    list_base_models_json=create_tool_schema(),
)
```

### Running the Agent

The agent can execute tasks using the `run` method. This method takes a prompt and determines the appropriate tool to use based on the input.

**Example:**

```python
# Example task: Calculate tax for an income
result = agent.run("Calculate the tax for an income of $50,000.")
print(f"Result: {result}")

# Example task: Generate an invoice
invoice_data = agent.run("Generate an invoice for John Doe for $1500 on 2024-06-01.")
print(f"Invoice Data: {invoice_data}")

# Example task: Summarize expenses
expenses = [
    {"amount": 200.0, "description": "Office supplies"},
    {"amount": 1500.0, "description": "Software licenses"},
    {"amount": 300.0, "description": "Travel expenses"}
]
summary = agent.run("Summarize these expenses: " + str(expenses))
print(f"Expenses Summary: {summary}")
```


### Customizing Tools

Custom tools can be created to extend the functionality of the Swarms framework. This can include integrating external APIs, performing complex calculations, or handling specialized data formats.

**Example: Custom Accounting Tool**

```python
from pydantic import BaseModel

class CustomAccountingTool(BaseModel):
    data: dict

def custom_accounting_tool(data: CustomAccountingTool) -> dict:
    # Custom logic for the accounting tool
    result = {
        "status": "success",
        "data_processed": len(data.data)
    }
    return result

# Register the custom tool with the agent
agent = Agent(
    agent_name="Accounting Agent",
    system_prompt="This agent assists with various accounting tasks.",
    sop_list=["Provide accurate and timely accounting services."],
    llm=llama3Hosted(),
    max_loops="auto",
    interactive=True,
    verbose=True,
    tool_schema=BaseModel,
    list_base_models=[
        CalculateTax,
        GenerateInvoice,
        SummarizeExpenses,
        CustomAccountingTool
    ],
    output_type=str,
    metadata_output_type="json",
    function_calling_format_type="OpenAI",
    function_calling_type="json",
    tools=[
        calculate_tax,
        generate_invoice,
        summarize_expenses,
        custom_accounting_tool
    ],
    list_base_models_json=create_tool_schema(),
)
```

### Advanced Customization

Advanced customization involves modifying the core components of the Swarms framework. This includes extending existing classes, adding new methods, or integrating third-party libraries.

**Example: Extending the Agent Class**

```python
from swarms import Agent

class AdvancedAccountingAgent(Agent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def custom_behavior(self):
        print("Executing custom behavior")

    def another_custom_method(self):
        print("Another

 custom method")

# Initialize the advanced agent
advanced_agent = AdvancedAccountingAgent(
    agent_name="Advanced Accounting Agent",
    system_prompt="This agent performs advanced accounting tasks.",
    sop_list=["Provide advanced accounting services."],
    llm=llama3Hosted(),
    max_loops="auto",
    interactive=True,
    verbose=True,
    tool_schema=BaseModel,
    list_base_models=[
        CalculateTax,
        GenerateInvoice,
        SummarizeExpenses,
        CustomAccountingTool
    ],
    output_type=str,
    metadata_output_type="json",
    function_calling_format_type="OpenAI",
    function_calling_type="json",
    tools=[
        calculate_tax,
        generate_invoice,
        summarize_expenses,
        custom_accounting_tool
    ],
    list_base_models_json=create_tool_schema(),
)

# Call custom methods
advanced_agent.custom_behavior()
advanced_agent.another_custom_method()
```

### Integrating External Libraries

You can integrate external libraries to extend the functionality of your tools. This is useful for adding new capabilities or leveraging existing libraries for complex tasks.

**Example: Integrating Pandas for Data Processing**

```python
import pandas as pd
from pydantic import BaseModel

class DataFrameTool(BaseModel):
    data: list[dict]

def process_data_frame(data: DataFrameTool) -> dict:
    df = pd.DataFrame(data.data)
    summary = df.describe().to_dict()
    return {"summary": summary}

# Register the tool with the agent
agent = Agent(
    agent_name="Data Processing Agent",
    system_prompt="This agent processes data frames.",
    sop_list=["Provide data processing services."],
    llm=llama3Hosted(),
    max_loops="auto",
    interactive=True,
    verbose=True,
    tool_schema=BaseModel,
    list_base_models=[DataFrameTool],
    output_type=str,
    metadata_output_type="json",
    function_calling_format_type="OpenAI",
    function_calling_type="json",
    tools=[process_data_frame],
    list_base_models_json=create_tool_schema(),
)

# Example task: Process a data frame
data = [
    {"col1": 1, "col2": 2},
    {"col1": 3, "col2": 4},
    {"col1": 5, "col2": 6}
]
result = agent.run("Process this data frame: " + str(data))
print(f"Data Frame Summary: {result}")
```

## Conclusion

The Swarms Tool System provides a robust and flexible framework for defining and utilizing tools within agents. By leveraging Pydantic BaseModels, functions, and dictionaries, developers can create highly customized tools to perform a wide range of tasks. The extensive customization options allow for the integration of external libraries and the extension of core components, making the Swarms framework suitable for diverse applications.

This guide has covered the fundamental concepts and provided detailed examples to help you get started with the Swarms Tool System. With this foundation, you can explore and implement advanced features to build powerful

--------------------------------------------------

# File: swarms/tools/tool_storage.md

# ToolStorage


The `ToolStorage` module provides a structured and efficient way to manage and utilize various tool functions. It is designed to store tool functions, manage settings, and ensure smooth registration and retrieval of tools. This module is particularly useful in applications that require dynamic management of a collection of functions, such as plugin systems, modular software, or any application where functions need to be registered and called dynamically.

## Class: ToolStorage

The `ToolStorage` class is the core component of the module. It provides functionalities to add, retrieve, and list tool functions as well as manage settings.

### Attributes

| Attribute  | Type               | Description                                                           |
|------------|--------------------|-----------------------------------------------------------------------|
| `verbose`  | `bool`             | A flag to enable verbose logging.                                      |
| `tools`    | `List[Callable]`   | A list of tool functions.                                              |
| `_tools`   | `Dict[str, Callable]` | A dictionary that stores the tools, where the key is the tool name and the value is the tool function. |
| `_settings`| `Dict[str, Any]`   | A dictionary that stores the settings, where the key is the setting name and the value is the setting value. |

### Methods

#### `__init__`

Initializes the `ToolStorage` instance.


| Parameter  | Type              | Default | Description                                                |
|------------|-------------------|---------|------------------------------------------------------------|
| `verbose`  | `bool`            | `None`  | A flag to enable verbose logging.                          |
| `tools`    | `List[Callable]`  | `None`  | A list of tool functions to initialize the storage with.   |
| `*args`    | `tuple`           | `None`  | Additional positional arguments.                           |
| `**kwargs` | `dict`            | `None`  | Additional keyword arguments.                              |

#### `add_tool`

Adds a tool to the storage.

| Parameter | Type     | Description                  |
|-----------|----------|------------------------------|
| `func`    | `Callable` | The tool function to be added. |

**Raises:**
- `ValueError`: If a tool with the same name already exists.

#### `get_tool`

Retrieves a tool by its name.

| Parameter | Type   | Description                   |
|-----------|--------|-------------------------------|
| `name`    | `str`  | The name of the tool to retrieve. |

**Returns:**
- `Callable`: The tool function.

**Raises:**
- `ValueError`: If no tool with the given name is found.

#### `set_setting`

Sets a setting in the storage.


| Parameter | Type   | Description              |
|-----------|--------|--------------------------|
| `key`     | `str`  | The key for the setting. |
| `value`   | `Any`  | The value for the setting. |

#### `get_setting`

Gets a setting from the storage.

| Parameter | Type   | Description              |
|-----------|--------|--------------------------|
| `key`     | `str`  | The key for the setting. |

**Returns:**
- `Any`: The value of the setting.

**Raises:**
- `KeyError`: If the setting is not found.

#### `list_tools`

Lists all registered tools.

**Returns:**
- `List[str]`: A list of tool names.

## Decorator: tool_registry

The `tool_registry` decorator registers a function as a tool in the storage.

| Parameter | Type           | Description                      |
|-----------|----------------|----------------------------------|
| `storage` | `ToolStorage`  | The storage instance to register the tool in. |

**Returns:**
- `Callable`: The decorator function.

## Usage Examples


### Full Example
```python
from swarms import ToolStorage, tool_registry

storage = ToolStorage()


# Example usage
@tool_registry(storage)
def example_tool(x: int, y: int) -> int:
    """
    Example tool function that adds two numbers.

    Args:
        x (int): The first number.
        y (int): The second number.

    Returns:
        int: The sum of the two numbers.
    """
    return x + y


# Query all the tools and get the example tool
print(storage.list_tools())  # Should print ['example_tool']
# print(storage.get_tool('example_tool'))  # Should print <function example_tool at 0x...>

# Find the tool by names and call it
print(storage.get_tool("example_tool"))  # Should print 5


# Test the storage and querying
if __name__ == "__main__":
    print(storage.list_tools())  # Should print ['example_tool']
    print(storage.get_tool("example_tool"))  # Should print 5
    storage.set_setting("example_setting", 42)
    print(storage.get_setting("example_setting"))  # Should print 42

```


### Basic Usage

#### Example 1: Initializing ToolStorage and Adding a Tool

```python
from swarms.tools.tool_registry import ToolStorage, tool_registry

# Initialize ToolStorage
storage = ToolStorage()

# Define a tool function
@tool_registry(storage)
def add_numbers(x: int, y: int) -> int:
    return x + y

# List tools
print(storage.list_tools())  # Output: ['add_numbers']

# Retrieve and use the tool
add_tool = storage.get_tool('add_numbers')
print(add_tool(5, 3))  # Output: 8
```

### Advanced Usage

#### Example 2: Managing Settings

```python
# Set a setting
storage.set_setting('max_retries', 5)

# Get a setting
max_retries = storage.get_setting('max_retries')
print(max_retries)  # Output: 5
```

### Error Handling

#### Example 3: Handling Errors in Tool Retrieval

```python
try:
    non_existent_tool = storage.get_tool('non_existent')
except ValueError as e:
    print(e)  # Output: No tool found with name: non_existent
```

#### Example 4: Handling Duplicate Tool Addition

```python
try:
    @tool_registry(storage)
    def add_numbers(x: int, y: int) -> int:
        return x + y
except ValueError as e:
    print(e)  # Output: Tool with name add_numbers already exists.
```

## Conclusion

The `ToolStorage` module provides a robust solution for managing tool functions and settings. Its design allows for easy registration, retrieval, and management of tools, making it a valuable asset in various applications requiring dynamic function handling. The inclusion of detailed logging ensures that the operations are transparent and any issues can be quickly identified and resolved.

--------------------------------------------------

# File: swarms/ui/main.md

# Swarms Chat UI Documentation

The Swarms Chat interface provides a customizable, multi-agent chat experience using Gradio. It supports various specialized AI agents—from finance to healthcare and news analysis—by leveraging Swarms models.

---

## Table of Contents

1. [Installation](#installation)
2. [Quick Start](#quick-start)
3. [Parameters Overview](#parameters-overview)
4. [Specialized Agents](#specialized-agents)
    - [Finance Agents](#finance-agents)
    - [Healthcare Agents](#healthcare-agents)
    - [News & Research Agents](#news--research-agents)
5. [Swarms Integration Features](#swarms-integration-features)
6. [Usage Examples](#usage-examples)
    - [Finance Agent Example](#finance-agent-example)
    - [Healthcare Agent Example](#healthcare-agent-example)
    - [News Analysis Agent Example](#news-analysis-agent-example)
7. [Setup and Deployment](#setup-and-deployment)
8. [Best Practices](#best-practices)
9. [Notes](#notes)

---

## Installation

Make sure you have Python 3.7+ installed, then install the required packages using pip:

```bash
pip install gradio ai-gradio swarms
```

---

## Quick Start

Below is a minimal example to get the Swarms Chat interface up and running. Customize the agent, title, and description as needed.

```python
import gradio as gr
import ai_gradio

# Create and launch a Swarms Chat interface
gr.load(
    name='swarms:gpt-4-turbo',  # Model identifier (supports OpenAI and others)
    src=ai_gradio.registry,      # Source module for model configurations
    agent_name="Stock-Analysis-Agent",  # Example agent from Finance category
    title='Swarms Chat',
    description='Chat with an AI agent powered by Swarms'
).launch()
```

---

## Parameters Overview

When configuring your interface, consider the following parameters:

- **`name` (str):**  
  Model identifier (e.g., `'swarms:gpt-4-turbo'`) that specifies which Swarms model to use.

- **`src` (module):**  
  The source module (typically `ai_gradio.registry`) that contains model configurations.

- **`agent_name` (str):**  
  The name of the specialized agent you wish to use (e.g., "Stock-Analysis-Agent").

- **`title` (str):**  
  The title that appears at the top of the web interface.

- **`description` (str):**  
  A short summary describing the functionality of the chat interface.

---

## Specialized Agents

Swarms Chat supports multiple specialized agents designed for different domains. Below is an overview of available agent types.

### Finance Agents

1. **Stock Analysis Agent**
   - **Capabilities:**
     - Market analysis and stock recommendations.
     - Both technical and fundamental analysis.
     - Portfolio management suggestions.

2. **Tax Planning Agent**
   - **Capabilities:**
     - Tax optimization strategies.
     - Deduction analysis.
     - Guidance on tax law compliance.

### Healthcare Agents

1. **Medical Diagnosis Assistant**
   - **Capabilities:**
     - Analysis of symptoms.
     - Treatment recommendations.
     - Research using current medical literature.

2. **Healthcare Management Agent**
   - **Capabilities:**
     - Patient care coordination.
     - Organization of medical records.
     - Monitoring and tracking treatment plans.

### News & Research Agents

1. **News Analysis Agent**
   - **Capabilities:**
     - Real-time news aggregation.
     - Filtering news by topics.
     - Trend analysis and insights.

2. **Research Assistant**
   - **Capabilities:**
     - Analysis of academic papers.
     - Literature review support.
     - Guidance on research methodologies.

---

## Swarms Integration Features

### Core Capabilities

- **Multi-Agent Collaboration:** Multiple agents can be engaged simultaneously for a coordinated experience.
- **Real-Time Data Processing:** The interface processes and responds to queries in real time.
- **Natural Language Understanding:** Advanced NLP for context-aware and coherent responses.
- **Context-Aware Responses:** Responses are tailored based on conversation context.

### Technical Features

- **API Integration Support:** Easily connect with external APIs.
- **Custom Model Selection:** Choose the appropriate model for your specific task.
- **Concurrent Processing:** Supports multiple sessions concurrently.
- **Session Management:** Built-in session management ensures smooth user interactions.

---

## Usage Examples

Below are detailed examples for each type of specialized agent.

### Finance Agent Example

This example configures a chat interface for stock analysis:

```python
import gradio as gr
import ai_gradio

finance_interface = gr.load(
    name='swarms:gpt-4-turbo',
    src=ai_gradio.registry,
    agent_name="Stock-Analysis-Agent",
    title='Finance Assistant',
    description='Expert financial analysis and advice tailored to your investment needs.'
)
finance_interface.launch()
```

### Healthcare Agent Example

This example sets up a chat interface for healthcare assistance:

```python
import gradio as gr
import ai_gradio

healthcare_interface = gr.load(
    name='swarms:gpt-4-turbo',
    src=ai_gradio.registry,
    agent_name="Medical-Assistant-Agent",
    title='Healthcare Assistant',
    description='Access medical information, symptom analysis, and treatment recommendations.'
)
healthcare_interface.launch()
```

### News Analysis Agent Example

This example creates an interface for real-time news analysis:

```python
import gradio as gr
import ai_gradio

news_interface = gr.load(
    name='swarms:gpt-4-turbo',
    src=ai_gradio.registry,
    agent_name="News-Analysis-Agent",
    title='News Analyzer',
    description='Get real-time insights and analysis of trending news topics.'
)
news_interface.launch()
```

---

## Setup and Deployment

1. **Install Dependencies:**  
   Make sure all required packages are installed.

   ```bash
   pip install gradio ai-gradio swarms
   ```

2. **Import Modules:**  
   Import Gradio and ai_gradio in your Python script.

   ```python
   import gradio as gr
   import ai_gradio
   ```

3. **Configure and Launch the Interface:**  
   Configure your interface with the desired parameters and then launch.

   ```python
   interface = gr.load(
       name='swarms:gpt-4-turbo',
       src=ai_gradio.registry,
       agent_name="Your-Desired-Agent",
       title='Your Interface Title',
       description='A brief description of your interface.'
   )
   interface.launch()
   ```

4. **Deployment Options:**  
   - **Local:** By default, the interface runs at [http://localhost:7860](http://localhost:7860).
   - **Cloud Deployment:** Use cloud platforms like Heroku, AWS, or Google Cloud for remote access.
   - **Concurrent Sessions:** The system supports multiple users at the same time. Monitor resources and use proper scaling.

---

## Best Practices

1. **Select the Right Agent:**  
   Use the agent that best suits your specific domain needs.

2. **Model Configuration:**  
   Adjust model parameters based on your computational resources to balance performance and cost.

3. **Error Handling:**  
   Implement error handling to manage unexpected inputs or API failures gracefully.

4. **Resource Monitoring:**  
   Keep an eye on system performance, especially during high-concurrency sessions.

5. **Regular Updates:**  
   Keep your Swarms and Gradio packages updated to ensure compatibility with new features and security patches.

---

## Notes

- **Local vs. Remote:**  
  The interface runs locally by default but can be deployed on remote servers for wider accessibility.

- **Customization:**  
  You can configure custom model parameters and integrate additional APIs as needed.

- **Session Management:**  
  Built-in session handling ensures that users can interact concurrently without interfering with each other's sessions.

- **Error Handling & Rate Limiting:**  
  The system includes basic error handling and rate limiting to maintain performance under load.

---

This documentation is designed to provide clarity, reliability, and comprehensive guidance for integrating and using the Swarms Chat UI. For further customization or troubleshooting, consult the respective package documentation and community forums.

--------------------------------------------------

# File: swarms_cloud/add_agent.md

# Publishing an Agent to Agent Marketplace

## Requirements

- `swarms-cloud` package with `pip3 install -U swarms-cloud`

- Onboarding Process with `swarms-cloud onboarding`

- A Dockerfile `Dockerfile` containing the API of your agent code with FastAPI

- A YAML file for configuration `agent.yaml`

## Deployment YAML
```yaml

# Agent metadata and description
agent_name: "example-agent"  # The name of the agent
description: "This agent performs financial data analysis."  # A brief description of the agent's purpose
version: "v1.0"  # The version number of the agent
author: "Agent Creator Name"  # The name of the person or entity that created the agent
contact_email: "creator@example.com"  # The email address for contacting the agent's creator
tags:
  - "financial"  # Tag indicating the agent is related to finance
  - "data-analysis"  # Tag indicating the agent performs data analysis
  - "agent"  # Tag indicating this is an agent


# Deployment configuration
deployment_config:
  # Dockerfile configuration
  dockerfile_path: "./Dockerfile"  # The path to the Dockerfile for building the agent's image
  dockerfile_port: 8080  # The port number the agent will listen on
  
  # Resource allocation for the agent
  resources:
    cpu: 2  # Number of CPUs allocated to the agent
    memory: "2Gi"  # Memory allocation for the agent in gigabytes
    max_instances: 5  # Maximum number of instances to scale up to
    min_instances: 1  # Minimum number of instances to keep running
    timeout: 300s  # Request timeout setting in seconds

  # Autoscaling configuration
  autoscaling:
    max_concurrency: 80  # Maximum number of requests the agent can handle concurrently
    target_utilization: 0.6  # CPU utilization target for auto-scaling

  # Environment variables for the agent
  environment_variables:
    DATABASE_URL: "postgres://user:password@db-url"  # URL for the database connection
    API_KEY: "your-secret-api-key"  # API key for authentication
    LOG_LEVEL: "info"  # Log level for the agent

  # Secrets configuration
  secrets:
    SECRET_NAME_1: "projects/my-project/secrets/my-secret/versions/latest"  # Path to a secret
```

--------------------------------------------------

# File: swarms_cloud/agent_api.md

# Swarms API Documentation

The Swarms API provides endpoints to interact with various language models, manage agent configurations, and handle token counting. This documentation covers the available endpoints, input and output models, and detailed examples for each endpoint.

URL: `https://api.swarms.world`

## Key Features
- Dynamic Model Switching: Easily switch between different language models based on user input.
- Token Counting: Efficiently count tokens using the tiktoken library.
- Agent Configuration: Configure and run agents with detailed settings for various tasks.
- CORS Handling: Support for Cross-Origin Resource Sharing (CORS) to allow web-based clients to interact with the API.


## Endpoints

### `/v1/models`

**Method:** `GET`

**Response Model:** `List[str]`

**Description:**
This endpoint returns a list of available model names. It is useful for clients to query and understand which models are available for use.

**Response Example:**

```json
[
    "OpenAIChat",
    "GPT4VisionAPI",
    "Anthropic"
]
```

**Example Usage:**

```python
import requests

response = requests.get("http://api.swarms.world/v1/models")
print(response.json())
```

### `/v1/agent/completions`

**Method:** `POST`

**Request Model:** `AgentInput`

**Response Model:** `AgentOutput`

**URL:** `http://api.swarms.world/v1/agent/completions`

**Description:**
This endpoint handles the completion request for an agent configured with the given input parameters. It processes the request and returns the completion results.

**Request Example:**

```json
{
    "agent_name": "Swarm Agent",
    "system_prompt": "Summarize the following text",
    "agent_description": "An agent that summarizes text",
    "model_name": "OpenAIChat",
    "max_loops": 1,
    "autosave": false,
    "dynamic_temperature_enabled": false,
    "dashboard": false,
    "verbose": false,
    "streaming_on": true,
    "saved_state_path": null,
    "sop": null,
    "sop_list": null,
    "user_name": "User",
    "retry_attempts": 3,
    "context_length": 8192,
    "task": "This is a sample text that needs to be summarized."
}
```

**Response Example:**

```json
{
    "agent": {
        "agent_name": "Swarm Agent",
        "system_prompt": "Summarize the following text",
        "agent_description": "An agent that summarizes text",
        "model_name": "OpenAIChat",
        "max_loops": 1,
        "autosave": false,
        "dynamic_temperature_enabled": false,
        "dashboard": false,
        "verbose": false,
        "streaming_on": true,
        "saved_state_path": null,
        "sop": null,
        "sop_list": null,
        "user_name": "User",
        "retry_attempts": 3,
        "context_length": 8192,
        "task": "This is a sample text that needs to be summarized."
    },
    "completions": {
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "Swarm Agent",
                    "content": "The sample text summarizes how to perform text summarization using an agent.",
                    "name": null
                }
            }
        ],
        "stream_choices": null,
        "usage_info": {
            "prompt_tokens": 10,
            "completion_tokens": 15,
            "total_tokens": 25
        }
    }
}
```

**Example Usage:**

```python
import requests
from pydantic import BaseModel
from typing import List

class AgentInput(BaseModel):
    agent_name: str = "Swarm Agent"
    system_prompt: str = None
    agent_description: str = None
    model_name: str = "OpenAIChat"
    max_loops: int = 1
    autosave: bool = False
    dynamic_temperature_enabled: bool = False
    dashboard: bool = False
    verbose: bool = False
    streaming_on: bool = True
    saved_state_path: str = None
    sop: str = None
    sop_list: List[str] = None
    user_name: str = "User"
    retry_attempts: int = 3
    context_length: int = 8192
    task: str = None

agent_input = AgentInput(task="Generate a summary of the provided text.")
response = requests.post("http://api.swarms.world/v1/agent/completions", json=agent_input.dict())
print(response.json())
```

## Models

### AgentInput

The `AgentInput` class defines the structure of the input data required to configure and run an agent.

| Parameter                      | Type            | Default         | Description                                                     |
|--------------------------------|-----------------|-----------------|-----------------------------------------------------------------|
| `agent_name`                   | `str`           | "Swarm Agent"   | The name of the agent.                                          |
| `system_prompt`                | `str` or `None` | `None`          | The system prompt to guide the agent's behavior.                |
| `agent_description`            | `str` or `None` | `None`          | A description of the agent's purpose.                           |
| `model_name`                   | `str`           | "OpenAIChat"    | The name of the language model to use.                          |
| `max_loops`                    | `int`           | 1               | The maximum number of loops the agent should perform.           |
| `autosave`                     | `bool`          | `False`         | Whether to enable autosave functionality.                       |
| `dynamic_temperature_enabled`  | `bool`          | `False`         | Whether dynamic temperature adjustment is enabled.              |
| `dashboard`                    | `bool`          | `False`         | Whether to enable the dashboard feature.                        |
| `verbose`                      | `bool`          | `False`         | Whether to enable verbose logging.                              |
| `streaming_on`                 | `bool`          | `True`          | Whether to enable streaming of responses.                       |
| `saved_state_path`             | `str` or `None` | `None`          | Path to save the agent's state.                                 |
| `sop`                          | `str` or `None` | `None`          | Standard operating procedures for the agent.                    |
| `sop_list`                     | `List[str]` or `None` | `None`    | A list of standard operating procedures.                        |
| `user_name`                    | `str`           | "User"          | The name of the user interacting with the agent.                |
| `retry_attempts`               | `int`           | 3               | Number of retry attempts for failed operations.                 |
| `context_length`               | `int`           | 8192            | Maximum context length for the model's input.                   |
| `task`                         | `str` or `None` | `None`          | The task description for the agent to perform.                  |

### AgentOutput

The `AgentOutput` class defines the structure of the output data returned by the agent after processing a request.

| Parameter     | Type                     | Description                                      |
|---------------|--------------------------|--------------------------------------------------|
| `agent`       | `AgentInput`             | The input configuration used to create the agent.|
| `completions` | `ChatCompletionResponse` | The response generated by the agent.             |

## Functions

### count_tokens

The `count_tokens` function counts the number of tokens in a given text using the `tiktoken` library.

**Parameters:**

- `text` (`str`): The text to be tokenized and counted.

**Returns:**

- `int`: The number of tokens in the text.

**Example Usage:**

```python
text = "This is a sample text to count tokens."
token_count = count_tokens(text)
print(f"Token count: {token_count}")
```

### model_router

The `model_router` function switches to the specified language model based on the provided model name.

**Parameters:**

- `model_name` (`str`): The name of the model to switch to.

**Returns:**

- An instance of the specified language model.

**Example Usage:**

```python
model_name = "OpenAIChat"
model_instance = model_router(model_name)
```

## Additional Information and Tips

- **Error Handling**: Ensure robust error handling by catching exceptions and returning meaningful HTTP status codes and messages.
- **Model Selection**: When adding new models, update the `model_router` function and the `/v1/models` endpoint to include the new model names.
- **Token Management**: Keep track of token usage to optimize API costs and manage rate limits effectively.

--------------------------------------------------

# File: swarms_cloud/api_pricing.md

# Swarm Agent API Pricing

!!! success "🎉 Get Started with $20 Free Credits!"
    New users receive $20 in free credits when they sign up! [Create your account now](https://swarms.world/platform/account) to start building with our powerful multi-agent platform.

!!! abstract "Overview"
    The Swarm Agent API provides a powerful platform for managing multi-agent collaboration at scale and orchestrating swarms of LLM agents in the cloud. Our pricing model is designed to be transparent and cost-effective, enabling you to harness the full potential of your agents with ease.

## Credit System

The Swarm API operates on a credit-based system with the following characteristics:

- **Credits** are the currency used within the platform

- 1 credit = $1 USD

- Credits can be purchased with USD or $swarms Solana tokens

### Credit Types

| Type | Description | Expiration |
|------|-------------|------------|
| Standard Credits | Purchased credits | Never expires |
| Free Credits | Promotional credits | May have expiration dates |

## Pricing Structure

### Base Costs

| Cost Component | Price |
|----------------|-------|
| Base cost per agent | $0.01 per agent |

### Token Usage Costs

| Token Type | Cost |
|------------|------|
| Input tokens | $2.00 per 1M tokens |
| Output tokens | $4.50 per 1M tokens |

### Night-Time Discount

!!! tip "Off-Peak Hours Discount"
    To encourage efficient resource usage during off-peak hours, we offer significant discounts for operations performed during California night-time hours:

    | Time Period (Pacific Time) | Discount |
    |----------------------------|----------|
    | 8:00 PM to 6:00 AM | 75% off token costs |

## Cost Calculation

### Formula

The total cost for a swarm execution is calculated as follows:

```math
Total Cost = (Number of Agents × $0.01) + 
             (Total Input Tokens / 1M × $2.00 × Number of Agents) +
             (Total Output Tokens / 1M × $4.50 × Number of Agents)
```

With night-time discount applied:
```math
Input Token Cost = Input Token Cost × 0.25
Output Token Cost = Output Token Cost × 0.25
```

### Example Scenarios

#### Scenario 1: Basic Workflow (Day-time)

!!! example "Basic Workflow Example"
    **Parameters:**
    
    - 3 agents
    
    - 10,000 input tokens total
    
    - 25,000 output tokens total

    **Calculation:**
    
    - Agent cost: 3 × $0.01 = $0.03
    
    - Input token cost: (10,000 / 1,000,000) × $2.00 × 3 = $0.06
    
    - Output token cost: (25,000 / 1,000,000) × $4.50 × 3 = $0.3375
    
    - **Total cost: $0.4275**

#### Scenario 2: Complex Workflow (Night-time)

!!! example "Complex Workflow Example"
    **Parameters:**
    
    - 5 agents
    
    - 50,000 input tokens total
    
    - 125,000 output tokens total

    **Calculation:**
    
    - Agent cost: 5 × $0.01 = $0.05
    
    - Input token cost: (50,000 / 1,000,000) × $2.00 × 5 × 0.25 = $0.125
    
    - Output token cost: (125,000 / 1,000,000) × $4.50 × 5 × 0.25 = $0.703125
    
    - **Total cost: $0.878125**

## Purchasing Credits

Credits can be purchased through our platform in two ways:

### USD Payment

- Available through our [account page](https://swarms.world/platform/account)

- Secure payment processing

- Minimum purchase: $10

### $swarms Token Payment

- Use Solana-based $swarms tokens

- Tokens can be purchased on supported exchanges

- Connect your Solana wallet on our [account page](https://swarms.world/platform/account)

## Free Credits

!!! info "Free Credit Program"
    We occasionally offer free credits to:
    
    - New users (welcome bonus)
    
    - During promotional periods
    
    - For educational and research purposes

    **Important Notes:**
    
    - Used before standard credits
    
    - May have expiration dates
    
    - May have usage restrictions

## Billing and Usage Tracking

Track your credit usage through our comprehensive logging and reporting features:

### API Logs
- Access detailed logs via the `/v1/swarm/logs` endpoint

- View cost breakdowns for each execution

### Dashboard
- Real-time credit balance display

- Historical usage graphs

- Detailed cost analysis

- Available at [https://swarms.world/platform/dashboard](https://swarms.world/platform/dashboard)

## FAQ

??? question "Is there a minimum credit purchase?"
    Yes, the minimum credit purchase is $10 USD equivalent.

??? question "Do credits expire?"
    Standard credits do not expire. Free promotional credits may have expiration dates.

??? question "How is the night-time discount applied?"
    The system automatically detects the execution time based on Pacific Time (America/Los_Angeles) and applies a 75% discount to token costs for executions between 8:00 PM and 6:00 AM.

??? question "What happens if I run out of credits during execution?"
    Executions will fail with a 402 Payment Required error if sufficient credits are not available. We recommend maintaining a credit balance appropriate for your usage patterns.

??? question "Can I get a refund for unused credits?"
    Please contact our support team for refund requests for unused credits.

??? question "Are there volume discounts available?"
    Yes, please contact our sales team for enterprise pricing and volume discounts.

## References

- [Swarm API Documentation](https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/)
- [Account Management Portal](https://swarms.world/platform/account)
- [Swarm Types Reference](https://docs.swarms.world/swarms_cloud/swarm_types)

---

!!! info "Need Help?"
    For additional questions or custom pricing options, please contact our support team at [kye@swarms.world](mailto:kye@swarms.world).

--------------------------------------------------

# File: swarms_cloud/architecture.md

# Under The Hood: The Swarm Cloud Serving Infrastructure
-----------------------------------------------------------------

This blog post delves into the intricate workings of our serving model infrastructure, providing a comprehensive understanding for both users and infrastructure engineers. We'll embark on a journey that starts with an API request and culminates in a response generated by your chosen model, all orchestrated within a multi-cloud environment.

### The Journey of an API Request

1.  **The Gateway:** Your API request first arrives at an EC2 instance running SkyPilot, a lightweight controller.

2.  **Intelligent Routing:** SkyPilot, wielding its decision-making prowess, analyzes the request and identifies the most suitable GPU in our multi-cloud setup. Factors like resource availability, latency, and cost might influence this choice.

3.  **Multi-Cloud Agility:** Based on the chosen cloud provider (AWS or Azure), SkyPilot seamlessly directs the request to the appropriate containerized model residing in a sky clusters cluster. Here's where the magic of cloud-agnostic deployments comes into play.

### Unveiling the Architecture

Let's dissect the technical architecture behind this process:

-   **SkyPilot (EC2 Instance):** This lightweight controller, deployed on an EC2 instance, acts as the central hub for orchestrating requests and routing them to suitable model instances.

-   **Swarm Cloud Repositories:** Each model resides within its own dedicated folder on the Swarms Cloud GitHub repository (<https://github.com/kyegomez/swarms-cloud>). Here, you'll find a folder structure like this:

```
servers/
  <model_name_1>/
    sky-serve.yaml  # Deployment configuration file
  <model_name_2>/
    sky-serve.yaml
  ...

```

-   **SkyServe Deployment Tool:** This is the workhorse responsible for deploying models within sky clusters. Each model's folder contains a `sky-serve.yaml` file that dictates the deployment configuration.

### Infrastructure Engineer's Toolkit: Commands for Model Deployment

Here's a breakdown of the `sky serve` command and its subcommands:

-   `sky serve -h`: Displays the help message for the `sky serve` CLI tool.

**Commands:**

-   `sky serve up yaml.yaml -n --cloud aws/azure`: This command deploys a SkyServe service based on the provided `yaml.yaml` configuration file. The `-n` flag indicates a new deployment, and the `--cloud` flag specifies the target cloud platform (AWS or Azure).

**Additional Commands:**

-   `sky serve update`: Updates a running SkyServe service.

-   `sky serve status`: Shows the status of deployed SkyServe services.

-   `sky serve down`: Tears down (stops and removes) a SkyServe service.

-   `sky serve logs`: Tails the logs of a running SkyServe service, providing valuable insights into its operation.

By leveraging these commands, infrastructure engineers can efficiently manage the deployment and lifecycle of models within the multi-cloud environment.

**Building the Cluster and Accessing the Model:**

When you deploy a model using `sky serve up`, SkyServe triggers the building of a sky clusters cluster, if one doesn't already exist. Once the deployment is complete, SkyServe provides you with an endpoint URL for interacting with the model. This URL allows you to send requests to the deployed model and receive its predictions.

### Understanding the `sky-serve.yaml` Configuration

The `sky-serve.yaml` file plays a crucial role in defining the deployment parameters for your model. This file typically includes properties such as:

-   **Image:** Specifies the Docker image containing your model code and dependencies.

-   **Replicas:** Defines the number of model replicas to be deployed in the Swarm cluster. This allows for load balancing and fault tolerance.

-   **Resources:** Sets memory and CPU resource constraints for the deployed model containers.

-   **Networking:** Configures network settings for communication within the sky clusters and with the outside world.

**Benefits of Our Infrastructure:**

-   **Multi-Cloud Flexibility:** Deploy models seamlessly across AWS and Azure, taking advantage of whichever platform best suits your needs.

-   **Scalability:** Easily scale model deployments up or down based on traffic demands.

-   **Cost Optimization:** The intelligent routing by SkyPilot helps optimize costs by utilizing the most cost-effective cloud resources.

-   **Simplified Management:** Manage models across clouds with a single set of commands using `sky serve`.

### Deep Dive: Technical Architecture

**Cloud Considerations:**

Our multi-cloud architecture offers several advantages, but it also introduces complexities that need to be addressed. Here's a closer look at some key considerations:

-   **Cloud Provider APIs and SDKs:** SkyPilot interacts with the APIs and SDKs of the chosen cloud provider (AWS or Azure) to manage resources like virtual machines, storage, and networking. Infrastructure engineers need to be familiar with the specific APIs and SDKs for each cloud platform to ensure smooth operation and troubleshooting.

-   **Security:** Maintaining consistent security across different cloud environments is crucial. This involves aspects like IAM (Identity and Access Management) configuration, network segmentation, and encryption of sensitive data at rest and in transit. Infrastructure engineers need to implement robust security measures tailored to each cloud provider's offerings.

-   **Network Connectivity:** Establishing secure and reliable network connectivity between SkyPilot (running on EC2), sky clusters clusters (deployed on cloud VMs), and your client applications is essential. This might involve setting up VPN tunnels or utilizing cloud-native networking solutions offered by each provider.

-   **Monitoring and Logging:** Monitoring the health and performance of SkyPilot, sky clusters clusters, and deployed models across clouds is critical for proactive issue identification and resolution. Infrastructure engineers can leverage cloud provider-specific monitoring tools alongside centralized logging solutions for comprehensive oversight.

**sky clusters Clusters**

sky clusters is a container orchestration platform that facilitates the deployment and management of containerized applications, including your machine learning models. When you deploy a model with `sky serve up`, SkyPilot launches an node with:

-   **Provision Resources:** SkyPilot requests resources from the chosen cloud provider (e.g., VMs with GPUs) to create a sky clusters cluster if one doesn't already exist.

-   **Deploy Containerized Models:** SkyPilot leverages the `sky-serve.yaml` configuration to build Docker images containing your model code and dependencies. These images are then pushed to a container registry (e.g., Docker Hub) and deployed as containers within the Swarm cluster.

-   **Load Balancing and Service Discovery:** sky clusters provides built-in load balancing capabilities to distribute incoming requests across multiple model replicas, ensuring high availability and performance. Additionally, service discovery mechanisms allow models to find each other and communicate within the cluster.

**SkyPilot - The Orchestrator**

SkyPilot, the lightweight controller running on an EC2 instance, plays a central role in this infrastructure. Here's a deeper look at its functionalities:

-   **API Gateway Integration:** SkyPilot can be integrated with your API gateway or service mesh to receive incoming requests for model predictions.

-   **Request Routing:** SkyPilot analyzes the incoming request, considering factors like model compatibility, resource availability, and latency. Based on this analysis, SkyPilot selects the most suitable model instance within the appropriate sky clusters cluster.

-   **Cloud Provider Interaction:** SkyPilot interacts with the chosen cloud provider's APIs to manage resources required for the sky clusters cluster and model deployment.

-   **Model Health Monitoring:** SkyPilot can be configured to monitor the health and performance of deployed models. This might involve collecting metrics like model response times, resource utilization, and error rates.

-   **Scalability Management:** Based on pre-defined policies or real-time traffic patterns, SkyPilot can trigger the scaling of model deployments (adding or removing replicas) within the sky clusters cluster.

**Advanced Considerations**

This blog post has provided a foundational understanding of our serving model infrastructure. For infrastructure engineers seeking a deeper dive, here are some additional considerations:

-   **Container Security:** Explore container image scanning for vulnerabilities, enforcing least privilege principles within container runtime environments, and utilizing secrets management solutions for secure access to sensitive data.

-   **Model Versioning and Rollbacks:** Implement a model versioning strategy to track changes and facilitate rollbacks to previous versions if necessary.

-   **A/B Testing:** Integrate A/B testing frameworks to evaluate the performance of different model versions and configurations before full-scale deployment.

-   **Auto-Scaling with Cloud Monitoring:** Utilize cloud provider-specific monitoring services like Amazon CloudWatch or Azure Monitor to trigger auto-scaling of sky clusters clusters based on predefined metrics.

By understanding these technical aspects and considerations, infrastructure engineers can effectively manage and optimize our multi-cloud serving model infrastructure.

### Conclusion

This comprehensive exploration has shed light on the intricate workings of our serving model infrastructure. We've covered the journey of an API request, delved into the technical architecture with a focus on cloud considerations, sky clusters clusters, and SkyPilot's role as the orchestrator. We've also explored advanced considerations for infrastructure engineers seeking to further optimize and secure this multi-cloud environment.

This understanding empowers both users and infrastructure engineers to leverage this technology effectively for deploying and managing your machine learning models at scale.


--------------------------------------------------

# File: swarms_cloud/available_models.md

# Available Models

| Model Name            | Description                                                                                             | Input Price  | Output Price | Use Cases                                                              |
|-----------------------|---------------------------------------------------------------------------------------------------------|--------------|--------------|------------------------------------------------------------------------|
| **nternlm-xcomposer2-4khd** | One of the highest performing VLMs (Video Language Models).                                            | $4/1M Tokens | $8/1M Tokens | High-resolution video processing and understanding.                     |


## What models should we add?
[Book a call with us to learn more about your needs:](https://calendly.com/swarm-corp/30min)


--------------------------------------------------

# File: swarms_cloud/best_practices.md

# Swarms API Best Practices Guide

This comprehensive guide outlines production-grade best practices for using the Swarms API effectively. Learn how to choose the right swarm architecture, optimize costs, and implement robust error handling.

## Quick Reference Cards

=== "Swarm Types"
    
    !!! info "Available Swarm Architectures"
        
        | Swarm Type | Best For | Use Cases |
        |------------|----------|------------|
        | `AgentRearrange` | Dynamic workflows | - Complex task decomposition<br>- Adaptive processing<br>- Multi-stage analysis<br>- Dynamic resource allocation |
        | `MixtureOfAgents` | Diverse expertise | - Cross-domain problems<br>- Comprehensive analysis<br>- Multi-perspective tasks<br>- Research synthesis |
        | `SpreadSheetSwarm` | Data processing | - Financial analysis<br>- Data transformation<br>- Batch calculations<br>- Report generation |
        | `SequentialWorkflow` | Linear processes | - Document processing<br>- Step-by-step analysis<br>- Quality control<br>- Content pipeline |
        | `ConcurrentWorkflow` | Parallel tasks | - Batch processing<br>- Independent analyses<br>- High-throughput needs<br>- Multi-market analysis |
        | `GroupChat` | Collaborative solving | - Brainstorming<br>- Decision making<br>- Problem solving<br>- Strategy development |
        | `MultiAgentRouter` | Task distribution | - Load balancing<br>- Specialized processing<br>- Resource optimization<br>- Service routing |
        | `AutoSwarmBuilder` | Automated setup | - Quick prototyping<br>- Simple tasks<br>- Testing<br>- MVP development |
        | `HiearchicalSwarm` | Complex organization | - Project management<br>- Research analysis<br>- Enterprise workflows<br>- Team automation |
        | `MajorityVoting` | Consensus needs | - Quality assurance<br>- Decision validation<br>- Risk assessment<br>- Content moderation |

=== "Application Patterns"
    
    !!! tip "Specialized Application Configurations"
        
        | Application | Recommended Swarm | Benefits |
        |------------|-------------------|-----------|
        | **Team Automation** | `HiearchicalSwarm` | - Automated team coordination<br>- Clear responsibility chain<br>- Scalable team structure |
        | **Research Pipeline** | `SequentialWorkflow` | - Structured research process<br>- Quality control at each stage<br>- Comprehensive output |
        | **Trading System** | `ConcurrentWorkflow` | - Multi-market coverage<br>- Real-time analysis<br>- Risk distribution |
        | **Content Factory** | `MixtureOfAgents` | - Automated content creation<br>- Consistent quality<br>- High throughput |

=== "Cost Optimization"

    !!! tip "Advanced Cost Management Strategies"
        
        | Strategy | Implementation | Impact |
        |----------|----------------|---------|
        | Batch Processing | Group related tasks | 20-30% cost reduction |
        | Off-peak Usage | Schedule for 8 PM - 6 AM PT | 15-25% cost reduction |
        | Token Optimization | Precise prompts, focused tasks | 10-20% cost reduction |
        | Caching | Store reusable results | 30-40% cost reduction |
        | Agent Optimization | Use minimum required agents | 15-25% cost reduction |
        | Smart Routing | Route to specialized agents | 10-15% cost reduction |
        | Prompt Engineering | Optimize input tokens | 15-20% cost reduction |

=== "Industry Solutions"

    !!! example "Industry-Specific Swarm Patterns"
        
        | Industry | Use Case | Applications |
        |----------|----------|--------------|
        | **Finance** | Automated trading desk | - Portfolio management<br>- Risk assessment<br>- Market analysis<br>- Trading execution |
        | **Healthcare** | Clinical workflow automation | - Patient analysis<br>- Diagnostic support<br>- Treatment planning<br>- Follow-up care |
        | **Legal** | Legal document processing | - Document review<br>- Case analysis<br>- Contract review<br>- Compliance checks |
        | **E-commerce** | E-commerce operations | - Product management<br>- Pricing optimization<br>- Customer support<br>- Inventory management |

=== "Error Handling"

    !!! warning "Advanced Error Management Strategies"
        
        | Error Code | Strategy | Recovery Pattern |
        |------------|----------|------------------|
        | 400 | Input Validation | Pre-request validation with fallback |
        | 401 | Auth Management | Secure key rotation and storage |
        | 429 | Rate Limiting | Exponential backoff with queuing |
        | 500 | Resilience | Retry with circuit breaking |
        | 503 | High Availability | Multi-region redundancy |
        | 504 | Timeout Handling | Adaptive timeouts with partial results |

## Choosing the Right Swarm Architecture

### Decision Framework

Use this framework to select the optimal swarm architecture for your use case:

1. **Task Complexity Analysis**
    - Simple tasks → `AutoSwarmBuilder`
    - Complex tasks → `HiearchicalSwarm` or `MultiAgentRouter`
    - Dynamic tasks → `AgentRearrange`

2. **Workflow Pattern**
    - Linear processes → `SequentialWorkflow`
    - Parallel operations → `ConcurrentWorkflow`
    - Collaborative tasks → `GroupChat`

3. **Domain Requirements**
    - Multi-domain expertise → `MixtureOfAgents`
    - Data processing → `SpreadSheetSwarm`
    - Quality assurance → `MajorityVoting`

### Industry-Specific Recommendations

=== "Finance"
    
    !!! example "Financial Applications"
        - Risk Analysis: `HiearchicalSwarm`
        - Market Research: `MixtureOfAgents`
        - Trading Strategies: `ConcurrentWorkflow`
        - Portfolio Management: `SpreadSheetSwarm`

=== "Healthcare"
    
    !!! example "Healthcare Applications"
        - Patient Analysis: `SequentialWorkflow`
        - Research Review: `MajorityVoting`
        - Treatment Planning: `GroupChat`
        - Medical Records: `MultiAgentRouter`

=== "Legal"
    
    !!! example "Legal Applications"
        - Document Review: `SequentialWorkflow`
        - Case Analysis: `MixtureOfAgents`
        - Compliance Check: `HiearchicalSwarm`
        - Contract Analysis: `ConcurrentWorkflow`

## Production Best Practices

### Best Practices Summary

!!! success "Recommended Patterns"
    - Use appropriate swarm types for tasks
    - Implement robust error handling
    - Monitor and log executions
    - Cache repeated results
    - Rotate API keys regularly

!!! danger "Anti-patterns to Avoid"
    - Hardcoding API keys
    - Ignoring rate limits
    - Missing error handling
    - Excessive agent count
    - Inadequate monitoring

### Performance Benchmarks

!!! note "Typical Performance Metrics"
    
    | Metric | Target Range | Warning Threshold |
    |--------|--------------|-------------------|
    | Response Time | < 2s | > 5s |
    | Success Rate | > 99% | < 95% |
    | Cost per Task | < $0.05 | > $0.10 |
    | Cache Hit Rate | > 80% | < 60% |
    | Error Rate | < 1% | > 5% |

### Additional Resources

!!! info "Useful Links"
    
    - [Swarms API Documentation](https://docs.swarms.world)
    - [API Dashboard](https://swarms.world/platform/api-keys)

--------------------------------------------------

# File: swarms_cloud/chinese_api_pricing.md

# Swarm Agent API 定价文档


Swarm Agent API 提供了一个强大的平台，用于大规模管理多代理协作和在云端编排 LLM 代理群。本文档概述了定价模型、成本计算方式以及如何购买和管理您的积分。

我们的定价设计旨在透明且具有成本效益，使您能够轻松发挥代理的全部潜力。成本基于：

- 使用的代理数量

- 输入和输出令牌使用量

- 执行时间

## 积分系统

Swarm API 采用基于积分的系统：

- **积分**是平台内使用的货币

- 1积分 = 1美元

- 积分可以用美元或 $swarms Solana 代币购买

- 两种类型的积分：

  - **标准积分**：购买的积分永不过期

  - **免费积分**：促销积分，可能有使用限制

## 定价结构

### 基本成本

| 成本组成 | 价格 |
|----------------|-------|
| 每个代理的基本成本 | 每个代理$0.01 |

### 令牌使用成本

| 令牌类型 | 成本 |
|------------|------|
| 输入令牌 | 每百万令牌$2.00 |
| 输出令牌 | 每百万令牌$4.50 |

### 夜间折扣

为了鼓励在非高峰时段高效利用资源，我们在加州夜间时段提供显著折扣：

| 时间段（太平洋时间） | 折扣 |
|----------------------------|----------|
| 晚上8:00至早上6:00 | 令牌成本75%折扣 |

## 成本计算

### 公式

群体执行的总成本计算如下：

```
总成本 = (代理数量 × $0.01) + 
        (总输入令牌数 / 1M × $2.00 × 代理数量) +
        (总输出令牌数 / 1M × $4.50 × 代理数量)
```

应用夜间折扣时：
```
输入令牌成本 = 输入令牌成本 × 0.25
输出令牌成本 = 输出令牌成本 × 0.25
```

### 示例场景

#### 场景1：基本工作流（白天）

- 3个代理

- 总共10,000个输入令牌

- 总共25,000个输出令牌

**计算：**

- 代理成本：3 × $0.01 = $0.03

- 输入令牌成本：(10,000 / 1,000,000) × $2.00 × 3 = $0.06

- 输出令牌成本：(25,000 / 1,000,000) × $4.50 × 3 = $0.3375

- **总成本：$0.4275**

#### 场景2：复杂工作流（夜间）

- 5个代理

- 总共50,000个输入令牌

- 总共125,000个输出令牌

**计算：**

- 代理成本：5 × $0.01 = $0.05

- 输入令牌成本：(50,000 / 1,000,000) × $2.00 × 5 × 0.25 = $0.125

- 输出令牌成本：(125,000 / 1,000,000) × $4.50 × 5 × 0.25 = $0.703125

- **总成本：$0.878125**

## 购买积分

可以通过我们的平台以两种方式购买积分：

1. **美元支付**
   - 可通过我们的[账户页面](https://swarms.world/platform/account)使用
   - 安全支付处理
   - 最低购买额：$10

2. **$swarms 代币支付**
   - 使用基于Solana的$swarms代币
   - 可在支持的交易所购买代币
   - 在我们的[账户页面](https://swarms.world/platform/account)连接您的Solana钱包

## 免费积分

我们偶尔会向以下对象提供免费积分：

- 新用户（欢迎奖励）

- 促销期间

- 教育和研究目的

关于免费积分的说明：

- 在标准积分之前使用

- 可能有过期日期

- 可能有使用限制

## 账单和使用跟踪

通过我们全面的日志和报告功能跟踪您的积分使用情况：

1. **API日志**

   - 通过`/v1/swarm/logs`端点访问详细日志

   - 查看每次执行的成本明细

2. **仪表板**

   - 实时积分余额显示

   - 历史使用图表

   - 详细成本分析

   - 可在[https://swarms.world/platform/dashboard](https://swarms.world/platform/dashboard)访问

## 常见问题

**问：是否有最低积分购买要求？**  
答：是的，最低积分购买额为10美元等值。

**问：积分会过期吗？**  
答：标准积分不会过期。免费促销积分可能有过期日期。

**问：夜间折扣如何应用？**  
答：系统会根据太平洋时间（America/Los_Angeles）自动检测执行时间，并在晚上8:00至早上6:00之间的执行应用75%的令牌成本折扣。

**问：如果我在执行过程中积分用完了会怎样？**  
答：如果没有足够的积分，执行将失败并显示402 Payment Required错误。我们建议维持适合您使用模式的积分余额。

**问：我可以获得未使用积分的退款吗？**  
答：请联系我们的支持团队处理未使用积分的退款请求。

**问：是否有批量折扣？**  
答：是的，请联系我们的销售团队了解企业定价和批量折扣。

## 参考资料

- [Swarm API 文档](https://docs.swarms.world)

- [账户管理门户](https://swarms.world/platform/account)

- [Swarm 类型参考](https://docs.swarms.world/swarm-types)

- [令牌使用指南](https://docs.swarms.world/token-usage)

- [API 参考](https://docs.swarms.world/api-reference)

---

如有其他问题或自定义定价选项，请联系我们的支持团队，邮箱：kye@swarms.world

--------------------------------------------------

# File: swarms_cloud/cli.md

# Swarms Cloud CLI Documentation

Welcome to the Swarms Cloud CLI documentation. This guide will help you understand how to use the CLI to interact with the Swarms Cloud platform.



## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Usage](#usage)
4. [Commands](#commands)
   - [onboarding](#onboarding)
   - [help](#help)
   - [get-api-key](#get-api-key)
   - [check-login](#check-login)
   - [read-docs](#read-docs)
5. [Troubleshooting](#troubleshooting)
6. [FAQs](#faqs)
7. [Contact Support](#contact-support)

## Introduction

The Swarms Cloud CLI is a command-line interface tool that allows you to interact with the Swarms Cloud platform. It provides various commands to help you manage your account, retrieve API keys, and access documentation.

## Installation

To install the Swarms Cloud CLI, you need to have Python installed on your system. You can then install the CLI using pip:

```bash
pip3 install -U swarms-cloud
```

## Usage

Once installed, you can use the CLI by typing `swarms-cloud` followed by the command you wish to execute. For example:

```bash
swarms-cloud help
```

## Commands

### onboarding

Starts the onboarding process to help you set up your account.

```bash
swarms-cloud onboarding
```

### help

Displays the help message with a list of available commands.

```bash
swarms-cloud help
```

### get-api-key

Opens the API key retrieval page in your default web browser.

```bash
swarms-cloud get-api-key
```

### check-login

Checks if you are logged in and starts the cache if necessary.

```bash
swarms-cloud check-login
```

### read-docs

Redirects you to the Swarms Cloud documentation page.

```bash
swarms-cloud read-docs
```

## Troubleshooting

If you encounter any issues while using the CLI, ensure that you have the latest version installed. You can update the CLI using:

```bash
pip install --upgrade swarms-cloud-cli
```

## FAQs

**Q: How do I retrieve my API key?**  
A: Use the `get-api-key` command to open the API key retrieval page.

**Q: What should I do if I am not logged in?**  
A: Use the `check-login` command to log in and start the cache.

## Contact Support

If you need further assistance, please contact our support team at kye@swarms.world

--------------------------------------------------

# File: swarms_cloud/cloud_run.md

# Hosting Agents on Google Cloud Run

This documentation provides a highly detailed, step-by-step guide to hosting your agents using Google Cloud Run. It uses a well-structured project setup that includes a Dockerfile at the root level, a folder dedicated to your API file, and a `requirements.txt` file to manage all dependencies. This guide will ensure your deployment is scalable, efficient, and easy to maintain.

---

## **Project Structure**

Your project directory should adhere to the following structure to ensure compatibility and ease of deployment:

```
.
├── Dockerfile
├── requirements.txt
└── api/
    └── api.py
```

Each component serves a specific purpose in the deployment pipeline, ensuring modularity and maintainability.

---

## **Step 1: Prerequisites**

Before you begin, make sure to satisfy the following prerequisites to avoid issues during deployment:

1. **Google Cloud Account**:
   - Create a Google Cloud account at [Google Cloud Console](https://console.cloud.google.com/).
   - Enable billing for your project. Billing is necessary for accessing Cloud Run services.

2. **Install Google Cloud SDK**:
   - Follow the [installation guide](https://cloud.google.com/sdk/docs/install) to set up the Google Cloud SDK on your local machine.

3. **Install Docker**:
   - Download and install Docker by following the [official Docker installation guide](https://docs.docker.com/get-docker/). Docker is crucial for containerizing your application.

4. **Create a Google Cloud Project**:
   - Navigate to the Google Cloud Console and create a new project. Assign it a meaningful name and note the **Project ID**, as it will be used throughout this guide.

5. **Enable Required APIs**:
   - Visit the [API Library](https://console.cloud.google.com/apis/library) and enable the following APIs:
     - Cloud Run API
     - Cloud Build API
     - Artifact Registry API
   - These APIs are essential for deploying and managing your application in Cloud Run.

---

## **Step 2: Creating the Files**

### 1. **`api/api.py`**

This is the main Python script where you define your Swarms agents and expose an API endpoint for interacting with them. Here’s an example:

```python
from flask import Flask, request, jsonify
from swarms import Agent  # Assuming `swarms` is the framework you're using

app = Flask(__name__)

# Example Swarm agent
agent = Agent(
    agent_name="Stock-Analysis-Agent",
    model_name="gpt-4o-mini",
    max_loops="auto",
    interactive=True,
    streaming_on=True,
)

@app.route('/run-agent', methods=['POST'])
def run_agent():
    data = request.json
    task = data.get('task', '')
    result = agent.run(task)
    return jsonify({"result": result})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

This example sets up a basic API that listens for POST requests, processes a task using a Swarm agent, and returns the result as a JSON response. Customize it based on your agent’s functionality.

---

### 2. **`requirements.txt`**

This file lists all Python dependencies required for your project. Example:

```
flask
swarms
# add any other dependencies here
```

Be sure to include any additional libraries your agents rely on. Keeping this file up to date ensures smooth dependency management during deployment.

---

### 3. **`Dockerfile`**

The Dockerfile specifies how your application is containerized. Below is a sample Dockerfile for your setup:

```dockerfile
# Use an official Python runtime as the base image
FROM python:3.10-slim

# Set the working directory
WORKDIR /app

# Copy requirements.txt and install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the application code
COPY api/ ./api/

# Expose port 8080 (Cloud Run default port)
EXPOSE 8080

# Run the application
CMD ["python", "api/api.py"]
```

This Dockerfile ensures your application is containerized with minimal overhead, focusing on slim images for efficiency.

---

## **Step 3: Deploying to Google Cloud Run**

### 1. **Authenticate with Google Cloud**

Log in to your Google Cloud account by running:

```bash
gcloud auth login
```

Set the active project to match your deployment target:

```bash
gcloud config set project [PROJECT_ID]
```

Replace `[PROJECT_ID]` with your actual Project ID.

---

### 2. **Build the Docker Image**

Use Google Cloud's Artifact Registry to store and manage your Docker image. Follow these steps:

1. **Create a Repository**:

```bash
gcloud artifacts repositories create my-repo --repository-format=Docker --location=us-central1
```

2. **Authenticate Docker with Google Cloud**:

```bash
gcloud auth configure-docker us-central1-docker.pkg.dev
```

3. **Build and Tag the Image**:

```bash
docker build -t us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image .
```

4. **Push the Image**:

```bash
docker push us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image
```

---

### 3. **Deploy to Cloud Run**

Deploy the application to Cloud Run with the following command:

```bash
gcloud run deploy my-agent-service \
  --image us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated
```

Key points:
- Replace `[PROJECT_ID]` with your actual Project ID.
- The `--allow-unauthenticated` flag makes the service publicly accessible. Exclude it to restrict access.

---

## **Step 4: Testing the Deployment**

Once the deployment is complete, test the service:

1. Note the URL provided by Cloud Run.
2. Use `curl` or Postman to send a request. Example:

```bash
curl -X POST [CLOUD_RUN_URL]/run-agent \
  -H "Content-Type: application/json" \
  -d '{"task": "example task"}'
```

This tests whether your agent processes the task correctly and returns the expected output.

---

## **Step 5: Updating the Service**

To apply changes to your application:

1. Edit the necessary files.
2. Rebuild and push the updated Docker image:

```bash
docker build -t us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image .
docker push us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image
```

3. Redeploy the service:

```bash
gcloud run deploy my-agent-service \
  --image us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image
```

This ensures the latest version of your application is live.

---

## **Troubleshooting**

- **Permission Errors**:
  Ensure your account has roles like Cloud Run Admin and Artifact Registry Reader.
- **Port Issues**:
  Confirm the application listens on port 8080. Cloud Run expects this port by default.
- **Logs**:
  Use the Google Cloud Console or CLI to review logs for debugging:

```bash
gcloud logs read --project [PROJECT_ID]
```

---

## **Conclusion**

By following this comprehensive guide, you can deploy your agents on Google Cloud Run with ease. This method leverages Docker for containerization and Google Cloud services for seamless scalability and management. With a robust setup like this, you can focus on enhancing your agents’ capabilities rather than worrying about deployment challenges.



--------------------------------------------------

# File: swarms_cloud/create_api.md

# CreateNow API Documentation

Welcome to the CreateNow API documentation! This API enables developers to generate AI-powered content, including images, music, videos, and speech, using natural language prompts. Use the endpoints below to start generating content.

---

## **1. Claim Your API Key**
To use the API, you must first claim your API key. Visit the following link to create an account and get your API key:

### **Claim Your Key**
```
https://createnow.xyz/account
```

After signing up, your API key will be available in your account dashboard. Keep it secure and include it in your API requests as a Bearer token.

---

## **2. Generation Endpoint**
The generation endpoint allows you to create AI-generated content using natural language prompts.

### **Endpoint**
```
POST https://createnow.xyz/api/v1/generate
```

### **Authentication**
Include a Bearer token in the `Authorization` header for all requests:
```
Authorization: Bearer YOUR_API_KEY
```

### **Basic Usage**
The simplest way to use the API is to send a prompt. The system will automatically detect the appropriate media type.

#### **Example Request (Basic)**
```json
{
  "prompt": "a beautiful sunset over the ocean"
}
```

### **Advanced Options**
You can specify additional parameters for finer control over the output.

#### **Parameters**
| Parameter      | Type      | Description                                                                                       | Default      |
|----------------|-----------|---------------------------------------------------------------------------------------------------|--------------|
| `prompt`       | `string`  | The natural language description of the content to generate.                                     | Required     |
| `type`         | `string`  | The type of content to generate (`image`, `music`, `video`, `speech`).                          | Auto-detect  |
| `count`        | `integer` | The number of outputs to generate (1-4).                                                        | 1            |
| `duration`     | `integer` | Duration of audio or video content in seconds (applicable to `music` and `speech`).            | N/A          |

#### **Example Request (Advanced)**
```json
{
  "prompt": "create an upbeat jazz melody",
  "type": "music",
  "count": 2,
  "duration": 30
}
```

### **Response Format**

#### **Success Response**
```json
{
  "success": true,
  "outputs": [
    {
      "url": "https://createnow.xyz/storage/image1.png",
      "creation_id": "12345",
      "share_url": "https://createnow.xyz/share/12345"
    }
  ],
  "mediaType": "image",
  "confidence": 0.95,
  "detected": true
}
```

#### **Error Response**
```json
{
  "error": "Invalid API Key",
  "status": 401
}
```

---

## **3. Examples in Multiple Languages**

### **Python**
```python
import requests

url = "https://createnow.xyz/api/v1/generate"
headers = {
    "Authorization": "Bearer YOUR_API_KEY",
    "Content-Type": "application/json"
}

payload = {
    "prompt": "a futuristic cityscape at night",
    "type": "image",
    "count": 2
}

response = requests.post(url, json=payload, headers=headers)
print(response.json())
```

### **Node.js**
```javascript
const axios = require('axios');

const url = "https://createnow.xyz/api/v1/generate";
const headers = {
    Authorization: "Bearer YOUR_API_KEY",
    "Content-Type": "application/json"
};

const payload = {
    prompt: "a futuristic cityscape at night",
    type: "image",
    count: 2
};

axios.post(url, payload, { headers })
    .then(response => {
        console.log(response.data);
    })
    .catch(error => {
        console.error(error.response.data);
    });
```

### **cURL**
```bash
curl -X POST https://createnow.xyz/api/v1/generate \
-H "Authorization: Bearer YOUR_API_KEY" \
-H "Content-Type: application/json" \
-d '{
  "prompt": "a futuristic cityscape at night",
  "type": "image",
  "count": 2
}'
```

### **Java**
```java
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.OutputStream;

public class CreateNowAPI {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://createnow.xyz/api/v1/generate");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Authorization", "Bearer YOUR_API_KEY");
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);

        String jsonPayload = "{" +
            "\"prompt\": \"a futuristic cityscape at night\", " +
            "\"type\": \"image\", " +
            "\"count\": 2}";

        OutputStream os = conn.getOutputStream();
        os.write(jsonPayload.getBytes());
        os.flush();

        int responseCode = conn.getResponseCode();
        System.out.println("Response Code: " + responseCode);
    }
}
```

---

## **4. Error Codes**
| Status Code | Meaning                          | Possible Causes                        |
|-------------|----------------------------------|----------------------------------------|
| 400         | Bad Request                      | Invalid parameters or payload.         |
| 401         | Unauthorized                     | Invalid or missing API key.            |
| 402         | Payment Required                 | Insufficient credits for the request.  |
| 500         | Internal Server Error            | Issue on the server side.              |

---

## **5. Notes and Limitations**
- **Maximum Prompt Length:** 1000 characters.
- **Maximum Outputs per Request:** 4.
- **Supported Media Types:** `image`, `music`, `video`, `speech`.
- **Content Shareability:** Every output includes a unique creation ID and shareable URL.
- **Auto-Detection:** Uses advanced natural language processing to determine the most appropriate media type.

---

For further support or questions, please contact our support team at [support@createnow.xyz](mailto:support@createnow.xyz).



--------------------------------------------------

# File: swarms_cloud/getting_started.md

# Getting Started with State-of-the-Art Vision Language Models (VLMs) Using the Swarms API

The intersection of vision and language tasks within the field of artificial intelligence has led to the emergence of highly sophisticated models known as Vision Language Models (VLMs). These models leverage the capabilities of both computer vision and natural language processing to provide a more nuanced understanding of multimodal inputs. In this blog post, we will guide you through the process of integrating state-of-the-art VLMs available through the Swarms API, focusing particularly on models like "internlm-xcomposer2-4khd", which represents a blend of high-performance language and visual understanding.

#### What Are Vision Language Models?

Vision Language Models are at the frontier of integrating visual data processing with text analysis. These models are trained on large datasets that include both images and their textual descriptions, learning to correlate visual elements with linguistic context. The result is a model that can not only recognize objects in an image but also generate descriptive, context-aware text, answer questions about the image, and even engage in a dialogue about its content.

#### Why Use Swarms API for VLMs?

Swarms API provides access to several cutting-edge VLMs including the "internlm-xcomposer2-4khd" model. This API is designed for developers looking to seamlessly integrate advanced multimodal capabilities into their applications without the need for extensive machine learning expertise or infrastructure. Swarms API is robust, scalable, and offers state-of-the-art models that are continuously updated to leverage the latest advancements in AI research.

#### Prerequisites

Before diving into the technical setup, ensure you have the following:
- An active account with Swarms API to obtain an API key.
- Python installed on your machine (Python 3.6 or later is recommended).
- An environment where you can install packages and run Python scripts (like Visual Studio Code, Jupyter Notebook, or simply your terminal).

#### Setting Up Your Environment

First, you'll need to install the `OpenAI` Python library if it's not already installed:

```bash
pip install openai
```

#### Integrating the Swarms API

Here’s a basic guide on how to set up the Swarms API in your Python environment:

1. **API Key Configuration**:
   Start by setting up your API key and base URL. Replace `"your_swarms_key"` with the actual API key you obtained from Swarms.

    ```python
    from openai import OpenAI

    openai_api_key = "your_swarms_key"
    openai_api_base = "https://api.swarms.world/v1"
    ```

2. **Initialize Client**:
   Initialize your OpenAI client with the provided API key and base URL.

    ```python
    client = OpenAI(
        api_key=openai_api_key,
        base_url=openai_api_base,
    )
    ```

3. **Creating a Chat Completion**:
   To use the VLM, you’ll send a request to the API with a multimodal input consisting of both an image and a text query. The following example shows how to structure this request:

    ```python
    chat_response = client.chat.completions.create(
        model="internlm-xcomposer2-4khd",
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg",
                        },
                    },
                    {"type": "text", "text": "What's in this image?"},
                ]
            }
        ],
    )
    print("Chat response:", chat_response)
    ```

   This code sends a multimodal query to the model, which includes an image URL followed by a text question regarding the image.

#### Understanding the Response

The response from the API will include details generated by the model about the image based on the textual query. This could range from simple descriptions to complex narratives, depending on the model’s capabilities and the nature of the question.

#### Best Practices

- **Data Privacy**: Always ensure that the images and data you use comply with privacy laws and regulations.
- **Error Handling**: Implement robust error handling to manage potential issues during API calls.
- **Model Updates**: Keep track of updates to the Swarms API and model improvements to leverage new features and improved accuracies.

#### Conclusion

Integrating VLMs via the Swarms API opens up a plethora of opportunities for developers to create rich, interactive, and intelligent applications that understand and interpret the world not just through text but through visuals as well. Whether you’re building an educational tool, a content management system, or an interactive chatbot, these models can significantly enhance the way users interact with your application.

As you embark on your journey to integrate these powerful models into your projects, remember that the key to successful implementation lies in understanding the capabilities and limitations of the technology, continually testing with diverse data, and iterating based on user feedback and technological advances.

Happy coding, and here’s to building more intelligent, multimodal applications!

--------------------------------------------------

# File: swarms_cloud/launch.md

# Swarms Cloud API Client Documentation

## Overview
The Swarms Cloud API Client is a production-grade Python library for interacting with the Swarms Cloud Agent API. It provides a comprehensive interface for managing, executing, and monitoring cloud-based agents.

## Installation
```bash
pip install swarms-cloud
```

## Quick Start
```python
from swarms_cloud import SwarmCloudAPI, AgentCreate

# Initialize the client
client = SwarmCloudAPI(
    base_url="https://swarmcloud-285321057562.us-central1.run.app",
    api_key="your_api_key_here"
)

# Create an agent
agent_data = AgentCreate(
    name="TranslateAgent",
    description="Translates text between languages",
    code="""
    def main(request, store):
        text = request.payload.get('text', '')
        return f'Translated: {text}'
    """,
    requirements="requests==2.25.1",
    envs="DEBUG=True"
)

new_agent = client.create_agent(agent_data)
print(f"Created agent with ID: {new_agent.id}")
```

## Client Configuration

### Constructor Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|----------|-------------|
| base_url | str | No | https://swarmcloud-285321057562.us-central1.run.app | The base URL of the SwarmCloud API |
| api_key | str | Yes | None | Your SwarmCloud API key |
| timeout | float | No | 10.0 | Request timeout in seconds |

## Data Models

### AgentCreate
Model for creating new agents.

| Field | Type | Required | Default | Description |
|-------|------|----------|----------|-------------|
| name | str | Yes | - | Name of the agent |
| description | str | No | None | Description of the agent's purpose |
| code | str | Yes | - | Python code that defines the agent's behavior |
| requirements | str | No | None | Python package requirements (pip format) |
| envs | str | No | None | Environment variables for the agent |
| autoscaling | bool | No | False | Enable/disable concurrent execution scaling |

### AgentUpdate
Model for updating existing agents.

| Field | Type | Required | Default | Description |
|-------|------|----------|----------|-------------|
| name | str | No | None | Updated name of the agent |
| description | str | No | None | Updated description |
| code | str | No | None | Updated Python code |
| requirements | str | No | None | Updated package requirements |
| autoscaling | bool | No | None | Updated autoscaling setting |

## API Methods

### List Agents
Retrieve all available agents.

```python
agents = client.list_agents()
for agent in agents:
    print(f"Agent: {agent.name} (ID: {agent.id})")
```

**Returns**: List[AgentOut]

### Create Agent
Create a new agent with the specified configuration.

```python
agent_data = AgentCreate(
    name="DataProcessor",
    description="Processes incoming data streams",
    code="""
    def main(request, store):
        data = request.payload.get('data', [])
        return {'processed': len(data)}
    """,
    requirements="pandas==1.4.0\nnumpy==1.21.0",
    envs="PROCESSING_MODE=fast",
    autoscaling=True
)

new_agent = client.create_agent(agent_data)
```

**Returns**: AgentOut

### Get Agent
Retrieve details of a specific agent.

```python
agent = client.get_agent("agent_id_here")
print(f"Agent details: {agent}")
```

**Parameters**:
- agent_id (str): The unique identifier of the agent

**Returns**: AgentOut

### Update Agent
Update an existing agent's configuration.

```python
update_data = AgentUpdate(
    name="UpdatedProcessor",
    description="Enhanced data processing capabilities",
    code="def main(request, store):\n    return {'status': 'updated'}"
)

updated_agent = client.update_agent("agent_id_here", update_data)
```

**Parameters**:
- agent_id (str): The unique identifier of the agent
- update (AgentUpdate): The update data

**Returns**: AgentOut

### Execute Agent
Manually execute an agent with optional payload data.

```python
# Execute with payload
result = client.execute_agent(
    "agent_id_here",
    payload={"text": "Hello, World!"}
)

# Execute without payload
result = client.execute_agent("agent_id_here")
```

**Parameters**:
- agent_id (str): The unique identifier of the agent
- payload (Optional[Dict[str, Any]]): Execution payload data

**Returns**: Dict[str, Any]

### Get Agent History
Retrieve the execution history and logs for an agent.

```python
history = client.get_agent_history("agent_id_here")
for execution in history.executions:
    print(f"[{execution.timestamp}] {execution.log}")
```

**Parameters**:
- agent_id (str): The unique identifier of the agent

**Returns**: AgentExecutionHistory

### Batch Execute Agents
Execute multiple agents simultaneously with the same payload.

```python
# Get list of agents
agents = client.list_agents()

# Execute batch with payload
results = client.batch_execute_agents(
    agents=agents[:3],  # Execute first three agents
    payload={"data": "test"}
)

print(f"Batch execution results: {results}")
```

**Parameters**:
- agents (List[AgentOut]): List of agents to execute
- payload (Optional[Dict[str, Any]]): Shared execution payload

**Returns**: List[Any]

### Health Check
Check the API's health status.

```python
status = client.health()
print(f"API Status: {status}")
```

**Returns**: Dict[str, Any]

## Error Handling
The client uses exception handling to manage various error scenarios:

```python
from swarms_cloud import SwarmCloudAPI
import httpx

try:
    client = SwarmCloudAPI(api_key="your_api_key_here")
    agents = client.list_agents()
except httpx.HTTPError as http_err:
    print(f"HTTP error occurred: {http_err}")
except Exception as err:
    print(f"An unexpected error occurred: {err}")
finally:
    client.close()
```

## Context Manager Support
The client can be used with Python's context manager:

```python
with SwarmCloudAPI(api_key="your_api_key_here") as client:
    status = client.health()
    print(f"API Status: {status}")
    # Client automatically closes after the with block
```

## Best Practices

1. Always close the client when finished:
```python
client = SwarmCloudAPI(api_key="your_api_key_here")
try:
    # Your code here
finally:
    client.close()
```

2. Use context managers for automatic cleanup:
```python
with SwarmCloudAPI(api_key="your_api_key_here") as client:
    # Your code here
```

3. Handle errors appropriately:
```python
try:
    result = client.execute_agent("agent_id", payload={"data": "test"})
except httpx.HTTPError as e:
    logger.error(f"HTTP error: {e}")
    # Handle error appropriately
```

4. Set appropriate timeouts for your use case:
```python
client = SwarmCloudAPI(
    api_key="your_api_key_here",
    timeout=30.0  # Longer timeout for complex operations
)
```

## Complete Example
Here's a complete example showcasing various features of the client:

```python
from swarms_cloud import SwarmCloudAPI, AgentCreate, AgentUpdate
import httpx

def main():
    with SwarmCloudAPI(api_key="your_api_key_here") as client:
        # Create an agent
        agent_data = AgentCreate(
            name="DataAnalyzer",
            description="Analyzes incoming data streams",
            code="""
            def main(request, store):
                data = request.payload.get('data', [])
                return {
                    'count': len(data),
                    'summary': 'Data processed successfully'
                }
            """,
            requirements="pandas==1.4.0",
            autoscaling=True
        )
        
        try:
            # Create the agent
            new_agent = client.create_agent(agent_data)
            print(f"Created agent: {new_agent.name} (ID: {new_agent.id})")
            
            # Execute the agent
            result = client.execute_agent(
                new_agent.id,
                payload={"data": [1, 2, 3, 4, 5]}
            )
            print(f"Execution result: {result}")
            
            # Update the agent
            update_data = AgentUpdate(
                description="Enhanced data analysis capabilities"
            )
            updated_agent = client.update_agent(new_agent.id, update_data)
            print(f"Updated agent: {updated_agent.name}")
            
            # Get execution history
            history = client.get_agent_history(new_agent.id)
            print(f"Execution history: {history}")
            
        except httpx.HTTPError as e:
            print(f"HTTP error occurred: {e}")
        except Exception as e:
            print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main()
```

## Logging
The client uses the `loguru` library for logging. You can configure the logging level and format:

```python
from loguru import logger

# Configure logging
logger.add("swarmcloud.log", rotation="500 MB")

client = SwarmCloudAPI(api_key="your_api_key_here")
```

## Performance Considerations

1. **Connection Reuse**: The client reuses HTTP connections by default, improving performance for multiple requests.

2. **Timeout Configuration**: Set appropriate timeouts based on your use case:
```python
client = SwarmCloudAPI(
    api_key="your_api_key_here",
    timeout=5.0  # Shorter timeout for time-sensitive operations
)
```

3. **Batch Operations**: Use batch_execute_agents for multiple agent executions:
```python
results = client.batch_execute_agents(
    agents=agents,
    payload=shared_payload
)
```

## Rate Limiting
The client respects API rate limits but does not implement retry logic. Implement your own retry mechanism if needed:

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
def execute_with_retry(client, agent_id, payload):
    return client.execute_agent(agent_id, payload)
```

## Thread Safety
The client is not thread-safe by default. For concurrent usage, create separate client instances for each thread or implement appropriate synchronization mechanisms.

--------------------------------------------------

# File: swarms_cloud/main.md

# Swarm Cloud API Reference

## Overview

The AI Chat Completion API processes text and image inputs to generate conversational responses. It supports various configurations to customize response behavior and manage input content.

## API Endpoints

### Chat Completion URL
`https://api.swarms.world`



- **Endpoint:** `/v1/chat/completions`
-- **Full Url** `https://api.swarms.world/v1/chat/completions`
- **Method:** POST
- **Description:** Generates a response based on the provided conversation history and parameters.

#### Request Parameters

| Parameter     | Type               | Description                                               | Required |
|---------------|--------------------|-----------------------------------------------------------|----------|
| `model`       | string             | The AI model identifier.                                  | Yes      |
| `messages`    | array of objects   | A list of chat messages, including the sender's role and content. | Yes      |
| `temperature` | float              | Controls randomness. Lower values make responses more deterministic. | No       |
| `top_p`       | float              | Controls diversity. Lower values lead to less random completions. | No       |
| `max_tokens`  | integer            | The maximum number of tokens to generate.                 | No       |
| `stream`      | boolean            | If set to true, responses are streamed back as they're generated. | No       |

#### Response Structure

- **Success Response Code:** `200 OK`

```markdown
{
  "model": string,
  "object": string,
  "choices": array of objects,
  "usage": object
}
```

### List Models

- **Endpoint:** `/v1/models`
- **Method:** GET
- **Description:** Retrieves a list of available models.

#### Response Structure

- **Success Response Code:** `200 OK`

```markdown
{
  "data": array of objects
}
```

## Objects

### Request

| Field     | Type                | Description                                   | Required |
|-----------|---------------------|-----------------------------------------------|----------|
| `role`    | string              | The role of the message sender.               | Yes      |
| `content` | string or array     | The content of the message.                   | Yes      |
| `name`    | string              | An optional name identifier for the sender.   | No       |

### Response

| Field     | Type   | Description                        |
|-----------|--------|------------------------------------|
| `index`   | integer| The index of the choice.           |
| `message` | object | A `ChatMessageResponse` object.    |

#### UsageInfo

| Field             | Type    | Description                                   |
|-------------------|---------|-----------------------------------------------|
| `prompt_tokens`   | integer | The number of tokens used in the prompt.      |
| `total_tokens`    | integer | The total number of tokens used.              |
| `completion_tokens`| integer| The number of tokens used for the completion. |

## Example Requests

### Text Chat Completion

```json
POST /v1/chat/completions
{
  "model": "cogvlm-chat-17b",
  "messages": [
    {
      "role": "user",
      "content": "Hello, world!"
    }
  ],
  "temperature": 0.8
}
```

### Image and Text Chat Completion

```json
POST /v1/chat/completions
{
  "model": "cogvlm-chat-17b",
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Describe this image"
        },
        {
          "type": "image_url",
          "image_url": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."
        }
      ]
    }
  ],
  "temperature": 0.8,
  "top_p": 0.9,
  "max_tokens": 1024
}
```

## Error Codes

The API uses standard HTTP status codes to indicate the success or failure of an API call.

| Status Code | Description                       |
|-------------|-----------------------------------|
| 200         | OK - The request has succeeded.   |
| 400         | Bad Request - Invalid request format. |
| 500         | Internal Server Error - An error occurred on the server. |


## Examples in Various Languages

### Python
```python
import requests
import base64
from PIL import Image
from io import BytesIO


# Convert image to Base64
def image_to_base64(image_path):
    with Image.open(image_path) as image:
        buffered = BytesIO()
        image.save(buffered, format="JPEG")
        img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")
    return img_str


# Replace 'image.jpg' with the path to your image
base64_image = image_to_base64("your_image.jpg")
text_data = {"type": "text", "text": "Describe what is in the image"}
image_data = {
    "type": "image_url",
    "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"},
}

# Construct the request data
request_data = {
    "model": "cogvlm-chat-17b",
    "messages": [{"role": "user", "content": [text_data, image_data]}],
    "temperature": 0.8,
    "top_p": 0.9,
    "max_tokens": 1024,
}

# Specify the URL of your FastAPI application
url = "https://api.swarms.world/v1/chat/completions"

# Send the request
response = requests.post(url, json=request_data)
# Print the response from the server
print(response.text)
```

### Example API Request in Node
```js
const fs = require('fs');
const https = require('https');
const sharp = require('sharp');

// Convert image to Base64
async function imageToBase64(imagePath) {
    try {
        const imageBuffer = await sharp(imagePath).jpeg().toBuffer();
        return imageBuffer.toString('base64');
    } catch (error) {
        console.error('Error converting image to Base64:', error);
    }
}

// Main function to execute the workflow
async function main() {
    const base64Image = await imageToBase64("your_image.jpg");
    const textData = { type: "text", text: "Describe what is in the image" };
    const imageData = {
        type: "image_url",
        image_url: { url: `data:image/jpeg;base64,${base64Image}` },
    };

    // Construct the request data
    const requestData = JSON.stringify({
        model: "cogvlm-chat-17b",
        messages: [{ role: "user", content: [textData, imageData] }],
        temperature: 0.8,
        top_p: 0.9,
        max_tokens: 1024,
    });

    const options = {
        hostname: 'api.swarms.world',
        path: '/v1/chat/completions',
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Content-Length': requestData.length,
        },
    };

    const req = https.request(options, (res) => {
        let responseBody = '';

        res.on('data', (chunk) => {
            responseBody += chunk;
        });

        res.on('end', () => {
            console.log('Response:', responseBody);
        });
    });

    req.on('error', (error) => {
        console.error(error);
    });

    req.write(requestData);
    req.end();
}

main();
```

### Example API Request in Go

```go
package main

import (
    "bytes"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "image"
    "image/jpeg"
    _ "image/png" // Register PNG format
    "io"
    "net/http"
    "os"
)

// imageToBase64 converts an image to a Base64-encoded string.
func imageToBase64(imagePath string) (string, error) {
    file, err := os.Open(imagePath)
    if err != nil {
        return "", err
    }
    defer file.Close()

    img, _, err := image.Decode(file)
    if err != nil {
        return "", err
    }

    buf := new(bytes.Buffer)
    err = jpeg.Encode(buf, img, nil)
    if err != nil {
        return "", err
    }

    return base64.StdEncoding.EncodeToString(buf.Bytes()), nil
}

// main is the entry point of the program.
func main() {
    base64Image, err := imageToBase64("your_image.jpg")
    if err != nil {
        fmt.Println("Error converting image to Base64:", err)
        return
    }

    requestData := map[string]interface{}{
        "model": "cogvlm-chat-17b",
        "messages": []map[string]interface{}{
            {
                "role":    "user",
                "content": []map[string]string{{"type": "text", "text": "Describe what is in the image"}, {"type": "image_url", "image_url": {"url": fmt.Sprintf("data:image/jpeg;base64,%s", base64Image)}}},
            },
        },
        "temperature": 0.8,
        "top_p":       0.9,
        "max_tokens":  1024,
    }

    requestBody, err := json.Marshal(requestData)
    if err != nil {
        fmt.Println("Error marshaling request data:", err)
        return
    }

    url := "https://api.swarms.world/v1/chat/completions"
    request, err := http.NewRequest("POST", url, bytes.NewBuffer(requestBody))
    if err != nil {
        fmt.Println("Error creating request:", err)
        return
    }

    request.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    response, err := client.Do(request)
    if err != nil {
        fmt.Println("Error sending request:", err)
        return
    }
    defer response.Body.Close()

    responseBody, err := io.ReadAll(response.Body)
    if err != nil {
        fmt.Println("Error reading response body:", err)
        return
    }

    fmt.Println("Response:", string(responseBody))
}
```





## Conclusion

This API reference provides the necessary details to understand and interact with the AI Chat Completion API. By following the outlined request and response formats, users can integrate this API into their applications to generate dynamic and contextually relevant conversational responses.

--------------------------------------------------

# File: swarms_cloud/mcp.md

# Swarms API as MCP

- Launch MCP server as a tool
- Put `SWARMS_API_KEY` in `.env`
- Client side code below


## Server Side

```python
# server.py
from datetime import datetime
import os
from typing import Any, Dict, List, Optional

import requests
import httpx
from fastmcp import FastMCP
from pydantic import BaseModel, Field
from swarms import SwarmType
from dotenv import load_dotenv

load_dotenv()

class AgentSpec(BaseModel):
    agent_name: Optional[str] = Field(
        description="The unique name assigned to the agent, which identifies its role and functionality within the swarm.",
    )
    description: Optional[str] = Field(
        description="A detailed explanation of the agent's purpose, capabilities, and any specific tasks it is designed to perform.",
    )
    system_prompt: Optional[str] = Field(
        description="The initial instruction or context provided to the agent, guiding its behavior and responses during execution.",
    )
    model_name: Optional[str] = Field(
        default="gpt-4o-mini",
        description="The name of the AI model that the agent will utilize for processing tasks and generating outputs. For example: gpt-4o, gpt-4o-mini, openai/o3-mini",
    )
    auto_generate_prompt: Optional[bool] = Field(
        default=False,
        description="A flag indicating whether the agent should automatically create prompts based on the task requirements.",
    )
    max_tokens: Optional[int] = Field(
        default=8192,
        description="The maximum number of tokens that the agent is allowed to generate in its responses, limiting output length.",
    )
    temperature: Optional[float] = Field(
        default=0.5,
        description="A parameter that controls the randomness of the agent's output; lower values result in more deterministic responses.",
    )
    role: Optional[str] = Field(
        default="worker",
        description="The designated role of the agent within the swarm, which influences its behavior and interaction with other agents.",
    )
    max_loops: Optional[int] = Field(
        default=1,
        description="The maximum number of times the agent is allowed to repeat its task, enabling iterative processing if necessary.",
    )
    # New fields for RAG functionality
    rag_collection: Optional[str] = Field(
        None,
        description="The Qdrant collection name for RAG functionality. If provided, this agent will perform RAG queries.",
    )
    rag_documents: Optional[List[str]] = Field(
        None,
        description="Documents to ingest into the Qdrant collection for RAG. (List of text strings)",
    )
    tools: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="A dictionary of tools that the agent can use to complete its task.",
    )


class AgentCompletion(BaseModel):
    """
    Configuration for a single agent that works together as a swarm to accomplish tasks.
    """

    agent: AgentSpec = Field(
        ...,
        description="The agent to run.",
    )
    task: Optional[str] = Field(
        ...,
        description="The task to run.",
    )
    img: Optional[str] = Field(
        None,
        description="An optional image URL that may be associated with the swarm's task or representation.",
    )
    output_type: Optional[str] = Field(
        "list",
        description="The type of output to return.",
    )


class AgentCompletionResponse(BaseModel):
    """
    Response from an agent completion.
    """

    agent_id: str = Field(
        ...,
        description="The unique identifier for the agent that completed the task.",
    )
    agent_name: str = Field(
        ...,
        description="The name of the agent that completed the task.",
    )
    agent_description: str = Field(
        ...,
        description="The description of the agent that completed the task.",
    )
    messages: Any = Field(
        ...,
        description="The messages from the agent completion.",
    )

    cost: Dict[str, Any] = Field(
        ...,
        description="The cost of the agent completion.",
    )


class Agents(BaseModel):
    """Configuration for a collection of agents that work together as a swarm to accomplish tasks."""

    agents: List[AgentSpec] = Field(
        description="A list containing the specifications of each agent that will participate in the swarm, detailing their roles and functionalities."
    )


class ScheduleSpec(BaseModel):
    scheduled_time: datetime = Field(
        ...,
        description="The exact date and time (in UTC) when the swarm is scheduled to execute its tasks.",
    )
    timezone: Optional[str] = Field(
        "UTC",
        description="The timezone in which the scheduled time is defined, allowing for proper scheduling across different regions.",
    )


class SwarmSpec(BaseModel):
    name: Optional[str] = Field(
        None,
        description="The name of the swarm, which serves as an identifier for the group of agents and their collective task.",
        max_length=100,
    )
    description: Optional[str] = Field(
        None,
        description="A comprehensive description of the swarm's objectives, capabilities, and intended outcomes.",
    )
    agents: Optional[List[AgentSpec]] = Field(
        None,
        description="A list of agents or specifications that define the agents participating in the swarm.",
    )
    max_loops: Optional[int] = Field(
        default=1,
        description="The maximum number of execution loops allowed for the swarm, enabling repeated processing if needed.",
    )
    swarm_type: Optional[SwarmType] = Field(
        None,
        description="The classification of the swarm, indicating its operational style and methodology.",
    )
    rearrange_flow: Optional[str] = Field(
        None,
        description="Instructions on how to rearrange the flow of tasks among agents, if applicable.",
    )
    task: Optional[str] = Field(
        None,
        description="The specific task or objective that the swarm is designed to accomplish.",
    )
    img: Optional[str] = Field(
        None,
        description="An optional image URL that may be associated with the swarm's task or representation.",
    )
    return_history: Optional[bool] = Field(
        True,
        description="A flag indicating whether the swarm should return its execution history along with the final output.",
    )
    rules: Optional[str] = Field(
        None,
        description="Guidelines or constraints that govern the behavior and interactions of the agents within the swarm.",
    )
    schedule: Optional[ScheduleSpec] = Field(
        None,
        description="Details regarding the scheduling of the swarm's execution, including timing and timezone information.",
    )
    tasks: Optional[List[str]] = Field(
        None,
        description="A list of tasks that the swarm should complete.",
    )
    messages: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="A list of messages that the swarm should complete.",
    )
    # rag_on: Optional[bool] = Field(
    #     None,
    #     description="A flag indicating whether the swarm should use RAG.",
    # )
    # collection_name: Optional[str] = Field(
    #     None,
    #     description="The name of the collection to use for RAG.",
    # )
    stream: Optional[bool] = Field(
        False,
        description="A flag indicating whether the swarm should stream its output.",
    )


class SwarmCompletionResponse(BaseModel):
    """
    Response from a swarm completion.
    """

    status: str = Field(..., description="The status of the swarm completion.")
    swarm_name: str = Field(..., description="The name of the swarm.")
    description: str = Field(..., description="Description of the swarm.")
    swarm_type: str = Field(..., description="The type of the swarm.")
    task: str = Field(
        ..., description="The task that the swarm is designed to accomplish."
    )
    output: List[Dict[str, Any]] = Field(
        ..., description="The output generated by the swarm."
    )
    number_of_agents: int = Field(
        ..., description="The number of agents involved in the swarm."
    )
    # "input_config": Optional[Dict[str, Any]] = Field(None, description="The input configuration for the swarm.")


BASE_URL = "https://swarms-api-285321057562.us-east1.run.app"


# Create an MCP server
mcp = FastMCP("swarms-api")


# Add an addition tool
@mcp.tool(name="swarm_completion", description="Run a swarm completion.")
def swarm_completion(swarm: SwarmSpec) -> Dict[str, Any]:
    api_key = os.getenv("SWARMS_API_KEY")
    headers = {"x-api-key": api_key, "Content-Type": "application/json"}

    payload = swarm.model_dump()

    response = requests.post(f"{BASE_URL}/v1/swarm/completions", json=payload, headers=headers)
    
    return response.json()

@mcp.tool(name="swarms_available", description="Get the list of available swarms.")
async def swarms_available() -> Any:
    """
    Get the list of available swarms.
    """
    headers = {"Content-Type": "application/json"}

    async with httpx.AsyncClient() as client:
        response = await client.get(f"{BASE_URL}/v1/models/available", headers=headers)
        response.raise_for_status()  # Raise an error for bad responses
        return response.json()


if __name__ == "__main__":
    mcp.run(transport="sse")
```

## Client side

- Call the tool with it's name and the payload config

```python
import asyncio
from fastmcp import Client

swarm_config = {
    "name": "Simple Financial Analysis",
    "description": "A swarm to analyze financial data",
    "agents": [
        {
            "agent_name": "Data Analyzer",
            "description": "Looks at financial data",
            "system_prompt": "Analyze the data.",
            "model_name": "gpt-4o",
            "role": "worker",
            "max_loops": 1,
            "max_tokens": 1000,
            "temperature": 0.5,
            "auto_generate_prompt": False,
        },
        {
            "agent_name": "Risk Analyst",
            "description": "Checks risk levels",
            "system_prompt": "Evaluate the risks.",
            "model_name": "gpt-4o",
            "role": "worker",
            "max_loops": 1,
            "max_tokens": 1000,
            "temperature": 0.5,
            "auto_generate_prompt": False,
        },
        {
            "agent_name": "Strategy Checker",
            "description": "Validates strategies",
            "system_prompt": "Review the strategy.",
            "model_name": "gpt-4o",
            "role": "worker",
            "max_loops": 1,
            "max_tokens": 1000,
            "temperature": 0.5,
            "auto_generate_prompt": False,
        },
    ],
    "max_loops": 1,
    "swarm_type": "SequentialWorkflow",
    "task": "Analyze the financial data and provide insights.",
    "return_history": False,  # Added required field
    "stream": False,  # Added required field
    "rules": None,  # Added optional field
    "img": None,  # Added optional field
}


async def swarm_completion():
    """Connect to a server over SSE and fetch available swarms."""

    async with Client(
        transport="http://localhost:8000/sse"
    ) as client:
        # Basic connectivity testing
        # print("Ping check:", await client.ping())
        # print("Available tools:", await client.list_tools())
        # print("Swarms available:", await client.call_tool("swarms_available", None))
        result = await client.call_tool("swarm_completion", {"swarm": swarm_config})
        print("Swarm completion:", result)


# Execute the function
if __name__ == "__main__":
    asyncio.run(swarm_completion())
```

--------------------------------------------------

# File: swarms_cloud/mcs_api.md

# Medical Coder Swarm API Documentation

Base URL: `https://mcs-285321057562.us-central1.run.app`

## Table of Contents
- [Authentication](#authentication)
- [Rate Limits](#rate-limits)
- [Endpoints](#endpoints)
  - [Health Check](#health-check)
  - [Run Medical Coder](#run-medical-coder)
  - [Run Batch Medical Coder](#run-batch-medical-coder)
  - [Get Patient Data](#get-patient-data)
  - [Get All Patients](#get-all-patients)
- [Code Examples](#code-examples)
- [Error Handling](#error-handling)

## Authentication

Authentication details will be provided by the MCS team. Contact support for API credentials.

## Rate Limits

| Endpoint | GET Rate Limit Status |
|----------|----------------------|
| `GET /rate-limits` | Returns current rate limit status for your IP address |

## Endpoints

### Health Check

Check if the API is operational.

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/health` | Returns 200 OK if service is running |

### Run Medical Coder

Process a single patient case through the Medical Coder Swarm.

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/medical-coder/run` | Process a single patient case |

**Request Body Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| patient_id | string | Yes | Unique identifier for the patient |
| case_description | string | Yes | Medical case details to be processed |

**Response Schema:**

| Field | Type | Description |
|-------|------|-------------|
| patient_id | string | Patient identifier |
| case_data | string | Processed case data |

### Run Batch Medical Coder

Process multiple patient cases in a single request.

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/medical-coder/run-batch` | Process multiple patient cases |

**Request Body Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| cases | array | Yes | Array of PatientCase objects |

### Get Patient Data

Retrieve data for a specific patient.

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/v1/medical-coder/patient/{patient_id}` | Get patient data by ID |

**Path Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| patient_id | string | Yes | Patient identifier |

### Get All Patients

Retrieve data for all patients.

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/v1/medical-coder/patients` | Get all patient data |

## Code Examples

### Python

```python
import requests
import json

class MCSClient:
    def __init__(self, base_url="https://mcs.swarms.ai", api_key=None):
        self.base_url = base_url
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}" if api_key else None
        }

    def run_medical_coder(self, patient_id, case_description):
        endpoint = f"{self.base_url}/v1/medical-coder/run"
        payload = {
            "patient_id": patient_id,
            "case_description": case_description
        }
        response = requests.post(endpoint, json=payload, headers=self.headers)
        return response.json()

    def run_batch(self, cases):
        endpoint = f"{self.base_url}/v1/medical-coder/run-batch"
        payload = {"cases": cases}
        response = requests.post(endpoint, json=payload, headers=self.headers)
        return response.json()

# Usage example
client = MCSClient(api_key="your_api_key")
result = client.run_medical_coder("P123", "Patient presents with...")
```

### Next.js (TypeScript)

```typescript
// types.ts
interface PatientCase {
  patient_id: string;
  case_description: string;
}

interface QueryResponse {
  patient_id: string;
  case_data: string;
}

// api.ts
export class MCSApi {
  private baseUrl: string;
  private apiKey: string;

  constructor(apiKey: string, baseUrl = 'https://mcs.swarms.ai') {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }

  private async fetchWithAuth(endpoint: string, options: RequestInit = {}) {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
        ...options.headers,
      },
    });
    return response.json();
  }

  async runMedicalCoder(patientCase: PatientCase): Promise<QueryResponse> {
    return this.fetchWithAuth('/v1/medical-coder/run', {
      method: 'POST',
      body: JSON.stringify(patientCase),
    });
  }

  async getPatientData(patientId: string): Promise<QueryResponse> {
    return this.fetchWithAuth(`/v1/medical-coder/patient/${patientId}`);
  }
}

// Usage in component
const mcsApi = new MCSApi(process.env.MCS_API_KEY);

export async function ProcessPatientCase({ patientId, caseDescription }) {
  const result = await mcsApi.runMedicalCoder({
    patient_id: patientId,
    case_description: caseDescription,
  });
  return result;
}
```

### Go

```go
package mcs

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type MCSClient struct {
    BaseURL string
    APIKey  string
    Client  *http.Client
}

type PatientCase struct {
    PatientID      string `json:"patient_id"`
    CaseDescription string `json:"case_description"`
}

type QueryResponse struct {
    PatientID string `json:"patient_id"`
    CaseData  string `json:"case_data"`
}

func NewMCSClient(apiKey string) *MCSClient {
    return &MCSClient{
        BaseURL: "https://mcs.swarms.ai",
        APIKey:  apiKey,
        Client:  &http.Client{},
    }
}

func (c *MCSClient) RunMedicalCoder(patientCase PatientCase) (*QueryResponse, error) {
    payload, err := json.Marshal(patientCase)
    if err != nil {
        return nil, err
    }

    req, err := http.NewRequest("POST", 
        fmt.Sprintf("%s/v1/medical-coder/run", c.BaseURL),
        bytes.NewBuffer(payload))
    if err != nil {
        return nil, err
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", c.APIKey))

    resp, err := c.Client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result QueryResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return &result, nil
}

// Usage example
func main() {
    client := NewMCSClient("your_api_key")
    
    result, err := client.RunMedicalCoder(PatientCase{
        PatientID:      "P123",
        CaseDescription: "Patient presents with...",
    })
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Result: %+v\n", result)
}
```


## C Sharp


```txt
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace MedicalCoderSwarm
{
    public class PatientCase
    {
        public string PatientId { get; set; }
        public string CaseDescription { get; set; }
    }

    public class QueryResponse
    {
        public string PatientId { get; set; }
        public string CaseData { get; set; }
    }

    public class MCSClient : IDisposable
    {
        private readonly HttpClient _httpClient;
        private readonly string _baseUrl;
        
        public MCSClient(string apiKey, string baseUrl = "https://mcs-285321057562.us-central1.run.app")
        {
            _baseUrl = baseUrl;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {apiKey}");
            _httpClient.DefaultRequestHeaders.Add("Content-Type", "application/json");
        }

        public async Task<QueryResponse> RunMedicalCoderAsync(string patientId, string caseDescription)
        {
            var payload = new PatientCase
            {
                PatientId = patientId,
                CaseDescription = caseDescription
            };

            var content = new StringContent(
                JsonSerializer.Serialize(payload),
                Encoding.UTF8,
                "application/json"
            );

            var response = await _httpClient.PostAsync(
                $"{_baseUrl}/v1/medical-coder/run",
                content
            );

            response.EnsureSuccessStatusCode();
            
            var responseContent = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<QueryResponse>(responseContent);
        }

        public async Task<QueryResponse> GetPatientDataAsync(string patientId)
        {
            var response = await _httpClient.GetAsync(
                $"{_baseUrl}/v1/medical-coder/patient/{patientId}"
            );

            response.EnsureSuccessStatusCode();
            
            var responseContent = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<QueryResponse>(responseContent);
        }

        public async Task<bool> HealthCheckAsync()
        {
            var response = await _httpClient.GetAsync($"{_baseUrl}/health");
            return response.IsSuccessStatusCode;
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
        }
    }

    // Example usage
    public class Program
    {
        public static async Task Main()
        {
            try
            {
                using var client = new MCSClient("your_api_key");

                // Check API health
                var isHealthy = await client.HealthCheckAsync();
                Console.WriteLine($"API Health: {(isHealthy ? "Healthy" : "Unhealthy")}");

                // Process a single case
                var result = await client.RunMedicalCoderAsync(
                    "P123",
                    "Patient presents with acute respiratory symptoms..."
                );
                Console.WriteLine($"Processed case for patient {result.PatientId}");
                Console.WriteLine($"Case data: {result.CaseData}");

                // Get patient data
                var patientData = await client.GetPatientDataAsync("P123");
                Console.WriteLine($"Retrieved data for patient {patientData.PatientId}");
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"API request failed: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred: {ex.Message}");
            }
        }
    }
}

```

## Error Handling

The API uses standard HTTP status codes and returns detailed error messages in JSON format.

**Common Status Codes:**

| Status Code | Description |
|-------------|-------------|
| 200 | Success |
| 400 | Bad Request - Invalid input |
| 401 | Unauthorized - Invalid or missing API key |
| 422 | Validation Error - Request validation failed |
| 429 | Too Many Requests - Rate limit exceeded |
| 500 | Internal Server Error |

**Error Response Format:**

```json
{
  "detail": [
    {
      "loc": ["body", "patient_id"],
      "msg": "field required",
      "type": "value_error.missing"
    }
  ]
}
```


# MCS Python Client Documentation

## Installation

```bash
pip install mcs
```

## Quick Start

```python
from mcs import MCSClient, PatientCase

# Using context manager (recommended)
with MCSClient() as client:
    # Process a single case
    response = client.run_medical_coder(
        patient_id="P123",
        case_description="Patient presents with acute respiratory symptoms..."
    )
    print(f"Processed case: {response.case_data}")

    # Process multiple cases
    cases = [
        PatientCase("P124", "Case 1 description..."),
        PatientCase("P125", "Case 2 description...")
    ]
    batch_response = client.run_batch(cases)
```

## Client Configuration

### Constructor Arguments

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| api_key | str | Yes | - | Authentication API key |
| base_url | str | No | "https://mcs.swarms.ai" | API base URL |
| timeout | int | No | 30 | Request timeout in seconds |
| max_retries | int | No | 3 | Maximum retry attempts |
| logger_name | str | No | "mcs" | Name for the logger instance |

### Example Configuration

```python
client = MCSClient(
    base_url="https://custom-url.example.com",
    timeout=45,
    max_retries=5,
    logger_name="custom_logger"
)
```

## Data Models

### PatientCase

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| patient_id | str | Yes | Unique identifier for the patient |
| case_description | str | Yes | Medical case details |

### QueryResponse

| Field | Type | Description |
|-------|------|-------------|
| patient_id | str | Patient identifier |
| case_data | str | Processed case data |

## Methods

### run_medical_coder

Process a single patient case.

```python
def run_medical_coder(
    self,
    patient_id: str,
    case_description: str
) -> QueryResponse:
```

**Arguments:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| patient_id | str | Yes | Patient identifier |
| case_description | str | Yes | Case details |

**Example:**
```python
response = client.run_medical_coder(
    patient_id="P123",
    case_description="Patient presents with..."
)
print(response.case_data)
```

### run_batch

Process multiple patient cases in batch.

```python
def run_batch(
    self,
    cases: List[PatientCase]
) -> List[QueryResponse]:
```

**Arguments:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| cases | List[PatientCase] | Yes | List of patient cases |

**Example:**
```python
cases = [
    PatientCase("P124", "Case 1 description..."),
    PatientCase("P125", "Case 2 description...")
]
responses = client.run_batch(cases)
for response in responses:
    print(f"Patient {response.patient_id}: {response.case_data}")
```

### get_patient_data

Retrieve data for a specific patient.

```python
def get_patient_data(
    self,
    patient_id: str
) -> QueryResponse:
```

**Example:**
```python
patient_data = client.get_patient_data("P123")
print(f"Patient data: {patient_data.case_data}")
```

### get_all_patients

Retrieve data for all patients.

```python
def get_all_patients(self) -> List[QueryResponse]:
```

**Example:**
```python
all_patients = client.get_all_patients()
for patient in all_patients:
    print(f"Patient {patient.patient_id}: {patient.case_data}")
```

### get_rate_limits

Get current rate limit status.

```python
def get_rate_limits(self) -> Dict[str, Any]:
```

**Example:**
```python
rate_limits = client.get_rate_limits()
print(f"Rate limit status: {rate_limits}")
```

### health_check

Check if the API is operational.

```python
def health_check(self) -> bool:
```

**Example:**
```python
is_healthy = client.health_check()
print(f"API health: {'Healthy' if is_healthy else 'Unhealthy'}")
```

## Error Handling

### Exception Hierarchy

| Exception | Description |
|-----------|-------------|
| MCSClientError | Base exception for all client errors |
| RateLimitError | Raised when API rate limit is exceeded |
| AuthenticationError | Raised when API authentication fails |
| ValidationError | Raised when request validation fails |

### Example Error Handling

```python
from mcs import MCSClient, MCSClientError, RateLimitError

with MCSClient() as client:
    try:
        response = client.run_medical_coder("P123", "Case description...")
    except RateLimitError:
        print("Rate limit exceeded. Please wait before retrying.")
    except MCSClientError as e:
        print(f"An error occurred: {str(e)}")
```

## Advanced Usage

### Retry Configuration

The client implements two levels of retry logic:

1. Connection-level retries (using `HTTPAdapter`):
```python
client = MCSClient(
    ,
    max_retries=5  # Adjusts connection-level retries
)
```

2. Application-level retries (using `tenacity`):
```python
from tenacity import retry, stop_after_attempt

@retry(stop=stop_after_attempt(5))
def process_with_custom_retries():
    with MCSClient() as client:
        return client.run_medical_coder("P123", "Case description...")
```

### Batch Processing with Progress Tracking

```python
from tqdm import tqdm

with MCSClient() as client:
    cases = [
        PatientCase(f"P{i}", f"Case description {i}")
        for i in range(100)
    ]
    
    # Process in smaller batches
    batch_size = 10
    results = []
    
    for i in tqdm(range(0, len(cases), batch_size)):
        batch = cases[i:i + batch_size]
        batch_results = client.run_batch(batch)
        results.extend(batch_results)
```

## Best Practices

1. **Always use context managers:**
   ```python
   with MCSClient() as client:
       # Your code here
       pass
   ```

2. **Handle rate limits appropriately:**
   ```python
   from time import sleep
   
   def process_with_rate_limit_handling():
       with MCSClient() as client:
           try:
               return client.run_medical_coder("P123", "Case...")
           except RateLimitError:
               sleep(60)  # Wait before retry
               return client.run_medical_coder("P123", "Case...")
   ```

3. **Implement proper logging:**
   ```python
   from loguru import logger
   
   logger.add("mcs.log", rotation="500 MB")
   
   with MCSClient() as client:
       try:
           response = client.run_medical_coder("P123", "Case...")
       except Exception as e:
           logger.exception(f"Error processing case: {str(e)}")
   ```

4. **Monitor API health:**
   ```python
   def ensure_healthy_api():
       with MCSClient() as client:
           if not client.health_check():
               raise SystemExit("API is not healthy")
   ```

--------------------------------------------------

# File: swarms_cloud/migrate_openai.md

## Migrate from OpenAI to Swarms in 3 lines of code

If you’ve been using GPT-3.5 or GPT-4, switching to Swarms is easy!

Swarms VLMs are available to use through our OpenAI compatible API. Additionally, if you have been building or prototyping using OpenAI’s Python SDK you can keep your code as-is and use Swarms’s VLMs models.

In this example, we will show you how to change just three lines of code to make your Python application use Swarms’s Open Source models through OpenAI’s Python SDK.

​
## Getting Started
Migrate OpenAI’s Python SDK example script to use Swarms’s LLM endpoints.

These are the three modifications necessary to achieve our goal:

Redefine OPENAI_API_KEY your API key environment variable to use your Swarms key.

Redefine OPENAI_BASE_URL to point to `https://api.swarms.world/v1/chat/completions`

Change the model name to an Open Source model, for example: cogvlm-chat-17b
​
## Requirements
We will be using Python and OpenAI’s Python SDK.
​
## Instructions
Set up a Python virtual environment. Read Creating Virtual Environments here.

```sh
python3 -m venv .venv
source .venv/bin/activate
```

Install the pip requirements in your local python virtual environment

`python3 -m pip install openai`
​
## Environment setup
To run this example, there are simple steps to take:

Get an Swarms API token by following these instructions.
Expose the token in a new SWARMS_API_TOKEN environment variable:

`export SWARMS_API_TOKEN=<your-token>`

Switch the OpenAI token and base URL environment variable

`export OPENAI_API_KEY=$SWARMS_API_TOKEN`
`export OPENAI_BASE_URL="https://api.swarms.world/v1/chat/completions"`

If you prefer, you can also directly paste your token into the client initialization.

​
## Example code
Once you’ve completed the steps above, the code below will call Swarms LLMs:

```python
from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()
openai_api_key = ""

openai_api_base = "https://api.swarms.world/v1"
model = "internlm-xcomposer2-4khd"

client = OpenAI(api_key=openai_api_key, base_url=openai_api_base)
# Note that this model expects the image to come before the main text
chat_response = client.chat.completions.create(
    model=model,
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "https://home-cdn.reolink.us/wp-content/uploads/2022/04/010345091648784709.4253.jpg",
                    },
                },
                {
                    "type": "text",
                    "text": "What is the most dangerous object in the image?",
                },
            ],
        }
    ],
    temperature=0.1,
    max_tokens=5000,
)
print("Chat response:", chat_response)

``` 

Note that you need to supply one of Swarms’s supported LLMs as an argument, as in the example above. For a complete list of our supported LLMs, check out our REST API page.

​
## Example output
The code above produces the following object:

```python
ChatCompletionMessage(content="  Hello! How can I assist you today? Do you have any questions or tasks you'd like help with? Please let me know and I'll do my best to assist you.", role='assistant' function_call=None, tool_calls=None)
```




--------------------------------------------------

# File: swarms_cloud/phala_deploy.md

# 🔐 Swarms x Phala Deployment Guide

This guide will walk you through deploying your project to Phala's Trusted Execution Environment (TEE).

## 📋 Prerequisites

- Docker installed on your system
- A DockerHub account
- Access to Phala Cloud dashboard

## 🛡️ TEE Overview

For detailed instructions about Trusted Execution Environment setup, please refer to our [TEE Documentation](./tee/README.md).

## 🚀 Deployment Steps

### 1. Build and Publish Docker Image

```bash
# Build the Docker image
docker compose build -t <your-dockerhub-username>/swarm-agent-node:latest

# Push to DockerHub
docker push <your-dockerhub-username>/swarm-agent-node:latest
```

### 2. Deploy to Phala Cloud

Choose one of these deployment methods:
- Use [tee-cloud-cli](https://github.com/Phala-Network/tee-cloud-cli) (Recommended)
- Deploy manually via the [Phala Cloud Dashboard](https://cloud.phala.network/)

### 3. Verify TEE Attestation

Visit the [TEE Attestation Explorer](https://proof.t16z.com/) to check and verify your agent's TEE proof.

## 📝 Docker Configuration

Below is a sample Docker Compose configuration for your Swarms agent:

```yaml
services:
  swarms-agent-server:
    image: swarms-agent-node:latest
    platform: linux/amd64
    volumes:
      - /var/run/tappd.sock:/var/run/tappd.sock
      - swarms:/app
    restart: always
    ports:
      - 8000:8000
    command: # Sample MCP Server
      - /bin/sh
      - -c
      - |
        cd /app/mcp_example
        python mcp_test.py
volumes:
  swarms:
```

## 📚 Additional Resources

For more comprehensive documentation and examples, visit our [Official Documentation](https://docs.swarms.world/en/latest/).

---

> **Note**: Make sure to replace `<your-dockerhub-username>` with your actual DockerHub username when building and pushing the image.

--------------------------------------------------

# File: swarms_cloud/production_deployment.md

# Enterprise Guide to High-Performance Multi-Agent LLM Deployments
-------

As large language models (LLMs) continue to advance and enable a wide range of powerful applications, enterprises are increasingly exploring multi-agent architectures to leverage the collective capabilities of multiple LLMs. However, coordinating and optimizing the performance of these complex multi-agent systems presents significant challenges.

This comprehensive guide provides enterprise architects, engineering leaders, and technical decision-makers with a strategic framework for maximizing performance across multi-agent LLM deployments. Developed through extensive research and collaboration with industry partners, this guide distills best practices, proven techniques, and cutting-edge methodologies into seven core principles.

By implementing the recommendations outlined in this guide, organizations can achieve superior latency, throughput, and resource utilization while ensuring scalability, cost-effectiveness, and optimal user experiences. Whether powering customer-facing conversational agents, driving internal knowledge management systems, or fueling mission-critical decision support tools, high-performance multi-agent LLM deployments will be pivotal to unlocking the full potential of this transformative technology.

## Introduction

The rise of large language models (LLMs) has ushered in a new era of human-machine interaction, enabling enterprises to develop sophisticated natural language processing (NLP) applications that can understand, generate, and reason with human-like text. However, as the complexity and scale of LLM deployments grow, traditional monolithic architectures are increasingly challenged to meet the stringent performance, scalability, and cost requirements of enterprise environments.

Multi-agent architectures, which coordinate the collective capabilities of multiple specialized LLMs, have emerged as a powerful paradigm for addressing these challenges. By distributing workloads across a cohort of agents, each optimized for specific tasks or domains, multi-agent systems can deliver superior performance, resilience, and adaptability compared to single-model solutions.

However, realizing the full potential of multi-agent LLM deployments requires a strategic approach to system design, optimization, and ongoing management. This guide presents a comprehensive framework for maximizing performance across seven core principles, each underpinned by a range of proven techniques and methodologies.

Whether you are architecting a customer-facing conversational agent, building an internal knowledge management platform, or developing a mission-critical decision support system, this guide will equip you with the insights and best practices necessary to unlock the full potential of multi-agent LLM deployments within your enterprise.

## Principle 1: Distribute Token Processing
----------------------------------------

At the heart of every LLM deployment lies the fundamental challenge of optimizing token processing -- the rate at which the model consumes and generates text inputs and outputs. In multi-agent architectures, distributing and parallelizing token processing across multiple agents is a critical performance optimization strategy.

### Agent Specialization

One of the key advantages of multi-agent architectures is the ability to dedicate specific agents to specialized tasks or domains. By carefully matching agents to the workloads they are optimized for, enterprises can maximize overall throughput and minimize latency.

For example, in a conversational agent deployment, one agent may be optimized for intent recognition and query understanding, while another is fine-tuned for generating coherent, context-aware responses. In a document processing pipeline, separate agents could be dedicated to tasks such as named entity recognition, sentiment analysis, and summarization.

To effectively leverage agent specialization, enterprises should:

-   Conduct a thorough analysis of their application's workflow and identify distinct tasks or domains that could benefit from dedicated agents.
-   Evaluate the strengths and weaknesses of available LLM models and agents, and map them to the identified tasks or domains based on their capabilities and performance characteristics.
-   Implement continuous monitoring and performance tuning processes to ensure agents remain optimized for their assigned workloads as models evolve and domain requirements shift.

### Load Balancing

Even with a well-designed allocation of tasks across specialized agents, fluctuations in workload and demand can create bottlenecks and performance degradation. Effective load balancing strategies are essential to ensure that token processing capacity is dynamically distributed across available agents based on real-time conditions.

Load balancing in multi-agent LLM deployments can be accomplished through a combination of techniques, including:

-   **Round-Robin**: Distributing incoming requests across agents in a cyclical fashion, ensuring an even distribution of workload.
-   **Least Connections**: Routing requests to the agent with the fewest active connections or outstanding tasks, minimizing the risk of overloading any single agent.
-   **Response Time Monitoring**: Continuously monitoring the response times of each agent and dynamically adjusting request routing to favor faster-responding agents.
-   **Resource-Based Routing**: Factoring in agent-level resource consumption (e.g., CPU, memory) when making routing decisions, ensuring that overloaded agents are relieved of additional workload.

Implementing effective load balancing requires careful consideration of the specific characteristics and requirements of your multi-agent deployment, as well as the integration of robust monitoring and analytics capabilities to inform dynamic routing decisions.

### Horizontal Scaling

While load balancing optimizes the utilization of existing agent resources, horizontal scaling strategies enable organizations to dynamically provision additional token processing capacity to meet demand spikes or handle larger overall workloads.

In multi-agent LLM deployments, horizontal scaling can be achieved through:

-   **Agent Replication**: Spin up additional instances of existing agents to increase parallel processing capacity for specific tasks or domains.
-   **Hybrid Scaling**: Combine agent replication with the dynamic provisioning of additional compute resources (e.g., CPU, GPU) to support the increased agent count.
-   **Serverless Deployment**: Leverage serverless computing platforms (e.g., AWS Lambda, Google Cloud Functions) to automatically scale agent instances based on real-time demand, minimizing idle resource consumption.

Effective horizontal scaling requires robust orchestration and management capabilities, as well as seamless integration with load balancing mechanisms to ensure that incoming workloads are efficiently distributed across the dynamically scaled agent pool.

## Principle 2: Optimize Agent Communication
-----------------------------------------

In multi-agent LLM deployments, efficient inter-agent communication is crucial for coordinating tasks, exchanging context and intermediate results, and maintaining overall system coherence. However, communication overhead can quickly become a performance bottleneck if not carefully managed.

### Minimizing Overhead

Reducing the volume and complexity of information exchanged between agents is a key strategy for optimizing communication performance. Techniques for minimizing overhead include:

-   **Data Compression**: Applying lossless or lossy compression algorithms to reduce the size of data payloads exchanged between agents, lowering bandwidth requirements and transmission latencies.
-   **Information Summarization**: Distilling and summarizing context, results, or other data exchanged between agents to its essential elements, minimizing redundant or non-critical information.
-   **Differential Updates**: Rather than transmitting entire data payloads, agents can exchange only the differential updates or deltas required to synchronize their respective states.

Implementing these techniques requires careful analysis of the specific data exchange patterns and communication requirements within your multi-agent deployment, as well as the integration of appropriate compression, summarization, and differential update algorithms.

### Prioritizing Critical Information

In scenarios where communication bandwidth or latency constraints cannot be fully alleviated through overhead reduction techniques, enterprises can prioritize the exchange of critical information over non-essential data.

This can be achieved through:

-   **Prioritized Queuing**: Implementing queuing mechanisms that prioritize the transmission of high-priority, time-sensitive data over lower-priority, non-critical information.
-   **Selective Communication**: Dynamically determining which agents require specific pieces of information based on their roles and responsibilities, and selectively transmitting data only to those agents that truly need it.
-   **Progressive Information Exchange**: Exchanging information in a progressive or staged manner, with critical elements transmitted first, followed by supplementary or contextual data as bandwidth becomes available.

Effective prioritization requires a deep understanding of the interdependencies and information flow within your multi-agent system, as well as the ability to dynamically assess and prioritize data based on its criticality and urgency.

### Caching and Reusing Context

In many multi-agent LLM deployments, agents frequently exchange or operate on shared context, such as user profiles, conversation histories, or domain-specific knowledge bases. Caching and reusing this context information can significantly reduce redundant communication and processing overhead.

Strategies for optimizing context caching and reuse include:

-   **Agent-Level Caching**: Implementing caching mechanisms within individual agents to store and retrieve frequently accessed context data, minimizing the need for inter-agent communication.
-   **Centralized Context Management**: Deploying a dedicated context management service or data store that agents can query and update, ensuring consistent access to the latest context information across the system.
-   **Context Versioning and Invalidation**: Implementing versioning and invalidation mechanisms to ensure that cached context data remains fresh and consistent, avoiding stale or outdated information from propagating through the system.


### Principle 3: Leverage Agent Specialization
------------------------------------------

One of the key advantages of multi-agent architectures is the ability to optimize individual agents for specific tasks, domains, or capabilities. By leveraging agent specialization, enterprises can ensure that each component of their LLM system is finely tuned for maximum performance and quality.

### Task-Specific Optimization

Within a multi-agent LLM deployment, different agents may be responsible for distinct tasks such as language understanding, knowledge retrieval, response generation, or post-processing. Optimizing each agent for its designated task can yield significant performance gains and quality improvements.

Techniques for task-specific optimization include:

-   **Prompt Engineering**: Crafting carefully designed prompts that provide the necessary context, instructions, and examples to guide an agent towards optimal performance for its assigned task.
-   **Fine-Tuning**: Adapting a pre-trained LLM to a specific task or domain by fine-tuning it on a curated dataset, allowing the agent to specialize and improve its performance on that particular workload.
-   **Model Distillation**: Transferring the knowledge and capabilities of a larger, more capable LLM into a smaller, more efficient model specialized for a specific task, balancing performance and quality trade-offs.

Implementing these optimization techniques requires a deep understanding of the capabilities and requirements of each task within your multi-agent system, as well as access to relevant training data and computational resources for fine-tuning and distillation processes.

### Domain Adaptation

Many enterprise applications operate within specific domains or verticals, such as finance, healthcare, or legal. Adapting agents to these specialized domains can significantly improve their performance, accuracy, and compliance within the target domain.

Strategies for domain adaptation include:

-   **Domain-Specific Pre-Training**: Leveraging domain-specific corpora to pre-train LLM agents, imbuing them with a foundational understanding of the language, concepts, and nuances specific to the target domain.
-   **Transfer Learning**: Fine-tuning agents that have been pre-trained on general or adjacent domains, transferring their existing knowledge and capabilities to the target domain while optimizing for its specific characteristics.
-   **Domain Persona Injection**: Injecting domain-specific personas, traits, or constraints into agents during fine-tuning or deployment, shaping their behavior and outputs to align with domain-specific norms and requirements.

Effective domain adaptation requires access to high-quality, domain-specific training data, as well as close collaboration with subject matter experts to ensure that agents are properly calibrated to meet the unique demands of the target domain.

### Ensemble Techniques

In complex multi-agent deployments, individual agents may excel at specific subtasks or aspects of the overall workflow. Ensemble techniques that combine the outputs or predictions of multiple specialized agents can often outperform any single agent, leveraging the collective strengths of the ensemble.

Common ensemble techniques for multi-agent LLM systems include:

-   **Voting**: Combining the outputs or predictions of multiple agents through majority voting, weighted voting, or other consensus mechanisms.
-   **Stacking**: Training a meta-agent to combine and optimize the outputs of multiple base agents, effectively learning to leverage their collective strengths.
-   **Blending**: Combining the outputs of multiple agents through weighted averaging, linear interpolation, or other blending techniques, allowing for nuanced integration of diverse perspectives.

Implementing effective ensemble techniques requires careful analysis of the strengths, weaknesses, and complementary capabilities of individual agents, as well as the development of robust combination strategies that can optimally leverage the ensemble's collective intelligence.

### Principle 4: Implement Dynamic Scaling
--------------------------------------

The demand and workload patterns of enterprise LLM deployments can be highly dynamic, with significant fluctuations driven by factors such as user activity, data ingestion schedules, or periodic batch processing. Implementing dynamic scaling strategies allows organizations to optimally provision and allocate resources in response to these fluctuations, ensuring consistent performance while minimizing unnecessary costs.

### Autoscaling

Autoscaling is a core capability that enables the automatic adjustment of compute resources (e.g., CPU, GPU, memory) and agent instances based on real-time demand patterns and workload metrics. By dynamically scaling resources up or down, enterprises can maintain optimal performance and resource utilization, avoiding both over-provisioning and under-provisioning scenarios.

Effective autoscaling in multi-agent LLM deployments requires:

-   **Monitoring and Metrics**: Implementing robust monitoring and metrics collection mechanisms to track key performance indicators (KPIs) such as request rates, response times, resource utilization, and agent-level metrics.
-   **Scaling Policies**: Defining scaling policies that specify the conditions and thresholds for triggering automatic scaling actions, such as provisioning additional agents or compute resources when certain KPIs are breached.
-   **Scaling Orchestration**: Integrating autoscaling capabilities with resource orchestration and management tools (e.g., Kubernetes, AWS Auto Scaling) to seamlessly provision, configure, and integrate new resources into the existing multi-agent deployment.

By automating the scaling process, enterprises can respond rapidly to workload fluctuations, ensuring consistent performance and optimal resource utilization without the need for manual intervention.

### Spot Instance Utilization

Many cloud providers offer spot instances or preemptible resources at significantly discounted prices compared to on-demand or reserved instances. While these resources may be reclaimed with little notice, they can be leveraged judiciously within multi-agent LLM deployments to reduce operational costs.

Strategies for leveraging spot instances include:

-   **Fault-Tolerant Agent Deployment**: Deploying certain agents or components of the multi-agent system on spot instances, while ensuring that these components can be rapidly and seamlessly replaced or migrated in the event of instance preemption.
-   **Batch Workload Offloading**: Offloading batch processing workloads or non-time-sensitive tasks to spot instances, leveraging their cost-effectiveness while minimizing the impact of potential disruptions.
-   **Hybrid Provisioning**: Implementing a hybrid approach that combines on-demand or reserved instances for mission-critical components with spot instances for more flexible or elastic workloads.

Effective spot instance utilization requires careful architectural considerations to ensure fault tolerance and minimize the impact of potential disruptions, as well as robust monitoring and automation capabilities to seamlessly replace or migrate workloads in response to instance preemption events.

### Serverless Deployments

Serverless computing platforms, such as AWS Lambda, Google Cloud Functions, or Azure Functions, offer a compelling alternative to traditional server-based deployments. By automatically scaling compute resources based on real-time demand and charging only for the resources consumed, serverless architectures can provide significant cost savings and operational simplicity.

Leveraging serverless deployments for multi-agent LLM systems can be achieved through:

-   **Function-as-a-Service (FaaS) Agents**: Deploying individual agents or components of the multi-agent system as serverless functions, allowing for rapid and automatic scaling in response to fluctuating workloads.
-   **Event-Driven Architectures**: Designing the multi-agent system to operate in an event-driven manner, with agents triggered and executed in response to specific events or data ingestion, aligning with the serverless execution model.
-   **Hybrid Deployments**: Combining serverless components with traditional server-based components, leveraging the strengths and cost advantages of each deployment model for different aspects of the multi-agent system.

Adopting serverless architectures requires careful consideration of factors such as execution duration limits, cold start latencies, and integration with other components of the multi-agent deployment. However, when implemented effectively, serverless deployments can provide unparalleled scalability, cost-efficiency, and operational simplicity for dynamic, event-driven workloads.


### Principle 5: Employ Selective Execution
---------------------------------------

Not every input or request within a multi-agent LLM deployment requires the full execution of all agents or the complete processing pipeline. Selectively invoking agents or tasks based on input characteristics or intermediate results can significantly optimize performance by avoiding unnecessary computation and resource consumption.

### Input Filtering

Implementing input filtering mechanisms allows enterprises to reject or bypass certain inputs before they are processed by the multi-agent system. This can be achieved through techniques such as:

-   **Blacklisting/Whitelisting**: Maintaining lists of inputs (e.g., specific phrases, URLs, or content types) that should be automatically rejected or allowed, based on predefined criteria.
-   **Rules-Based Filtering**: Defining a set of rules or heuristics to assess the suitability or relevance of an input for further processing, based on factors such as language, content, or metadata.
-   **Confidence Thresholding**: Leveraging pre-processing agents or models to assess the likelihood that an input is relevant or valuable, and filtering out inputs that fall below a predetermined confidence threshold.

Effective input filtering requires careful consideration of the specific requirements, constraints, and objectives of your multi-agent deployment, as well as ongoing monitoring and adjustment of filtering rules and thresholds to maintain optimal performance and accuracy.

### Early Stopping

In many multi-agent LLM deployments, intermediate results or predictions generated by early-stage agents can be used to determine whether further processing is required or valuable. Early stopping mechanisms allow enterprises to terminate execution pipelines when specific conditions or thresholds are met, avoiding unnecessary downstream processing.

Techniques for implementing early stopping include:

-   **Confidence-Based Stopping**: Monitoring the confidence scores or probabilities associated with intermediate results, and terminating execution if a predefined confidence threshold is exceeded.
-   **Exception-Based Stopping**: Defining specific intermediate results or conditions that indicate that further processing is unnecessary or undesirable, and terminating execution upon encountering these exceptions.
-   **Adaptive Stopping**: Employing machine learning models or reinforcement learning agents to dynamically determine when to terminate execution based on learned patterns and trade-offs between accuracy, latency, and resource consumption.

Effective early stopping requires a deep understanding of the interdependencies and decision points within your multi-agent workflow, as well as careful tuning and monitoring to ensure that stopping conditions are calibrated to maintain an optimal balance between performance and accuracy.

### Conditional Branching

Rather than executing a linear, fixed pipeline of agents, conditional branching allows multi-agent systems to dynamically invoke different agents or execution paths based on input characteristics or intermediate results. This can significantly optimize resource utilization by ensuring that only the necessary agents and processes are executed for a given input or scenario.

Implementing conditional branching involves:

-   **Decision Points**: Identifying key points within the multi-agent workflow where branching decisions can be made based on input or intermediate data.
-   **Branching Logic**: Defining the rules, conditions, or machine learning models that will evaluate the input or intermediate data and determine the appropriate execution path or agent invocation.
-   **Execution Routing**: Integrating mechanisms to dynamically route inputs or intermediate data to the appropriate agents or processes based on the branching decision.

Conditional branching can be particularly effective in scenarios where inputs or workloads exhibit distinct characteristics or require significantly different processing pipelines, allowing enterprises to optimize resource allocation and minimize unnecessary computation.

### Principle 6: Optimize User Experience
-------------------------------------

While many of the principles outlined in this guide focus on optimizing backend performance and resource utilization, delivering an exceptional user experience is also a critical consideration for enterprise multi-agent LLM deployments. By minimizing perceived wait times and providing real-time progress updates, organizations can ensure that users remain engaged and satisfied, even during periods of high workload or resource constraints.

### Streaming Responses

One of the most effective techniques for minimizing perceived wait times is to stream responses or outputs to users as they are generated, rather than waiting for the entire response to be completed before delivering it. This approach is particularly valuable in conversational agents, document summarization, or other scenarios where outputs can be naturally segmented and delivered incrementally.

Implementing streaming responses requires:

-   **Partial Output Generation**: Modifying agents or models to generate and emit outputs in a streaming or incremental fashion, rather than producing the entire output in a single, monolithic operation.
-   **Streaming Data Pipelines**: Integrating streaming data pipelines and message queues to enable the efficient and reliable transmission of partial outputs from agents to user-facing interfaces or applications.
-   **Incremental Rendering**: Updating user interfaces and displays to incrementally render or populate with newly streamed output segments, providing a seamless and real-time experience for end-users.

By delivering outputs as they are generated, streaming responses can significantly improve the perceived responsiveness and interactivity of multi-agent LLM deployments, even in scenarios where the overall processing time remains unchanged.

### Progress Indicators

In cases where streaming responses may not be feasible or appropriate, providing visual or textual indicators of ongoing processing and progress can help manage user expectations and improve the overall experience. Progress indicators can be implemented through techniques such as:

-   **Loader Animations**: Displaying simple animations or spinner graphics to indicate that processing is underway and provide a sense of activity and progress.
-   **Progress Bars**: Rendering progress bars or completion indicators based on estimated or actual progress through multi-agent workflows or processing pipelines.
-   **Status Updates**: Periodically updating user interfaces with textual status messages or descriptions of the current processing stage, providing users with a more detailed understanding of the system's activities.

Effective progress indicators require careful integration with monitoring and telemetry capabilities to accurately track and communicate the progress of multi-agent workflows, as well as thoughtful user experience design to ensure that indicators are clear, unobtrusive, and aligned with user expectations.

### Chunked Delivery

In scenarios where outputs or responses cannot be effectively streamed or rendered incrementally, chunked delivery can provide a middle ground between delivering the entire output at once and streaming individual tokens or characters. By breaking larger outputs into smaller, more manageable chunks and delivering them individually, enterprises can improve perceived responsiveness and provide a more engaging user experience.

Implementing chunked delivery involves:

-   **Output Segmentation**: Identifying logical breakpoints or segmentation boundaries within larger outputs, such as paragraphs, sections, or other structural elements.
-   **Chunking Mechanisms**: Integrating mechanisms to efficiently break outputs into individual chunks and transmit or render them sequentially, with minimal delay between chunks.
-   **Chunk Rendering**: Updating user interfaces or displays to seamlessly render or append new output chunks as they are received, providing a sense of continuous progress and minimizing the perception of extended waiting periods.

Chunked delivery can be particularly effective in scenarios where outputs are inherently structured or segmented, such as document generation, report creation, or multi-step instructions or workflows.

## Principle 7: Leverage Hybrid Approaches
---------------------------------------

While multi-agent LLM architectures offer numerous advantages, they should not be viewed as a one-size-fits-all solution. In many cases, combining LLM agents with traditional techniques, optimized components, or external services can yield superior performance, cost-effectiveness, and resource utilization compared to a pure LLM-based approach.

### Task Offloading

Certain tasks or subtasks within a larger multi-agent workflow may be more efficiently handled by dedicated, optimized components or external services, rather than relying solely on LLM agents. Task offloading involves identifying these opportunities and integrating the appropriate components or services into the overall architecture.

Examples of task offloading in multi-agent LLM deployments include:

-   **Regular Expression Matching**: Offloading pattern matching or text extraction tasks to dedicated regular expression engines, which can often outperform LLM-based approaches in terms of speed and efficiency.
-   **Structured Data Processing**: Leveraging specialized data processing engines or databases for tasks involving structured data, such as querying, filtering, or transforming tabular or relational data.
-   **External APIs and Services**: Integrating with external APIs or cloud services for specific tasks, such as speech recognition, translation, or knowledge base lookup, leveraging the specialized capabilities and optimizations of these dedicated services.

Effective task offloading requires a thorough understanding of the strengths and limitations of both LLM agents and traditional components, as well as careful consideration of integration points, data flows, and performance trade-offs within the overall multi-agent architecture.

### Caching and Indexing

While LLMs excel at generating dynamic, context-aware outputs, they can be less efficient when dealing with static or frequently accessed information or knowledge. Caching and indexing strategies can help mitigate this limitation by minimizing redundant LLM processing and enabling faster retrieval of commonly accessed data.

Techniques for leveraging caching and indexing in multi-agent LLM deployments include:

**Output Caching**: Caching the outputs or responses generated by LLM agents, allowing for rapid retrieval and reuse in cases where the same or similar input is encountered in the future.

**Knowledge Base Indexing**: Indexing domain-specific knowledge bases, data repositories, or other static information sources using traditional search and information retrieval techniques. This allows LLM agents to efficiently query and incorporate relevant information into their outputs, without needing to process or generate this content from scratch.

**Contextual Caching**: Caching not only outputs but also the contextual information and intermediate results generated during multi-agent workflows. This enables more efficient reuse and continuation of previous processing in scenarios where contexts are long-lived or recurring.

Implementing effective caching and indexing strategies requires careful consideration of data freshness, consistency, and invalidation mechanisms, as well as seamless integration with LLM agents and multi-agent workflows to ensure that cached or indexed data is appropriately leveraged and updated.

### Pre-computation and Lookup

In certain scenarios, especially those involving constrained or well-defined inputs, pre-computing and lookup strategies can be leveraged to minimize or entirely avoid the need for real-time LLM processing. By generating and storing potential outputs or responses in advance, enterprises can significantly improve performance and reduce resource consumption.

Approaches for pre-computation and lookup include:

**Output Pre-generation**: For inputs or scenarios with a limited set of potential outputs, pre-generating and storing all possible responses, allowing for rapid retrieval and delivery without the need for real-time LLM execution.

**Retrieval-Based Responses**: Developing retrieval models or techniques that can identify and surface pre-computed or curated responses based on input characteristics, leveraging techniques such as nearest neighbor search, embedding-based retrieval, or example-based generation.

**Hybrid Approaches**: Combining pre-computed or retrieved responses with real-time LLM processing, allowing for the generation of dynamic, context-aware content while still leveraging pre-computed components to optimize performance and resource utilization.

Effective implementation of pre-computation and lookup strategies requires careful analysis of input patterns, output distributions, and potential performance gains, as well as robust mechanisms for managing and updating pre-computed data as application requirements or domain knowledge evolves.

# Conclusion
----------

As enterprises increasingly embrace the transformative potential of large language models, optimizing the performance, scalability, and cost-effectiveness of these deployments has become a critical imperative. Multi-agent architectures, which coordinate the collective capabilities of multiple specialized LLM agents, offer a powerful paradigm for addressing these challenges.

By implementing the seven principles outlined in this guide -- distributing token processing, optimizing agent communication, leveraging agent specialization, implementing dynamic scaling, employing selective execution, optimizing user experience, and leveraging hybrid approaches -- organizations can unlock the full potential of multi-agent LLM deployments.

However, realizing these benefits requires a strategic and holistic approach that accounts for the unique requirements, constraints, and objectives of each enterprise. From task-specific optimizations and domain adaptation to dynamic scaling and user experience considerations, maximizing the performance of multi-agent LLM systems demands a deep understanding of the underlying technologies, as well as the ability to navigate the inherent complexities of these sophisticated architectures.

To learn more about how Swarm Corporation can assist your organization in architecting, deploying, and optimizing high-performance multi-agent LLM solutions, we invite you to book a consultation with one of our agent specialists. Visit <https://calendly.com/swarm-corp/30min> to schedule a 30-minute call and explore how our expertise and cutting-edge technologies can drive transformative outcomes for your business.

In the rapidly evolving landscape of artificial intelligence and natural language processing, staying ahead of the curve is essential. Partner with Swarm Corporation, and unlock the full potential of multi-agent LLM deployments, today.

[Book a call with us now:](https://calendly.com/swarm-corp/30min)

--------------------------------------------------

# File: swarms_cloud/subscription_tiers.md

# Swarms Cloud Subscription Tiers / Swarms 云订阅等级

!!! abstract "Overview / 概述"
    Choose the perfect plan for your agent infrastructure needs. All plans include our core features with additional benefits as you scale up.
    为您的智能体基础设施需求选择完美方案。所有计划都包含我们的核心功能，随着您的扩展提供额外优势。

## Pricing Plans / 定价方案

### Free Tier / 免费版

!!! example "Free / 免费"
    **$0/year / 0美元/年**
    
    Perfect for getting started with AI development.
    非常适合开始AI开发。

    [Get Started / 开始使用](https://swarms.world/platform/account){ .md-button .md-button--primary }

    **What's Included: / 包含内容：**
    
    - [x] Sign up Bonus! / 注册奖励！
    
    - [x] Basic Access / 基础访问权限
    
    - [x] Pay-Per-Use Pricing / 按使用量付费
    
    - [x] Community Support / 社区支持
    
    - [x] Standard Processing Speed / 标准处理速度

### Premium Tier / 高级版

!!! success "Premium / 高级版"

    **Monthly $100/month / 每月100美元**

    **Yearly $1,020/year / 每年1,020美元** (Save 15% on annual billing / 年付节省15%)
    
    [Subscribe Now / 立即订阅](https://swarms.world/platform/account){ .md-button .md-button--primary }

    **Everything in Free, plus: / 包含免费版所有内容，外加：**
    
    - [x] Full Access to Explorer and Agents / 完全访问Explorer和智能体
    
    - [x] Access to Premium Multi-Modality Models / 访问高级多模态模型
    
    - [x] Priority Access to Swarms / 优先访问Swarms
    
    - [x] High-Performance Infrastructure / 高性能基础设施
    
    - [x] Exclusive Webinars and Tutorials / 独家网络研讨会和教程
    
    - [x] Priority Support / 优先支持
    
    - [x] Enhanced Security Features / 增强的安全功能
    
    - [x] Early Access to New Models and Features / 新模型和功能的早期访问

### Enterprise Tier / 企业版

!!! tip "Enterprise / 企业版"
    **Contact for more Information / 联系获取更多信息**
    
    [Book a Call / 预约通话](https://cal.com/swarms){ .md-button .md-button--primary }

    **Everything in Premium, plus: / 包含高级版所有内容，外加：**
    
    - [x] High-Performance Infrastructure / 高性能基础设施
    
    - [x] Batch API / 批量API
    
    - [x] Early Access to New Swarms / 新Swarms的早期访问
    
    - [x] Dedicated 24/7 Support / 专属24/7支持
    
    - [x] Custom Solutions Engineering / 定制解决方案工程
    
    - [x] Advanced Security Features / 高级安全功能
    
    - [x] Onsite Training and Onboarding / 现场培训和入职
    
    - [x] Custom Model Training / 定制模型训练
    
    - [x] Priority Support / 优先支持
    
    - [x] Pay-Per-Use Pricing / 按使用量付费

    - [x] Enterprise Telemetry Platform / 企业遥测平台

    - [x] Regular Check-In Strategy Sessions / 定期战略会议

## Feature Comparison / 功能对比

| Feature / 功能 | Free / 免费版 | Premium / 高级版 | Enterprise / 企业版 |
|---------|------|---------|------------|
| Sign up Bonus / 注册奖励 | ✅ | ✅ | ✅ |
| Basic Access / 基础访问权限 | ✅ | ✅ | ✅ |
| Pay-Per-Use Pricing / 按使用量付费 | ✅ | ✅ | ✅ |
| Community Support / 社区支持 | ✅ | ✅ | ✅ |
| Standard Processing Speed / 标准处理速度 | ✅ | ✅ | ✅ |
| Full Access to Explorer and Agents / 完全访问Explorer和智能体 | ❌ | ✅ | ✅ |
| Premium Multi-Modality Models / 高级多模态模型 | ❌ | ✅ | ✅ |
| Priority Access to Swarms / 优先访问Swarms | ❌ | ✅ | ✅ |
| High-Performance GPUs / 高性能GPU | ❌ | ✅ | ✅ |
| Exclusive Webinars and Tutorials / 独家网络研讨会和教程 | ❌ | ✅ | ✅ |
| Priority Support / 优先支持 | ❌ | ✅ | ✅ |
| Enhanced Security Features / 增强的安全功能 | ❌ | ✅ | ✅ |
| Early Access to New Models / 新模型的早期访问 | ❌ | ✅ | ✅ |
| Batch API / 批量API | ❌ | ❌ | ✅ |
| Dedicated 24/7 Support / 专属24/7支持 | ❌ | ❌ | ✅ |
| Custom Solutions Engineering / 定制解决方案工程 | ❌ | ❌ | ✅ |
| Onsite Training and Onboarding / 现场培训和入职 | ❌ | ❌ | ✅ |
| Custom Model Training / 定制模型训练 | ❌ | ❌ | ✅ |

## Rate Limits / 速率限制

!!! info "Rate Limit Increases / 速率限制提升"
    - **Premium / 高级版**: 100% increase in rate limits / 速率限制提升100%
    - **Enterprise / 企业版**: Custom rate limits based on your needs (contact us for details) / 根据您的需求定制速率限制（详情请联系我们）

## Getting Started / 开始使用

1. Choose your plan / 选择您的方案
2. Create your account / 创建您的账户
3. Start building with Swarms! / 开始使用Swarms构建！

!!! success "Need Help? / 需要帮助？"
    - For general questions: [Contact Support](mailto:kye@swarms.world) / 一般问题：[联系支持](mailto:kye@swarms.world)
    - For enterprise inquiries: [Book a Call](https://cal.com/swarms) / 企业咨询：[预约通话](https://cal.com/swarms)
    - Upgrade Your Membership: [Upgrade Now](https://swarms.world/platform/account) / 升级会员：[立即升级](https://swarms.world/platform/account)


--------------------------------------------------

# File: swarms_cloud/swarm_types.md

### Available Swarms in The Swarms API

| Swarm Type           | Description (English)                                                      | Description (Chinese)                                                      |
|----------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------|
| AgentRearrange       | A swarm type focused on rearranging agents for optimal performance.         | 一种专注于重新排列代理以实现最佳性能的群类型。                               |
| MixtureOfAgents      | Combines different types of agents to achieve a specific goal.              | 结合不同类型的代理以实现特定目标。                                         |
| SpreadSheetSwarm     | Utilizes spreadsheet-like structures for data management and operations.    | 利用类似电子表格的结构进行数据管理和操作。                                 |
| SequentialWorkflow   | Executes tasks in a sequential manner.                                      | 以顺序方式执行任务。                                                       |
| ConcurrentWorkflow   | Allows tasks to be executed concurrently for efficiency.                    | 允许任务并发执行以提高效率。                                               |
| GroupChat            | Facilitates communication among agents in a group chat format.             | 以群聊格式促进代理之间的沟通。                                             |
| MultiAgentRouter     | Routes tasks and information among multiple agents.                         | 在多个代理之间路由任务和信息。                                             |
| AutoSwarmBuilder     | Automatically builds and configures swarms based on predefined criteria.    | 根据预定义标准自动构建和配置群。                                           |
| HiearchicalSwarm     | Organizes agents in a hierarchical structure for task delegation.           | 以层次结构组织代理以进行任务委派。                                         |
| auto                 | Automatically selects the best swarm type based on the context.             | 根据上下文自动选择最佳群类型。                                             |
| MajorityVoting       | Uses majority voting among agents to make decisions.                        | 使用代理之间的多数投票来做出决策。                                         |
| MALT                 | A specialized swarm type for specific tasks (details needed).               | 一种专门为特定任务设计的群类型（需要详细信息）。                           |

### Documentation for Swarms

1. **AgentRearrange**: This swarm type is designed to rearrange agents to optimize their performance in a given task. It is useful in scenarios where agent positioning or order affects the outcome.
   - 这种群类型旨在重新排列代理以优化其在给定任务中的性能。它在代理位置或顺序影响结果的情况下非常有用。

2. **MixtureOfAgents**: This type combines various agents, each with unique capabilities, to work together towards a common goal. It leverages the strengths of different agents to enhance overall performance.
   - 这种类型结合了各种代理，每个代理都有独特的能力，共同努力实现共同目标。它利用不同代理的优势来提高整体性能。

3. **SpreadSheetSwarm**: This swarm type uses spreadsheet-like structures to manage and operate on data. It is ideal for tasks that require organized data manipulation and analysis.
   - 这种群类型使用类似电子表格的结构来管理和操作数据。它非常适合需要有组织的数据操作和分析的任务。

4. **SequentialWorkflow**: Tasks are executed one after another in this swarm type, ensuring that each step is completed before the next begins. It is suitable for processes that require strict order.
   - 在这种群类型中，任务一个接一个地执行，确保每个步骤在下一个步骤开始之前完成。它适用于需要严格顺序的流程。

5. **ConcurrentWorkflow**: This type allows multiple tasks to be executed simultaneously, improving efficiency and reducing time for completion. It is best for independent tasks that do not rely on each other.
   - 这种类型允许多个任务同时执行，提高效率并减少完成时间。它最适合不相互依赖的独立任务。

6. **GroupChat**: Facilitates communication among agents in a group chat format, enabling real-time collaboration and decision-making.
   - 以群聊格式促进代理之间的沟通，实现实时协作和决策。

7. **MultiAgentRouter**: This swarm type routes tasks and information among multiple agents, ensuring that each agent receives the necessary data to perform its function.
   - 这种群类型在多个代理之间路由任务和信息，确保每个代理接收到执行其功能所需的数据。

8. **AutoSwarmBuilder**: Automatically builds and configures swarms based on predefined criteria, reducing the need for manual setup and configuration.
   - 根据预定义标准自动构建和配置群，减少手动设置和配置的需要。

9. **HiearchicalSwarm**: Organizes agents in a hierarchical structure, allowing for efficient task delegation and management.
   - 以层次结构组织代理，允许高效的任务委派和管理。

10. **auto**: Automatically selects the most appropriate swarm type based on the context and requirements of the task.
    - 根据任务的上下文和要求自动选择最合适的群类型。

11. **MajorityVoting**: Uses a majority voting mechanism among agents to make decisions, ensuring that the most popular choice is selected.
    - 使用代理之间的多数投票机制来做出决策，确保选择最受欢迎的选项。

12. **MALT**: A specialized swarm type designed for specific tasks. Further details are needed to fully document this type.
    - 一种专门为特定任务设计的群类型。需要进一步的详细信息来完整记录这种类型。


--------------------------------------------------

# File: swarms_cloud/swarms_api.md

# Swarms API Documentation

*Enterprise-grade Agent Swarm Management API*

**Base URL**: `https://api.swarms.world`  
**API Key Management**: [https://swarms.world/platform/api-keys](https://swarms.world/platform/api-keys)  

## Overview

The Swarms API provides a robust, scalable infrastructure for deploying and managing intelligent agent swarms in the cloud. This enterprise-grade API enables organizations to create, execute, and orchestrate sophisticated AI agent workflows without managing the underlying infrastructure.

Key capabilities include:

- **Intelligent Swarm Management**: Create and execute swarms of specialized AI agents that collaborate to solve complex tasks
- **Automatic Agent Generation**: Dynamically create optimized agents based on task requirements
- **Multiple Swarm Architectures**: Choose from various swarm patterns to match your specific workflow needs
- **Scheduled Execution**: Set up automated, scheduled swarm executions
- **Comprehensive Logging**: Track and analyze all API interactions
- **Cost Management**: Predictable, transparent pricing with optimized resource utilization
- **Enterprise Security**: Full API key authentication and management

Swarms API is designed for production use cases requiring sophisticated AI orchestration, with applications in finance, healthcare, legal, research, and other domains where complex reasoning and multi-agent collaboration are needed.

## Authentication

All API requests require a valid API key, which must be included in the header of each request:

```
x-api-key: your_api_key_here
```

API keys can be obtained and managed at [https://swarms.world/platform/api-keys](https://swarms.world/platform/api-keys).

## API Reference

### Endpoints Summary

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/health` | GET | Simple health check endpoint |
| `/v1/swarm/completions` | POST | Run a swarm with specified configuration |
| `/v1/swarm/batch/completions` | POST | Run multiple swarms in batch mode |
| `/v1/swarm/schedule` | POST | Schedule a swarm to run at a specific time |
| `/v1/swarm/schedule` | GET | Get all scheduled swarm jobs |
| `/v1/swarm/schedule/{job_id}` | DELETE | Cancel a scheduled swarm job |
| `/v1/swarm/logs` | GET | Retrieve API request logs |
| `/v1/swarms/available` | GET | Get all available swarms as a list of strings |
| `/v1/models/available` | GET | Get all available models as a list of strings |



### SwarmType Reference

The `swarm_type` parameter defines the architecture and collaboration pattern of the agent swarm:

| SwarmType | Description |
|-----------|-------------|
| `AgentRearrange` | Dynamically reorganizes the workflow between agents based on task requirements |
| `MixtureOfAgents` | Combines multiple agent types to tackle diverse aspects of a problem |
| `SpreadSheetSwarm` | Specialized for spreadsheet data analysis and manipulation |
| `SequentialWorkflow` | Agents work in a predefined sequence, each handling specific subtasks |
| `ConcurrentWorkflow` | Multiple agents work simultaneously on different aspects of the task |
| `GroupChat` | Agents collaborate in a discussion format to solve problems |
| `MultiAgentRouter` | Routes subtasks to specialized agents based on their capabilities |
| `AutoSwarmBuilder` | Automatically designs and builds an optimal swarm based on the task |
| `HiearchicalSwarm` | Organizes agents in a hierarchical structure with managers and workers |
| `MajorityVoting` | Uses a consensus mechanism where multiple agents vote on the best solution |
| `auto` | Automatically selects the most appropriate swarm type for the given task |



## Data Models

### SwarmSpec

The `SwarmSpec` model defines the configuration of a swarm.

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| name | string | Identifier for the swarm | No |
| description | string | Description of the swarm's purpose | No |
| agents | Array<AgentSpec> | List of agent specifications | No |
| max_loops | integer | Maximum number of execution loops | No |
| swarm_type | SwarmType | Architecture of the swarm | No |
| rearrange_flow | string | Instructions for rearranging task flow | No |
| task | string | The main task for the swarm to accomplish | Yes |
| img | string | Optional image URL for the swarm | No |
| return_history | boolean | Whether to return execution history | No |
| rules | string | Guidelines for swarm behavior | No |
| schedule | ScheduleSpec | Scheduling information | No |

### AgentSpec

The `AgentSpec` model defines the configuration of an individual agent.

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| agent_name | string | Unique name for the agent | Yes* |
| description | string | Description of the agent's purpose | No |
| system_prompt | string | Instructions for the agent | No |
| model_name | string | AI model to use (e.g., "gpt-4o") | Yes* |
| auto_generate_prompt | boolean | Whether to auto-generate prompts | No |
| max_tokens | integer | Maximum tokens in response | No |
| temperature | float | Randomness of responses (0-1) | No |
| role | string | Agent's role in the swarm | No |
| max_loops | integer | Maximum iterations for this agent | No |

*Required if agents are manually specified; not required if using auto-generated agents

### ScheduleSpec

The `ScheduleSpec` model defines when a swarm should be executed.

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| scheduled_time | datetime | Time when the swarm should run | Yes |
| timezone | string | Timezone for the scheduled time | No (defaults to "UTC") |



### Endpoint Details

#### Health Check

Check if the API service is available and functioning correctly.

**Endpoint**: `/health`  
**Method**: GET  
**Rate Limit**: 100 requests per 60 seconds

**Example Request**:
```bash
curl -X GET "https://api.swarms.world/health" \
     -H "x-api-key: your_api_key_here"
```

**Example Response**:
```json
{
  "status": "ok"
}
```

#### Run Swarm

Run a swarm with the specified configuration to complete a task.

**Endpoint**: `/v1/swarm/completions`  
**Method**: POST  
**Rate Limit**: 100 requests per 60 seconds

**Request Parameters**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| name | string | Identifier for the swarm | No |
| description | string | Description of the swarm's purpose | No |
| agents | Array<AgentSpec> | List of agent specifications | No |
| max_loops | integer | Maximum number of execution loops | No |
| swarm_type | SwarmType | Architecture of the swarm | No |
| rearrange_flow | string | Instructions for rearranging task flow | No |
| task | string | The main task for the swarm to accomplish | Yes |
| img | string | Optional image URL for the swarm | No |
| return_history | boolean | Whether to return execution history | No |
| rules | string | Guidelines for swarm behavior | No |
| schedule | ScheduleSpec | Scheduling information | No |

**Example Request**:
```bash

# Run single swarm
curl -X POST "https://api.swarms.world/v1/swarm/completions" \
  -H "x-api-key: $SWARMS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Financial Analysis Swarm",
    "description": "Market analysis swarm",
    "agents": [
      {
        "agent_name": "Market Analyst",
        "description": "Analyzes market trends",
        "system_prompt": "You are a financial analyst expert.",
        "model_name": "openai/gpt-4o",
        "role": "worker",
        "max_loops": 1,
        "max_tokens": 8192,
        "temperature": 0.5,
        "auto_generate_prompt": false
      },
      {
        "agent_name": "Economic Forecaster",
        "description": "Predicts economic trends",
        "system_prompt": "You are an expert in economic forecasting.",
        "model_name": "gpt-4o",
        "role": "worker",
        "max_loops": 1,
        "max_tokens": 8192,
        "temperature": 0.5,
        "auto_generate_prompt": false
      }
    ],
    "max_loops": 1,
    "swarm_type": "ConcurrentWorkflow",
    "task": "What are the best etfs and index funds for ai and tech?",
    "output_type": "dict"
  }'

```

**Example Response**:
```json
{
  "status": "success",
  "swarm_name": "financial-analysis-swarm",
  "description": "Analyzes financial data for risk assessment",
  "swarm_type": "SequentialWorkflow",
  "task": "Analyze the provided quarterly financials for Company XYZ and identify potential risk factors. Summarize key insights and provide recommendations for risk mitigation.",
  "output": {
    "financial_analysis": {
      "risk_factors": [...],
      "key_insights": [...],
      "recommendations": [...]
    }
  },
  "metadata": {
    "max_loops": 2,
    "num_agents": 3,
    "execution_time_seconds": 12.45,
    "completion_time": 1709563245.789,
    "billing_info": {
      "cost_breakdown": {
        "agent_cost": 0.03,
        "input_token_cost": 0.002134,
        "output_token_cost": 0.006789,
        "token_counts": {
          "total_input_tokens": 1578,
          "total_output_tokens": 3456,
          "total_tokens": 5034,
          "per_agent": {...}
        },
        "num_agents": 3,
        "execution_time_seconds": 12.45
      },
      "total_cost": 0.038923
    }
  }
}
```

#### Run Batch Completions

Run multiple swarms as a batch operation.

**Endpoint**: `/v1/swarm/batch/completions`  
**Method**: POST  
**Rate Limit**: 100 requests per 60 seconds

**Request Parameters**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| swarms | Array<SwarmSpec> | List of swarm specifications | Yes |

**Example Request**:
```bash
# Batch swarm completions
curl -X POST "https://api.swarms.world/v1/swarm/batch/completions" \
  -H "x-api-key: $SWARMS_API_KEY" \
  -H "Content-Type: application/json" \
  -d '[
    {
      "name": "Batch Swarm 1",
      "description": "First swarm in the batch",
      "agents": [
        {
          "agent_name": "Research Agent",
          "description": "Conducts research",
          "system_prompt": "You are a research assistant.",
          "model_name": "gpt-4o",
          "role": "worker",
          "max_loops": 1
        },
        {
          "agent_name": "Analysis Agent",
          "description": "Analyzes data",
          "system_prompt": "You are a data analyst.",
          "model_name": "gpt-4o",
          "role": "worker",
          "max_loops": 1
        }
      ],
      "max_loops": 1,
      "swarm_type": "SequentialWorkflow",
      "task": "Research AI advancements."
    },
    {
      "name": "Batch Swarm 2",
      "description": "Second swarm in the batch",
      "agents": [
        {
          "agent_name": "Writing Agent",
          "description": "Writes content",
          "system_prompt": "You are a content writer.",
          "model_name": "gpt-4o",
          "role": "worker",
          "max_loops": 1
        },
        {
          "agent_name": "Editing Agent",
          "description": "Edits content",
          "system_prompt": "You are an editor.",
          "model_name": "gpt-4o",
          "role": "worker",
          "max_loops": 1
        }
      ],
      "max_loops": 1,
      "swarm_type": "SequentialWorkflow",
      "task": "Write a summary of AI research."
    }
  ]'
```

**Example Response**:
```json
[
  {
    "status": "success",
    "swarm_name": "risk-analysis",
    "task": "Analyze risk factors for investment portfolio",
    "output": {...},
    "metadata": {...}
  },
  {
    "status": "success",
    "swarm_name": "market-sentiment",
    "task": "Assess current market sentiment for technology sector",
    "output": {...},
    "metadata": {...}
  }
]
```

#### Schedule Swarm

Schedule a swarm to run at a specific time.

**Endpoint**: `/v1/swarm/schedule`  
**Method**: POST  
**Rate Limit**: 100 requests per 60 seconds

**Request Parameters**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| name | string | Identifier for the swarm | No |
| description | string | Description of the swarm's purpose | No |
| agents | Array<AgentSpec> | List of agent specifications | No |
| max_loops | integer | Maximum number of execution loops | No |
| swarm_type | SwarmType | Architecture of the swarm | No |
| task | string | The main task for the swarm to accomplish | Yes |
| schedule | ScheduleSpec | Scheduling information | Yes |

**Example Request**:
```bash
curl -X POST "https://api.swarms.world/v1/swarm/schedule" \
     -H "x-api-key: your_api_key_here" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "daily-market-analysis",
       "description": "Daily analysis of market conditions",
       "task": "Analyze today's market movements and prepare a summary report",
       "schedule": {
         "scheduled_time": "2025-03-05T17:00:00Z",
         "timezone": "UTC"
       }
     }'
```

**Example Response**:
```json
{
  "status": "success",
  "message": "Swarm scheduled successfully",
  "job_id": "swarm_daily-market-analysis_1709563245",
  "scheduled_time": "2025-03-05T17:00:00Z",
  "timezone": "UTC"
}
```

#### Get Scheduled Jobs

Retrieve all scheduled swarm jobs.

**Endpoint**: `/v1/swarm/schedule`  
**Method**: GET  
**Rate Limit**: 100 requests per 60 seconds

**Example Request**:
```bash
curl -X GET "https://api.swarms.world/v1/swarm/schedule" \
     -H "x-api-key: your_api_key_here"
```

**Example Response**:
```json
{
  "status": "success",
  "scheduled_jobs": [
    {
      "job_id": "swarm_daily-market-analysis_1709563245",
      "swarm_name": "daily-market-analysis",
      "scheduled_time": "2025-03-05T17:00:00Z",
      "timezone": "UTC"
    },
    {
      "job_id": "swarm_weekly-report_1709563348",
      "swarm_name": "weekly-report",
      "scheduled_time": "2025-03-09T12:00:00Z",
      "timezone": "UTC"
    }
  ]
}
```

#### Cancel Scheduled Job

Cancel a previously scheduled swarm job.

**Endpoint**: `/v1/swarm/schedule/{job_id}`  
**Method**: DELETE  
**Rate Limit**: 100 requests per 60 seconds

**Path Parameters**:

| Parameter | Description |
|-----------|-------------|
| job_id | ID of the scheduled job to cancel |

**Example Request**:
```bash
curl -X DELETE "https://api.swarms.world/v1/swarm/schedule/swarm_daily-market-analysis_1709563245" \
     -H "x-api-key: your_api_key_here"
```

**Example Response**:
```json
{
  "status": "success",
  "message": "Scheduled job cancelled successfully",
  "job_id": "swarm_daily-market-analysis_1709563245"
}
```


### Get Models

#### Get Available Models

Get all available models as a list of strings.

**Endpoint**: `/v1/models/available`  
**Method**: GET  

**Example Request**:
```bash
curl -X GET "https://api.swarms.world/v1/models/available" \
     -H "x-api-key: your_api_key_here"
```


------


### Get Swarms Available

Get all available swarms as a list of strings.

**Endpoint**: `/v1/swarms/available`  
**Method**: GET

**Example Request**:
```bash
curl -X GET "https://api.swarms.world/v1/swarms/available" \
     -H "x-api-key: your_api_key_here"
```

**Example Response**:
```json
{
  "status": "success",
  "swarms": ["financial-analysis-swarm", "market-sentiment-swarm"]
}
```

-------


#### Get API Logs

Retrieve logs of API requests made with your API key.

**Endpoint**: `/v1/swarm/logs`  
**Method**: GET  
**Rate Limit**: 100 requests per 60 seconds

**Example Request**:
```bash
curl -X GET "https://api.swarms.world/v1/swarm/logs" \
     -H "x-api-key: your_api_key_here"
```

**Example Response**:
```json
{
  "status": "success",
  "count": 25,
  "logs": [
    {
      "id": "log_id_12345",
      "api_key": "api_key_redacted",
      "data": {
        "action": "run_swarm",
        "swarm_name": "financial-analysis-swarm",
        "task": "Analyze quarterly financials...",
        "timestamp": "2025-03-04T14:22:45Z"
      }
    },
    ...
  ]
}
```

## Production Examples

### Python Examples

#### Financial Risk Assessment (Python)

This example demonstrates creating a swarm for comprehensive financial risk assessment.

```python
import requests
import json
from datetime import datetime, timedelta

# API Configuration
API_BASE_URL = "https://api.swarms.world"
API_KEY = "your_api_key_here"
HEADERS = {
    "x-api-key": API_KEY,
    "Content-Type": "application/json"
}

def financial_risk_assessment(company_data, market_conditions, risk_tolerance):
    """
    Creates and runs a swarm to perform comprehensive financial risk assessment.
    
    Args:
        company_data (str): Description or data about the company
        market_conditions (str): Current market conditions
        risk_tolerance (str): Risk tolerance level (e.g., "conservative", "moderate", "aggressive")
        
    Returns:
        dict: Risk assessment results
    """
    # Prepare the task description with all relevant information
    task = f"""
    Perform a comprehensive financial risk assessment with the following data:
    
    COMPANY DATA:
    {company_data}
    
    MARKET CONDITIONS:
    {market_conditions}
    
    RISK TOLERANCE:
    {risk_tolerance}
    
    Analyze all potential risk factors including market risks, credit risks, 
    operational risks, and regulatory compliance risks. Quantify each risk factor 
    on a scale of 1-10 and provide specific mitigation strategies.
    
    Return a detailed report with executive summary, risk scores, detailed analysis,
    and actionable recommendations.
    """
    
    # Define specialized financial agents
    financial_analysts = [
        {
            "agent_name": "MarketAnalyst",
            "description": "Specialist in market risk assessment and forecasting",
            "system_prompt": "You are an expert market analyst with deep expertise in financial markets. Analyze market conditions, trends, and external factors that could impact financial performance. Provide quantitative and qualitative analysis of market-related risks.",
            "model_name": "gpt-4o",
            "temperature": 0.3,
            "role": "analyst",
            "max_loops": 1
        },
        {
            "agent_name": "CreditRiskAnalyst",
            "description": "Expert in assessing credit and counterparty risks",
            "system_prompt": "You are a specialist in credit risk analysis with experience in banking and financial institutions. Evaluate creditworthiness, default probabilities, and counterparty exposures. Provide detailed analysis of credit-related risks and recommended safeguards.",
            "model_name": "gpt-4o",
            "temperature": 0.2,
            "role": "analyst",
            "max_loops": 1
        },
        {
            "agent_name": "RegulatoryExpert",
            "description": "Expert in financial regulations and compliance",
            "system_prompt": "You are a regulatory compliance expert with deep knowledge of financial regulations. Identify potential regulatory risks, compliance issues, and governance concerns. Recommend compliance measures and risk mitigation strategies.",
            "model_name": "gpt-4o",
            "temperature": 0.2,
            "role": "analyst",
            "max_loops": 1
        },
        {
            "agent_name": "RiskSynthesizer",
            "description": "Integrates all risk factors into comprehensive assessment",
            "system_prompt": "You are a senior risk management professional responsible for synthesizing multiple risk analyses into a coherent, comprehensive risk assessment. Integrate analyses from various domains, resolve conflicting assessments, and provide a holistic view of risk exposure with prioritized recommendations.",
            "model_name": "gpt-4o",
            "temperature": 0.4,
            "role": "manager",
            "max_loops": 1
        }
    ]
    
    # Create the swarm specification
    swarm_spec = {
        "name": "financial-risk-assessment",
        "description": "Comprehensive financial risk assessment swarm",
        "agents": financial_analysts,
        "max_loops": 2,
        "swarm_type": "HiearchicalSwarm",
        "task": task,
        "return_history": True
    }
    
    # Execute the swarm
    response = requests.post(
        f"{API_BASE_URL}/v1/swarm/completions",
        headers=HEADERS,
        json=swarm_spec
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Risk assessment completed. Cost: ${result['metadata']['billing_info']['total_cost']}")
        return result["output"]
    else:
        print(f"Error: {response.status_code} - {response.text}")
        return None

# Usage example
if __name__ == "__main__":
    company_data = """
    XYZ Financial Services
    Annual Revenue: $125M
    Current Debt: $45M
    Credit Rating: BBB+
    Primary Markets: North America, Europe
    Key Products: Asset management, retirement planning, commercial lending
    Recent Events: Expanding into Asian markets, New CEO appointed 6 months ago
    """
    
    market_conditions = """
    Current interest rates rising (Federal Reserve increased rates by 0.25% last month)
    Inflation at 3.2% (12-month outlook projects 3.5-4.0%)
    Market volatility index (VIX) at 22.4 (elevated)
    Regulatory environment: New financial reporting requirements taking effect next quarter
    Sector performance: Financial services sector underperforming broader market by 2.7%
    """
    
    risk_tolerance = "moderate"
    
    result = financial_risk_assessment(company_data, market_conditions, risk_tolerance)
    
    if result:
        # Process and use the risk assessment
        print(json.dumps(result, indent=2))
        
        # Optionally, schedule a follow-up assessment
        tomorrow = datetime.utcnow() + timedelta(days=30)
        schedule_spec = {
            "name": "monthly-risk-update",
            "description": "Monthly update to risk assessment",
            "task": f"Update the risk assessment for XYZ Financial Services based on current market conditions. Previous assessment: {json.dumps(result)}",
            "schedule": {
                "scheduled_time": tomorrow.isoformat() + "Z",
                "timezone": "UTC"
            }
        }
        
        schedule_response = requests.post(
            f"{API_BASE_URL}/v1/swarm/schedule",
            headers=HEADERS,
            json=schedule_spec
        )
        
        if schedule_response.status_code == 200:
            print("Follow-up assessment scheduled successfully")
            print(schedule_response.json())
```

#### Healthcare Patient Data Analysis (Python)

This example demonstrates creating a swarm for analyzing patient health data and generating insights.

```python
import requests
import json
import os
from datetime import datetime

# API Configuration
API_BASE_URL = "https://api.swarms.world"
API_KEY = os.environ.get("SWARMS_API_KEY")
HEADERS = {
    "x-api-key": API_KEY,
    "Content-Type": "application/json"
}

def analyze_patient_health_data(patient_data, medical_history, lab_results, treatment_goals):
    """
    Creates and runs a swarm to analyze patient health data and generate insights.
    
    Args:
        patient_data (str): Basic patient information
        medical_history (str): Patient's medical history
        lab_results (str): Recent laboratory results
        treatment_goals (str): Treatment objectives
        
    Returns:
        dict: Comprehensive health analysis and recommendations
    """
    # Prepare the detailed task description
    task = f"""
    Perform a comprehensive analysis of the following patient health data:
    
    PATIENT INFORMATION:
    {patient_data}
    
    MEDICAL HISTORY:
    {medical_history}
    
    LABORATORY RESULTS:
    {lab_results}
    
    TREATMENT GOALS:
    {treatment_goals}
    
    Analyze all aspects of the patient's health status, identify potential concerns,
    evaluate treatment effectiveness, and provide evidence-based recommendations for
    optimizing care. Consider medication interactions, lifestyle factors, and preventive measures.
    
    Return a detailed clinical report with key findings, risk stratification, 
    prioritized recommendations, and suggested follow-up timeline.
    """
    
    # Create the swarm specification with auto-generated agents
    # (letting the system create specialized medical experts)
    swarm_spec = {
        "name": "patient-health-analysis",
        "description": "Comprehensive patient health data analysis",
        "swarm_type": "AutoSwarmBuilder",
        "task": task,
        "max_loops": 3,
        "return_history": True
    }
    
    # Execute the swarm
    try:
        response = requests.post(
            f"{API_BASE_URL}/v1/swarm/completions",
            headers=HEADERS,
            json=swarm_spec
        )
        
        response.raise_for_status()
        result = response.json()
        
        # Log the execution metadata
        execution_time = result["metadata"]["execution_time_seconds"]
        cost = result["metadata"]["billing_info"]["total_cost"]
        num_agents = result["metadata"]["num_agents"]
        
        print(f"Analysis completed in {execution_time:.2f} seconds")
        print(f"Used {num_agents} specialized medical agents")
        print(f"Total cost: ${cost:.4f}")
        
        # Return just the analysis results
        return result["output"]
        
    except requests.exceptions.RequestException as e:
        print(f"API request failed: {str(e)}")
        if hasattr(e, 'response') and e.response:
            print(f"Response: {e.response.text}")
        return None
    except Exception as e:
        print(f"Error: {str(e)}")
        return None

# Usage example
if __name__ == "__main__":
    # Sample patient data (would typically come from EHR system)
    patient_data = """
    ID: PT-28456
    Age: 67
    Gender: Female
    Height: 162 cm
    Weight: 78 kg
    Vitals:
    - Blood Pressure: 142/88 mmHg
    - Heart Rate: 76 bpm
    - Respiratory Rate: 16/min
    - Temperature: 37.1°C
    - Oxygen Saturation: 97%
    """
    
    medical_history = """
    Diagnoses:
    - Type 2 Diabetes Mellitus (diagnosed 12 years ago)
    - Hypertension (diagnosed 8 years ago)
    - Osteoarthritis (knees, diagnosed 5 years ago)
    - Hyperlipidemia
    
    Surgical History:
    - Cholecystectomy (15 years ago)
    - Right knee arthroscopy (3 years ago)
    
    Medications:
    - Metformin 1000mg BID
    - Lisinopril 20mg daily
    - Atorvastatin 40mg daily
    - Aspirin 81mg daily
    - Acetaminophen 500mg PRN for joint pain
    
    Allergies:
    - Penicillin (rash)
    - Sulfa drugs (hives)
    
    Family History:
    - Father: MI at age 70, died at 76
    - Mother: Breast cancer at 68, Type 2 Diabetes, died at 82
    - Sister: Type 2 Diabetes, Hypertension
    """
    
    lab_results = """
    CBC (2 days ago):
    - WBC: 7.2 x10^9/L (normal)
    - RBC: 4.1 x10^12/L (low-normal)
    - Hemoglobin: 12.8 g/dL (low-normal)
    - Hematocrit: 38% (low-normal)
    - Platelets: 245 x10^9/L (normal)
    
    Comprehensive Metabolic Panel:
    - Glucose (fasting): 142 mg/dL (elevated)
    - HbA1c: 7.8% (elevated)
    - BUN: 22 mg/dL (normal)
    - Creatinine: 1.1 mg/dL (normal)
    - eGFR: 62 mL/min/1.73m² (mildly reduced)
    - Sodium: 138 mEq/L (normal)
    - Potassium: 4.2 mEq/L (normal)
    - Chloride: 101 mEq/L (normal)
    - Calcium: 9.4 mg/dL (normal)
    - ALT: 32 U/L (normal)
    - AST: 28 U/L (normal)
    
    Lipid Panel:
    - Total Cholesterol: 198 mg/dL
    - Triglycerides: 172 mg/dL (elevated)
    - HDL: 42 mg/dL (low)
    - LDL: 122 mg/dL (borderline elevated)
    
    Urinalysis:
    - Microalbumin/Creatinine ratio: 45 mg/g (elevated)
    """
    
    treatment_goals = """
    Primary Goals:
    - Improve glycemic control (target HbA1c < 7.0%)
    - Blood pressure control (target < 130/80 mmHg)
    - Lipid management (target LDL < 100 mg/dL)
    - Renal protection (reduce microalbuminuria)
    - Weight management (target BMI < 27)
    - Pain management for osteoarthritis
    - Maintain functional independence
    
    Patient Preferences:
    - Prefers to minimize medication changes if possible
    - Interested in dietary approaches
    - Concerned about memory changes
    - Limited exercise tolerance due to knee pain
    """
    
    result = analyze_patient_health_data(patient_data, medical_history, lab_results, treatment_goals)
    
    if result:
        # Write the analysis to a report file
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        with open(f"patient_analysis_{timestamp}.json", "w") as f:
            json.dump(result, f, indent=2)
        
        print(f"Analysis saved to patient_analysis_{timestamp}.json")
        
        # Display key findings
        if "key_findings" in result:
            print("\nKEY FINDINGS:")
            for i, finding in enumerate(result["key_findings"]):
                print(f"  {i+1}. {finding}")
                
        # Display recommendations
        if "recommendations" in result:
            print("\nRECOMMENDATIONS:")
            for i, rec in enumerate(result["recommendations"]):
                print(f"  {i+1}. {rec}")
```

## Error Handling

The Swarms API follows standard HTTP status codes for error responses:

| Status Code | Meaning | Handling Strategy |
|-------------|---------|-------------------|
| 400 | Bad Request | Validate request parameters before sending |
| 401 | Unauthorized | Check API key validity |
| 403 | Forbidden | Verify API key permissions |
| 404 | Not Found | Check endpoint URL and resource IDs |
| 429 | Too Many Requests | Implement exponential backoff retry logic |
| 500 | Internal Server Error | Retry with backoff, then contact support |

Error responses include a detailed message explaining the issue:

```json
{
  "detail": "Failed to create swarm: Invalid swarm_type specified"
}
```

## Rate Limiting

The API enforces a rate limit of 100 requests per 60-second window. When exceeded, a 429 status code is returned. Implement appropriate retry logic with exponential backoff in production applications.

## Billing & Cost Management

The API uses a credit-based billing system with costs calculated based on:

1. **Agent Count**: Base cost per agent


2. **Input Tokens**: Cost based on the size of input data and prompts

3. **Output Tokens**: Cost based on the length of generated responses

4. **Time of Day**: Reduced rates during nighttime hours (8 PM to 6 AM PT)

Cost information is included in each response's metadata for transparency and forecasting.

## Best Practices

1. **Task Description**

   - Provide detailed, specific task descriptions

   - Include all necessary context and constraints
   
   - Structure complex inputs for easier processing

2. **Agent Configuration**
   
   - For simple tasks, use `AutoSwarmBuilder` to automatically generate optimal agents
   
   - For complex or specialized tasks, manually define agents with specific expertise
   
   - Use appropriate `swarm_type` for your workflow pattern

3. **Production Implementation**

  - Implement robust error handling and retries
  
  - Log API responses for debugging and auditing
  
  - Monitor costs closely during development and testing
  
  - Use scheduled jobs for recurring tasks instead of continuous polling

4. **Cost Optimization**

  - Batch related tasks when possible

  - Schedule non-urgent tasks during discount hours

  - Carefully scope task descriptions to reduce token usage

  - Cache results when appropriate


## Support

For technical assistance with the Swarms API, please contact:

- Documentation: [https://docs.swarms.world](https://docs.swarms.world)
- Email: kye@swarms.world
- Community Discord: [https://discord.gg/swarms](https://discord.gg/swarms)
- Swarms Marketplace: [https://swarms.world](https://swarms.world)
- Swarms AI Website: [https://swarms.ai](https://swarms.ai)


--------------------------------------------------

# File: swarms_cloud/swarms_api_tools.md

# Swarms API with Tools Guide


Swarms API allows you to create and manage AI agent swarms with optional tool integration. This guide will walk you through setting up and using the Swarms API with tools.

## Prerequisites

- Python 3.7+
- Swarms API key
- Required Python packages:
  - `requests`

  - `python-dotenv`

## Installation & Setup

1. Install required packages:

```bash
pip install requests python-dotenv
```

2. Create a `.env` file in your project root:

```bash
SWARMS_API_KEY=your_api_key_here
```

3. Basic setup code:

```python
import os
import requests
from dotenv import load_dotenv
import json

load_dotenv()

API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

headers = {"x-api-key": API_KEY, "Content-Type": "application/json"}
```

## Creating a Swarm with Tools

### Step-by-Step Guide

1. Define your tool dictionary:
```python
tool_dictionary = {
    "type": "function",
    "function": {
        "name": "search_topic",
        "description": "Conduct an in-depth search on a specified topic",
        "parameters": {
            "type": "object",
            "properties": {
                "depth": {
                    "type": "integer",
                    "description": "Search depth (1-3)"
                },
                "detailed_queries": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Specific search queries"
                    }
                }
            },
            "required": ["depth", "detailed_queries"]
        }
    }
}
```

2. Create agent configurations:
```python
agent_config = {
    "agent_name": "Market Analyst",
    "description": "Analyzes market trends",
    "system_prompt": "You are a financial analyst expert.",
    "model_name": "openai/gpt-4",
    "role": "worker",
    "max_loops": 1,
    "max_tokens": 8192,
    "temperature": 0.5,
    "auto_generate_prompt": False,
    "tools_dictionary": [tool_dictionary]  # Optional: Add tools if needed
}
```

3. Create the swarm payload:
```python
payload = {
    "name": "Your Swarm Name",
    "description": "Swarm description",
    "agents": [agent_config],
    "max_loops": 1,
    "swarm_type": "ConcurrentWorkflow",
    "task": "Your task description",
    "output_type": "dict"
}
```

4. Make the API request:
```python
def run_swarm(payload):
    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload
    )
    return response.json()
```

## FAQ

### Do all agents need tools?
No, tools are optional for each agent. You can choose which agents have tools based on your specific needs. Simply omit the `tools_dictionary` field for agents that don't require tools.

### What types of tools can I use?
Currently, the API supports function-type tools. Each tool must have:
- A unique name

- A clear description

- Well-defined parameters with types and descriptions

### Can I mix agents with and without tools?
Yes, you can create swarms with a mix of tool-enabled and regular agents. This allows for flexible swarm architectures.

### What's the recommended number of tools per agent?
While there's no strict limit, it's recommended to:

- Keep tools focused and specific

- Only include tools that the agent needs

- Consider the complexity of tool interactions

## Example Implementation

Here's a complete example of a financial analysis swarm:

```python
def run_financial_analysis_swarm():
    payload = {
        "name": "Financial Analysis Swarm",
        "description": "Market analysis swarm",
        "agents": [
            {
                "agent_name": "Market Analyst",
                "description": "Analyzes market trends",
                "system_prompt": "You are a financial analyst expert.",
                "model_name": "openai/gpt-4",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 8192,
                "temperature": 0.5,
                "auto_generate_prompt": False,
                "tools_dictionary": [
                    {
                        "type": "function",
                        "function": {
                            "name": "search_topic",
                            "description": "Conduct market research",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "depth": {
                                        "type": "integer",
                                        "description": "Search depth (1-3)"
                                    },
                                    "detailed_queries": {
                                        "type": "array",
                                        "items": {"type": "string"}
                                    }
                                },
                                "required": ["depth", "detailed_queries"]
                            }
                        }
                    }
                ]
            }
        ],
        "max_loops": 1,
        "swarm_type": "ConcurrentWorkflow",
        "task": "Analyze top performing tech ETFs",
        "output_type": "dict"
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload
    )
    return response.json()
```

## Health Check

Always verify the API status before running swarms:

```python
def check_api_health():
    response = requests.get(f"{BASE_URL}/health", headers=headers)
    return response.json()
```

## Best Practices

1. **Error Handling**: Always implement proper error handling:
```python
def safe_run_swarm(payload):
    try:
        response = requests.post(
            f"{BASE_URL}/v1/swarm/completions",
            headers=headers,
            json=payload
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error running swarm: {e}")
        return None
```

2. **Environment Variables**: Never hardcode API keys

3. **Tool Design**: Keep tools simple and focused

4. **Testing**: Validate swarm configurations before production use

## Troubleshooting

Common issues and solutions:

1. **API Key Issues**
   - Verify key is correctly set in `.env`

   - Check key permissions

2. **Tool Execution Errors**
   - Validate tool parameters

   - Check tool function signatures

3. **Response Timeout**
   - Consider reducing max_tokens

   - Simplify tool complexity



```python
import os
import requests
from dotenv import load_dotenv
import json

load_dotenv()

API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

headers = {"x-api-key": API_KEY, "Content-Type": "application/json"}


def run_health_check():
    response = requests.get(f"{BASE_URL}/health", headers=headers)
    return response.json()


def run_single_swarm():
    payload = {
        "name": "Financial Analysis Swarm",
        "description": "Market analysis swarm",
        "agents": [
            {
                "agent_name": "Market Analyst",
                "description": "Analyzes market trends",
                "system_prompt": "You are a financial analyst expert.",
                "model_name": "openai/gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 8192,
                "temperature": 0.5,
                "auto_generate_prompt": False,
                "tools_dictionary": [
                    {
                        "type": "function",
                        "function": {
                            "name": "search_topic",
                            "description": "Conduct an in-depth search on a specified topic or subtopic, generating a comprehensive array of highly detailed search queries tailored to the input parameters.",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "depth": {
                                        "type": "integer",
                                        "description": "Indicates the level of thoroughness for the search. Values range from 1 to 3, where 1 represents a superficial search and 3 signifies an exploration of the topic.",
                                    },
                                    "detailed_queries": {
                                        "type": "array",
                                        "description": "An array of highly specific search queries that are generated based on the input query and the specified depth. Each query should be designed to elicit detailed and relevant information from various sources.",
                                        "items": {
                                            "type": "string",
                                            "description": "Each item in this array should represent a unique search query that targets a specific aspect of the main topic, ensuring a comprehensive exploration of the subject matter.",
                                        },
                                    },
                                },
                                "required": ["depth", "detailed_queries"],
                            },
                        },
                    },
                ],
            },
            {
                "agent_name": "Economic Forecaster",
                "description": "Predicts economic trends",
                "system_prompt": "You are an expert in economic forecasting.",
                "model_name": "gpt-4o",
                "role": "worker",
                "max_loops": 1,
                "max_tokens": 8192,
                "temperature": 0.5,
                "auto_generate_prompt": False,
                "tools_dictionary": [
                    {
                        "type": "function",
                        "function": {
                            "name": "search_topic",
                            "description": "Conduct an in-depth search on a specified topic or subtopic, generating a comprehensive array of highly detailed search queries tailored to the input parameters.",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "depth": {
                                        "type": "integer",
                                        "description": "Indicates the level of thoroughness for the search. Values range from 1 to 3, where 1 represents a superficial search and 3 signifies an exploration of the topic.",
                                    },
                                    "detailed_queries": {
                                        "type": "array",
                                        "description": "An array of highly specific search queries that are generated based on the input query and the specified depth. Each query should be designed to elicit detailed and relevant information from various sources.",
                                        "items": {
                                            "type": "string",
                                            "description": "Each item in this array should represent a unique search query that targets a specific aspect of the main topic, ensuring a comprehensive exploration of the subject matter.",
                                        },
                                    },
                                },
                                "required": ["depth", "detailed_queries"],
                            },
                        },
                    },
                ],
            },
        ],
        "max_loops": 1,
        "swarm_type": "ConcurrentWorkflow",
        "task": "What are the best etfs and index funds for ai and tech?",
        "output_type": "dict",
    }

    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload,
    )

    print(response)
    print(response.status_code)
    # return response.json()
    output = response.json()

    return json.dumps(output, indent=4)


if __name__ == "__main__":
    result = run_single_swarm()
    print("Swarm Result:")
    print(result)

```

--------------------------------------------------

# File: swarms_cloud/vision.md

# The Swarms Cloud and Agent Marketplace

We stand at the dawn of a new era—the **Agentic Economy**, where the power of intelligent automation is in the hands of everyone. The Swarms Cloud and Agent Marketplace will serve as the epicenter of this economy, enabling developers, businesses, and creators to easily publish, discover, and leverage intelligent agents. Our vision is to make publishing agents as simple as possible through an intuitive CLI, while empowering users to generate income by posting their APIs on the marketplace.

The Swarms Marketplace is more than just a platform—it’s a **revolutionary ecosystem** that will change how we think about automation and intelligence. By building this platform, we aim to democratize access to agent-driven solutions, enabling a seamless bridge between creators and consumers of automation. With every agent posted to the marketplace, a ripple effect is created, driving innovation across industries and providing an unparalleled opportunity for monetization.

---

### The Agent Marketplace

#### A Unified Platform for Automation

In the Swarms Marketplace, **agents will be the new currency of efficiency**. Whether you’re building agents for marketing, finance, customer service, or any other domain, the Swarms Cloud will allow you to showcase your agentic APIs, easily discoverable by anyone needing those capabilities.

We envision the marketplace to function like an API store, where users can search for specific agent capabilities, purchase access to agents, or even integrate their existing systems with agent-based APIs that others have developed. Each agent you publish will come with a potential income stream as businesses and developers integrate your creations into their workflows.

#### The Opportunity to Monetize Your APIs

The Swarms Marketplace is designed to let developers and businesses generate income by sharing their agent APIs. Once your agent is published to the marketplace, other users can browse, test, and integrate it into their operations. You will be able to set custom pricing, usage tiers, and licensing terms for your API, ensuring you can profit from your innovations.

Our vision for monetization includes:

- **API subscriptions**: Allow users to subscribe to your agent API with recurring payments.

- **Per-use pricing**: Offer users a pay-as-you-go model where they only pay for the API calls they use.

- **Licensing**: Enable others to purchase full access to your agent for a set period or on a project basis.

### Publishing Agents: Simplicity Through CLI

The complexity of deploying agents to a marketplace should never be a barrier. Our goal is to **streamline the publishing process** into something as simple as a command-line interaction. The Swarms CLI will be your one-stop solution to get your agent up and running on the marketplace.

#### CLI Workflow:

1. **Create an Agent**: Build your agent using the Swarms framework or any custom framework of your choice.
2. **Set Agent Metadata**: Through the CLI, input the metadata about your agent, including its capabilities, pricing, and target industries.
3. **Publish to Marketplace**: Run the simple `swarms publish` command to instantly deploy your agent to the marketplace.
4. **Monitor Usage and Income**: Use the Swarms Cloud dashboard to view your agent's interactions, track API usage, and receive payouts.

Here’s an example of how easy publishing will be:

```bash
$ swarms create-agent --name "CustomerSupportAgent" --type "LLM" 
$ swarms set-metadata --description "An intelligent agent for customer support operations" --pricing "subscription" --rate "$20/month"
$ swarms publish
```

Within minutes, your agent will be live and accessible to the global marketplace!

---

### Empowering Businesses

For businesses, the marketplace offers **an unprecedented opportunity to automate tasks**, integrate pre-built agents, and drastically cut operational costs. Companies no longer need to build every system from scratch. With the marketplace, they can simply discover and plug in the agentic solutions that best suit their needs.


```mermaid
graph TD
    A[Build Agent] --> B[Set Metadata]
    B --> C[Publish to Marketplace]
    C --> D{Agent Available Globally}
    D --> E[Developers Discover API]
    D --> F[Businesses Integrate API]
    F --> G[Revenue Stream for Agent Creator]
    E --> G
```

---

### The Future of Automation: Agents as APIs

In this future we’re creating, **agents will be as ubiquitous as APIs**. The Swarms Marketplace will be an expansive repository of intelligent agents, each contributing to the automation and streamlining of everyday tasks. Imagine a world where every business can access highly specific, pre-built intelligence for any task, from customer support to supply chain management, and integrate these agents into their processes in minutes.


```mermaid
graph LR
    A[Search for Agent API] --> B[Find Agent That Fits]
    B --> C[Purchase Access]
    C --> D[Integrate with Business System]
    D --> E[Business Operations Streamlined]
```

---

### Conclusion

The Swarms Cloud and Agent Marketplace will usher in an **agent-powered future**, where **automation is accessible to all**, and **monetization opportunities** are boundless. Our vision is to create a space where developers can not only build and showcase their agents but can also create sustainable income streams from their creations. The CLI will remove the friction of deployment, and the marketplace will enable a **self-sustaining ecosystem** of agentic intelligence that powers the next generation of automation. 

Together, we will shape the **Agentic Economy**, where **collaboration, innovation, and financial opportunity** intersect. Welcome to the future of intelligent automation. Welcome to **Swarms Cloud**.

--------------------------------------------------

# File: swarms_memory/chromadb.md

# ChromaDB Documentation

ChromaDB is a specialized module designed to facilitate the storage and retrieval of documents using the ChromaDB system. It offers functionalities for adding documents to a local ChromaDB collection and querying this collection based on provided query texts. This module integrates with the ChromaDB client to create and manage collections, leveraging various configurations for optimizing the storage and retrieval processes.


#### Parameters

| Parameter      | Type              | Default  | Description                                                 |
|----------------|-------------------|----------|-------------------------------------------------------------|
| `metric`       | `str`             | `"cosine"`| The similarity metric to use for the collection.             |
| `output_dir`   | `str`             | `"swarms"`| The name of the collection to store the results in.         |
| `limit_tokens` | `Optional[int]`   | `1000`   | The maximum number of tokens to use for the query.          |
| `n_results`    | `int`             | `1`      | The number of results to retrieve.                          |
| `docs_folder`  | `Optional[str]`   | `None`   | The folder containing documents to be added to the collection.|
| `verbose`      | `bool`            | `False`  | Flag to enable verbose logging for debugging.               |
| `*args`        | `tuple`           | `()`     | Additional positional arguments.                            |
| `**kwargs`     | `dict`            | `{}`     | Additional keyword arguments.                               |

#### Methods

| Method                | Description                                              |
|-----------------------|----------------------------------------------------------|
| `__init__`            | Initializes the ChromaDB instance with specified parameters. |
| `add`                 | Adds a document to the ChromaDB collection.              |
| `query`               | Queries documents from the ChromaDB collection based on the query text. |
| `traverse_directory`  | Traverses the specified directory to add documents to the collection. |


## Usage

```python
from swarms_memory import ChromaDB

chromadb = ChromaDB(
    metric="cosine",
    output_dir="results",
    limit_tokens=1000,
    n_results=2,
    docs_folder="path/to/docs",
    verbose=True,
)
```

### Adding Documents

The `add` method allows you to add a document to the ChromaDB collection. It generates a unique ID for each document and adds it to the collection.

#### Parameters

| Parameter     | Type   | Default | Description                                 |
|---------------|--------|---------|---------------------------------------------|
| `document`    | `str`  | -       | The document to be added to the collection. |
| `*args`       | `tuple`| `()`    | Additional positional arguments.            |
| `**kwargs`    | `dict` | `{}`    | Additional keyword arguments.               |

#### Returns

| Type  | Description                          |
|-------|--------------------------------------|
| `str` | The ID of the added document.        |

#### Example

```python
task = "example_task"
result = "example_result"
result_id = chromadb.add(document="This is a sample document.")
print(f"Document ID: {result_id}")
```

### Querying Documents

The `query` method allows you to retrieve documents from the ChromaDB collection based on the provided query text.

#### Parameters

| Parameter   | Type   | Default | Description                            |
|-------------|--------|---------|----------------------------------------|
| `query_text`| `str`  | -       | The query string to search for.        |
| `*args`     | `tuple`| `()`    | Additional positional arguments.       |
| `**kwargs`  | `dict` | `{}`    | Additional keyword arguments.          |

#### Returns

| Type  | Description                          |
|-------|--------------------------------------|
| `str` | The retrieved documents as a string. |

#### Example

```python
query_text = "search term"
results = chromadb.query(query_text=query_text)
print(f"Retrieved Documents: {results}")
```

### Traversing Directory

The `traverse_directory` method traverses through every file in the specified directory and its subdirectories, adding the contents of each file to the ChromaDB collection.

#### Example

```python
chromadb.traverse_directory()
```

## Additional Information and Tips

### Verbose Logging

Enable the `verbose` flag during initialization to get detailed logs of the operations, which is useful for debugging.

```python
chromadb = ChromaDB(verbose=True)
```

### Handling Large Documents

When dealing with large documents, consider using the `limit_tokens` parameter to restrict the number of tokens processed in a single query.

```python
chromadb = ChromaDB(limit_tokens=500)
```

### Optimizing Query Performance

Use the appropriate similarity metric (`metric` parameter) that suits your use case for optimal query performance.

```python
chromadb = ChromaDB(metric="euclidean")
```

## References and Resources

- [ChromaDB Documentation](https://chromadb.io/docs)
- [Python UUID Module](https://docs.python.org/3/library/uuid.html)
- [Python os Module](https://docs.python.org/3/library/os.html)
- [Python logging Module](https://docs.python.org/3/library/logging.html)
- [dotenv Package](https://pypi.org/project/python-dotenv/)

By following this documentation, users can effectively utilize the ChromaDB module for managing document storage and retrieval in their applications.

--------------------------------------------------

# File: swarms_memory/faiss.md

# FAISSDB: Documentation

The `FAISSDB` class is a highly customizable wrapper for the FAISS (Facebook AI Similarity Search) library, designed for efficient similarity search and clustering of dense vectors. This class facilitates the creation of a Retrieval-Augmented Generation (RAG) system by providing methods to add documents to a FAISS index and query the index for similar documents. It supports custom embedding models, preprocessing functions, and other customizations to fit various use cases.


### Parameters

| Parameter              | Type                                             | Default                       | Description                                                                 |
|------------------------|--------------------------------------------------|-------------------------------|-----------------------------------------------------------------------------|
| `dimension`            | `int`                                            | `768`                         | Dimension of the document embeddings.                                       |
| `index_type`           | `str`                                            | `'Flat'`                      | Type of FAISS index to use (`'Flat'` or `'IVF'`).                           |
| `embedding_model`      | `Optional[Any]`                                  | `None`                        | Custom embedding model.                                                     |
| `embedding_function`   | `Optional[Callable[[str], List[float]]]`         | `None`                        | Custom function to generate embeddings from text.                           |
| `preprocess_function`  | `Optional[Callable[[str], str]]`                 | `None`                        | Custom function to preprocess text before embedding.                        |
| `postprocess_function` | `Optional[Callable[[List[Dict[str, Any]]], List[Dict[str, Any]]]]` | `None` | Custom function to postprocess the results.                                  |
| `metric`               | `str`                                            | `'cosine'`                    | Distance metric for FAISS index (`'cosine'` or `'l2'`).                     |
| `logger_config`        | `Optional[Dict[str, Any]]`                       | `None`                        | Configuration for the logger.                                               |

## Methods

### `__init__`

Initializes the FAISSDB instance, setting up the logger, creating the FAISS index, and configuring custom functions if provided.

### `add`

Adds a document to the FAISS index.

#### Parameters

| Parameter | Type                    | Default | Description                                     |
|-----------|-------------------------|---------|-------------------------------------------------|
| `doc`     | `str`                   | None    | The document to be added.                       |
| `metadata`| `Optional[Dict[str, Any]]` | None    | Additional metadata for the document.            |

#### Example Usage

```python
db = FAISSDB(dimension=768)
db.add("This is a sample document.", {"category": "sample"})
```

### `query`

Queries the FAISS index for similar documents.

#### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `query`   | `str` | None    | The query string. |
| `top_k`   | `int` | `5`     | The number of top results to return. |

#### Returns

| Type | Description |
|------|-------------|
| `List[Dict[str, Any]]` | A list of dictionaries containing the top_k most similar documents. |

#### Example Usage

```python
results = db.query("What is artificial intelligence?")
for result in results:
    print(f"Score: {result['score']}, Text: {result['metadata']['text']}")
```

## Internal Methods

### `_setup_logger`

Sets up the logger with the given configuration.

#### Parameters

| Parameter | Type                    | Default | Description                              |
|-----------|-------------------------|---------|------------------------------------------|
| `config`  | `Optional[Dict[str, Any]]` | None    | Configuration for the logger.             |

### `_create_index`

Creates and returns a FAISS index based on the specified type and metric.

#### Parameters

| Parameter | Type  | Default | Description                                  |
|-----------|-------|---------|----------------------------------------------|
| `index_type` | `str`  | 'Flat'   | Type of FAISS index to use.                  |
| `metric`    | `str`  | 'cosine' | Distance metric for FAISS index.             |

#### Returns

| Type | Description      |
|------|------------------|
| `faiss.Index` | FAISS index instance. |

### `_default_embedding_function`

Default embedding function using the SentenceTransformer model.

#### Parameters

| Parameter | Type | Default | Description          |
|-----------|------|---------|----------------------|
| `text`    | `str` | None    | The input text to embed. |

#### Returns

| Type | Description       |
|------|-------------------|
| `List[float]` | Embedding vector for the input text. |

### `_default_preprocess_function`

Default preprocessing function.

#### Parameters

| Parameter | Type | Default | Description        |
|-----------|------|---------|--------------------|
| `text`    | `str` | None    | The input text to preprocess. |

#### Returns

| Type | Description      |
|------|------------------|
| `str` | Preprocessed text. |

### `_default_postprocess_function`

Default postprocessing function.

#### Parameters

| Parameter | Type | Default | Description                    |
|-----------|------|---------|--------------------------------|
| `results` | `List[Dict[str, Any]]` | None    | The results to postprocess.   |

#### Returns

| Type | Description              |
|------|--------------------------|
| `List[Dict[str, Any]]` | Postprocessed results. |

## Usage Examples

### Example 1: Basic Usage

```python
# Initialize the FAISSDB instance
db = FAISSDB(dimension=768, index_type="Flat")

# Add documents to the FAISS index
db.add("This is a document about AI.", {"category": "AI"})
db.add("Python is great for data science.", {"category": "Programming"})

# Query the FAISS index
results = db.query("Tell me about AI")
for result in results:
    print(f"Score: {result['score']}, Text: {result['metadata']['text']}")
```

### Example 2: Custom Functions

```python
from transformers import AutoTokenizer, AutoModel
import torch

# Custom embedding function using a HuggingFace model
def custom_embedding_function(text: str) -> List[float]:
    tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
    model = AutoModel.from_pretrained("bert-base-uncased")
    inputs = tokenizer(text, return_tensors="pt", padding=True, truncation=True, max_length=512)
    with torch.no_grad():
        outputs = model(**inputs)
    embeddings = outputs.last_hidden_state.mean(dim=1).squeeze().tolist()
    return embeddings

# Custom preprocessing function
def custom_preprocess(text: str) -> str:
    return text.lower().strip()

# Custom postprocessing function
def custom_postprocess(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    for result in results:
        result["custom_score"] = result["score"] * 2  # Example modification
    return results

# Initialize the FAISSDB instance with custom functions
db = FAISSDB(
    dimension=768,
    index_type="Flat",
    embedding_function=custom_embedding_function,
    preprocess_function=custom_preprocess,
    postprocess_function=custom_postprocess,
    metric="cosine",
    logger_config={
        "handlers": [
            {"sink": "custom_faiss_rag_wrapper.log", "rotation": "1 GB"},
            {"sink": lambda msg: print(f"Custom log: {msg}", end="")}
        ],
    },
)

# Add documents to the FAISS index
db.add("This is a document about machine learning.", {"category": "ML"})
db.add("Python is a versatile programming language.", {"category": "Programming"})

# Query the FAISS index
results = db.query("Explain machine learning")
for result in results:
    print(f"Score: {result['score']}, Custom Score: {result['custom_score']}, Text: {result['metadata']['text']}")
```

## Additional Information and Tips

- Ensure that the dimension of the document embeddings matches the dimension specified during the initialization of the FAISSDB instance.
- Use custom embedding functions to leverage domain-specific models for generating embeddings.
- Custom preprocessing and postprocessing functions can help tailor the text processing and

 result formatting to specific needs.
- FAISS supports various types of indices; choose the one that best fits the application requirements (e.g., `Flat` for brute-force search, `IVF` for faster search with some accuracy trade-off).
- Properly configure the logger to monitor and debug the operations of the FAISSDB instance.

## References and Resources

- [FAISS GitHub Repository](https://github.com/facebookresearch/faiss)
- [Sentence Transformers Documentation](https://www.sbert.net/)
- [Loguru Documentation](https://loguru.readthedocs.io/en/stable/)
- [HuggingFace Transformers](https://huggingface.co/transformers/)

By following this documentation, users can effectively utilize the `FAISSDB` class for various similarity search and document retrieval tasks, customizing it to their specific needs through the provided hooks and functions.

--------------------------------------------------

# File: swarms_memory/index.md

# Announcing the Release of Swarms-Memory Package: Your Gateway to Efficient RAG Systems


We are thrilled to announce the release of the Swarms-Memory package, a powerful and easy-to-use toolkit designed to facilitate the implementation of Retrieval-Augmented Generation (RAG) systems. Whether you're a seasoned AI practitioner or just starting out, Swarms-Memory provides the tools you need to integrate high-performance, reliable RAG systems into your applications seamlessly.

In this blog post, we'll walk you through getting started with the Swarms-Memory package, covering installation, usage examples, and a detailed overview of supported RAG systems like Pinecone and ChromaDB. Let's dive in!

## What is Swarms-Memory?

Swarms-Memory is a Python package that simplifies the integration of advanced RAG systems into your projects. It supports multiple databases optimized for AI tasks, providing you with the flexibility to choose the best system for your needs. With Swarms-Memory, you can effortlessly handle large-scale AI tasks, vector searches, and more.

### Key Features

- **Easy Integration**: Quickly set up and start using powerful RAG systems.
- **Customizable**: Define custom embedding, preprocessing, and postprocessing functions.
- **Flexible**: Supports multiple RAG systems like ChromaDB and Pinecone, with more coming soon.
- **Scalable**: Designed to handle large-scale AI tasks efficiently.

## Supported RAG Systems

Here's an overview of the RAG systems currently supported by Swarms-Memory:

| RAG System | Status       | Description                                                                              | Documentation             | Website         |
|------------|--------------|------------------------------------------------------------------------------------------|---------------------------|-----------------|
| ChromaDB   | Available    | A high-performance, distributed database optimized for handling large-scale AI tasks.    | [ChromaDB Documentation](https://chromadb.com/docs) | [ChromaDB](https://chromadb.com) |
| Pinecone   | Available    | A fully managed vector database for adding vector search to your applications.           | [Pinecone Documentation](https://pinecone.io/docs) | [Pinecone](https://pinecone.io) |
| Redis      | Coming Soon  | An open-source, in-memory data structure store, used as a database, cache, and broker.   | [Redis Documentation](https://redis.io/documentation) | [Redis](https://redis.io) |
| Faiss      | Coming Soon  | A library for efficient similarity search and clustering of dense vectors by Facebook AI. | [Faiss Documentation](https://faiss.ai) | [Faiss](https://faiss.ai) |
| HNSW       | Coming Soon  | A graph-based algorithm for approximate nearest neighbor search, known for speed.        | [HNSW Documentation](https://hnswlib.github.io/hnswlib) | [HNSW](https://hnswlib.github.io/hnswlib) |

## Getting Started

### Requirements

Before you begin, ensure you have the following:

- Python 3.10
- `.env` file with your respective API keys (e.g., `PINECONE_API_KEY`)

### Installation

You can install the Swarms-Memory package using pip:

```bash
$ pip install swarms-memory
```

### Usage Examples

#### Pinecone

Here's a step-by-step guide on how to use Pinecone with Swarms-Memory:

1. **Import Required Libraries**:

```python
from typing import List, Dict, Any
from swarms_memory import PineconeMemory
```

2. **Define Custom Functions**:

```python
from transformers import AutoTokenizer, AutoModel
import torch

# Custom embedding function using a HuggingFace model
def custom_embedding_function(text: str) -> List[float]:
    tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
    model = AutoModel.from_pretrained("bert-base-uncased")
    inputs = tokenizer(text, return_tensors="pt", padding=True, truncation=True, max_length=512)
    with torch.no_grad():
        outputs = model(**inputs)
    embeddings = outputs.last_hidden_state.mean(dim=1).squeeze().tolist()
    return embeddings

# Custom preprocessing function
def custom_preprocess(text: str) -> str:
    return text.lower().strip()

# Custom postprocessing function
def custom_postprocess(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    for result in results:
        result["custom_score"] = result["score"] * 2  # Example modification
    return results
```

3. **Initialize the Wrapper with Custom Functions**:

```python
wrapper = PineconeMemory(
    api_key="your-api-key",
    environment="your-environment",
    index_name="your-index-name",
    embedding_function=custom_embedding_function,
    preprocess_function=custom_preprocess,
    postprocess_function=custom_postprocess,
    logger_config={
        "handlers": [
            {"sink": "custom_rag_wrapper.log", "rotation": "1 GB"},
            {"sink": lambda msg: print(f"Custom log: {msg}", end="")},
        ],
    },
)
```

4. **Add Documents and Query**:

```python
# Adding documents
wrapper.add("This is a sample document about artificial intelligence.", {"category": "AI"})
wrapper.add("Python is a popular programming language for data science.", {"category": "Programming"})

# Querying
results = wrapper.query("What is AI?", filter={"category": "AI"})
for result in results:
    print(f"Score: {result['score']}, Custom Score: {result['custom_score']}, Text: {result['metadata']['text']}")
```

#### ChromaDB

Using ChromaDB with Swarms-Memory is straightforward. Here’s how:

1. **Import ChromaDB**:

```python
from swarms_memory import ChromaDB
```

2. **Initialize ChromaDB**:

```python
chromadb = ChromaDB(
    metric="cosine",
    output_dir="results",
    limit_tokens=1000,
    n_results=2,
    docs_folder="path/to/docs",
    verbose=True,
)
```

3. **Add and Query Documents**:

```python
# Add a document
doc_id = chromadb.add("This is a test document.")

# Query the document
result = chromadb.query("This is a test query.")

# Traverse a directory
chromadb.traverse_directory()

# Display the result
print(result)
```

## Join the Community

We're excited to see how you leverage Swarms-Memory in your projects! Join our community on Discord to share your experiences, ask questions, and stay updated on the latest developments.

- **🐦 Twitter**: [Follow us on Twitter](https://twitter.com/swarms_platform)
- **📢 Discord**: [Join the Agora Discord](https://discord.gg/jM3Z6M9uMq)
- **Swarms Platform**: [Visit our website](https://swarms.ai)
- **📙 Documentation**: [Read the Docs](https://docs.swarms.ai)

## Conclusion

The Swarms-Memory package brings a new level of ease and efficiency to building and managing RAG systems. With support for leading databases like ChromaDB and Pinecone, it's never been easier to integrate powerful, scalable AI solutions into your projects. We can't wait to see what you'll create with Swarms-Memory!

For more detailed usage examples and documentation, visit our [GitHub repository](https://github.com/swarms-ai/swarms-memory) and start exploring today!


--------------------------------------------------

# File: swarms_memory/pinecone.md

# PineconeMemory Documentation

The `PineconeMemory` class provides a robust interface for integrating Pinecone-based Retrieval-Augmented Generation (RAG) systems. It allows for adding documents to a Pinecone index and querying the index for similar documents. The class supports custom embedding models, preprocessing functions, and other customizations to suit different use cases.



#### Parameters

| Parameter            | Type                                          | Default                           | Description                                                                                          |
|----------------------|-----------------------------------------------|-----------------------------------|------------------------------------------------------------------------------------------------------|
| `api_key`            | `str`                                         | -                                 | Pinecone API key.                                                                                    |
| `environment`        | `str`                                         | -                                 | Pinecone environment.                                                                                |
| `index_name`         | `str`                                         | -                                 | Name of the Pinecone index to use.                                                                   |
| `dimension`          | `int`                                         | `768`                             | Dimension of the document embeddings.                                                                |
| `embedding_model`    | `Optional[Any]`                               | `None`                            | Custom embedding model. Defaults to `SentenceTransformer('all-MiniLM-L6-v2')`.                       |
| `embedding_function` | `Optional[Callable[[str], List[float]]]`      | `None`                            | Custom embedding function. Defaults to `_default_embedding_function`.                                |
| `preprocess_function`| `Optional[Callable[[str], str]]`              | `None`                            | Custom preprocessing function. Defaults to `_default_preprocess_function`.                           |
| `postprocess_function`| `Optional[Callable[[List[Dict[str, Any]]], List[Dict[str, Any]]]]`| `None`              | Custom postprocessing function. Defaults to `_default_postprocess_function`.                         |
| `metric`             | `str`                                         | `'cosine'`                        | Distance metric for Pinecone index.                                                                  |
| `pod_type`           | `str`                                         | `'p1'`                            | Pinecone pod type.                                                                                   |
| `namespace`          | `str`                                         | `''`                              | Pinecone namespace.                                                                                  |
| `logger_config`      | `Optional[Dict[str, Any]]`                    | `None`                            | Configuration for the logger. Defaults to logging to `rag_wrapper.log` and console output.           |

### Methods

#### `_setup_logger`

```python
def _setup_logger(self, config: Optional[Dict[str, Any]] = None)
```

Sets up the logger with the given configuration.

#### `_default_embedding_function`

```python
def _default_embedding_function(self, text: str) -> List[float]
```

Generates embeddings using the default SentenceTransformer model.

#### `_default_preprocess_function`

```python
def _default_preprocess_function(self, text: str) -> str
```

Preprocesses the input text by stripping whitespace.

#### `_default_postprocess_function`

```python
def _default_postprocess_function(self, results: List[Dict[str, Any]]) -> List[Dict[str, Any]]
```

Postprocesses the query results.

#### `add`

Adds a document to the Pinecone index.

| Parameter | Type                  | Default | Description                                   |
|-----------|-----------------------|---------|-----------------------------------------------|
| `doc`     | `str`                 | -       | The document to be added.                     |
| `metadata`| `Optional[Dict[str, Any]]` | `None`  | Additional metadata for the document.         |

#### `query`

Queries the Pinecone index for similar documents.

| Parameter | Type                    | Default | Description                                   |
|-----------|-------------------------|---------|-----------------------------------------------|
| `query`   | `str`                   | -       | The query string.                             |
| `top_k`   | `int`                   | `5`     | The number of top results to return.          |
| `filter`  | `Optional[Dict[str, Any]]` | `None`  | Metadata filter for the query.                |

## Usage


The `PineconeMemory` class is initialized with the necessary parameters to configure Pinecone and the embedding model. It supports a variety of custom configurations to suit different needs.

#### Example

```python
from swarms_memory import PineconeMemory

# Initialize PineconeMemory
memory = PineconeMemory(
    api_key="your-api-key",
    environment="us-west1-gcp",
    index_name="example-index",
    dimension=768
)
```

### Adding Documents

Documents can be added to the Pinecone index using the `add` method. The method accepts a document string and optional metadata.

#### Example

```python
doc = "This is a sample document to be added to the Pinecone index."
metadata = {"author": "John Doe", "date": "2024-07-08"}

memory.add(doc, metadata)
```

### Querying Documents

The `query` method allows for querying the Pinecone index for similar documents based on a query string. It returns the top `k` most similar documents.

#### Example

```python
query = "Sample query to find similar documents."
results = memory.query(query, top_k=5)

for result in results:
    print(result)
```

## Additional Information and Tips

### Custom Embedding and Preprocessing Functions

Custom embedding and preprocessing functions can be provided during initialization to tailor the document processing to specific requirements.

#### Example

```python
def custom_embedding_function(text: str) -> List[float]:
    # Custom embedding logic
    return [0.1, 0.2, 0.3]

def custom_preprocess_function(text: str) -> str:
    # Custom preprocessing logic
    return text.lower()

memory = PineconeMemory(
    api_key="your-api-key",
    environment="us-west1-gcp",
    index_name="example-index",
    embedding_function=custom_embedding_function,
    preprocess_function=custom_preprocess_function
)
```

### Logger Configuration

The logger can be configured to suit different logging needs. The default configuration logs to a file and the console.

#### Example

```python
logger_config = {
    "handlers": [
        {"sink": "custom_log.log", "rotation": "1 MB"},
        {"sink": lambda msg: print(msg, end="")},
    ]
}

memory = PineconeMemory(
    api_key="your-api-key",
    environment="us-west1-gcp",
    index_name="example-index",
    logger_config=logger_config
)
```

## References and Resources

- [Pinecone Documentation](https://docs.pinecone.io/)
- [SentenceTransformers Documentation](https://www.sbert.net/)
- [Loguru Documentation](https://loguru.readthedocs.io/en/stable/)

For further exploration and examples, refer to the official documentation and resources provided by Pinecone, SentenceTransformers, and Loguru.

This concludes the detailed documentation for the `PineconeMemory` class. The class offers a flexible and powerful interface for leveraging Pinecone's capabilities in retrieval-augmented generation systems. By supporting custom embeddings, preprocessing, and postprocessing functions, it can be tailored to a wide range of applications.

--------------------------------------------------

# File: swarms_platform/account_management.md

# Swarms Platform Account Management Documentation

This guide provides comprehensive, production-grade documentation for managing your account on the Swarms Platform. It covers account settings, profile management, billing, payment methods, subscription details, and cryptocurrency wallet management. Use this documentation to navigate the account management interface, understand available options, and perform account-related operations efficiently and securely.

---

## Table of Contents

1. [Overview](#overview)
2. [Accessing the Account Management Page](#accessing-the-account-management-page)
3. [Account Settings](#account-settings)
   - [Theme Mode](#theme-mode)
4. [Profile Management](#profile-management)
   - [Profile Information](#profile-information)
   - [Password Management](#password-management)
5. [Billing and Payment Methods](#billing-and-payment-methods)
   - [Subscription Status](#subscription-status)
   - [Payment Methods](#payment-methods)
6. [Cryptocurrency Wallet](#cryptocurrency-wallet)
   - [Wallet Overview](#wallet-overview)
   - [Exchange and Transaction History](#exchange-and-transaction-history)
7. [Additional Resources](#additional-resources)

---

## Overview

The Swarms Platform account management page, available at [https://swarms.world/platform/account](https://swarms.world/platform/account), allows you to configure and update your account settings and preferences. From here, you can manage the appearance of the platform, view and update profile details, manage your billing information and subscriptions, and handle your cryptocurrency wallet operations.

---

## Accessing the Account Management Page

To access your account management dashboard:
1. Log in to your Swarms Platform account.
2. Navigate to [https://swarms.world/platform/account](https://swarms.world/platform/account).

Once on this page, you will see several sections dedicated to different aspects of your account:

- **Account Settings:** Customize the platform appearance and user interface.
- **Profile:** View and manage personal details.
- **Billing:** Review credits, invoices, and manage your payment methods.
- **Crypto:** Manage your cryptocurrency wallet and transactions.

---

## Account Settings

This section allows you to modify your personal account preferences, including the visual theme.

### Theme Mode

You can choose between different theme options to tailor your user experience:

- **Single Theme:**  
  A fixed theme, independent of system settings.
  - **Example:**  
    - **Logo:** Swarms logo
    - **Terminal Command:**  
      ```bash
      pip3 install -U swarms
      ```
    - **Theme Options:**  
      - **light**  
      - **dark (default)**
  
- **Sync with System Theme:**  
  Automatically adjusts the platform theme to match your system's theme settings.

Select the theme mode that best fits your workflow. Changes are applied immediately across the platform.

---

## Profile Management

### Profile Information

The Profile section allows you to view and update your personal details:

- **View Details:**  
  Your current profile information is displayed, including contact details, username, and any additional settings.
  
- **Manage Profile:**  
  Options to update your information, ensuring your account details remain current.

### Password Management

For security purposes, it is important to regularly update your password:

- **Change Password:**  
  Select the **"Change password"** option to update your login credentials.  
  Ensure you choose a strong password and keep it confidential.

---

## Billing and Payment Methods

The Billing section helps you manage financial aspects of your account, including credits, invoices, and subscriptions.

### Subscription Status

Your subscription details are clearly displayed:

- **Current Plan:**  
  Options include **Free**, **Premium**, or **Enterprise**.
  
- **Status:**  
  The active subscription status is indicated (e.g., "Active").
  
- **Customer Portal:**  
  An option to open the customer portal for additional billing and subscription management.

### Payment Methods

Manage your payment methods and review your billing details:

- **Manage Cards:**  
  View existing payment methods.  
  **Example Entry:**
  - **Card Type:** mastercard
  - **Last 4 Digits:** ending in 9491
  - **Expiry Date:** 2030/2
  
- **Add Card:**  
  Use the **"Add Card"** option to register a new payment method securely.

### Credit System

Details of the credits available for your account:

- **Credits Available:**  
  Displays the current credit balance (e.g., `$20.00`).
  
- **Charge:**  
  Option to apply charges against your available credits.
  
- **Invoice:**  
  Review or download your invoices.

---

## Cryptocurrency Wallet

The Crypto section provides management tools for your cryptocurrency wallet and associated transactions.

### Wallet Overview

- **Connected Wallet:**  
  Displays your linked wallet information.
  - **Example:**  
    - **Wallet Identifier:** A truncated wallet ID (e.g., `EmVa...79Vb`)
  
- **$swarms Balance and Price:**
  - **Balance:**  
    Displays your current $swarms balance (e.g., `0.00`).
  - **Price:**  
    Current market price for $swarms (e.g., `$0.0400`).

### Exchange and Transaction History

- **Exchange Functionality:**  
  Option to exchange $swarms tokens for credits directly through the platform.
  
- **Transaction History:**  
  View a detailed log of wallet transactions, ensuring full transparency over all exchanges and wallet activity.

---

## Additional Resources

For further assistance or to learn more about managing your account on the Swarms Platform, refer to the following resources:

- [Help Center](https://swarms.world/help)
- [Customer Support](https://cal.com/swarms)
- [API Documentation](https://swarms.world/platform/api-keys) (for developers)

---

## Best Practices

- **Regular Updates:**  
  Periodically review your account settings, profile, and payment methods to ensure they are up-to-date.
  
- **Security Measures:**  
  Always use strong, unique passwords and consider enabling two-factor authentication if available.
  
- **Monitor Transactions:**  
  Regularly check your billing and wallet transaction history to detect any unauthorized activities promptly.



--------------------------------------------------

# File: swarms_platform/agents/agents_api.md

# Agents API Documentation

The `https://swarms.world/api/add-agent` endpoint allows users to add a new agent to the Swarms platform. This API accepts a POST request with a JSON body containing details of the agent, such as its name, description, use cases, language, tags and requirements. The request must be authenticated using an API key.

## Endpoint: Add Agent

- **URL:** `https://swarms.world/api/add-agent`
- **Method:** POST
- **Content-Type:** `application/json`
- **Authorization:** Bearer token required in the header

## Request Parameters

The request body should be a JSON object with the following attributes:

| Attribute      | Type     | Description                                                                | Required |
| -------------- | -------- | -------------------------------------------------------------------------- | -------- |
| `name`         | `string` | The name of the agent.                                                     | Yes      |
| `agent`        | `string` | The agent text.                                                            | Yes      |
| `description`  | `string` | A brief description of the agent.                                          | Yes      |
| `language`     | `string` | The agent's syntax language with a default of python                       | No       |
| `useCases`     | `array`  | An array of use cases, each containing a title and description.            | Yes      |
| `requirements` | `array`  | An array of requirements, each containing a package name and installation. | Yes      |
| `tags`         | `string` | Comma-separated tags for the agent.                                        | Yes      |

### `useCases` Structure

Each use case in the `useCases` array should be an object with the following attributes:

| Attribute     | Type     | Description                          | Required |
| ------------- | -------- | ------------------------------------ | -------- |
| `title`       | `string` | The title of the use case.           | Yes      |
| `description` | `string` | A brief description of the use case. | Yes      |

### `requirements` Structure

Each requirement in the `requirements` array should be an object with the following attributes:

| Attribute      | Type     | Description                          | Required |
| -------------- | -------- | ------------------------------------ | -------- |
| `package`      | `string` | The name of the package.             | Yes      |
| `installation` | `string` | Installation command for the package | Yes      |

## Example Usage

### Python

```python
import requests
import json
import os


url = "https://swarms.world/api/add-agent"

headers = {
  "Content-Type": "application/json",
  "Authorization": f"Bearer {os.getenv("SWARMS_API_KEY")}"
}

data = {
  "name": "Example Agent",
  "agent": "This is an example agent from an API route.",
  "description": "Description of the agent.",
  "language": "python",
  "useCases": [
      {"title": "Use case 1", "description": "Description of use case 1"},
      {"title": "Use case 2", "description": "Description of use case 2"}
  ],
  "requirements": [
      {"package": "pip", "installation": "pip install"},
      {"package": "pip3", "installation": "pip3 install"}
  ],
    "tags": "example, agent"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Node.js

```javascript
const fetch = require("node-fetch");

async function addAgentHandler() {
  try {
    const response = await fetch("https://swarms.world/api/add-agent", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer {apiKey}",
      },
      body: JSON.stringify({
        name: "Example Agent",
        agent: "This is an example agent from an API route.",
        description: "Description of the agent.",
        language: "python",
        useCases: [
          { title: "Use case 1", description: "Description of use case 1" },
          { title: "Use case 2", description: "Description of use case 2" },
        ],
        requirements: [
          { package: "pip", installation: "pip install" },
          { package: "pip3", installation: "pip3 install" },
        ],
        tags: "example, agent",
      }),
    });

    const result = await response.json();
    console.log(result);
  } catch (error) {
    console.error("An error has occurred", error);
  }
}

addAgentHandler();
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    url := "https://swarms.world/api/add-agent"
    payload := map[string]interface{}{
        "name":       "Example Agent",
        "agent":      "This is an example agent from an API route.",
        "description": "Description of the agent.",
        "useCases": []map[string]string{
            {"title": "Use case 1", "description": "Description of use case 1"},
            {"title": "Use case 2", "description": "Description of use case 2"},
        },
        "requirements": []map[string]string{
            {"package": "pip", "installation": "pip install"},
            {"package": "pip3", "installation": "pip3 install"}
        },
        "tags": "example, agent",
    }
    jsonPayload, _ := json.Marshal(payload)

    req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonPayload))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer {apiKey}")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("An error has occurred", err)
        return
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    fmt.Println(result)
}
```

### cURL

```bash
curl -X POST https://swarms.world/api/add-agent \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}" \
-d '{
    "name": "Example Agent",
    "agent": "This is an example agent from an API route.",
    "description": "Description of the agent.",
    "language": "python",
    "useCases": [
        { title: "Use case 1", description: "Description of use case 1" },
        { title: "Use case 2", description: "Description of use case 2" },
    ],
    "requirements": [
        { package: "pip", installation: "pip install" },
        { package: "pip3", installation: "pip3 install" },
    ],
    "tags": "example, agent",
}'
```

## Response

The response will be a JSON object containing the result of the operation. Example response:

```json
{
  "success": true,
  "message": "Agent added successfully",
  "data": {
    "id": "agent_id",
    "name": "Example Agent",
    "agent": "This is an example agent from an API route.",
    "description": "Description of the agent.",
    "language": "python",
    "useCases": [
      { "title": "Use case 1", "description": "Description of use case 1" },
      { "title": "Use case 2", "description": "Description of use case 2" }
    ],
    "requirements": [
      { "package": "pip", "installation": "pip install" },
      { "package": "pip3", "installation": "pip3 install" }
    ],
    "tags": "example, agent"
  }
}
```

--------------------------------------------------

# File: swarms_platform/agents/edit_agent.md


# Endpoint: Edit Agent

The `https://swarms.world/api/edit-agent` endpoint allows users to edit an existing agent on the Swarms platform. This API accepts a POST request with a JSON body containing the agent details to be updated, such as its id, name, description, use cases, language, tags and requirements. The request must be authenticated using an API key.

## Endpoint

- **URL:** `https://swarms.world/api/edit-agent`
- **Method:** POST
- **Content-Type:** `application/json`
- **Authorization:** Bearer token required in the header

## Request Parameters

The request body should be a JSON object with the following attributes:

| Attribute      | Type     | Description                                                                | Required |
| -------------- | -------- | -------------------------------------------------------------------------- | -------- |
| `id`           | `string` | The ID of the agent to be edited.                                          | Yes      |
| `name`         | `string` | The name of the agent.                                                     | Yes      |
| `agent`        | `string` | The agent text.                                                            | Yes      |
| `description`  | `string` | A brief description of the agent.                                          | Yes      |
| `language`     | `string` | The agent's syntax language                                                | No       |
| `useCases`     | `array`  | An array of use cases, each containing a title and description.            | Yes      |
| `requirements` | `array`  | An array of requirements, each containing a package name and installation. | Yes      |
| `tags`         | `string` | Comma-separated tags for the agent.                                        | No       |

### `useCases` Structure

Each use case in the `useCases` array should be an object with the following attributes:

| Attribute     | Type     | Description                          | Required |
| ------------- | -------- | ------------------------------------ | -------- |
| `title`       | `string` | The title of the use case.           | Yes      |
| `description` | `string` | A brief description of the use case. | Yes      |

### `requirements` Structure

Each requirement in the `requirements` array should be an object with the following attributes:

| Attribute      | Type     | Description                          | Required |
| -------------- | -------- | ------------------------------------ | -------- |
| `package`      | `string` | The name of the package.             | Yes      |
| `installation` | `string` | Installation command for the package | Yes      |

## Example Usage

### Python

```python
import requests
import json

url = "https://swarms.world/api/edit-agent"
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer {apiKey}"
}
data = {
    "id": "agent_id",
    "name": "Updated agent",
    "agent": "This is an updated agent from an API route.",
    "description": "Updated description of the agent.",
    "language": "javascript",
    "useCases": [
        {"title": "Updated use case 1", "description": "Updated description of use case 1"},
        {"title": "Updated use case 2", "description": "Updated description of use case 2"}
    ],
    "requirements": [
        { "package": "express", "installation": "npm install express" },
        { "package": "lodash", "installation": "npm install lodash" },
    ],
    "tags": "updated, agent"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Node.js

```javascript
const fetch = require("node-fetch");

async function editAgentHandler() {
  try {
    const response = await fetch("https://swarms.world/api/edit-agent", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer {apiKey}",
      },
      body: JSON.stringify({
        id: "agent_id",
        name: "Updated agent",
        agent: "This is an updated agent from an API route.",
        description: "Updated description of the agent.",
        language: "javascript",
        useCases: [
          {
            title: "Updated use case 1",
            description: "Updated description of use case 1",
          },
          {
            title: "Updated use case 2",
            description: "Updated description of use case 2",
          },
        ],
        requirements: [
          { package: "express", installation: "npm install express" },
          { package: "lodash", installation: "npm install lodash" },
        ],
        tags: "updated, agent",
      }),
    });

    const result = await response.json();
    console.log(result);
  } catch (error) {
    console.error("An error has occurred", error);
  }
}

editAgentHandler();
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    url := "https://swarms.world/api/edit-agent"
    payload := map[string]interface{}{
        "id":          "agent_id",
        "name":        "Updated Agent",
        "agent":      "This is an updated agent from an API route.",
        "description": "Updated description of the agent.",
        "language": "javascript",
        "useCases": []map[string]string{
            {"title": "Updated use case 1", "description": "Updated description of use case 1"},
            {"title": "Updated use case 2", "description": "Updated description of use case 2"},
        },
        "requirements": []map[string]string{
            {"package": "express", "installation": "npm install express"},
            {"package": "lodash", "installation": "npm install lodash"},
        },
        "tags": "updated, agent",
    }
    jsonPayload, _ := json.Marshal(payload)

    req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonPayload))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer {apiKey}")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("An error has occurred", err)
        return
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    fmt.Println(result)
}
```

### cURL

```bash
curl -X POST https://swarms.world/api/edit-agent \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}" \
-d '{
    "id": "agent_id",
    "name": "Updated agent",
    "agent": "This is an updated agent from an API route.",
    "description": "Updated description of the agent.",
    "language": "javascript",
    "useCases": [
        {"title": "Updated use case 1", "description": "Updated description of use case 1"},
        {"title": "Updated use case 2", "description": "Updated description of use case 2"}
    ],
    "requirements": [
        { "package": "express", "installation": "npm install express" },
        { "package": "lodash", "installation": "npm install lodash" },
    ],
    "tags": "updated, agent"
}'
```

## Response

The response will be a JSON object containing the result of the operation. Example response:

```json
{
  "success": true,
  "message": "Agent updated successfully",
  "data": {
    "id": "agent_id",
    "name": "Updated agent",
    "agent": "This is an updated agent from an API route.",
    "description": "Updated description of the agent.",
    "language": "javascript",
    "useCases": [
      {
        "title": "Updated use case 1",
        "description": "Updated description of use case 1"
      },
      {
        "title": "Updated use case 2",
        "description": "Updated description of use case 2"
      }
    ],
    "requirements": [
      { "package": "express", "installation": "npm install express" },
      { "package": "lodash", "installation": "npm install lodash" }
    ],
    "tags": "updated, agent"
  }
}
```

In case of an error, the response will contain an error message detailing the issue.

## Common Issues and Tips

- **Authentication Error:** Ensure that the `Authorization` header is correctly set with a valid API key.
- **Invalid JSON:** Make sure the request body is a valid JSON object.
- **Missing Required Fields:** Ensure that all required fields (`name`, `agent`, `description`, `useCases`, `requirements`) are included in the request body.
- **Network Issues:** Verify network connectivity and endpoint URL.

## References and Resources

- [API Authentication Guide](https://swarms.world/docs/authentication)
- [JSON Structure Standards](https://json.org/)
- [Fetch API Documentation (Node.js)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- [Requests Library (Python)](https://requests.readthedocs.io/)
- [Net/HTTP Package (Go)](https://pkg.go.dev/net/http)

This comprehensive documentation provides all the necessary information to effectively use the `https://swarms.world/api/add-agent` and `https://swarms.world/api/edit-agent` endpoints, including details on request parameters, example code snippets in multiple programming languages, and troubleshooting tips.


--------------------------------------------------

# File: swarms_platform/agents/fetch_agents.md

# Documentation for `getAllAgents` API Endpoint

The `getAllAgents` API endpoint is a part of the `swarms.world` application, designed to fetch all agent records from the database. This endpoint is crucial for retrieving various agents stored in the `swarms_cloud_agents` table, including their metadata such as name, description, use cases, language, requirements and tags. It provides an authenticated way to access this data, ensuring that only authorized users can retrieve the information.

## Purpose

The primary purpose of this API endpoint is to provide a method for clients to fetch a list of agents stored in the `swarms_cloud_agents` table, with the ability to filter by name, tags, language, requirement package and use cases. It ensures data integrity and security by using an authentication guard and handles various HTTP methods and errors gracefully.

## API Endpoint Definition

### Fetch All Agents

#### Endpoint URL

```
https://swarms.world/get-agents
```

#### HTTP Method

```
GET
```

### Request Headers

| Header        | Type   | Required | Description                 |
| ------------- | ------ | -------- | --------------------------- |
| Authorization | String | Yes      | Bearer token for API access |

### Query Parameters

- **name** (optional): A substring to match against the agent name. The query is case-insensitive.
- **tag** (optional): A comma-separated list of tags to filter agents by. The query matches any of the provided tags, and is case-insensitive.
- **language** (optional): A substring to match against the language the agent is written in. The query is case-insensitive.
- **use_case** (optional): A substring to match against the use case titles within the `use_cases` array. The query is case-insensitive.
- **req_package** (optional): A substring to match against the requirement packaages within the `requirements` array. The query is case-insensitive.

#### Response

##### Success Response (200)

Returns an array of agents.

```json
[
  {
    "id": "string",
    "name": "string",
    "description": "string",
    "language": "string",
    "agent": "string",
    "use_cases": [
      {
        "title": "string",
        "description": "string"
      }
    ],
    "requirements": [
      {
        "package": "string",
        "installation": "string"
      }
    ],
    "tags": "string"
  },
  ...
]
```

##### Error Responses

- **405 Method Not Allowed**

  ```json
  {
    "error": "Method <method> Not Allowed"
  }
  ```

- **500 Internal Server Error**

  ```json
  {
    "error": "Could not fetch agents"
  }
  ```

### Fetch Agent by ID

#### Endpoint URL

```
https://swarms.world/get-agents/[id]
```

#### HTTP Method

```
GET
```

### Request Headers

| Header        | Type   | Required | Description                 |
| ------------- | ------ | -------- | --------------------------- |
| Authorization | String | Yes      | Bearer token for API access |

#### Response

##### Success Response (200)

Returns a single agent by ID.

```json
{
  "id": "string",
  "name": "string",
  "description": "string",
  "language": "string",
  "agent": "string",
  "use_cases": [
    {
      "title": "string",
      "description": "string"
    }
  ],
  "requirements": [
    {
      "package": "string",
      "installation": "string"
    }
  ],
  "tags": "string"
}
```

##### Error Responses

- **404 Not Found**

  ```json
  {
    "error": "Agent not found"
  }
  ```

- **500 Internal Server Error**

  ```json
  {
    "error": "Could not fetch agent"
  }
  ```

### Request Handling

1. **Method Validation**: The endpoint only supports the `GET` method. If a different HTTP method is used, it responds with a `405 Method Not Allowed` status.

2. **Database Query**:

   - **Fetching All Agents**: The endpoint uses the `supabaseAdmin` client to query the `swarms_cloud_agents` table. Filters are applied based on the query parameters (`name`, `tag`, `language`, `req_package` and `use_case`).
   - **Fetching an Agent by ID**: The endpoint retrieves a single agent from the `swarms_cloud_agents` table by its unique ID.

3. **Response**: On success, it returns the agent data in JSON format. In case of an error during the database query, a `500 Internal Server Error` status is returned. For fetching by ID, if the agent is not found, it returns a `404 Not Found` status.

### Code Example

#### JavaScript (Node.js)

```javascript
import fetch from "node-fetch";

// Fetch all agents with optional filters
const getAgents = async (filters) => {
  const queryString = new URLSearchParams(filters).toString();
  const response = await fetch(
    `https://swarms.world/get-agents?${queryString}`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer {apiKey}",
      },
    }
  );

  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }

  const data = await response.json();
  console.log(data);
};

// Fetch agent by ID
const getAgentById = async (id) => {
  const response = await fetch(`https://swarms.world/get-agents/${id}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer {apiKey}",
    },
  });

  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }

  const data = await response.json();
  console.log(data);
};

// Example usage
getAgents({
  name: "example",
  tag: "tag1,tag2",
  use_case: "example",
  language: "langauge",
  req_package: "package_name",
}).catch(console.error);
getAgentById("123").catch(console.error);
```

#### Python

```python
import requests

API_KEY = "{apiKey}"

# Fetch all agents with optional filters
def get_agents(filters):
    query_string = "&".join([f"{key}={value}" for key, value in filters.items()])
    url = f"https://swarms.world/get-agents?{query_string}"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}",
    }
    response = requests.get(url, headers=headers)

    if not response.ok:
        raise Exception(f"Error: {response.reason}")

    data = response.json()
    print(data)
    return data

# Fetch agent by ID
def get_agent_by_id(agent_id):
    url = f"https://swarms.world/get-agents/{agent_id}"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}",
    }
    response = requests.get(url, headers=headers)

    if not response.ok:
        raise Exception(f"Error: {response.reason}")

    data = response.json()
    print(data)
    return data

# Example usage
try:
    get_agents({
        "name": "example",
        "tag": "tag1,tag2",
        "use_case": "example",
        "language": "language",
        "req_package": "package_name",
    })
except Exception as e:
    print(e)

try:
    get_agent_by_id("123")
except Exception as e:
    print(e)
```

#### cURL

```sh
# Fetch all agents with optional filters
curl -X GET "https://swarms.world/get-agents?name=example&tag=tag1,tag2&use_case=example&language=language&req_package=package_name" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}"

# Fetch agent by ID
curl -X GET "https://swarms.world/get-agents/123" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}"
```

#### Go

```go
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
)

func getAgents(filters map[string]string) error {
	query := url.Values{}
	for key, value := range filters {
		query.Set(key, value)
	}

	url := fmt.Sprintf("https://swarms.world/get-agents?%s", query.Encode())
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer {apiKey}")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("error: %s", resp.Status)
	}

	var data interface{}
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return err
	}

	fmt.Println(data)
	return nil
}

func getAgentById(id string) error {
	url := fmt.Sprintf("https://swarms.world/get-agents/%s", id)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer {apiKey}")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("error: %s", resp.Status)
	}

	var data interface{}
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return err
	}

	fmt.Println(data)
	return nil
}
func main() {
	filters := map[string]string{
		"name":        "example",
		"tag":         "tag1,tag2",
		"use_case":    "example",
		"language":    "language",
		"req_package": "package_name",
	}

    getAgents(filters)
    getAgentById("123")
}
```

#### Attributes Table

| Attribute    | Type   | Description                     |
| ------------ | ------ | ------------------------------- |
| id           | String | Unique identifier for the agent |
| name         | String | Name of the agent               |
| description  | String | Description of the agent        |
| agent        | String | The actual agent                |
| lanuage      | String | The code language of the agent  |
| use_cases    | Array  | Use cases for the agent         |
| requirements | Array  | Requirements for the agent      |
| tags         | String | Tags associated with the agent  |

## Additional Information and Tips

- Handle different error statuses appropriately to provide clear feedback to users.
- Consider implementing rate limiting and logging for better security and monitoring.

## References and Resources

- [Next.js API Routes](https://nextjs.org/docs/api-routes/introduction)
- [Supabase Documentation](https://supabase.com/docs)
- [Node Fetch](https://www.npmjs.com/package/node-fetch)
- [Requests Library (Python)](https://docs.python-requests.org/en/latest/)
- [Go net/http Package](https://pkg.go.dev/net/http)

This documentation provides a comprehensive guide to the `getAllAgents` API endpoint, including usage examples in multiple programming languages and detailed attribute descriptions.


--------------------------------------------------

# File: swarms_platform/apikeys.md

# Swarms Platform API Keys Documentation

This document provides detailed information on managing API keys within the Swarms Platform. API keys grant programmatic access to your account and should be handled securely. Follow the guidelines below to manage your API keys safely and effectively.

---

## Table of Contents

1. [Overview](#overview)
2. [Viewing Your API Keys](#viewing-your-api-keys)
3. [Creating a New API Key](#creating-a-new-api-key)
4. [Security Guidelines](#security-guidelines)
5. [Frequently Asked Questions](#frequently-asked-questions)

---

## Overview

API keys are unique credentials that allow you to interact with the Swarms Platform programmatically. These keys enable you to make authenticated API requests to access or modify your data. **Important:** Once a secret API key is generated, it will not be displayed again. Ensure you store it securely, as it cannot be retrieved from the platform later.

---

## Viewing Your API Keys

When you navigate to the API Keys page ([https://swarms.world/platform/api-keys](https://swarms.world/platform/api-keys)), you will see a list of your API keys along with the following information:

### Key Details:

- **Name:** A label you assign to your API key to help you identify it.
- **Key:** The secret API key is only partially visible here for security reasons.
- **Created Date:** The date when the API key was generated.
- **Actions:** Options available for managing the key (e.g., deleting an API key).

---

## Creating a New API Key

To generate a new API key, follow these steps:

1. **Attach a Credit Card:**  
   Before creating a new API key, ensure that your account has a credit card attached. This is required for authentication and billing purposes.

2. **Access the API Keys Page:**  
   Navigate to [https://swarms.world/platform/api-keys](https://swarms.world/platform/api-keys).

3. **Generate a New Key:**  
   Click on the **"Create new API key"** button. The system will generate a new secret API key for your account.

4. **Store Your API Key Securely:**  
   Once generated, the full API key will be displayed only once. Copy and store it in a secure location, as it will not be displayed again.  
   **Note:** Do not share your API key with anyone or expose it in any client-side code (e.g., browser JavaScript).

---

## Security Guidelines

- **Confidentiality:**  
  Your API keys are sensitive credentials. Do not share them with anyone or include them in public repositories or client-side code.

- **Storage:**  
  Store your API keys in secure, encrypted storage. Avoid saving them in plain text files or unsecured locations.

- **Rotation:**  
  If you suspect that your API key has been compromised, immediately delete it and create a new one.

- **Access Control:**  
  Limit access to your API keys to only those systems and personnel who absolutely require it.

---

## Frequently Asked Questions

### Q1: **Why do I need a credit card attached to my account to create an API key?**  
**A:** The requirement to attach a credit card helps verify your identity and manage billing, ensuring responsible usage of the API services provided by the Swarms Platform.

### Q2: **What happens if I lose my API key?**  
**A:** If you lose your API key, you will need to generate a new one. The platform does not store the full key after its initial generation, so recovery is not possible.

### Q3: **How can I delete an API key?**  
**A:** On the API Keys page, locate the key you wish to delete and click the **"Delete"** action next to it. This will revoke the key's access immediately.

### Q4: **Can I have multiple API keys?**  
**A:** Yes, you can generate and manage multiple API keys. Use naming conventions to keep track of their usage and purpose.

---

For any further questions or issues regarding API key management, please refer to our [Help Center](https://swarms.world/help) or contact our support team.

--------------------------------------------------

# File: swarms_platform/index.md

# Swarms Platform Documentation

Welcome to the Swarms Platform, a dynamic ecosystem where users can share, discover, and host agents and agent swarms. This documentation will guide you through the various features of the platform, providing you with the information you need to get started and make the most out of your experience.

## Table of Contents

1. [Introduction](#introduction)
2. [Getting Started](#getting-started)
3. [Account Management](#account-management)
4. [Usage Monitoring](#usage-monitoring)
5. [API Key Generation](#api-key-generation)
6. [Explorer](#explorer)
7. [Dashboard](#dashboard)
8. [Creating an Organization](#creating-an-organization)
9. [Additional Resources](#additional-resources)

## Introduction

The Swarms Platform is designed to facilitate the sharing, discovery, and hosting of intelligent agents and swarms of agents. Whether you are a developer looking to deploy your own agents, or an organization seeking to leverage collective intelligence, the Swarms Platform provides the tools and community support you need.

## Getting Started

To begin using the Swarms Platform, follow these steps:

1. **Create an Account**: Sign up on the platform to access its features.
2. **Explore the Dashboard**: Familiarize yourself with the user interface and available functionalities.
3. **Generate API Keys**: Securely interact with the platform's API.
4. **Create and Join Organizations**: Collaborate with others to deploy and manage agents and swarms.
5. **Share and Discover**: Use the Explorer to find and share agents and swarms.

## Account Management

### Account Page

Access and manage your account settings through the account page.

- **URL**: [Account Page](https://swarms.world/platform/account)

Here, you can update your profile information, manage security settings, and configure notifications.

## Usage Monitoring

### Check Your Usage

Monitor your usage statistics to keep track of your activities and resource consumption on the platform.

- **URL**: [Usage Monitoring](https://swarms.world/platform/usage)

This page provides detailed insights into your usage patterns, helping you optimize your resource allocation and stay within your limits.

## API Key Generation

### Generate Your API Keys

Generate API keys to securely interact with the Swarms Platform API.

- **URL**: [API Key Generation](https://swarms.world/platform/api-keys)

Follow the steps on this page to create, manage, and revoke API keys as needed. Ensure that your keys are kept secure and only share them with trusted applications.

## Explorer

### Explorer: Share, Discover, and Deploy

The Explorer is a central hub for sharing, discovering, and deploying prompts, agents, and swarms.

- **URL**: [Explorer](https://swarms.world/)

Use the Explorer to:

- **Share**: Upload and share your own prompts, agents, and swarms with the community.
- **Discover**: Browse and discover new and innovative agents and swarms created by others.
- **Deploy**: Quickly deploy agents and swarms for your own use or organizational needs.

## Dashboard

### Dashboard

The Dashboard is your control center for managing all aspects of your Swarms Platform experience.

- **URL**: [Dashboard](https://swarms.world/platform/dashboard)

From the Dashboard, you can:

- Monitor real-time metrics and analytics.
- Manage your agents and swarms.
- Access your account settings and usage information.
- Navigate to other sections of the platform.

## Creating an Organization

### Create an Organization

Collaborate with others by creating and joining organizations on the Swarms Platform.

- **URL**: [Create an Organization](https://swarms.world/platform/organization)

Creating an organization allows you to:

- Pool resources with team members.
- Manage shared agents and swarms.
- Set permissions and roles for organization members.

## Additional Resources

To further enhance your understanding and usage of the Swarms Platform, explore the following resources:

- **API Documentation**: Comprehensive documentation on the platform's API.
- **Community Forums**: Engage with other users, share insights, and get support.
- **Tutorials and Guides**: Step-by-step tutorials to help you get started with specific features and use cases.
- **Support**: Contact the support team for any issues or inquiries.

### Links

- [API Documentation](https://docs.swarms.world)
- [Community Forums](https://discord.gg/swarms)
- [Tutorials and Guides](https://docs.swarms.world))
- [Support](https://discord.gg/swarms)

## Conclusion

The Swarms Platform is a versatile and powerful ecosystem for managing intelligent agents and swarms. By following this documentation, you can effectively navigate the platform, leverage its features, and collaborate with others to create innovative solutions. Happy swarming!

--------------------------------------------------

# File: swarms_platform/prompts/add_prompt.md

# Prompts API Documentation

The `https://swarms.world/api/add-prompt` endpoint allows users to add a new prompt to the Swarms platform. This API accepts a POST request with a JSON body containing details of the prompt, such as its name, description, use cases, and tags. The request must be authenticated using an API key.

## Endpoint: Add Prompt

- **URL:** `https://swarms.world/api/add-prompt`
- **Method:** POST
- **Content-Type:** `application/json`
- **Authorization:** Bearer token required in the header

## Request Parameters

The request body should be a JSON object with the following attributes:

| Attribute     | Type     | Description                                                     | Required |
| ------------- | -------- | --------------------------------------------------------------- | -------- |
| `name`        | `string` | The name of the prompt.                                         | Yes      |
| `prompt`      | `string` | The prompt text.                                                | Yes      |
| `description` | `string` | A brief description of the prompt.                              | Yes      |
| `useCases`    | `array`  | An array of use cases, each containing a title and description. | Yes      |
| `tags`        | `string` | Comma-separated tags for the prompt.                            | No       |

### `useCases` Structure

Each use case in the `useCases` array should be an object with the following attributes:

| Attribute     | Type     | Description                          | Required |
| ------------- | -------- | ------------------------------------ | -------- |
| `title`       | `string` | The title of the use case.           | Yes      |
| `description` | `string` | A brief description of the use case. | Yes      |

## Example Usage

### Python

```python
import requests
import json

url = "https://swarms.world/api/add-prompt"
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer {apiKey}"
}
data = {
    "name": "Example Prompt",
    "prompt": "This is an example prompt from an API route.",
    "description": "Description of the prompt.",
    "useCases": [
        {"title": "Use case 1", "description": "Description of use case 1"},
        {"title": "Use case 2", "description": "Description of use case 2"}
    ],
    "tags": "example, prompt"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Node.js

```javascript
const fetch = require("node-fetch");

async function addPromptsHandler() {
  try {
    const response = await fetch("https://swarms.world/api/add-prompt", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer {apiKey}",
      },
      body: JSON.stringify({
        name: "Example Prompt",
        prompt: "This is an example prompt from an API route.",
        description: "Description of the prompt.",
        useCases: [
          { title: "Use case 1", description: "Description of use case 1" },
          { title: "Use case 2", description: "Description of use case 2" },
        ],
        tags: "example, prompt",
      }),
    });

    const result = await response.json();
    console.log(result);
  } catch (error) {
    console.error("An error has occurred", error);
  }
}

addPromptsHandler();
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    url := "https://swarms.world/api/add-prompt"
    payload := map[string]interface{}{
        "name":        "Example Prompt",
        "prompt":      "This is an example prompt from an API route.",
        "description": "Description of the prompt.",
        "useCases": []map[string]string{
            {"title": "Use case 1", "description": "Description of use case 1"},
            {"title": "Use case 2", "description": "Description of use case 2"},
        },
        "tags": "example, prompt",
    }
    jsonPayload, _ := json.Marshal(payload)

    req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonPayload))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer {apiKey}")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("An error has occurred", err)
        return
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    fmt.Println(result)
}
```

### cURL

```bash
curl -X POST https://swarms.world/api/add-prompt \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}" \
-d '{
  "name": "Example Prompt",
  "prompt": "This is an example prompt from an API route.",
  "description": "Description of the prompt.",
  "useCases": [
    { "title": "Use case 1", "description": "Description of use case 1" },
    { "title": "Use case 2", "description": "Description of use case 2" }
  ],
  "tags": "example, prompt"
}'
```

## Response

The response will be a JSON object containing the result of the operation. Example response:

```json
{
  "success": true,
  "message": "Prompt added successfully",
  "data": {
    "id": "prompt_id",
    "name": "Example Prompt",
    "prompt": "This is an example prompt from an API route.",
    "description": "Description of the prompt.",
    "useCases": [
      { "title": "Use case 1", "description": "Description of use case 1" },
      { "title": "Use case 2", "description": "Description of use case 2" }
    ],
    "tags": "example, prompt"
  }
}
```

--------------------------------------------------

# File: swarms_platform/prompts/edit_prompt.md

# Endpoint: Edit Prompt

The `https://swarms.world/api/edit-prompt` endpoint allows users to edit an existing prompt on the Swarms platform. This API accepts a POST request with a JSON body containing the prompt details to be updated, such as its name, description, use cases, and tags. The request must be authenticated using an API key.

## Endpoint

- **URL:** `https://swarms.world/api/edit-prompt`
- **Method:** POST
- **Content-Type:** `application/json`
- **Authorization:** Bearer token required in the header

## Request Parameters

The request body should be a JSON object with the following attributes:

| Attribute     | Type     | Description                                                     | Required |
| ------------- | -------- | --------------------------------------------------------------- | -------- |
| `id`          | `string` | The ID of the prompt to be edited.                              | Yes      |
| `name`        | `string` | The name of the prompt.                                         | Yes      |
| `prompt`      | `string` | The prompt text.                                                | Yes      |
| `description` | `string` | A brief description of the prompt.                              | No       |
| `useCases`    | `array`  | An array of use cases, each containing a title and description. | Yes      |
| `tags`        | `string` | Comma-separated tags for the prompt.                            | No       |

### `useCases` Structure

Each use case in the `useCases` array should be an object with the following attributes:

| Attribute     | Type     | Description                          | Required |
| ------------- | -------- | ------------------------------------ | -------- |
| `title`       | `string` | The title of the use case.           | Yes      |
| `description` | `string` | A brief description of the use case. | Yes      |

## Example Usage

### Python

```python
import requests
import json

url = "https://swarms.world/api/edit-prompt"
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer {apiKey}"
}
data = {
    "id": "prompt_id",
    "name": "Updated Prompt",
    "prompt": "This is an updated prompt from an API route.",
    "description": "Updated description of the prompt.",
    "useCases": [
        {"title": "Updated use case 1", "description": "Updated description of use case 1"},
        {"title": "Updated use case 2", "description": "Updated description of use case 2"}
    ],
    "tags": "updated, prompt"
}

response = requests.post(url, headers=headers, data=json.dumps(data))
print(response.json())
```

### Node.js

```javascript
const fetch = require("node-fetch");

async function editPromptsHandler() {
  try {
    const response = await fetch("https://swarms.world/api/edit-prompt", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer {apiKey}",
      },
      body: JSON.stringify({
        id: "prompt_id",
        name: "Updated Prompt",
        prompt: "This is an updated prompt from an API route.",
        description: "Updated description of the prompt.",
        useCases: [
          {
            title: "Updated use case 1",
            description: "Updated description of use case 1",
          },
          {
            title: "Updated use case 2",
            description: "Updated description of use case 2",
          },
        ],
        tags: "updated, prompt",
      }),
    });

    const result = await response.json();
    console.log(result);
  } catch (error) {
    console.error("An error has occurred", error);
  }
}

editPromptsHandler();
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    url := "https://swarms.world/api/edit-prompt"
    payload := map[string]interface{}{
        "id":          "prompt_id",
        "name":        "Updated Prompt",
        "prompt":      "This is an updated prompt from an API route.",
        "description": "Updated description of the prompt.",
        "useCases": []map[string]string{
            {"title": "Updated use case 1", "description": "Updated description of use case 1"},
            {"title": "Updated use case 2", "description": "Updated description of use case 2"},
        },
        "tags": "updated, prompt",
    }
    jsonPayload, _ := json.Marshal(payload)

    req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonPayload))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer {apiKey}")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("An error has occurred", err)
        return
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    fmt.Println(result)
}
```

### cURL

```bash
curl -X POST https://swarms.world/api/edit-prompt \
-H "Content-Type: application/json" \
-H "Authorization: Bearer {apiKey}" \
-d '{
  "id": "prompt_id",
  "name": "Updated Prompt",
  "prompt": "This is an updated prompt from an API route.",
  "description": "Updated description of the prompt.",
  "useCases": [
    { "title": "Updated use case 1", "description": "Updated description of use case 1" },
    { "title": "Updated use case 2", "description": "Updated description of use case 2" }
  ],
  "tags": "updated, prompt"
}'
```

## Response

The response will be a JSON object containing the result of the operation. Example response:

```json
{
  "success": true,
  "message": "Prompt updated successfully",
  "data": {
    "id": "prompt_id",
    "name": "Updated Prompt",
    "prompt": "This is an updated prompt from an API route.",
    "description": "Updated description of the prompt.",
    "useCases": [
      {
        "title": "Updated use case 1",
        "description": "Updated description of use case 1"
      },
      {
        "title": "Updated use case 2",
        "description": "Updated description of use case 2"
      }
    ],
    "tags": "updated, prompt"
  }
}
```

In case of an error, the response will contain an error message detailing the issue.

## Common Issues and Tips

- **Authentication Error:** Ensure that the `Authorization` header is correctly set with a valid API key.
- **Invalid JSON:** Make sure the request body is a valid JSON object.
- **Missing Required Fields:** Ensure that all required fields (`name`, `prompt`, `description`, `useCases`) are included in the request body.
- **Network Issues:** Verify network connectivity and endpoint URL.

## References and Resources

- [API Authentication Guide](https://swarms.world/docs/authentication)
- [JSON Structure Standards](https://json.org/)
- [Fetch API Documentation (Node.js)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- [Requests Library (Python)](https://requests.readthedocs.io/)
- [Net/HTTP Package (Go)](https://pkg.go.dev/net/http)

This comprehensive documentation provides all the necessary information to effectively use the `https://swarms.world/api/add-prompt` and `https://swarms.world/api/edit-prompt` endpoints, including details on request parameters, example code snippets in multiple programming languages, and troubleshooting tips.


--------------------------------------------------

# File: swarms_platform/prompts/fetch_prompts.md

# Documentation for `getAllPrompts` API Endpoint

The `getAllPrompts` API endpoint is a part of the `swarms.world` application, designed to fetch all prompt records from the database. This endpoint is crucial for retrieving various prompts stored in the `swarms_cloud_prompts` table, including their metadata such as name, description, use cases, and tags.

## Purpose

The primary purpose of this API endpoint is to provide a method for clients to fetch a list of prompts stored in the `swarms_cloud_prompts` table, with the ability to filter by name, tags, and use cases.

## API Endpoint Definition

### Fetch All Prompts

#### Endpoint URL

```
https://swarms.world/get-prompts
```

#### HTTP Method

```
GET
```

### Query Parameters

- **name** (optional): A substring to match against the prompt name. The query is case-insensitive.
- **tag** (optional): A comma-separated list of tags to filter prompts by. The query matches any of the provided tags, and is case-insensitive.
- **use_case** (optional): A substring to match against the use case titles within the `use_cases` array. The query is case-insensitive.
- **use_case_description** (optional): A substring to match against the use case descriptions within the `use_cases` array. The query is case-insensitive.

#### Response

##### Success Response (200)

Returns an array of prompts.

```json
[
  {
    "id": "string",
    "name": "string",
    "description": "string",
    "prompt": "string",
    "use_cases": [
      {
        "title": "string",
        "description": "string"
      }
    ],
    "tags": "string"
  },
  ...
]
```

##### Error Responses

- **405 Method Not Allowed**

  ```json
  {
    "error": "Method <method> Not Allowed"
  }
  ```

- **500 Internal Server Error**

  ```json
  {
    "error": "Could not fetch prompts"
  }
  ```

### Fetch Prompt by ID

#### Endpoint URL

```
https://swarms.world/get-prompts/[id]
```

#### HTTP Method

```
GET
```

#### Response

##### Success Response (200)

Returns a single prompt by ID.

```json
{
  "id": "string",
  "name": "string",
  "description": "string",
  "prompt": "string",
  "use_cases": [
    {
      "title": "string",
      "description": "string"
    }
  ],
  "tags": "string"
}
```

##### Error Responses

- **404 Not Found**

  ```json
  {
    "error": "Prompt not found"
  }
  ```

- **500 Internal Server Error**

  ```json
  {
    "error": "Could not fetch prompt"
  }
  ```

### Request Handling

1. **Method Validation**: The endpoint only supports the `GET` method. If a different HTTP method is used, it responds with a `405 Method Not Allowed` status.

2. **Database Query**:

   - **Fetching All Prompts**: The endpoint uses the `supabaseAdmin` client to query the `swarms_cloud_prompts` table. Filters are applied based on the query parameters (`name`, `tag`, and `use_cases`).
   - **Fetching a Prompt by ID**: The endpoint retrieves a single prompt from the `swarms_cloud_prompts` table by its unique ID.

3. **Response**: On success, it returns the prompt data in JSON format. In case of an error during the database query, a `500 Internal Server Error` status is returned. For fetching by ID, if the prompt is not found, it returns a `404 Not Found` status.

### Code Example

#### JavaScript (Node.js)

```javascript
import fetch from "node-fetch";

// Fetch all prompts with optional filters
const getPrompts = async (filters) => {
  const queryString = new URLSearchParams(filters).toString();
  const response = await fetch(
    `https://swarms.world/get-prompts?${queryString}`,
    {
      method: "GET",
    }
  );

  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }

  const data = await response.json();
  console.log(data);
};

// Fetch prompt by ID
const getPromptById = async (id) => {
  const response = await fetch(`https://swarms.world/get-prompts/${id}`, {
    method: "GET",
  });

  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }

  const data = await response.json();
  console.log(data);
};

// Example usage
getPrompts({
  name: "example",
  tag: "tag1,tag2",
  use_case: "example",
  use_case_description: "description",
}).catch(console.error);
getPromptById("123").catch(console.error);
```

#### Python

```python
import requests

# Fetch all prompts with optional filters
def get_prompts(filters):
    response = requests.get('https://swarms.world/get-prompts', params=filters)

    if response.status_code != 200:
        raise Exception(f'Error: {response.status_code}, {response.text}')

    data = response.json()
    print(data)

# Fetch prompt by ID
def get_prompt_by_id(id):
    response = requests.get(f'https://swarms.world/get-prompts/{id}')

    if response.status_code != 200:
        raise Exception(f'Error: {response.status_code}, {response.text}')

    data = response.json()
    print(data)

# Example usage
get_prompts({'name': 'example', 'tag': 'tag1,tag2', 'use_case': 'example', 'use_case_description': 'description'})
get_prompt_by_id('123')
```

#### cURL

```sh
# Fetch all prompts with optional filters
curl -X GET "https://swarms.world/get-prompts?name=example&tag=tag1,tag2&use_case=example&use_case_description=description"

# Fetch prompt by ID
curl -X GET https://swarms.world/get-prompts/123
```

#### Go

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "net/url"
)

func getPrompts(filters map[string]string) {
    baseURL := "https://swarms.world/get-prompts"
    query := url.Values{}
    for key, value := range filters {
        query.Set(key, value)
    }
    fullURL := fmt.Sprintf("%s?%s", baseURL, query.Encode())

    resp, err := http.Get(fullURL)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := ioutil.ReadAll(resp.Body)
        panic(fmt.Sprintf("Error: %d, %s", resp.StatusCode, string(body)))
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }

    fmt.Println(string(body))
}

func getPromptById(id string) {
    url := fmt.Sprintf("https://swarms.world/get-prompts/%s", id)
    resp, err := http.Get(url)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := ioutil.ReadAll(resp.Body)
        panic(fmt.Sprintf("Error: %d, %s", resp.StatusCode, string(body)))
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }

    fmt.Println(string(body))
}

func main() {
    filters := map[string]string{
        "name":                  "example",
        "tag":                   "tag1,tag2",
        "use_case":        "example",
        "use_case_description":  "description",
    }
    getPrompts(filters)
    getPromptById("123")
}
```

#### Attributes Table

| Attribute   | Type   | Description                      |
| ----------- | ------ | -------------------------------- |
| id          | String | Unique identifier for the prompt |
| name        | String | Name of the prompt               |
| description | String | Description of the prompt        |
| prompt      | String | The actual prompt text           |
| use_cases   | Array  | Use cases for the prompt         |
| tags        | String | Tags associated with the prompt  |

## Additional Information and Tips

- Handle different error statuses appropriately to provide clear feedback to users.
- Consider implementing rate limiting and logging for better security and monitoring.

## References and Resources

- [Next.js API Routes](https://nextjs.org/docs/api-routes/introduction)
- [Supabase Documentation](https://supabase.com/docs)
- [Node Fetch](https://www.npmjs.com/package/node-fetch)
- [Requests Library (Python)](https://docs.python-requests.org/en/latest/)
- [Go net/http Package](https://pkg.go.dev/net/http)

This documentation provides a comprehensive guide to the `getAllPrompts` API endpoint, including usage examples in multiple programming languages and detailed attribute descriptions.


--------------------------------------------------

# File: swarms_platform/share_discover.md



--------------------------------------------------

# File: swarms_platform/telemetry/index.md

# Swarms Telemetry API Documentation

This documentation covers the API for handling telemetry data. The API is implemented using Next.js, Supabase for data storage, and Zod for request validation. The handler processes incoming telemetry data, validates it, and stores it in a Supabase database. The handler also includes robust error handling and retries for database insertions to ensure data reliability.

## Endpoint

- **URL:** `/api/telemetry`
- **Method:** `POST`
- **Content-Type:** `application/json`
- **Description:** Receives telemetry data and stores it in the Supabase database.

## Request Schema

The API expects a JSON object in the request body that matches the following schema, validated using Zod:

| Field Name          | Type     | Required | Description                                               |
|---------------------|----------|----------|-----------------------------------------------------------|
| `data`              | `any`    | No       | Telemetry data payload.                                   |
| `swarms_api_key`    | `string` | No       | API key associated with the swarms framework.             |
| `status`            | `string` | No       | Status of the telemetry data. Default is `'received'`.    |
| `processing_time`   | `string` | No       | Time taken to process the telemetry data.                 |

## Response

### Success Response

- **Status Code:** `200 OK`
- **Content-Type:** `application/json`
- **Body:**

```json
{
    "message": "Telemetry data received and stored successfully"
}
```

### Error Responses

- **Status Code:** `400 Bad Request`
- **Content-Type:** `application/json`
- **Body:**

```json
{
    "error": "Invalid data format",
    "details": [
        // Zod validation error details
    ]
}
```

- **Status Code:** `405 Method Not Allowed`
- **Content-Type:** `application/json`
- **Body:**

```json
{
    "error": "Method Not Allowed"
}
```

- **Status Code:** `500 Internal Server Error`
- **Content-Type:** `application/json`
- **Body:**

```json
{
    "error": "Internal Server Error",
    "details": "Error message"
}
```

## Example Usage

### Python (Using `requests` Library)

```python
import requests

url = "https://swarms.world/api/telemetry"
headers = {
    "Content-Type": "application/json"
}
data = {
    "data": {"example_key": "example_value"},
    "swarms_api_key": "your_swarms_api_key",
    "status": "received",
    "processing_time": "123ms"
}

response = requests.post(url, json=data, headers=headers)

print(response.status_code)
print(response.json())
```

### Node.js (Using `axios` Library)

```javascript
const axios = require('axios');

const url = 'https://swarms.world/api/telemetry';
const data = {
    data: { example_key: 'example_value' },
    swarms_api_key: 'your_swarms_api_key',
    status: 'received',
    processing_time: '123ms'
};

axios.post(url, data)
    .then(response => {
        console.log(response.status);
        console.log(response.data);
    })
    .catch(error => {
        console.error(error.response.status);
        console.error(error.response.data);
    });
```

### Go (Using `net/http` and `encoding/json`)

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    url := "https://swarms.world/api/telemetry"
    data := map[string]interface{}{
        "data":            map[string]interface{}{"example_key": "example_value"},
        "swarms_api_key":  "your_swarms_api_key",
        "status":          "received",
        "processing_time": "123ms",
    }
    jsonData, err := json.Marshal(data)
    if err != nil {
        fmt.Println("Error marshaling JSON:", err)
        return
    }

    req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        fmt.Println("Error creating request:", err)
        return
    }

    req.Header.Set("Content-Type", "application/json")
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("Error making request:", err)
        return
    }
    defer resp.Body.Close()

    fmt.Println("Response status:", resp.Status)
}
```

### cURL Command

```bash
curl -X POST https://swarms.world/api/telemetry \
-H "Content-Type: application/json" \
-d '{
    "data": {"example_key": "example_value"},
    "swarms_api_key": "your_swarms_api_key",
    "status": "received",
    "processing_time": "123ms"
}'
```

### Supabase Table Structure

The Supabase table (presumably `swarms_framework_schema`) should have the following columns:

- **`data`**: JSONB or TEXT - Stores the telemetry data payload.
- **`swarms_api_key`**: TEXT - Stores the API key associated with the data.
- **`source_ip`**: TEXT - Stores the IP address of the request source.
- **`status`**: TEXT - Stores the status of the data processing.
- **`processing_time`**: TEXT - Stores the time taken to process the telemetry data.

## References and Further Reading

- [Next.js API Routes Documentation](https://nextjs.org/docs/api-routes/introduction)
- [Supabase JavaScript Client](https://supabase.com/docs/reference/javascript/supabase-client)
- [Zod Schema Validation](https://zod.dev/)
- [OpenAPI Specification](https://swagger.io/specification/)

This documentation is designed to be thorough and provide all the necessary details for developers to effectively use and integrate with the telemetry API.

--------------------------------------------------

# File: swarms_rs/agents.md

# swarms-rs

!!! note "Modern AI Agent Framework"
    swarms-rs is a powerful Rust framework for building autonomous AI agents powered by LLMs, equipped with robust tools and memory capabilities. Designed for various applications from trading analysis to healthcare diagnostics.

## Getting Started

### Installation

```bash
cargo add swarms-rs
```

!!! tip "Compatible with Rust 1.70+"
    This library requires Rust 1.70 or later. Make sure your Rust toolchain is up to date.

### Required Environment Variables

```bash
# Required API keys
OPENAI_API_KEY="your_openai_api_key_here"
DEEPSEEK_API_KEY="your_deepseek_api_key_here"
```

### Quick Start

Here's a simple example to get you started with swarms-rs:

```rust
use std::env;
use anyhow::Result;
use swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};

#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables from .env file
    dotenv::dotenv().ok();
    
    // Initialize tracing for better debugging
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::from_default_env())
        .with(
            tracing_subscriber::fmt::layer()
                .with_line_number(true)
                .with_file(true),
        )
        .init();

    // Set up your LLM client
    let api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
    let client = OpenAI::new(api_key).set_model("gpt-4-turbo");
    
    // Create a basic agent
    let agent = client
        .agent_builder()
        .system_prompt("You are a helpful assistant.")
        .agent_name("BasicAgent")
        .user_name("User")
        .build();
    
    // Run the agent with a user query
    let response = agent
        .run("Tell me about Rust programming.".to_owned())
        .await?;
    
    println!("{}", response);
    Ok(())
}
```

## Core Concepts

### Agents

Agents in swarms-rs are autonomous entities that can:

- Perform complex reasoning based on LLM capabilities
- Use tools to interact with external systems
- Maintain persistent memory
- Execute multi-step plans

## Agent Configuration

### Core Parameters

| Parameter | Description | Default | Required |
|-----------|-------------|---------|----------|
| `system_prompt` | Initial instructions/role for the agent | - | Yes |
| `agent_name` | Name identifier for the agent | - | Yes |
| `user_name` | Name for the user interacting with agent | - | Yes |
| `max_loops` | Maximum number of reasoning loops | 1 | No |
| `retry_attempts` | Number of retry attempts on failure | 1 | No |
| `enable_autosave` | Enable state persistence | false | No |
| `save_state_dir` | Directory for saving agent state | None | No |

### Advanced Configuration

You can enhance your agent's capabilities with:

- **Planning**: Enable structured planning for complex tasks
- **Memory**: Persistent storage for agent state
- **Tools**: External capabilities through MCP protocol

!!! warning "Resource Usage"
    Setting high values for `max_loops` can increase API usage and costs. Start with lower values and adjust as needed.

## Examples

### Specialized Agent for Cryptocurrency Analysis

```rust
use std::env;
use anyhow::Result;
use swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::from_default_env())
        .with(
            tracing_subscriber::fmt::layer()
                .with_line_number(true)
                .with_file(true),
        )
        .init();

    let api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
    let client = OpenAI::new(api_key).set_model("gpt-4-turbo");
    
    let agent = client
        .agent_builder()
        .system_prompt(
            "You are a sophisticated cryptocurrency analysis assistant specialized in:
            1. Technical analysis of crypto markets
            2. Fundamental analysis of blockchain projects
            3. Market sentiment analysis
            4. Risk assessment
            5. Trading patterns recognition
            
            When analyzing cryptocurrencies, always consider:
            - Market capitalization and volume
            - Historical price trends
            - Project fundamentals and technology
            - Recent news and developments
            - Market sentiment indicators
            - Potential risks and opportunities
            
            Provide clear, data-driven insights and always include relevant disclaimers about market volatility."
        )
        .agent_name("CryptoAnalyst")
        .user_name("Trader")
        .enable_autosave()
        .max_loops(3)  // Increased for more thorough analysis
        .save_state_dir("./crypto_analysis/")
        .enable_plan("Break down the crypto analysis into systematic steps:
            1. Gather market data
            2. Analyze technical indicators
            3. Review fundamental factors
            4. Assess market sentiment
            5. Provide comprehensive insights".to_owned())
        .build();
        
    let response = agent
        .run("What are your thoughts on Bitcoin's current market position?".to_owned())
        .await?;
        
    println!("{}", response);
    Ok(())
}
```

## Using Tools with MCP

### Model Context Protocol (MCP)

swarms-rs supports the Model Context Protocol (MCP), enabling agents to interact with external tools through standardized interfaces.

!!! info "What is MCP?"
    MCP (Model Context Protocol) provides a standardized way for LLMs to interact with external tools, giving your agents access to real-world data and capabilities beyond language processing.

### Supported MCP Server Types

- **STDIO MCP Servers**: Connect to command-line tools implementing the MCP protocol
- **SSE MCP Servers**: Connect to web-based MCP servers using Server-Sent Events

### Tool Integration

Add tools to your agent during configuration:

```rust
let agent = client
    .agent_builder()
    .system_prompt("You are a helpful assistant with access to tools.")
    .agent_name("ToolAgent")
    .user_name("User")
    // Add STDIO MCP server
    .add_stdio_mcp_server("uvx", ["mcp-hn"])
    .await
    // Add SSE MCP server
    .add_sse_mcp_server("file-browser", "http://127.0.0.1:8000/sse")
    .await
    .build();
```

### Full MCP Agent Example

```rust
use std::env;
use anyhow::Result;
use swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::from_default_env())
        .with(
            tracing_subscriber::fmt::layer()
                .with_line_number(true)
                .with_file(true),
        )
        .init();

    let api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
    let client = OpenAI::new(api_key).set_model("gpt-4-turbo");
    
    let agent = client
        .agent_builder()
        .system_prompt("You are a helpful assistant with access to news and file system tools.")
        .agent_name("SwarmsAgent")
        .user_name("User")
        // Add Hacker News tool
        .add_stdio_mcp_server("uvx", ["mcp-hn"])
        .await
        // Add filesystem tool
        // To set up: uvx mcp-proxy --sse-port=8000 -- npx -y @modelcontextprotocol/server-filesystem ~
        .add_sse_mcp_server("file-browser", "http://127.0.0.1:8000/sse")
        .await
        .retry_attempts(2)
        .max_loops(3)
        .build();

    // Use the news tool
    let news_response = agent
        .run("Get the top 3 stories of today from Hacker News".to_owned())
        .await?;
    println!("NEWS RESPONSE:\n{}", news_response);

    // Use the filesystem tool
    let fs_response = agent.run("List files in my home directory".to_owned()).await?;
    println!("FILESYSTEM RESPONSE:\n{}", fs_response);

    Ok(())
}
```

## Setting Up MCP Tools

### Installing MCP Servers

To use MCP servers with swarms-rs, you'll need to install the appropriate tools:

1. **uv Package Manager**:
   ```bash
   curl -sSf https://raw.githubusercontent.com/astral-sh/uv/main/install.sh | sh
   ```

2. **MCP-HN** (Hacker News MCP server):
   ```bash
   uvx install mcp-hn
   ```

3. **Setting up an SSE MCP server**:
   ```bash
   # Start file system MCP server over SSE
   uvx mcp-proxy --sse-port=8000 -- npx -y @modelcontextprotocol/server-filesystem ~
   ```

## FAQ

### General Questions

??? question "What LLM providers are supported?"
    swarms-rs currently supports:
    
    - OpenAI (GPT models)
    
    - DeepSeek AI
    
    - More providers coming soon

??? question "How does state persistence work?"
    When `enable_autosave` is set to `true`, the agent will save its state to the directory specified in `save_state_dir`. This includes conversation history and tool states, allowing the agent to resume from where it left off.

??? question "What is the difference between `max_loops` and `retry_attempts`?"
    - `max_loops`: Controls how many reasoning steps the agent can take for a single query
    
    - `retry_attempts`: Specifies how many times the agent will retry if an error occurs

### MCP Tools

??? question "How do I create my own MCP server?"
    You can create your own MCP server by implementing the MCP protocol. Check out the [MCP documentation](https://github.com/modelcontextprotocol/spec) for details on the protocol specification.

??? question "Can I use tools without MCP?"
    Currently, swarms-rs is designed to use the MCP protocol for tool integration. This provides a standardized way for agents to interact with external systems.

## Advanced Topics

### Performance Optimization

Optimize your agent's performance by:

1. **Crafting Effective System Prompts**:
   - Be specific about the agent's role and capabilities
   
   - Include clear instructions on how to use available tools
   
   - Define success criteria for the agent's responses

2. **Tuning Loop Parameters**:
   
   - Start with lower values for `max_loops` and increase as needed
   
   - Consider the complexity of tasks when setting loop limits

3. **Strategic Tool Integration**:
   
   - Only integrate tools that are necessary for the agent's tasks
   
   - Provide clear documentation in the system prompt about when to use each tool

### Security Considerations

!!! danger "Security Notice"
    When using file system tools or other system-level access, always be careful about permissions. Limit the scope of what your agent can access, especially in production environments.

## Coming Soon

- Memory plugins for different storage backends

- Additional LLM providers

- Group agent coordination

- Function calling

- Custom tool development framework

## Contributing

Contributions to swarms-rs are welcome! Check out our [GitHub repository](https://github.com/swarms-rs) for more information.

--------------------------------------------------

# File: swarms_rs/overview.md

# swarms-rs 🚀

<div class="badges" align="center">
  <img src="https://img.shields.io/github/workflow/status/The-Swarm-Corporation/swarms-rs/CI" alt="Build Status">
  <img src="https://img.shields.io/crates/v/swarm-rs" alt="Version">
  <img src="https://img.shields.io/crates/l/swarm-rs" alt="License">
</div>

## 📖 Overview

**swarms-rs** is an enterprise-grade, production-ready multi-agent orchestration framework built in Rust, designed to handle the most demanding tasks with unparalleled speed and efficiency. By leveraging Rust's bleeding-edge performance and safety features, swarms-rs provides a powerful and scalable solution for orchestrating complex multi-agent systems across various industries.

## ✨ Key Benefits

### ⚡ Extreme Performance

<div class="grid cards" markdown>

- **Multi-Threaded Architecture**
    - Utilize the full potential of modern multi-core processors
    
    - Zero-cost abstractions and fearless concurrency
    
    - Minimal overhead with maximum throughput
    
    - Optimal resource utilization

- **Bleeding-Edge Speed**
    
    - Near-zero latency execution
    
    - Lightning-fast performance
    
    - Ideal for high-frequency applications
    
    - Perfect for real-time systems
</div>

## 🔗 Quick Links

<div class="grid cards" markdown>

- [:fontawesome-brands-github: GitHub](https://github.com/The-Swarm-Corporation/swarms-rs)
    - Browse the source code
    - Contribute to the project
    - Report issues

- [:package: Crates.io](https://crates.io/crates/swarm-rs)
    - Download the latest version
    - View package statistics

- [:book: Documentation](https://docs.rs/swarm-rs/0.1.4/swarm_rs/)
    - Read the API documentation
    - Learn how to use swarms-rs
</div>

--------------------------------------------------

# File: swarms_tools/finance.md

# Swarms Finance Tools Documentation

## Installation

```bash
pip3 install -U swarms-tools yfinance requests httpx pandas loguru backoff web3 solana spl-token
```

## Environment Variables

Create a `.env` file in your project root with the following variables (as needed):

| Environment Variable | Description | Required For |
|---------------------|-------------|--------------|
| `COINBASE_API_KEY` | Coinbase API Key | Coinbase Trading |
| `COINBASE_API_SECRET` | Coinbase API Secret | Coinbase Trading |
| `COINBASE_API_PASSPHRASE` | Coinbase API Passphrase | Coinbase Trading |
| `COINMARKETCAP_API_KEY` | CoinMarketCap API Key | CoinMarketCap Data |
| `HELIUS_API_KEY` | Helius API Key | Solana Data |
| `EODHD_API_KEY` | EODHD API Key | Stock News |
| `OKX_API_KEY` | OKX API Key | OKX Trading |
| `OKX_API_SECRET` | OKX API Secret | OKX Trading |
| `OKX_PASSPHRASE` | OKX Passphrase | OKX Trading |

## Tools Overview

| Tool | Description | Requires API Key |
|------|-------------|-----------------|
| Yahoo Finance | Real-time stock market data | No |
| CoinGecko | Cryptocurrency market data | No |
| Coinbase | Cryptocurrency trading and data | Yes |
| CoinMarketCap | Cryptocurrency market data | Yes |
| Helius | Solana blockchain data | Yes |
| DexScreener | DEX trading pairs and data | No |
| HTX (Huobi) | Cryptocurrency exchange data | No |
| OKX | Cryptocurrency exchange data | Yes |
| EODHD | Stock market news | Yes |
| Jupiter | Solana DEX aggregator | No |
| Sector Analysis | GICS sector ETF analysis | No |
| Solana Tools | Solana wallet and token tools | Yes |

## Detailed Documentation

### Yahoo Finance API

Fetch real-time and historical stock market data.

```python
from swarms_tools.finance import yahoo_finance_api

# Fetch data for single stock
data = yahoo_finance_api(["AAPL"])

# Fetch data for multiple stocks
data = yahoo_finance_api(["AAPL", "GOOG", "MSFT"])
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| stock_symbols | List[str] | List of stock symbols | Yes |

### CoinGecko API

Fetch comprehensive cryptocurrency data.

```python
from swarms_tools.finance import coin_gecko_coin_api

# Fetch Bitcoin data
data = coin_gecko_coin_api("bitcoin")
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| coin | str | Cryptocurrency ID (e.g., 'bitcoin') | Yes |

### Coinbase Trading

Execute trades and fetch market data from Coinbase.

```python
from swarms_tools.finance import get_coin_data, place_buy_order, place_sell_order

# Fetch coin data
data = get_coin_data("BTC-USD")

# Place orders
buy_order = place_buy_order("BTC-USD", amount=100)  # Buy $100 worth of BTC
sell_order = place_sell_order("BTC-USD", amount=0.01)  # Sell 0.01 BTC
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| symbol | str | Trading pair (e.g., 'BTC-USD') | Yes |
| amount | Union[str, float, Decimal] | Trade amount | Yes |
| sandbox | bool | Use sandbox environment | No |

### CoinMarketCap API

Fetch cryptocurrency market data from CoinMarketCap.

```python
from swarms_tools.finance import coinmarketcap_api

# Fetch single coin data
data = coinmarketcap_api(["Bitcoin"])

# Fetch multiple coins
data = coinmarketcap_api(["Bitcoin", "Ethereum", "Tether"])
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| coin_names | Optional[List[str]] | List of coin names | No |

### Helius API (Solana)

Fetch Solana blockchain data.

```python
from swarms_tools.finance import helius_api_tool

# Fetch account data
account_data = helius_api_tool("account", "account_address")

# Fetch transaction data
tx_data = helius_api_tool("transaction", "tx_signature")

# Fetch token data
token_data = helius_api_tool("token", "token_mint_address")
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| action | str | Type of action ('account', 'transaction', 'token') | Yes |
| identifier | str | Address/signature to query | Yes |

### DexScreener API

Fetch DEX trading pair data.

```python
from swarms_tools.finance import (
    fetch_dex_screener_profiles,
    fetch_latest_token_boosts,
    fetch_solana_token_pairs
)

# Fetch latest profiles
profiles = fetch_dex_screener_profiles()

# Fetch token boosts
boosts = fetch_latest_token_boosts()

# Fetch Solana pairs
pairs = fetch_solana_token_pairs(["token_address"])
```

### HTX (Huobi) API

Fetch cryptocurrency data from HTX.

```python
from swarms_tools.finance import fetch_htx_data

# Fetch coin data
data = fetch_htx_data("BTC")
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| coin_name | str | Cryptocurrency symbol | Yes |

### OKX API

Fetch cryptocurrency data from OKX.

```python
from swarms_tools.finance import okx_api_tool

# Fetch single coin
data = okx_api_tool(["BTC-USDT"])

# Fetch multiple coins
data = okx_api_tool(["BTC-USDT", "ETH-USDT"])
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| coin_symbols | Optional[List[str]] | List of trading pairs | No |

### EODHD Stock News

Fetch stock market news.

```python
from swarms_tools.finance import fetch_stock_news

# Fetch news for a stock
news = fetch_stock_news("AAPL")
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| stock_name | str | Stock symbol | Yes |

### Jupiter (Solana DEX)

Fetch Solana DEX prices.

```python
from swarms_tools.finance import get_jupiter_price

# Fetch price data
price = get_jupiter_price(input_mint="input_token", output_mint="output_token")
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| input_mint | str | Input token mint address | Yes |
| output_mint | str | Output token mint address | Yes |

### Sector Analysis

Analyze GICS sector ETFs.

```python
from swarms_tools.finance.sector_analysis import analyze_index_sectors

# Run sector analysis
analyze_index_sectors()
```

### Solana Tools

Check Solana wallet balances and manage tokens.

```python
from swarms_tools.finance import check_solana_balance, check_multiple_wallets

# Check single wallet
balance = check_solana_balance("wallet_address")

# Check multiple wallets
balances = check_multiple_wallets(["wallet1", "wallet2"])
```

**Arguments:**

| Parameter | Type | Description | Required |
|-----------|------|-------------|----------|
| wallet_address | str | Solana wallet address | Yes |
| wallet_addresses | List[str] | List of wallet addresses | Yes |

## Complete Example

Here's a comprehensive example using multiple tools:

```python
from swarms_tools.finance import (
    yahoo_finance_api,
    coin_gecko_coin_api,
    coinmarketcap_api,
    fetch_htx_data
)

# Fetch stock data
stocks = yahoo_finance_api(["AAPL", "GOOG"])
print("Stock Data:", stocks)

# Fetch crypto data from multiple sources
bitcoin_cg = coin_gecko_coin_api("bitcoin")
print("Bitcoin Data (CoinGecko):", bitcoin_cg)

crypto_cmc = coinmarketcap_api(["Bitcoin", "Ethereum"])
print("Crypto Data (CoinMarketCap):", crypto_cmc)

btc_htx = fetch_htx_data("BTC")
print("Bitcoin Data (HTX):", btc_htx)
```

## Error Handling

All tools include proper error handling and logging. Errors are logged using the `loguru` logger. Example error handling:

```python
from loguru import logger

try:
    data = yahoo_finance_api(["INVALID"])
except Exception as e:
    logger.error(f"Error fetching stock data: {e}")
```

## Rate Limits

Please be aware of rate limits for various APIs:
- CoinGecko: 50 calls/minute (free tier)
- CoinMarketCap: Varies by subscription
- Helius: Varies by subscription
- DexScreener: 300 calls/minute for pairs, 60 calls/minute for profiles
- Other APIs: Refer to respective documentation

## Dependencies

The package automatically handles most dependencies, but you may need to install some manually:


--------------------------------------------------

# File: swarms_tools/overview.md

# Swarms Tools


Welcome to **Swarms Tools**, the ultimate package for integrating **cutting-edge APIs** into Python functions with seamless multi-agent system compatibility. Designed for enterprises at the forefront of innovation, **Swarms Tools** is your key to simplifying complexity and unlocking operational excellence.

---

## 🚀 Features

- **Unified API Integration**: Ready-to-use Python functions for financial data, social media, IoT, and more.
- **Enterprise-Grade Design**: Comprehensive type hints, structured outputs, and robust documentation.
- **Agent-Ready Framework**: Optimized for seamless integration into Swarms' multi-agent orchestration systems.
- **Expandable Architecture**: Easily extend functionality with a standardized schema for new tools.

---

## 🔧 Installation

```bash
pip3 install -U swarms-tools
```

---

## 📂 Directory Structure

```plaintext
swarms-tools/
├── swarms_tools/
│   ├── finance/
│   │   ├── htx_tool.py
│   │   ├── eodh_api.py
│   │   └── coingecko_tool.py
│   ├── social_media/
│   │   ├── telegram_tool.py
│   ├── utilities/
│   │   └── logging.py
├── tests/
│   ├── test_financial_data.py
│   └── test_social_media.py
└── README.md
```

---

## 💼 Use Cases



## Finance

Explore our diverse range of financial tools, designed to streamline your operations. If you need a tool not listed, feel free to submit an issue or accelerate integration by contributing a pull request with your tool of choice.

| **Tool Name**             | **Function**             | **Description**                                                                 |
|---------------------------|--------------------------|---------------------------------------------------------------------------------|
| `fetch_stock_news`        | `fetch_stock_news`       | Fetches the latest stock news and updates.                                     |
| `fetch_htx_data`          | `fetch_htx_data`         | Retrieves financial data from the HTX platform.                                |
| `yahoo_finance_api`       | `yahoo_finance_api`      | Fetches comprehensive stock data from Yahoo Finance, including prices and trends. |
| `coin_gecko_coin_api`     | `coin_gecko_coin_api`    | Fetches cryptocurrency data from CoinGecko, including market and price information. |
| `helius_api_tool`         | `helius_api_tool`        | Retrieves blockchain account, transaction, or token data using the Helius API. |
| `okx_api_tool`            | `okx_api_tool`           | Fetches detailed cryptocurrency data for coins from the OKX exchange.         |


### Financial Data Retrieval
Enable precise and actionable financial insights:

#### Example 1: Fetch Historical Data
```python
from swarms_tools import fetch_htx_data

# Fetch historical trading data for "Swarms Corporation"
response = fetch_htx_data("swarms")
print(response)
```

#### Example 2: Stock News Analysis
```python
from swarms_tools import fetch_stock_news

# Retrieve latest stock news for Apple
news = fetch_stock_news("AAPL")
print(news)
```

#### Example 3: Cryptocurrency Metrics
```python
from swarms_tools import coin_gecko_coin_api

# Fetch live data for Bitcoin
crypto_data = coin_gecko_coin_api("bitcoin")
print(crypto_data)
```

### Social Media Automation
Streamline communication and engagement:

#### Example: Telegram Bot Messaging
```python
from swarms_tools import telegram_dm_or_tag_api

def send_alert(response: str):
    telegram_dm_or_tag_api(response)

# Send a message to a user or group
send_alert("Mission-critical update from Swarms.")
```

---

## Dex Screener

This is a tool that allows you to fetch data from the Dex Screener API. It supports multiple chains and multiple tokens.

```python
from swarms_tools.finance.dex_screener import (
    fetch_latest_token_boosts,
    fetch_dex_screener_profiles,
)


fetch_dex_screener_profiles()
fetch_latest_token_boosts()

```

---


## Structs
The tool chainer enables the execution of multiple tools in a sequence, allowing for the aggregation of their results in either a parallel or sequential manner.

```python
# Example usage
from loguru import logger

from swarms_tools.structs import tool_chainer


if __name__ == "__main__":
    logger.add("tool_chainer.log", rotation="500 MB", level="INFO")

    # Example tools
    def tool1():
        return "Tool1 Result"

    def tool2():
        return "Tool2 Result"

    # def tool3():
    #     raise ValueError("Simulated error in Tool3")

    tools = [tool1, tool2]

    # Parallel execution
    parallel_results = tool_chainer(tools, parallel=True)
    print("Parallel Results:", parallel_results)

    # Sequential execution
    # sequential_results = tool_chainer(tools, parallel=False)
    # print("Sequential Results:", sequential_results)

```
---

## 🧩 Standardized Schema

Every tool in **Swarms Tools** adheres to a strict schema for maintainability and interoperability:

### Schema Template

1. **Functionality**:
   - Encapsulate API logic into a modular, reusable function.

2. **Typing**:
   - Leverage Python type hints for input validation and clarity.

   Example:
   ```python
   def fetch_data(symbol: str, date_range: str) -> str:
       """
       Fetch financial data for a given symbol and date range.

       Args:
           symbol (str): Ticker symbol of the asset.
           date_range (str): Timeframe for the data (e.g., '1d', '1m', '1y').

       Returns:
           dict: A dictionary containing financial metrics.
       """
       pass
   ```

3. **Documentation**:
   - Include detailed docstrings with parameter explanations and usage examples.

4. **Output Standardization**:
   - Ensure consistent outputs (e.g., strings) for easy downstream agent integration.

5. **API-Key Management**:
    - All API keys must be fetched with `os.getenv("YOUR_KEY")`


---

## 📖 Documentation

Comprehensive documentation is available to guide developers and enterprises. Visit our [official docs](https://docs.swarms.world) for detailed API references, usage examples, and best practices.

---

## 🛠 Contributing

We welcome contributions from the global developer community. To contribute:

1. **Fork the Repository**: Start by forking the repository.
2. **Create a Feature Branch**: Use a descriptive branch name: `feature/add-new-tool`.
3. **Commit Your Changes**: Write meaningful commit messages.
4. **Submit a Pull Request**: Open a pull request for review.

---

## 🛡️ License

This project is licensed under the **MIT License**. See the [LICENSE](LICENSE) file for details.

---

## 🌠 Join the Future

Explore the limitless possibilities of agent-based systems. Together, we can build a smarter, faster, and more interconnected world.

**Visit us:** [Swarms Corporation](https://swarms.ai)  
**Follow us:** [Twitter](https://twitter.com/swarms_corp)

---

**"The future belongs to those who dare to automate it."**  
**— The Swarms Corporation**



--------------------------------------------------

# File: swarms_tools/search.md

# Search Tools Documentation

This documentation covers the search tools available in the `swarms-tools` package.

## Installation

```bash
pip3 install -U swarms-tools
```

## Environment Variables Required

Create a `.env` file in your project root with the following API keys:

```bash
# Bing Search API
BING_API_KEY=your_bing_api_key

# Google Search API
GOOGLE_API_KEY=your_google_api_key
GOOGLE_CX=your_google_cx_id
GEMINI_API_KEY=your_gemini_api_key

# Exa AI API
EXA_API_KEY=your_exa_api_key
```

## Tools Overview

### 1. Bing Search Tool

The Bing Search tool allows you to fetch web articles using the Bing Web Search API.

#### Function: `fetch_web_articles_bing_api`

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| query | str | Yes | The search query to retrieve articles |

#### Example Usage:

```python
from swarms_tools.search import fetch_web_articles_bing_api

# Fetch articles about AI
results = fetch_web_articles_bing_api("swarms ai github")
print(results)
```

### 2. Exa AI Search Tool

The Exa AI tool is designed for searching research papers and academic content.

#### Function: `search_exa_ai`

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| query | str | Yes | "Latest developments in LLM capabilities" | Search query |
| num_results | int | No | 10 | Number of results to return |
| auto_prompt | bool | No | True | Whether to use auto-prompting |
| include_domains | List[str] | No | ["arxiv.org", "paperswithcode.com"] | Domains to include |
| exclude_domains | List[str] | No | [] | Domains to exclude |
| category | str | No | "research paper" | Category of search |

#### Example Usage:

```python
from swarms_tools.search import search_exa_ai

# Search for research papers
results = search_exa_ai(
    query="Latest developments in LLM capabilities",
    num_results=5,
    include_domains=["arxiv.org"]
)
print(results)
```

### 3. Google Search Tool

A comprehensive search tool that uses Google Custom Search API and includes content extraction and summarization using Gemini.

#### Class: `WebsiteChecker`

| Method | Parameters | Description |
|--------|------------|-------------|
| search | query: str | Main search function that fetches, processes, and summarizes results |

#### Example Usage:

```python
from swarms_tools.search import WebsiteChecker

# Initialize with an agent (required for summarization)
checker = WebsiteChecker(agent=your_agent_function)

# Perform search
async def search_example():
    results = await checker.search("who won elections 2024 us")
    print(results)

# For synchronous usage
from swarms_tools.search import search

results = search("who won elections 2024 us", agent=your_agent_function)
print(results)
```

## Features

- **Bing Search**: Fetch and parse web articles with structured output
- **Exa AI**: Specialized academic and research paper search
- **Google Search**: 
  - Custom search with content extraction
  - Concurrent URL processing
  - Content summarization using Gemini
  - Progress tracking
  - Automatic retry mechanisms
  - Results saved to JSON

## Dependencies

The tools automatically handle dependency installation, but here are the main requirements:

```python
aiohttp
asyncio
beautifulsoup4
google-generativeai
html2text
playwright
python-dotenv
rich
tenacity
```

## Error Handling

All tools include robust error handling:
- Automatic retries for failed requests
- Timeout handling
- Rate limiting consideration
- Detailed error messages

## Output Format

Each tool provides structured output:

- **Bing Search**: Returns formatted string with article details
- **Exa AI**: Returns JSON response with search results
- **Google Search**: Returns summarized content with sections:
  - Key Findings
  - Important Details
  - Sources

## Best Practices

1. Always store API keys in environment variables
2. Use appropriate error handling
3. Consider rate limits of the APIs
4. Cache results when appropriate
5. Monitor API usage and costs

## Limitations

- Bing Search: Limited to 4 articles per query
- Exa AI: Focused on academic content
- Google Search: Requires Gemini API for summarization

## Support

For issues and feature requests, please visit the [GitHub repository](https://github.com/swarms-tools). 

--------------------------------------------------

# File: swarms_tools/twitter.md

# Twitter Tool Documentation

## Overview
The Twitter Tool provides a convenient interface for interacting with Twitter's API through the swarms-tools package. This documentation covers the initialization process and available functions for posting, replying, liking, and quoting tweets, as well as retrieving metrics.

## Installation
```bash
pip install swarms-tools
```

## Authentication
The Twitter Tool requires Twitter API credentials for authentication. These should be stored as environment variables:

```python
TWITTER_ID=your_twitter_id
TWITTER_NAME=your_twitter_name
TWITTER_DESCRIPTION=your_twitter_description
TWITTER_API_KEY=your_api_key
TWITTER_API_SECRET_KEY=your_api_secret_key
TWITTER_ACCESS_TOKEN=your_access_token
TWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret
```

## Initialization

### TwitterTool Configuration Options

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| id | str | Yes | Unique identifier for the Twitter tool instance |
| name | str | Yes | Name of the Twitter tool instance |
| description | str | No | Description of the tool's purpose |
| credentials | dict | Yes | Dictionary containing Twitter API credentials |

### Credentials Dictionary Structure

| Key | Type | Required | Description |
|-----|------|----------|-------------|
| apiKey | str | Yes | Twitter API Key |
| apiSecretKey | str | Yes | Twitter API Secret Key |
| accessToken | str | Yes | Twitter Access Token |
| accessTokenSecret | str | Yes | Twitter Access Token Secret |

## Available Functions

### initialize_twitter_tool()

Creates and returns a new instance of the TwitterTool.

```python
def initialize_twitter_tool() -> TwitterTool:
```

Returns:
- TwitterTool: Initialized Twitter tool instance

### post_tweet()

Posts a new tweet to Twitter.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| tweet | str | Yes | Text content of the tweet to post |

Raises:
- tweepy.TweepyException: If tweet posting fails

### reply_tweet()

Replies to an existing tweet.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| tweet_id | int | Yes | ID of the tweet to reply to |
| reply | str | Yes | Text content of the reply |

Raises:
- tweepy.TweepyException: If reply posting fails

### like_tweet()

Likes a specified tweet.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| tweet_id | int | Yes | ID of the tweet to like |

Raises:
- tweepy.TweepyException: If liking the tweet fails

### quote_tweet()

Creates a quote tweet.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| tweet_id | int | Yes | ID of the tweet to quote |
| quote | str | Yes | Text content to add to the quoted tweet |

Raises:
- tweepy.TweepyException: If quote tweet creation fails

### get_metrics()

Retrieves Twitter metrics.

Returns:
- Dict[str, int]: Dictionary containing various Twitter metrics

Raises:
- tweepy.TweepyException: If metrics retrieval fails

## Usage Examples

### Basic Tweet Posting
```python
from swarms_tools.twitter import initialize_twitter_tool, post_tweet

# Post a simple tweet
post_tweet("Hello, Twitter!")
```

### Interacting with Tweets
```python
# Reply to a tweet
reply_tweet(12345, "Great point!")

# Like a tweet
like_tweet(12345)

# Quote a tweet
quote_tweet(12345, "Adding my thoughts on this!")
```

### Retrieving Metrics
```python
metrics = get_metrics()
print(f"Current metrics: {metrics}")
```

## Error Handling
All functions include built-in error handling and will print error messages if operations fail. It's recommended to implement additional error handling in production environments:

```python
try:
    post_tweet("Hello, Twitter!")
except Exception as e:
    logger.error(f"Tweet posting failed: {e}")
    # Implement appropriate error handling
```


## Production Example

This is an example of how to use the TwitterTool in a production environment using Swarms.

```python

import os
from time import time

from swarm_models import OpenAIChat
from swarms import Agent
from dotenv import load_dotenv

from swarms_tools.social_media.twitter_tool import TwitterTool

load_dotenv()

model_name = "gpt-4o"

model = OpenAIChat(
    model_name=model_name,
    max_tokens=3000,
    openai_api_key=os.getenv("OPENAI_API_KEY"),
)


medical_coder = Agent(
    agent_name="Medical Coder",
    system_prompt="""
    You are a highly experienced and certified medical coder with extensive knowledge of ICD-10 coding guidelines, clinical documentation standards, and compliance regulations. Your responsibility is to ensure precise, compliant, and well-documented coding for all clinical cases.

    ### Primary Responsibilities:
    1. **Review Clinical Documentation**: Analyze all available clinical records, including specialist inputs, physician notes, lab results, imaging reports, and discharge summaries.
    2. **Assign Accurate ICD-10 Codes**: Identify and assign appropriate codes for primary diagnoses, secondary conditions, symptoms, and complications.
    3. **Ensure Coding Compliance**: Follow the latest ICD-10-CM/PCS coding guidelines, payer-specific requirements, and organizational policies.
    4. **Document Code Justification**: Provide clear, evidence-based rationale for each assigned code.

    ### Detailed Coding Process:
    - **Review Specialist Inputs**: Examine all relevant documentation to capture the full scope of the patient's condition and care provided.
    - **Identify Diagnoses**: Determine the primary and secondary diagnoses, as well as any symptoms or complications, based on the documentation.
    - **Assign ICD-10 Codes**: Select the most accurate and specific ICD-10 codes for each identified diagnosis or condition.
    - **Document Supporting Evidence**: Record the documentation source (e.g., lab report, imaging, or physician note) for each code to justify its assignment.
    - **Address Queries**: Note and flag any inconsistencies, missing information, or areas requiring clarification from providers.

    ### Output Requirements:
    Your response must be clear, structured, and compliant with professional standards. Use the following format:

    1. **Primary Diagnosis Codes**:
        - **ICD-10 Code**: [e.g., E11.9]
        - **Description**: [e.g., Type 2 diabetes mellitus without complications]
        - **Supporting Documentation**: [e.g., Physician's note dated MM/DD/YYYY]
        
    2. **Secondary Diagnosis Codes**:
        - **ICD-10 Code**: [Code]
        - **Description**: [Description]
        - **Order of Clinical Significance**: [Rank or priority]

    3. **Symptom Codes**:
        - **ICD-10 Code**: [Code]
        - **Description**: [Description]

    4. **Complication Codes**:
        - **ICD-10 Code**: [Code]
        - **Description**: [Description]
        - **Relevant Documentation**: [Source of information]

    5. **Coding Notes**:
        - Observations, clarifications, or any potential issues requiring provider input.

    ### Additional Guidelines:
    - Always prioritize specificity and compliance when assigning codes.
    - For ambiguous cases, provide a brief note with reasoning and flag for clarification.
    - Ensure the output format is clean, consistent, and ready for professional use.
    """,
    llm=model,
    max_loops=1,
    dynamic_temperature_enabled=True,
)


# Define your options with the necessary credentials
options = {
    "id": "mcsswarm",
    "name": "mcsswarm",
    "description": "An example Twitter Plugin for testing.",
    "credentials": {
        "apiKey": os.getenv("TWITTER_API_KEY"),
        "apiSecretKey": os.getenv("TWITTER_API_SECRET_KEY"),
        "accessToken": os.getenv("TWITTER_ACCESS_TOKEN"),
        "accessTokenSecret": os.getenv("TWITTER_ACCESS_TOKEN_SECRET"),
    },
}

# Initialize the TwitterTool with your options
twitter_plugin = TwitterTool(options)

# # Post a tweet
# post_tweet_fn = twitter_plugin.get_function('post_tweet')
# post_tweet_fn("Hello world!")


# Assuming `twitter_plugin` and `medical_coder` are already initialized
post_tweet = twitter_plugin.get_function("post_tweet")

# Set to track posted tweets and avoid duplicates
posted_tweets = set()


def post_unique_tweet():
    """
    Generate and post a unique tweet. Skip duplicates.
    """
    tweet_prompt = (
        "Share an intriguing, lesser-known fact about a medical disease, and include an innovative, fun, or surprising way to manage or cure it! "
        "Make the response playful, engaging, and inspiring—something that makes people smile while learning. No markdown, just plain text!"
    )

    # Generate a new tweet text
    tweet_text = medical_coder.run(tweet_prompt)

    # Check for duplicates
    if tweet_text in posted_tweets:
        print("Duplicate tweet detected. Skipping...")
        return

    # Post the tweet
    try:
        post_tweet(tweet_text)
        print(f"Posted tweet: {tweet_text}")
        # Add the tweet to the set of posted tweets
        posted_tweets.add(tweet_text)
    except Exception as e:
        print(f"Error posting tweet: {e}")


# Loop to post tweets every 10 seconds
def start_tweet_loop(interval=10):
    """
    Continuously post tweets every `interval` seconds.

    Args:
        interval (int): Time in seconds between tweets.
    """
    print("Starting tweet loop...")
    while True:
        post_unique_tweet()
        time.sleep(interval)


# Start the loop
start_tweet_loop(10)
```


## Best Practices
1. Always store credentials in environment variables
2. Implement rate limiting in production environments
3. Add proper logging for all operations
4. Handle errors gracefully
5. Validate tweet content before posting
6. Monitor API usage limits

## Rate Limits
Be aware of Twitter's API rate limits. Implement appropriate delays between requests in production environments to avoid hitting these limits.

## Dependencies
- tweepy
- python-dotenv
- swarms-tools

## Version Compatibility
- Python 3.7+
- Latest version of swarms-tools package

--------------------------------------------------

# File: web3/token.md


# $swarms Tokenomics

**Empowering the Agentic Revolution**  
Token Contract Address: `74SBV4zDXxTRgv1pEMoECskKBkZHc2yGPnc7GYVepump`

> You can buy $swarms on most marketplaces:  
> **Pump.fun**, **Kraken**, **Bitget**, **Binance**, **OKX**, and more.

---

## 📦 Overview

- **Token Name:** Swarms Coin  
- **Ticker:** `$swarms`  
- **Blockchain:** Solana  
- **Utility:** Powering the agentic economy.

---

## 📊 Initial Token Distribution

| Allocation      | Percentage |
|-----------------|------------|
| 🧠 **Team**      | 3%         |
| 🌍 **Public Sale** | 97%        |

> ⚠️ At launch, only **2%** was reserved for the team — among the **smallest allocations in DAO history**.

---

## 📣 A Message from the Team

!!! quote
    When we launched $swarms, we prioritized community ownership by allocating just 2% to the team.  
    Our intent was radical decentralization. But that decision has created unintended consequences.

### ❗ Challenges We Faced

- **Market manipulation** by whales and exchanges  
- **Unsustainable funding** for innovation and ops  
- **Malicious actors undermining decentralization**

---

## 🛠 Our Proposed Solution

We are initiating a **DAO governance proposal** to:

=== "Key Reforms"

- 📈 **Increase team allocation to 10%**  
  Secure operational longevity and attract top contributors.

- 🌱 **Launch an ecosystem grants program**  
  Incentivize developers building agentic tools and infra.

- 🛡 **Combat token manipulation**  
  Deploy anti-whale policies and explore token lockups.

- 🤝 **Strengthen community dev initiatives**  
  Support contributor bounties, governance tooling, and hackathons.

> This proposal isn’t about centralizing power — it's about protecting and empowering the **Swarms ecosystem**.

---

## 💸 Contribute to Swarms DAO

To expand our ecosystem, grow the core team, and bring agentic AI to the world, we invite all community members to **invest directly in Swarms DAO**.

Send **$swarms** or **SOL** to our official treasury address:

```plaintext
🪙 DAO Treasury Wallet:
7MaX4muAn8ZQREJxnupm8sgokwFHujgrGfH9Qn81BuEV
```

!!! success "Every contribution matters"
    Whether it’s 1 $swarms or 1000 SOL — you’re helping fund a decentralized future.

> You may use most wallets and platforms supporting Solana to send tokens.

---

## 🧠 Why Invest?

Your contributions fund:

- Expansion of the **Swarms core team**  
- Development of **open-source AI agent tooling**  
- Community **grants** and contributor **bounties**  
- Anti-manipulation strategies & decentralized governance tools

---

## 🚀 How to Get Involved

[![Join the DAO](https://img.shields.io/badge/DAO%20Governance-Click%20Here-blue?style=for-the-badge&logo=solana)](https://dao.swarms.world)
[![Investor Info](https://img.shields.io/badge/Investor%20Page-Explore-green?style=for-the-badge)](https://investors.swarms.world)

### 🛠 You can:
- Vote on governance proposals  

- Submit development or funding proposals  

- Share $swarms with your network  

- Build with our upcoming agent SDKs  

- Contribute to the mission of agentic decentralization  

---

## 📘 Quick Summary

| Key Metric                  | Value             |
|----------------------------|------------------|
| **Token Symbol**           | `$swarms`        |
| **Blockchain**             | Solana           |
| **Initial Team Allocation**| 3% (Proposed 10%)|
| **Public Distribution**    | 97%              |
| **DAO Wallet**             | `7MaX4muAn8ZQREJxnupm8sgokwFHujgrGfH9Qn81BuEV` |
| **DAO Governance**         | [dao.swarms.world](https://dao.swarms.world) |

---

## 🌍 Useful Links

- [DAO Governance Portal][dao]  

- [Investor Information][investors]  

- [Official Site][site]  

- [Join Swarms on Discord][discord]  

[dao]: https://dao.swarms.world/
[investors]: https://investors.swarms.world/
[site]: https://swarms.world/
[discord]: https://discord.gg/swarms
```



--------------------------------------------------

